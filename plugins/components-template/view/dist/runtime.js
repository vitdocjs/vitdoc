function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a = function() {
      return f2.apply(this, arguments);
    };
    a.prototype = f2.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a;
}
var react = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$d = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols2;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key2 in from) {
      if (hasOwnProperty$d.call(from, key2)) {
        to[key2] = from[key2];
      }
    }
    if (getOwnPropertySymbols) {
      symbols2 = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols2.length; i++) {
        if (propIsEnumerable.call(from, symbols2[i])) {
          to[symbols2[i]] = from[symbols2[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v16.8.6
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var k$1 = objectAssign, n$3 = "function" === typeof Symbol && Symbol.for, p$2 = n$3 ? Symbol.for("react.element") : 60103, q$1 = n$3 ? Symbol.for("react.portal") : 60106, r$3 = n$3 ? Symbol.for("react.fragment") : 60107, t$2 = n$3 ? Symbol.for("react.strict_mode") : 60108, u = n$3 ? Symbol.for("react.profiler") : 60114, v$1 = n$3 ? Symbol.for("react.provider") : 60109, w$1 = n$3 ? Symbol.for("react.context") : 60110, x$2 = n$3 ? Symbol.for("react.concurrent_mode") : 60111, y$2 = n$3 ? Symbol.for("react.forward_ref") : 60112, z$2 = n$3 ? Symbol.for("react.suspense") : 60113, aa$1 = n$3 ? Symbol.for("react.memo") : 60115, ba$1 = n$3 ? Symbol.for("react.lazy") : 60116, A$1 = "function" === typeof Symbol && Symbol.iterator;
function ca$1(a, b2, d2, c2, e2, g2, h2, f2) {
  if (!a) {
    a = void 0;
    if (void 0 === b2)
      a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var l2 = [d2, c2, e2, g2, h2, f2], m2 = 0;
      a = Error(b2.replace(/%s/g, function() {
        return l2[m2++];
      }));
      a.name = "Invariant Violation";
    }
    a.framesToPop = 1;
    throw a;
  }
}
function B(a) {
  for (var b2 = arguments.length - 1, d2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c2 = 0; c2 < b2; c2++)
    d2 += "&args[]=" + encodeURIComponent(arguments[c2 + 1]);
  ca$1(false, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", d2);
}
var C$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, D$1 = {};
function E$1(a, b2, d2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = d2 || C$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  "object" !== typeof a && "function" !== typeof a && null != a ? B("85") : void 0;
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$1.prototype;
function G$1(a, b2, d2) {
  this.props = a;
  this.context = b2;
  this.refs = D$1;
  this.updater = d2 || C$1;
}
var H$1 = G$1.prototype = new F$1();
H$1.constructor = G$1;
k$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = { current: null }, J$1 = { current: null }, K$1 = Object.prototype.hasOwnProperty, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b2, d2) {
  var c2 = void 0, e2 = {}, g2 = null, h2 = null;
  if (null != b2)
    for (c2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (g2 = "" + b2.key), b2)
      K$1.call(b2, c2) && !L$1.hasOwnProperty(c2) && (e2[c2] = b2[c2]);
  var f2 = arguments.length - 2;
  if (1 === f2)
    e2.children = d2;
  else if (1 < f2) {
    for (var l2 = Array(f2), m2 = 0; m2 < f2; m2++)
      l2[m2] = arguments[m2 + 2];
    e2.children = l2;
  }
  if (a && a.defaultProps)
    for (c2 in f2 = a.defaultProps, f2)
      void 0 === e2[c2] && (e2[c2] = f2[c2]);
  return { $$typeof: p$2, type: a, key: g2, ref: h2, props: e2, _owner: J$1.current };
}
function da$1(a, b2) {
  return { $$typeof: p$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function N$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === p$2;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + ("" + a).replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var O$1 = /\/+/g, P$1 = [];
function Q$1(a, b2, d2, c2) {
  if (P$1.length) {
    var e2 = P$1.pop();
    e2.result = a;
    e2.keyPrefix = b2;
    e2.func = d2;
    e2.context = c2;
    e2.count = 0;
    return e2;
  }
  return { result: a, keyPrefix: b2, func: d2, context: c2, count: 0 };
}
function R(a) {
  a.result = null;
  a.keyPrefix = null;
  a.func = null;
  a.context = null;
  a.count = 0;
  10 > P$1.length && P$1.push(a);
}
function S$1(a, b2, d2, c2) {
  var e2 = typeof a;
  if ("undefined" === e2 || "boolean" === e2)
    a = null;
  var g2 = false;
  if (null === a)
    g2 = true;
  else
    switch (e2) {
      case "string":
      case "number":
        g2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case p$2:
          case q$1:
            g2 = true;
        }
    }
  if (g2)
    return d2(c2, a, "" === b2 ? "." + T$1(a, 0) : b2), 1;
  g2 = 0;
  b2 = "" === b2 ? "." : b2 + ":";
  if (Array.isArray(a))
    for (var h2 = 0; h2 < a.length; h2++) {
      e2 = a[h2];
      var f2 = b2 + T$1(e2, h2);
      g2 += S$1(e2, f2, d2, c2);
    }
  else if (null === a || "object" !== typeof a ? f2 = null : (f2 = A$1 && a[A$1] || a["@@iterator"], f2 = "function" === typeof f2 ? f2 : null), "function" === typeof f2)
    for (a = f2.call(a), h2 = 0; !(e2 = a.next()).done; )
      e2 = e2.value, f2 = b2 + T$1(e2, h2++), g2 += S$1(e2, f2, d2, c2);
  else
    "object" === e2 && (d2 = "" + a, B("31", "[object Object]" === d2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : d2, ""));
  return g2;
}
function U$1(a, b2, d2) {
  return null == a ? 0 : S$1(a, "", b2, d2);
}
function T$1(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b2.toString(36);
}
function ea$1(a, b2) {
  a.func.call(a.context, b2, a.count++);
}
function fa$1(a, b2, d2) {
  var c2 = a.result, e2 = a.keyPrefix;
  a = a.func.call(a.context, b2, a.count++);
  Array.isArray(a) ? V$1(a, c2, d2, function(a2) {
    return a2;
  }) : null != a && (N$1(a) && (a = da$1(a, e2 + (!a.key || b2 && b2.key === a.key ? "" : ("" + a.key).replace(O$1, "$&/") + "/") + d2)), c2.push(a));
}
function V$1(a, b2, d2, c2, e2) {
  var g2 = "";
  null != d2 && (g2 = ("" + d2).replace(O$1, "$&/") + "/");
  b2 = Q$1(b2, g2, c2, e2);
  U$1(a, fa$1, b2);
  R(b2);
}
function W$1() {
  var a = I$1.current;
  null === a ? B("321") : void 0;
  return a;
}
var X$1 = {
  Children: { map: function(a, b2, d2) {
    if (null == a)
      return a;
    var c2 = [];
    V$1(a, c2, null, b2, d2);
    return c2;
  }, forEach: function(a, b2, d2) {
    if (null == a)
      return a;
    b2 = Q$1(null, null, b2, d2);
    U$1(a, ea$1, b2);
    R(b2);
  }, count: function(a) {
    return U$1(a, function() {
      return null;
    }, null);
  }, toArray: function(a) {
    var b2 = [];
    V$1(a, b2, null, function(a2) {
      return a2;
    });
    return b2;
  }, only: function(a) {
    N$1(a) ? void 0 : B("143");
    return a;
  } },
  createRef: function() {
    return { current: null };
  },
  Component: E$1,
  PureComponent: G$1,
  createContext: function(a, b2) {
    void 0 === b2 && (b2 = null);
    a = {
      $$typeof: w$1,
      _calculateChangedBits: b2,
      _currentValue: a,
      _currentValue2: a,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    a.Provider = { $$typeof: v$1, _context: a };
    return a.Consumer = a;
  },
  forwardRef: function(a) {
    return { $$typeof: y$2, render: a };
  },
  lazy: function(a) {
    return { $$typeof: ba$1, _ctor: a, _status: -1, _result: null };
  },
  memo: function(a, b2) {
    return { $$typeof: aa$1, type: a, compare: void 0 === b2 ? null : b2 };
  },
  useCallback: function(a, b2) {
    return W$1().useCallback(a, b2);
  },
  useContext: function(a, b2) {
    return W$1().useContext(a, b2);
  },
  useEffect: function(a, b2) {
    return W$1().useEffect(a, b2);
  },
  useImperativeHandle: function(a, b2, d2) {
    return W$1().useImperativeHandle(a, b2, d2);
  },
  useDebugValue: function() {
  },
  useLayoutEffect: function(a, b2) {
    return W$1().useLayoutEffect(a, b2);
  },
  useMemo: function(a, b2) {
    return W$1().useMemo(a, b2);
  },
  useReducer: function(a, b2, d2) {
    return W$1().useReducer(a, b2, d2);
  },
  useRef: function(a) {
    return W$1().useRef(a);
  },
  useState: function(a) {
    return W$1().useState(a);
  },
  Fragment: r$3,
  StrictMode: t$2,
  Suspense: z$2,
  createElement: M$1,
  cloneElement: function(a, b2, d2) {
    null === a || void 0 === a ? B("267", a) : void 0;
    var c2 = void 0, e2 = k$1({}, a.props), g2 = a.key, h2 = a.ref, f2 = a._owner;
    if (null != b2) {
      void 0 !== b2.ref && (h2 = b2.ref, f2 = J$1.current);
      void 0 !== b2.key && (g2 = "" + b2.key);
      var l2 = void 0;
      a.type && a.type.defaultProps && (l2 = a.type.defaultProps);
      for (c2 in b2)
        K$1.call(b2, c2) && !L$1.hasOwnProperty(c2) && (e2[c2] = void 0 === b2[c2] && void 0 !== l2 ? l2[c2] : b2[c2]);
    }
    c2 = arguments.length - 2;
    if (1 === c2)
      e2.children = d2;
    else if (1 < c2) {
      l2 = Array(c2);
      for (var m2 = 0; m2 < c2; m2++)
        l2[m2] = arguments[m2 + 2];
      e2.children = l2;
    }
    return { $$typeof: p$2, type: a.type, key: g2, ref: h2, props: e2, _owner: f2 };
  },
  createFactory: function(a) {
    var b2 = M$1.bind(null, a);
    b2.type = a;
    return b2;
  },
  isValidElement: N$1,
  version: "16.8.6",
  unstable_ConcurrentMode: x$2,
  unstable_Profiler: u,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentDispatcher: I$1, ReactCurrentOwner: J$1, assign: k$1 }
}, Y$1 = { default: X$1 }, Z$1 = Y$1 && X$1 || Y$1;
var react_production_min = Z$1.default || Z$1;
(function(module) {
  {
    module.exports = react_production_min;
  }
})(react);
const React$a = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
var reactDom = { exports: {} };
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.13.6
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var d2 = null, e2 = false, g2 = 3, k2 = -1, l2 = -1, m2 = false, n2 = false;
  function p2() {
    if (!m2) {
      var a = d2.expirationTime;
      n2 ? q2() : n2 = true;
      r2(t2, a);
    }
  }
  function u2() {
    var a = d2, b2 = d2.next;
    if (d2 === b2)
      d2 = null;
    else {
      var c2 = d2.previous;
      d2 = c2.next = b2;
      b2.previous = c2;
    }
    a.next = a.previous = null;
    c2 = a.callback;
    b2 = a.expirationTime;
    a = a.priorityLevel;
    var f2 = g2, Q2 = l2;
    g2 = a;
    l2 = b2;
    try {
      var h2 = c2();
    } finally {
      g2 = f2, l2 = Q2;
    }
    if ("function" === typeof h2)
      if (h2 = { callback: h2, priorityLevel: a, expirationTime: b2, next: null, previous: null }, null === d2)
        d2 = h2.next = h2.previous = h2;
      else {
        c2 = null;
        a = d2;
        do {
          if (a.expirationTime >= b2) {
            c2 = a;
            break;
          }
          a = a.next;
        } while (a !== d2);
        null === c2 ? c2 = d2 : c2 === d2 && (d2 = h2, p2());
        b2 = c2.previous;
        b2.next = c2.previous = h2;
        h2.next = c2;
        h2.previous = b2;
      }
  }
  function v2() {
    if (-1 === k2 && null !== d2 && 1 === d2.priorityLevel) {
      m2 = true;
      try {
        do
          u2();
        while (null !== d2 && 1 === d2.priorityLevel);
      } finally {
        m2 = false, null !== d2 ? p2() : n2 = false;
      }
    }
  }
  function t2(a) {
    m2 = true;
    var b2 = e2;
    e2 = a;
    try {
      if (a)
        for (; null !== d2; ) {
          var c2 = exports.unstable_now();
          if (d2.expirationTime <= c2) {
            do
              u2();
            while (null !== d2 && d2.expirationTime <= c2);
          } else
            break;
        }
      else if (null !== d2) {
        do
          u2();
        while (null !== d2 && !w2());
      }
    } finally {
      m2 = false, e2 = b2, null !== d2 ? p2() : n2 = false, v2();
    }
  }
  var x2 = Date, y2 = "function" === typeof setTimeout ? setTimeout : void 0, z2 = "function" === typeof clearTimeout ? clearTimeout : void 0, A2 = "function" === typeof requestAnimationFrame ? requestAnimationFrame : void 0, B2 = "function" === typeof cancelAnimationFrame ? cancelAnimationFrame : void 0, C2, D2;
  function E2(a) {
    C2 = A2(function(b2) {
      z2(D2);
      a(b2);
    });
    D2 = y2(function() {
      B2(C2);
      a(exports.unstable_now());
    }, 100);
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var F2 = performance;
    exports.unstable_now = function() {
      return F2.now();
    };
  } else
    exports.unstable_now = function() {
      return x2.now();
    };
  var r2, q2, w2, G2 = null;
  "undefined" !== typeof window ? G2 = window : "undefined" !== typeof commonjsGlobal$1 && (G2 = commonjsGlobal$1);
  if (G2 && G2._schedMock) {
    var H2 = G2._schedMock;
    r2 = H2[0];
    q2 = H2[1];
    w2 = H2[2];
    exports.unstable_now = H2[3];
  } else if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var I2 = null, J2 = function(a) {
      if (null !== I2)
        try {
          I2(a);
        } finally {
          I2 = null;
        }
    };
    r2 = function(a) {
      null !== I2 ? setTimeout(r2, 0, a) : (I2 = a, setTimeout(J2, 0, false));
    };
    q2 = function() {
      I2 = null;
    };
    w2 = function() {
      return false;
    };
  } else {
    "undefined" !== typeof console && ("function" !== typeof A2 && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"), "function" !== typeof B2 && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));
    var K2 = null, L2 = false, M2 = -1, N2 = false, O2 = false, P2 = 0, R2 = 33, S2 = 33;
    w2 = function() {
      return P2 <= exports.unstable_now();
    };
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = function() {
      L2 = false;
      var a = K2, b2 = M2;
      K2 = null;
      M2 = -1;
      var c2 = exports.unstable_now(), f2 = false;
      if (0 >= P2 - c2)
        if (-1 !== b2 && b2 <= c2)
          f2 = true;
        else {
          N2 || (N2 = true, E2(V2));
          K2 = a;
          M2 = b2;
          return;
        }
      if (null !== a) {
        O2 = true;
        try {
          a(f2);
        } finally {
          O2 = false;
        }
      }
    };
    var V2 = function(a) {
      if (null !== K2) {
        E2(V2);
        var b2 = a - P2 + S2;
        b2 < S2 && R2 < S2 ? (8 > b2 && (b2 = 8), S2 = b2 < R2 ? R2 : b2) : R2 = b2;
        P2 = a + S2;
        L2 || (L2 = true, U2.postMessage(void 0));
      } else
        N2 = false;
    };
    r2 = function(a, b2) {
      K2 = a;
      M2 = b2;
      O2 || 0 > b2 ? U2.postMessage(void 0) : N2 || (N2 = true, E2(V2));
    };
    q2 = function() {
      K2 = null;
      L2 = false;
      M2 = -1;
    };
  }
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_NormalPriority = 3;
  exports.unstable_IdlePriority = 5;
  exports.unstable_LowPriority = 4;
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c2 = g2, f2 = k2;
    g2 = a;
    k2 = exports.unstable_now();
    try {
      return b2();
    } finally {
      g2 = c2, k2 = f2, v2();
    }
  };
  exports.unstable_next = function(a) {
    switch (g2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = g2;
    }
    var c2 = g2, f2 = k2;
    g2 = b2;
    k2 = exports.unstable_now();
    try {
      return a();
    } finally {
      g2 = c2, k2 = f2, v2();
    }
  };
  exports.unstable_scheduleCallback = function(a, b2) {
    var c2 = -1 !== k2 ? k2 : exports.unstable_now();
    if ("object" === typeof b2 && null !== b2 && "number" === typeof b2.timeout)
      b2 = c2 + b2.timeout;
    else
      switch (g2) {
        case 1:
          b2 = c2 + -1;
          break;
        case 2:
          b2 = c2 + 250;
          break;
        case 5:
          b2 = c2 + 1073741823;
          break;
        case 4:
          b2 = c2 + 1e4;
          break;
        default:
          b2 = c2 + 5e3;
      }
    a = { callback: a, priorityLevel: g2, expirationTime: b2, next: null, previous: null };
    if (null === d2)
      d2 = a.next = a.previous = a, p2();
    else {
      c2 = null;
      var f2 = d2;
      do {
        if (f2.expirationTime > b2) {
          c2 = f2;
          break;
        }
        f2 = f2.next;
      } while (f2 !== d2);
      null === c2 ? c2 = d2 : c2 === d2 && (d2 = a, p2());
      b2 = c2.previous;
      b2.next = c2.previous = a;
      a.next = c2;
      a.previous = b2;
    }
    return a;
  };
  exports.unstable_cancelCallback = function(a) {
    var b2 = a.next;
    if (null !== b2) {
      if (b2 === a)
        d2 = null;
      else {
        a === d2 && (d2 = b2);
        var c2 = a.previous;
        c2.next = b2;
        b2.previous = c2;
      }
      a.next = a.previous = null;
    }
  };
  exports.unstable_wrapCallback = function(a) {
    var b2 = g2;
    return function() {
      var c2 = g2, f2 = k2;
      g2 = b2;
      k2 = exports.unstable_now();
      try {
        return a.apply(this, arguments);
      } finally {
        g2 = c2, k2 = f2, v2();
      }
    };
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return g2;
  };
  exports.unstable_shouldYield = function() {
    return !e2 && (null !== d2 && d2.expirationTime < l2 || w2());
  };
  exports.unstable_continueExecution = function() {
    null !== d2 && p2();
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_getFirstCallbackNode = function() {
    return d2;
  };
})(scheduler_production_min);
(function(module) {
  {
    module.exports = scheduler_production_min;
  }
})(scheduler);
/** @license React v16.8.6
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, n$2 = objectAssign, r$2 = scheduler.exports;
function ba(a, b2, c2, d2, e2, f2, g2, h2) {
  if (!a) {
    a = void 0;
    if (void 0 === b2)
      a = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var l2 = [c2, d2, e2, f2, g2, h2], k2 = 0;
      a = Error(b2.replace(/%s/g, function() {
        return l2[k2++];
      }));
      a.name = "Invariant Violation";
    }
    a.framesToPop = 1;
    throw a;
  }
}
function x$1(a) {
  for (var b2 = arguments.length - 1, c2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, d2 = 0; d2 < b2; d2++)
    c2 += "&args[]=" + encodeURIComponent(arguments[d2 + 1]);
  ba(false, "Minified React error #" + a + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", c2);
}
aa ? void 0 : x$1("227");
function ca(a, b2, c2, d2, e2, f2, g2, h2, l2) {
  var k2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, k2);
  } catch (m2) {
    this.onError(m2);
  }
}
var da = false, ea = null, fa = false, ha = null, ia = { onError: function(a) {
  da = true;
  ea = a;
} };
function ja(a, b2, c2, d2, e2, f2, g2, h2, l2) {
  da = false;
  ea = null;
  ca.apply(ia, arguments);
}
function ka(a, b2, c2, d2, e2, f2, g2, h2, l2) {
  ja.apply(this, arguments);
  if (da) {
    if (da) {
      var k2 = ea;
      da = false;
      ea = null;
    } else
      x$1("198"), k2 = void 0;
    fa || (fa = true, ha = k2);
  }
}
var la = null, ma = {};
function na() {
  if (la)
    for (var a in ma) {
      var b2 = ma[a], c2 = la.indexOf(a);
      -1 < c2 ? void 0 : x$1("96", a);
      if (!oa[c2]) {
        b2.extractEvents ? void 0 : x$1("97", a);
        oa[c2] = b2;
        c2 = b2.eventTypes;
        for (var d2 in c2) {
          var e2 = void 0;
          var f2 = c2[d2], g2 = b2, h2 = d2;
          pa.hasOwnProperty(h2) ? x$1("99", h2) : void 0;
          pa[h2] = f2;
          var l2 = f2.phasedRegistrationNames;
          if (l2) {
            for (e2 in l2)
              l2.hasOwnProperty(e2) && qa(l2[e2], g2, h2);
            e2 = true;
          } else
            f2.registrationName ? (qa(f2.registrationName, g2, h2), e2 = true) : e2 = false;
          e2 ? void 0 : x$1("98", d2, a);
        }
      }
    }
}
function qa(a, b2, c2) {
  ra[a] ? x$1("100", a) : void 0;
  ra[a] = b2;
  sa[a] = b2.eventTypes[c2].dependencies;
}
var oa = [], pa = {}, ra = {}, sa = {}, ta = null, ua = null, va = null;
function wa(a, b2, c2) {
  var d2 = a.type || "unknown-event";
  a.currentTarget = va(c2);
  ka(d2, b2, void 0, a);
  a.currentTarget = null;
}
function xa(a, b2) {
  null == b2 ? x$1("30") : void 0;
  if (null == a)
    return b2;
  if (Array.isArray(a)) {
    if (Array.isArray(b2))
      return a.push.apply(a, b2), a;
    a.push(b2);
    return a;
  }
  return Array.isArray(b2) ? [a].concat(b2) : [a, b2];
}
function ya(a, b2, c2) {
  Array.isArray(a) ? a.forEach(b2, c2) : a && b2.call(c2, a);
}
var za = null;
function Aa(a) {
  if (a) {
    var b2 = a._dispatchListeners, c2 = a._dispatchInstances;
    if (Array.isArray(b2))
      for (var d2 = 0; d2 < b2.length && !a.isPropagationStopped(); d2++)
        wa(a, b2[d2], c2[d2]);
    else
      b2 && wa(a, b2, c2);
    a._dispatchListeners = null;
    a._dispatchInstances = null;
    a.isPersistent() || a.constructor.release(a);
  }
}
var Ba = { injectEventPluginOrder: function(a) {
  la ? x$1("101") : void 0;
  la = Array.prototype.slice.call(a);
  na();
}, injectEventPluginsByName: function(a) {
  var b2 = false, c2;
  for (c2 in a)
    if (a.hasOwnProperty(c2)) {
      var d2 = a[c2];
      ma.hasOwnProperty(c2) && ma[c2] === d2 || (ma[c2] ? x$1("102", c2) : void 0, ma[c2] = d2, b2 = true);
    }
  b2 && na();
} };
function Ca(a, b2) {
  var c2 = a.stateNode;
  if (!c2)
    return null;
  var d2 = ta(c2);
  if (!d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  c2 && "function" !== typeof c2 ? x$1("231", b2, typeof c2) : void 0;
  return c2;
}
function Da(a) {
  null !== a && (za = xa(za, a));
  a = za;
  za = null;
  if (a && (ya(a, Aa), za ? x$1("95") : void 0, fa))
    throw a = ha, fa = false, ha = null, a;
}
var Ea = Math.random().toString(36).slice(2), Fa = "__reactInternalInstance$" + Ea, Ga = "__reactEventHandlers$" + Ea;
function Ha(a) {
  if (a[Fa])
    return a[Fa];
  for (; !a[Fa]; )
    if (a.parentNode)
      a = a.parentNode;
    else
      return null;
  a = a[Fa];
  return 5 === a.tag || 6 === a.tag ? a : null;
}
function Ia(a) {
  a = a[Fa];
  return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
}
function Ja(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  x$1("33");
}
function Ka(a) {
  return a[Ga] || null;
}
function La(a) {
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function Ma(a, b2, c2) {
  if (b2 = Ca(a, c2.dispatchConfig.phasedRegistrationNames[b2]))
    c2._dispatchListeners = xa(c2._dispatchListeners, b2), c2._dispatchInstances = xa(c2._dispatchInstances, a);
}
function Na(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    for (var b2 = a._targetInst, c2 = []; b2; )
      c2.push(b2), b2 = La(b2);
    for (b2 = c2.length; 0 < b2--; )
      Ma(c2[b2], "captured", a);
    for (b2 = 0; b2 < c2.length; b2++)
      Ma(c2[b2], "bubbled", a);
  }
}
function Oa(a, b2, c2) {
  a && c2 && c2.dispatchConfig.registrationName && (b2 = Ca(a, c2.dispatchConfig.registrationName)) && (c2._dispatchListeners = xa(c2._dispatchListeners, b2), c2._dispatchInstances = xa(c2._dispatchInstances, a));
}
function Pa(a) {
  a && a.dispatchConfig.registrationName && Oa(a._targetInst, null, a);
}
function Qa(a) {
  ya(a, Na);
}
var Ra = !("undefined" === typeof window || !window.document || !window.document.createElement);
function Sa(a, b2) {
  var c2 = {};
  c2[a.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a] = "webkit" + b2;
  c2["Moz" + a] = "moz" + b2;
  return c2;
}
var Ta = { animationend: Sa("Animation", "AnimationEnd"), animationiteration: Sa("Animation", "AnimationIteration"), animationstart: Sa("Animation", "AnimationStart"), transitionend: Sa("Transition", "TransitionEnd") }, Ua = {}, Va = {};
Ra && (Va = document.createElement("div").style, "AnimationEvent" in window || (delete Ta.animationend.animation, delete Ta.animationiteration.animation, delete Ta.animationstart.animation), "TransitionEvent" in window || delete Ta.transitionend.transition);
function Wa(a) {
  if (Ua[a])
    return Ua[a];
  if (!Ta[a])
    return a;
  var b2 = Ta[a], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Va)
      return Ua[a] = b2[c2];
  return a;
}
var Xa = Wa("animationend"), Ya = Wa("animationiteration"), Za = Wa("animationstart"), $a = Wa("transitionend"), ab = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), bb = null, cb = null, db = null;
function eb() {
  if (db)
    return db;
  var a, b2 = cb, c2 = b2.length, d2, e2 = "value" in bb ? bb.value : bb.textContent, f2 = e2.length;
  for (a = 0; a < c2 && b2[a] === e2[a]; a++)
    ;
  var g2 = c2 - a;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return db = e2.slice(a, 1 < d2 ? 1 - d2 : void 0);
}
function fb() {
  return true;
}
function gb() {
  return false;
}
function y$1(a, b2, c2, d2) {
  this.dispatchConfig = a;
  this._targetInst = b2;
  this.nativeEvent = c2;
  a = this.constructor.Interface;
  for (var e2 in a)
    a.hasOwnProperty(e2) && ((b2 = a[e2]) ? this[e2] = b2(c2) : "target" === e2 ? this.target = d2 : this[e2] = c2[e2]);
  this.isDefaultPrevented = (null != c2.defaultPrevented ? c2.defaultPrevented : false === c2.returnValue) ? fb : gb;
  this.isPropagationStopped = gb;
  return this;
}
n$2(y$1.prototype, { preventDefault: function() {
  this.defaultPrevented = true;
  var a = this.nativeEvent;
  a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = false), this.isDefaultPrevented = fb);
}, stopPropagation: function() {
  var a = this.nativeEvent;
  a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = true), this.isPropagationStopped = fb);
}, persist: function() {
  this.isPersistent = fb;
}, isPersistent: gb, destructor: function() {
  var a = this.constructor.Interface, b2;
  for (b2 in a)
    this[b2] = null;
  this.nativeEvent = this._targetInst = this.dispatchConfig = null;
  this.isPropagationStopped = this.isDefaultPrevented = gb;
  this._dispatchInstances = this._dispatchListeners = null;
} });
y$1.Interface = { type: null, target: null, currentTarget: function() {
  return null;
}, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: null, isTrusted: null };
y$1.extend = function(a) {
  function b2() {
  }
  function c2() {
    return d2.apply(this, arguments);
  }
  var d2 = this;
  b2.prototype = d2.prototype;
  var e2 = new b2();
  n$2(e2, c2.prototype);
  c2.prototype = e2;
  c2.prototype.constructor = c2;
  c2.Interface = n$2({}, d2.Interface, a);
  c2.extend = d2.extend;
  hb(c2);
  return c2;
};
hb(y$1);
function ib(a, b2, c2, d2) {
  if (this.eventPool.length) {
    var e2 = this.eventPool.pop();
    this.call(e2, a, b2, c2, d2);
    return e2;
  }
  return new this(a, b2, c2, d2);
}
function jb(a) {
  a instanceof this ? void 0 : x$1("279");
  a.destructor();
  10 > this.eventPool.length && this.eventPool.push(a);
}
function hb(a) {
  a.eventPool = [];
  a.getPooled = ib;
  a.release = jb;
}
var kb = y$1.extend({ data: null }), lb = y$1.extend({ data: null }), mb = [9, 13, 27, 32], nb = Ra && "CompositionEvent" in window, ob = null;
Ra && "documentMode" in document && (ob = document.documentMode);
var pb = Ra && "TextEvent" in window && !ob, qb = Ra && (!nb || ob && 8 < ob && 11 >= ob), rb = String.fromCharCode(32), sb = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["compositionend", "keypress", "textInput", "paste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "blur compositionend keydown keypress keyup mousedown".split(" ") }, compositionStart: { phasedRegistrationNames: {
  bubbled: "onCompositionStart",
  captured: "onCompositionStartCapture"
}, dependencies: "blur compositionstart keydown keypress keyup mousedown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(" ") } }, tb = false;
function ub(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== mb.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "blur":
      return true;
    default:
      return false;
  }
}
function vb(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var wb = false;
function xb(a, b2) {
  switch (a) {
    case "compositionend":
      return vb(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      tb = true;
      return rb;
    case "textInput":
      return a = b2.data, a === rb && tb ? null : a;
    default:
      return null;
  }
}
function yb(a, b2) {
  if (wb)
    return "compositionend" === a || !nb && ub(a, b2) ? (a = eb(), db = cb = bb = null, wb = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return qb && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var zb = { eventTypes: sb, extractEvents: function(a, b2, c2, d2) {
  var e2 = void 0;
  var f2 = void 0;
  if (nb)
    b: {
      switch (a) {
        case "compositionstart":
          e2 = sb.compositionStart;
          break b;
        case "compositionend":
          e2 = sb.compositionEnd;
          break b;
        case "compositionupdate":
          e2 = sb.compositionUpdate;
          break b;
      }
      e2 = void 0;
    }
  else
    wb ? ub(a, c2) && (e2 = sb.compositionEnd) : "keydown" === a && 229 === c2.keyCode && (e2 = sb.compositionStart);
  e2 ? (qb && "ko" !== c2.locale && (wb || e2 !== sb.compositionStart ? e2 === sb.compositionEnd && wb && (f2 = eb()) : (bb = d2, cb = "value" in bb ? bb.value : bb.textContent, wb = true)), e2 = kb.getPooled(e2, b2, c2, d2), f2 ? e2.data = f2 : (f2 = vb(c2), null !== f2 && (e2.data = f2)), Qa(e2), f2 = e2) : f2 = null;
  (a = pb ? xb(a, c2) : yb(a, c2)) ? (b2 = lb.getPooled(sb.beforeInput, b2, c2, d2), b2.data = a, Qa(b2)) : b2 = null;
  return null === f2 ? b2 : null === b2 ? f2 : [f2, b2];
} }, Ab = null, Bb = null, Cb = null;
function Db(a) {
  if (a = ua(a)) {
    "function" !== typeof Ab ? x$1("280") : void 0;
    var b2 = ta(a.stateNode);
    Ab(a.stateNode, a.type, b2);
  }
}
function Eb(a) {
  Bb ? Cb ? Cb.push(a) : Cb = [a] : Bb = a;
}
function Fb() {
  if (Bb) {
    var a = Bb, b2 = Cb;
    Cb = Bb = null;
    Db(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Db(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb(a, b2, c2) {
  return a(b2, c2);
}
function Ib() {
}
var Jb = false;
function Kb(a, b2) {
  if (Jb)
    return a(b2);
  Jb = true;
  try {
    return Gb(a, b2);
  } finally {
    if (Jb = false, null !== Bb || null !== Cb)
      Ib(), Fb();
  }
}
var Lb = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function Mb(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!Lb[a.type] : "textarea" === b2 ? true : false;
}
function Nb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
function Ob(a) {
  if (!Ra)
    return false;
  a = "on" + a;
  var b2 = a in document;
  b2 || (b2 = document.createElement("div"), b2.setAttribute(a, "return;"), b2 = "function" === typeof b2[a]);
  return b2;
}
function Pb(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Qb(a) {
  var b2 = Pb(a) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d2 = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d2 = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a2) {
      d2 = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Rb(a) {
  a._valueTracker || (a._valueTracker = Qb(a));
}
function Sb(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a && (d2 = Pb(a) ? a.checked ? "true" : "false" : a.value);
  a = d2;
  return a !== c2 ? (b2.setValue(a), true) : false;
}
var Tb = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
Tb.hasOwnProperty("ReactCurrentDispatcher") || (Tb.ReactCurrentDispatcher = { current: null });
var Ub = /^(.*)[\\\/]/, z$1 = "function" === typeof Symbol && Symbol.for, Vb = z$1 ? Symbol.for("react.element") : 60103, Wb = z$1 ? Symbol.for("react.portal") : 60106, Xb = z$1 ? Symbol.for("react.fragment") : 60107, Yb = z$1 ? Symbol.for("react.strict_mode") : 60108, Zb = z$1 ? Symbol.for("react.profiler") : 60114, $b = z$1 ? Symbol.for("react.provider") : 60109, ac = z$1 ? Symbol.for("react.context") : 60110, bc = z$1 ? Symbol.for("react.concurrent_mode") : 60111, cc = z$1 ? Symbol.for("react.forward_ref") : 60112, dc = z$1 ? Symbol.for("react.suspense") : 60113, ec = z$1 ? Symbol.for("react.memo") : 60115, fc = z$1 ? Symbol.for("react.lazy") : 60116, gc = "function" === typeof Symbol && Symbol.iterator;
function hc(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = gc && a[gc] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
function ic(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case bc:
      return "ConcurrentMode";
    case Xb:
      return "Fragment";
    case Wb:
      return "Portal";
    case Zb:
      return "Profiler";
    case Yb:
      return "StrictMode";
    case dc:
      return "Suspense";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case ac:
        return "Context.Consumer";
      case $b:
        return "Context.Provider";
      case cc:
        var b2 = a.render;
        b2 = b2.displayName || b2.name || "";
        return a.displayName || ("" !== b2 ? "ForwardRef(" + b2 + ")" : "ForwardRef");
      case ec:
        return ic(a.type);
      case fc:
        if (a = 1 === a._status ? a._result : null)
          return ic(a);
    }
  return null;
}
function jc(a) {
  var b2 = "";
  do {
    a:
      switch (a.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var c2 = "";
          break a;
        default:
          var d2 = a._debugOwner, e2 = a._debugSource, f2 = ic(a.type);
          c2 = null;
          d2 && (c2 = ic(d2.type));
          d2 = f2;
          f2 = "";
          e2 ? f2 = " (at " + e2.fileName.replace(Ub, "") + ":" + e2.lineNumber + ")" : c2 && (f2 = " (created by " + c2 + ")");
          c2 = "\n    in " + (d2 || "Unknown") + f2;
      }
    b2 += c2;
    a = a.return;
  } while (a);
  return b2;
}
var kc = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, lc = Object.prototype.hasOwnProperty, mc = {}, nc = {};
function oc(a) {
  if (lc.call(nc, a))
    return true;
  if (lc.call(mc, a))
    return false;
  if (kc.test(a))
    return nc[a] = true;
  mc[a] = true;
  return false;
}
function pc(a, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qc(a, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pc(a, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function C(a, b2, c2, d2, e2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a;
  this.type = b2;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new C(a, 0, false, a, null);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  D[b2] = new C(b2, 1, false, a[1], null);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new C(a, 2, false, a.toLowerCase(), null);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new C(a, 2, false, a, null);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new C(a, 3, false, a.toLowerCase(), null);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new C(a, 3, true, a, null);
});
["capture", "download"].forEach(function(a) {
  D[a] = new C(a, 4, false, a, null);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new C(a, 6, false, a, null);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new C(a, 5, false, a.toLowerCase(), null);
});
var rc = /[\-:]([a-z])/g;
function sc(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(rc, sc);
  D[b2] = new C(b2, 1, false, a, null);
});
"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(rc, sc);
  D[b2] = new C(b2, 1, false, a, "http://www.w3.org/1999/xlink");
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(rc, sc);
  D[b2] = new C(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace");
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new C(a, 1, false, a.toLowerCase(), null);
});
function tc(a, b2, c2, d2) {
  var e2 = D.hasOwnProperty(b2) ? D[b2] : null;
  var f2 = null !== e2 ? 0 === e2.type : d2 ? false : !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1] ? false : true;
  f2 || (qc(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oc(b2) && (null === c2 ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a.setAttributeNS(d2, b2, c2) : a.setAttribute(b2, c2))));
}
function uc(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function vc(a, b2) {
  var c2 = b2.checked;
  return n$2({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a._wrapperState.initialChecked });
}
function wc(a, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = uc(null != b2.value ? b2.value : c2);
  a._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function xc(a, b2) {
  b2 = b2.checked;
  null != b2 && tc(a, "checked", b2, false);
}
function yc(a, b2) {
  xc(a, b2);
  var c2 = uc(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a.value || a.value != c2)
        a.value = "" + c2;
    } else
      a.value !== "" + c2 && (a.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? zc(a, b2.type, c2) : b2.hasOwnProperty("defaultValue") && zc(a, b2.type, uc(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function Ac(a, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c2 || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c2 = a.name;
  "" !== c2 && (a.name = "");
  a.defaultChecked = !a.defaultChecked;
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c2 && (a.name = c2);
}
function zc(a, b2, c2) {
  if ("number" !== b2 || a.ownerDocument.activeElement !== a)
    null == c2 ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c2 && (a.defaultValue = "" + c2);
}
var Bc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "blur change click focus input keydown keyup selectionchange".split(" ") } };
function Cc(a, b2, c2) {
  a = y$1.getPooled(Bc.change, a, b2, c2);
  a.type = "change";
  Eb(c2);
  Qa(a);
  return a;
}
var Dc = null, Ec = null;
function Fc(a) {
  Da(a);
}
function Gc(a) {
  var b2 = Ja(a);
  if (Sb(b2))
    return a;
}
function Hc(a, b2) {
  if ("change" === a)
    return b2;
}
var Ic = false;
Ra && (Ic = Ob("input") && (!document.documentMode || 9 < document.documentMode));
function Jc() {
  Dc && (Dc.detachEvent("onpropertychange", Kc), Ec = Dc = null);
}
function Kc(a) {
  "value" === a.propertyName && Gc(Ec) && (a = Cc(Ec, a, Nb(a)), Kb(Fc, a));
}
function Lc(a, b2, c2) {
  "focus" === a ? (Jc(), Dc = b2, Ec = c2, Dc.attachEvent("onpropertychange", Kc)) : "blur" === a && Jc();
}
function Mc(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return Gc(Ec);
}
function Nc(a, b2) {
  if ("click" === a)
    return Gc(b2);
}
function Oc(a, b2) {
  if ("input" === a || "change" === a)
    return Gc(b2);
}
var Pc = { eventTypes: Bc, _isInputEventSupported: Ic, extractEvents: function(a, b2, c2, d2) {
  var e2 = b2 ? Ja(b2) : window, f2 = void 0, g2 = void 0, h2 = e2.nodeName && e2.nodeName.toLowerCase();
  "select" === h2 || "input" === h2 && "file" === e2.type ? f2 = Hc : Mb(e2) ? Ic ? f2 = Oc : (f2 = Mc, g2 = Lc) : (h2 = e2.nodeName) && "input" === h2.toLowerCase() && ("checkbox" === e2.type || "radio" === e2.type) && (f2 = Nc);
  if (f2 && (f2 = f2(a, b2)))
    return Cc(f2, c2, d2);
  g2 && g2(a, e2, b2);
  "blur" === a && (a = e2._wrapperState) && a.controlled && "number" === e2.type && zc(e2, "number", e2.value);
} }, Qc = y$1.extend({ view: null, detail: null }), Rc = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};
function Sc(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Rc[a]) ? !!b2[a] : false;
}
function Tc() {
  return Sc;
}
var Uc = 0, Vc = 0, Wc = false, Xc = false, Yc = Qc.extend({ screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: Tc, button: null, buttons: null, relatedTarget: function(a) {
  return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  var b2 = Uc;
  Uc = a.screenX;
  return Wc ? "mousemove" === a.type ? a.screenX - b2 : 0 : (Wc = true, 0);
}, movementY: function(a) {
  if ("movementY" in a)
    return a.movementY;
  var b2 = Vc;
  Vc = a.screenY;
  return Xc ? "mousemove" === a.type ? a.screenY - b2 : 0 : (Xc = true, 0);
} }), Zc = Yc.extend({ pointerId: null, width: null, height: null, pressure: null, tangentialPressure: null, tiltX: null, tiltY: null, twist: null, pointerType: null, isPrimary: null }), $c = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["mouseout", "mouseover"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["mouseout", "mouseover"] }, pointerEnter: { registrationName: "onPointerEnter", dependencies: ["pointerout", "pointerover"] }, pointerLeave: {
  registrationName: "onPointerLeave",
  dependencies: ["pointerout", "pointerover"]
} }, ad = { eventTypes: $c, extractEvents: function(a, b2, c2, d2) {
  var e2 = "mouseover" === a || "pointerover" === a, f2 = "mouseout" === a || "pointerout" === a;
  if (e2 && (c2.relatedTarget || c2.fromElement) || !f2 && !e2)
    return null;
  e2 = d2.window === d2 ? d2 : (e2 = d2.ownerDocument) ? e2.defaultView || e2.parentWindow : window;
  f2 ? (f2 = b2, b2 = (b2 = c2.relatedTarget || c2.toElement) ? Ha(b2) : null) : f2 = null;
  if (f2 === b2)
    return null;
  var g2 = void 0, h2 = void 0, l2 = void 0, k2 = void 0;
  if ("mouseout" === a || "mouseover" === a)
    g2 = Yc, h2 = $c.mouseLeave, l2 = $c.mouseEnter, k2 = "mouse";
  else if ("pointerout" === a || "pointerover" === a)
    g2 = Zc, h2 = $c.pointerLeave, l2 = $c.pointerEnter, k2 = "pointer";
  var m2 = null == f2 ? e2 : Ja(f2);
  e2 = null == b2 ? e2 : Ja(b2);
  a = g2.getPooled(h2, f2, c2, d2);
  a.type = k2 + "leave";
  a.target = m2;
  a.relatedTarget = e2;
  c2 = g2.getPooled(l2, b2, c2, d2);
  c2.type = k2 + "enter";
  c2.target = e2;
  c2.relatedTarget = m2;
  d2 = b2;
  if (f2 && d2)
    a: {
      b2 = f2;
      e2 = d2;
      k2 = 0;
      for (g2 = b2; g2; g2 = La(g2))
        k2++;
      g2 = 0;
      for (l2 = e2; l2; l2 = La(l2))
        g2++;
      for (; 0 < k2 - g2; )
        b2 = La(b2), k2--;
      for (; 0 < g2 - k2; )
        e2 = La(e2), g2--;
      for (; k2--; ) {
        if (b2 === e2 || b2 === e2.alternate)
          break a;
        b2 = La(b2);
        e2 = La(e2);
      }
      b2 = null;
    }
  else
    b2 = null;
  e2 = b2;
  for (b2 = []; f2 && f2 !== e2; ) {
    k2 = f2.alternate;
    if (null !== k2 && k2 === e2)
      break;
    b2.push(f2);
    f2 = La(f2);
  }
  for (f2 = []; d2 && d2 !== e2; ) {
    k2 = d2.alternate;
    if (null !== k2 && k2 === e2)
      break;
    f2.push(d2);
    d2 = La(d2);
  }
  for (d2 = 0; d2 < b2.length; d2++)
    Oa(b2[d2], "bubbled", a);
  for (d2 = f2.length; 0 < d2--; )
    Oa(f2[d2], "captured", c2);
  return [a, c2];
} };
function bd(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var cd = Object.prototype.hasOwnProperty;
function dd(a, b2) {
  if (bd(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++)
    if (!cd.call(b2, c2[d2]) || !bd(a[c2[d2]], b2[c2[d2]]))
      return false;
  return true;
}
function ed(a) {
  var b2 = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    if (0 !== (b2.effectTag & 2))
      return 1;
    for (; b2.return; )
      if (b2 = b2.return, 0 !== (b2.effectTag & 2))
        return 1;
  }
  return 3 === b2.tag ? 2 : 3;
}
function fd(a) {
  2 !== ed(a) ? x$1("188") : void 0;
}
function gd(a) {
  var b2 = a.alternate;
  if (!b2)
    return b2 = ed(a), 3 === b2 ? x$1("188") : void 0, 1 === b2 ? null : a;
  for (var c2 = a, d2 = b2; ; ) {
    var e2 = c2.return, f2 = e2 ? e2.alternate : null;
    if (!e2 || !f2)
      break;
    if (e2.child === f2.child) {
      for (var g2 = e2.child; g2; ) {
        if (g2 === c2)
          return fd(e2), a;
        if (g2 === d2)
          return fd(e2), b2;
        g2 = g2.sibling;
      }
      x$1("188");
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      g2 = false;
      for (var h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        g2 ? void 0 : x$1("189");
      }
    }
    c2.alternate !== d2 ? x$1("190") : void 0;
  }
  3 !== c2.tag ? x$1("188") : void 0;
  return c2.stateNode.current === c2 ? a : b2;
}
function hd(a) {
  a = gd(a);
  if (!a)
    return null;
  for (var b2 = a; ; ) {
    if (5 === b2.tag || 6 === b2.tag)
      return b2;
    if (b2.child)
      b2.child.return = b2, b2 = b2.child;
    else {
      if (b2 === a)
        break;
      for (; !b2.sibling; ) {
        if (!b2.return || b2.return === a)
          return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return null;
}
var id$1 = y$1.extend({ animationName: null, elapsedTime: null, pseudoElement: null }), jd = y$1.extend({ clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), kd = Qc.extend({ relatedTarget: null });
function ld(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
var md = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, od = Qc.extend({ key: function(a) {
  if (a.key) {
    var b2 = md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = ld(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? nd[a.keyCode] || "Unidentified" : "";
}, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: Tc, charCode: function(a) {
  return "keypress" === a.type ? ld(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? ld(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), pd = Yc.extend({ dataTransfer: null }), qd = Qc.extend({ touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: Tc }), rd = y$1.extend({ propertyName: null, elapsedTime: null, pseudoElement: null }), sd = Yc.extend({ deltaX: function(a) {
  return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
}, deltaY: function(a) {
  return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
}, deltaZ: null, deltaMode: null }), td = [
  ["abort", "abort"],
  [Xa, "animationEnd"],
  [Ya, "animationIteration"],
  [Za, "animationStart"],
  ["canplay", "canPlay"],
  ["canplaythrough", "canPlayThrough"],
  ["drag", "drag"],
  ["dragenter", "dragEnter"],
  ["dragexit", "dragExit"],
  ["dragleave", "dragLeave"],
  ["dragover", "dragOver"],
  ["durationchange", "durationChange"],
  ["emptied", "emptied"],
  ["encrypted", "encrypted"],
  ["ended", "ended"],
  ["error", "error"],
  ["gotpointercapture", "gotPointerCapture"],
  ["load", "load"],
  ["loadeddata", "loadedData"],
  ["loadedmetadata", "loadedMetadata"],
  ["loadstart", "loadStart"],
  ["lostpointercapture", "lostPointerCapture"],
  ["mousemove", "mouseMove"],
  ["mouseout", "mouseOut"],
  ["mouseover", "mouseOver"],
  ["playing", "playing"],
  ["pointermove", "pointerMove"],
  ["pointerout", "pointerOut"],
  ["pointerover", "pointerOver"],
  ["progress", "progress"],
  ["scroll", "scroll"],
  ["seeking", "seeking"],
  ["stalled", "stalled"],
  ["suspend", "suspend"],
  ["timeupdate", "timeUpdate"],
  ["toggle", "toggle"],
  ["touchmove", "touchMove"],
  [$a, "transitionEnd"],
  ["waiting", "waiting"],
  ["wheel", "wheel"]
], ud = {}, vd = {};
function wd(a, b2) {
  var c2 = a[0];
  a = a[1];
  var d2 = "on" + (a[0].toUpperCase() + a.slice(1));
  b2 = { phasedRegistrationNames: { bubbled: d2, captured: d2 + "Capture" }, dependencies: [c2], isInteractive: b2 };
  ud[a] = b2;
  vd[c2] = b2;
}
[
  ["blur", "blur"],
  ["cancel", "cancel"],
  ["click", "click"],
  ["close", "close"],
  ["contextmenu", "contextMenu"],
  ["copy", "copy"],
  ["cut", "cut"],
  ["auxclick", "auxClick"],
  ["dblclick", "doubleClick"],
  ["dragend", "dragEnd"],
  ["dragstart", "dragStart"],
  ["drop", "drop"],
  ["focus", "focus"],
  ["input", "input"],
  ["invalid", "invalid"],
  ["keydown", "keyDown"],
  ["keypress", "keyPress"],
  ["keyup", "keyUp"],
  ["mousedown", "mouseDown"],
  ["mouseup", "mouseUp"],
  ["paste", "paste"],
  ["pause", "pause"],
  ["play", "play"],
  ["pointercancel", "pointerCancel"],
  ["pointerdown", "pointerDown"],
  ["pointerup", "pointerUp"],
  ["ratechange", "rateChange"],
  ["reset", "reset"],
  ["seeked", "seeked"],
  ["submit", "submit"],
  ["touchcancel", "touchCancel"],
  ["touchend", "touchEnd"],
  ["touchstart", "touchStart"],
  ["volumechange", "volumeChange"]
].forEach(function(a) {
  wd(a, true);
});
td.forEach(function(a) {
  wd(a, false);
});
var xd = { eventTypes: ud, isInteractiveTopLevelEventType: function(a) {
  a = vd[a];
  return void 0 !== a && true === a.isInteractive;
}, extractEvents: function(a, b2, c2, d2) {
  var e2 = vd[a];
  if (!e2)
    return null;
  switch (a) {
    case "keypress":
      if (0 === ld(c2))
        return null;
    case "keydown":
    case "keyup":
      a = od;
      break;
    case "blur":
    case "focus":
      a = kd;
      break;
    case "click":
      if (2 === c2.button)
        return null;
    case "auxclick":
    case "dblclick":
    case "mousedown":
    case "mousemove":
    case "mouseup":
    case "mouseout":
    case "mouseover":
    case "contextmenu":
      a = Yc;
      break;
    case "drag":
    case "dragend":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "dragstart":
    case "drop":
      a = pd;
      break;
    case "touchcancel":
    case "touchend":
    case "touchmove":
    case "touchstart":
      a = qd;
      break;
    case Xa:
    case Ya:
    case Za:
      a = id$1;
      break;
    case $a:
      a = rd;
      break;
    case "scroll":
      a = Qc;
      break;
    case "wheel":
      a = sd;
      break;
    case "copy":
    case "cut":
    case "paste":
      a = jd;
      break;
    case "gotpointercapture":
    case "lostpointercapture":
    case "pointercancel":
    case "pointerdown":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerup":
      a = Zc;
      break;
    default:
      a = y$1;
  }
  b2 = a.getPooled(e2, b2, c2, d2);
  Qa(b2);
  return b2;
} }, yd = xd.isInteractiveTopLevelEventType, zd = [];
function Ad(a) {
  var b2 = a.targetInst, c2 = b2;
  do {
    if (!c2) {
      a.ancestors.push(c2);
      break;
    }
    var d2;
    for (d2 = c2; d2.return; )
      d2 = d2.return;
    d2 = 3 !== d2.tag ? null : d2.stateNode.containerInfo;
    if (!d2)
      break;
    a.ancestors.push(c2);
    c2 = Ha(d2);
  } while (c2);
  for (c2 = 0; c2 < a.ancestors.length; c2++) {
    b2 = a.ancestors[c2];
    var e2 = Nb(a.nativeEvent);
    d2 = a.topLevelType;
    for (var f2 = a.nativeEvent, g2 = null, h2 = 0; h2 < oa.length; h2++) {
      var l2 = oa[h2];
      l2 && (l2 = l2.extractEvents(d2, b2, f2, e2)) && (g2 = xa(g2, l2));
    }
    Da(g2);
  }
}
var Bd = true;
function E(a, b2) {
  if (!b2)
    return null;
  var c2 = (yd(a) ? Cd : Dd).bind(null, a);
  b2.addEventListener(a, c2, false);
}
function Ed(a, b2) {
  if (!b2)
    return null;
  var c2 = (yd(a) ? Cd : Dd).bind(null, a);
  b2.addEventListener(a, c2, true);
}
function Cd(a, b2) {
  Hb(Dd, a, b2);
}
function Dd(a, b2) {
  if (Bd) {
    var c2 = Nb(b2);
    c2 = Ha(c2);
    null === c2 || "number" !== typeof c2.tag || 2 === ed(c2) || (c2 = null);
    if (zd.length) {
      var d2 = zd.pop();
      d2.topLevelType = a;
      d2.nativeEvent = b2;
      d2.targetInst = c2;
      a = d2;
    } else
      a = { topLevelType: a, nativeEvent: b2, targetInst: c2, ancestors: [] };
    try {
      Kb(Ad, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > zd.length && zd.push(a);
    }
  }
}
var Fd = {}, Gd = 0, Hd = "_reactListenersID" + ("" + Math.random()).slice(2);
function Id(a) {
  Object.prototype.hasOwnProperty.call(a, Hd) || (a[Hd] = Gd++, Fd[a[Hd]] = {});
  return Fd[a[Hd]];
}
function Jd(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Kd(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ld(a, b2) {
  var c2 = Kd(a);
  a = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a + c2.textContent.length;
      if (a <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a };
      a = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Kd(c2);
  }
}
function Md(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Md(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Nd() {
  for (var a = window, b2 = Jd(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a = b2.contentWindow;
    else
      break;
    b2 = Jd(a.document);
  }
  return b2;
}
function Od(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Pd() {
  var a = Nd();
  if (Od(a)) {
    if ("selectionStart" in a)
      var b2 = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        b2 = (b2 = a.ownerDocument) && b2.defaultView || window;
        var c2 = b2.getSelection && b2.getSelection();
        if (c2 && 0 !== c2.rangeCount) {
          b2 = c2.anchorNode;
          var d2 = c2.anchorOffset, e2 = c2.focusNode;
          c2 = c2.focusOffset;
          try {
            b2.nodeType, e2.nodeType;
          } catch (A2) {
            b2 = null;
            break a;
          }
          var f2 = 0, g2 = -1, h2 = -1, l2 = 0, k2 = 0, m2 = a, p2 = null;
          b:
            for (; ; ) {
              for (var t2; ; ) {
                m2 !== b2 || 0 !== d2 && 3 !== m2.nodeType || (g2 = f2 + d2);
                m2 !== e2 || 0 !== c2 && 3 !== m2.nodeType || (h2 = f2 + c2);
                3 === m2.nodeType && (f2 += m2.nodeValue.length);
                if (null === (t2 = m2.firstChild))
                  break;
                p2 = m2;
                m2 = t2;
              }
              for (; ; ) {
                if (m2 === a)
                  break b;
                p2 === b2 && ++l2 === d2 && (g2 = f2);
                p2 === e2 && ++k2 === c2 && (h2 = f2);
                if (null !== (t2 = m2.nextSibling))
                  break;
                m2 = p2;
                p2 = m2.parentNode;
              }
              m2 = t2;
            }
          b2 = -1 === g2 || -1 === h2 ? null : { start: g2, end: h2 };
        } else
          b2 = null;
      }
    b2 = b2 || { start: 0, end: 0 };
  } else
    b2 = null;
  return { focusedElem: a, selectionRange: b2 };
}
function Qd(a) {
  var b2 = Nd(), c2 = a.focusedElem, d2 = a.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Md(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Od(c2)) {
      if (b2 = d2.start, a = d2.end, void 0 === a && (a = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a, c2.value.length);
      else if (a = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ld(c2, f2);
        var g2 = Ld(c2, d2);
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d2 ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c2; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a = b2[c2], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Rd = Ra && "documentMode" in document && 11 >= document.documentMode, Sd = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ") } }, Td = null, Ud = null, Vd = null, Wd = false;
function Xd(a, b2) {
  var c2 = b2.window === b2 ? b2.document : 9 === b2.nodeType ? b2 : b2.ownerDocument;
  if (Wd || null == Td || Td !== Jd(c2))
    return null;
  c2 = Td;
  "selectionStart" in c2 && Od(c2) ? c2 = { start: c2.selectionStart, end: c2.selectionEnd } : (c2 = (c2.ownerDocument && c2.ownerDocument.defaultView || window).getSelection(), c2 = { anchorNode: c2.anchorNode, anchorOffset: c2.anchorOffset, focusNode: c2.focusNode, focusOffset: c2.focusOffset });
  return Vd && dd(Vd, c2) ? null : (Vd = c2, a = y$1.getPooled(Sd.select, Ud, a, b2), a.type = "select", a.target = Td, Qa(a), a);
}
var Yd = { eventTypes: Sd, extractEvents: function(a, b2, c2, d2) {
  var e2 = d2.window === d2 ? d2.document : 9 === d2.nodeType ? d2 : d2.ownerDocument, f2;
  if (!(f2 = !e2)) {
    a: {
      e2 = Id(e2);
      f2 = sa.onSelect;
      for (var g2 = 0; g2 < f2.length; g2++) {
        var h2 = f2[g2];
        if (!e2.hasOwnProperty(h2) || !e2[h2]) {
          e2 = false;
          break a;
        }
      }
      e2 = true;
    }
    f2 = !e2;
  }
  if (f2)
    return null;
  e2 = b2 ? Ja(b2) : window;
  switch (a) {
    case "focus":
      if (Mb(e2) || "true" === e2.contentEditable)
        Td = e2, Ud = b2, Vd = null;
      break;
    case "blur":
      Vd = Ud = Td = null;
      break;
    case "mousedown":
      Wd = true;
      break;
    case "contextmenu":
    case "mouseup":
    case "dragend":
      return Wd = false, Xd(c2, d2);
    case "selectionchange":
      if (Rd)
        break;
    case "keydown":
    case "keyup":
      return Xd(c2, d2);
  }
  return null;
} };
Ba.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
ta = Ka;
ua = Ia;
va = Ja;
Ba.injectEventPluginsByName({ SimpleEventPlugin: xd, EnterLeaveEventPlugin: ad, ChangeEventPlugin: Pc, SelectEventPlugin: Yd, BeforeInputEventPlugin: zb });
function Zd(a) {
  var b2 = "";
  aa.Children.forEach(a, function(a2) {
    null != a2 && (b2 += a2);
  });
  return b2;
}
function $d(a, b2) {
  a = n$2({ children: void 0 }, b2);
  if (b2 = Zd(b2.children))
    a.children = b2;
  return a;
}
function ae(a, b2, c2, d2) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a.length; c2++)
      e2 = b2.hasOwnProperty("$" + a[c2].value), a[c2].selected !== e2 && (a[c2].selected = e2), e2 && d2 && (a[c2].defaultSelected = true);
  } else {
    c2 = "" + uc(c2);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c2) {
        a[e2].selected = true;
        d2 && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function be(a, b2) {
  null != b2.dangerouslySetInnerHTML ? x$1("91") : void 0;
  return n$2({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function ce(a, b2) {
  var c2 = b2.value;
  null == c2 && (c2 = b2.defaultValue, b2 = b2.children, null != b2 && (null != c2 ? x$1("92") : void 0, Array.isArray(b2) && (1 >= b2.length ? void 0 : x$1("93"), b2 = b2[0]), c2 = b2), null == c2 && (c2 = ""));
  a._wrapperState = { initialValue: uc(c2) };
}
function de(a, b2) {
  var c2 = uc(b2.value), d2 = uc(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a.value && (a.value = c2), null == b2.defaultValue && a.defaultValue !== c2 && (a.defaultValue = c2));
  null != d2 && (a.defaultValue = "" + d2);
}
function ee(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && (a.value = b2);
}
var fe = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function ge(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function he(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? ge(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var ie = void 0, je = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c2, d2, e2);
    });
  } : a;
}(function(a, b2) {
  if (a.namespaceURI !== fe.svg || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    ie = ie || document.createElement("div");
    ie.innerHTML = "<svg>" + b2 + "</svg>";
    for (b2 = ie.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ke(a, b2) {
  if (b2) {
    var c2 = a.firstChild;
    if (c2 && c2 === a.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var le = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, me = ["Webkit", "ms", "Moz", "O"];
Object.keys(le).forEach(function(a) {
  me.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    le[b2] = le[a];
  });
});
function ne(a, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || le.hasOwnProperty(a) && le[a] ? ("" + b2).trim() : b2 + "px";
}
function oe(a, b2) {
  a = a.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = ne(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a.setProperty(c2, e2) : a[c2] = e2;
    }
}
var pe = n$2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function qe(a, b2) {
  b2 && (pe[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML ? x$1("137", a, "") : void 0), null != b2.dangerouslySetInnerHTML && (null != b2.children ? x$1("60") : void 0, "object" === typeof b2.dangerouslySetInnerHTML && "__html" in b2.dangerouslySetInnerHTML ? void 0 : x$1("61")), null != b2.style && "object" !== typeof b2.style ? x$1("62", "") : void 0);
}
function re(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function se(a, b2) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;
  var c2 = Id(a);
  b2 = sa[b2];
  for (var d2 = 0; d2 < b2.length; d2++) {
    var e2 = b2[d2];
    if (!c2.hasOwnProperty(e2) || !c2[e2]) {
      switch (e2) {
        case "scroll":
          Ed("scroll", a);
          break;
        case "focus":
        case "blur":
          Ed("focus", a);
          Ed("blur", a);
          c2.blur = true;
          c2.focus = true;
          break;
        case "cancel":
        case "close":
          Ob(e2) && Ed(e2, a);
          break;
        case "invalid":
        case "submit":
        case "reset":
          break;
        default:
          -1 === ab.indexOf(e2) && E(e2, a);
      }
      c2[e2] = true;
    }
  }
}
function te() {
}
var ue = null, ve = null;
function we(a, b2) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b2.autoFocus;
  }
  return false;
}
function xe(a, b2) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var ye = "function" === typeof setTimeout ? setTimeout : void 0, ze = "function" === typeof clearTimeout ? clearTimeout : void 0, Ae = r$2.unstable_scheduleCallback, Be = r$2.unstable_cancelCallback;
function Ce(a, b2, c2, d2, e2) {
  a[Ga] = e2;
  "input" === c2 && "radio" === e2.type && null != e2.name && xc(a, e2);
  re(c2, d2);
  d2 = re(c2, e2);
  for (var f2 = 0; f2 < b2.length; f2 += 2) {
    var g2 = b2[f2], h2 = b2[f2 + 1];
    "style" === g2 ? oe(a, h2) : "dangerouslySetInnerHTML" === g2 ? je(a, h2) : "children" === g2 ? ke(a, h2) : tc(a, g2, h2, d2);
  }
  switch (c2) {
    case "input":
      yc(a, e2);
      break;
    case "textarea":
      de(a, e2);
      break;
    case "select":
      b2 = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e2.multiple, c2 = e2.value, null != c2 ? ae(a, !!e2.multiple, c2, false) : b2 !== !!e2.multiple && (null != e2.defaultValue ? ae(a, !!e2.multiple, e2.defaultValue, true) : ae(a, !!e2.multiple, e2.multiple ? [] : "", false));
  }
}
function De(a) {
  for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType; )
    a = a.nextSibling;
  return a;
}
function Ee(a) {
  for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType; )
    a = a.nextSibling;
  return a;
}
var Fe = [], Ge = -1;
function F(a) {
  0 > Ge || (a.current = Fe[Ge], Fe[Ge] = null, Ge--);
}
function G(a, b2) {
  Ge++;
  Fe[Ge] = a.current;
  a.current = b2;
}
var He = {}, H = { current: He }, I = { current: false }, Ie = He;
function Je(a, b2) {
  var c2 = a.type.contextTypes;
  if (!c2)
    return He;
  var d2 = a.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function J(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function Ke(a) {
  F(I);
  F(H);
}
function Le(a) {
  F(I);
  F(H);
}
function Me(a, b2, c2) {
  H.current !== He ? x$1("168") : void 0;
  G(H, b2);
  G(I, c2);
}
function Ne(a, b2, c2) {
  var d2 = a.stateNode;
  a = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    e2 in a ? void 0 : x$1("108", ic(b2) || "Unknown", e2);
  return n$2({}, c2, d2);
}
function Oe(a) {
  var b2 = a.stateNode;
  b2 = b2 && b2.__reactInternalMemoizedMergedChildContext || He;
  Ie = H.current;
  G(H, b2);
  G(I, I.current);
  return true;
}
function Pe(a, b2, c2) {
  var d2 = a.stateNode;
  d2 ? void 0 : x$1("169");
  c2 ? (b2 = Ne(a, b2, Ie), d2.__reactInternalMemoizedMergedChildContext = b2, F(I), F(H), G(H, b2)) : F(I);
  G(I, c2);
}
var Qe = null, Re = null;
function Se(a) {
  return function(b2) {
    try {
      return a(b2);
    } catch (c2) {
    }
  };
}
function Te(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)
    return false;
  var b2 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (b2.isDisabled || !b2.supportsFiber)
    return true;
  try {
    var c2 = b2.inject(a);
    Qe = Se(function(a2) {
      return b2.onCommitFiberRoot(c2, a2);
    });
    Re = Se(function(a2) {
      return b2.onCommitFiberUnmount(c2, a2);
    });
  } catch (d2) {
  }
  return true;
}
function Ue(a, b2, c2, d2) {
  this.tag = a;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.contextDependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.effectTag = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childExpirationTime = this.expirationTime = 0;
  this.alternate = null;
}
function K(a, b2, c2, d2) {
  return new Ue(a, b2, c2, d2);
}
function Ve(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function We(a) {
  if ("function" === typeof a)
    return Ve(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === cc)
      return 11;
    if (a === ec)
      return 14;
  }
  return 2;
}
function Xe(a, b2) {
  var c2 = a.alternate;
  null === c2 ? (c2 = K(a.tag, b2, a.key, a.mode), c2.elementType = a.elementType, c2.type = a.type, c2.stateNode = a.stateNode, c2.alternate = a, a.alternate = c2) : (c2.pendingProps = b2, c2.effectTag = 0, c2.nextEffect = null, c2.firstEffect = null, c2.lastEffect = null);
  c2.childExpirationTime = a.childExpirationTime;
  c2.expirationTime = a.expirationTime;
  c2.child = a.child;
  c2.memoizedProps = a.memoizedProps;
  c2.memoizedState = a.memoizedState;
  c2.updateQueue = a.updateQueue;
  c2.contextDependencies = a.contextDependencies;
  c2.sibling = a.sibling;
  c2.index = a.index;
  c2.ref = a.ref;
  return c2;
}
function Ye(a, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a;
  if ("function" === typeof a)
    Ve(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case Xb:
          return Ze(c2.children, e2, f2, b2);
        case bc:
          return $e(c2, e2 | 3, f2, b2);
        case Yb:
          return $e(c2, e2 | 2, f2, b2);
        case Zb:
          return a = K(12, c2, b2, e2 | 4), a.elementType = Zb, a.type = Zb, a.expirationTime = f2, a;
        case dc:
          return a = K(13, c2, b2, e2), a.elementType = dc, a.type = dc, a.expirationTime = f2, a;
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case $b:
                g2 = 10;
                break a;
              case ac:
                g2 = 9;
                break a;
              case cc:
                g2 = 11;
                break a;
              case ec:
                g2 = 14;
                break a;
              case fc:
                g2 = 16;
                d2 = null;
                break a;
            }
          x$1("130", null == a ? a : typeof a, "");
      }
  b2 = K(g2, c2, b2, e2);
  b2.elementType = a;
  b2.type = d2;
  b2.expirationTime = f2;
  return b2;
}
function Ze(a, b2, c2, d2) {
  a = K(7, a, d2, b2);
  a.expirationTime = c2;
  return a;
}
function $e(a, b2, c2, d2) {
  a = K(8, a, d2, b2);
  b2 = 0 === (b2 & 1) ? Yb : bc;
  a.elementType = b2;
  a.type = b2;
  a.expirationTime = c2;
  return a;
}
function af(a, b2, c2) {
  a = K(6, a, null, b2);
  a.expirationTime = c2;
  return a;
}
function bf(a, b2, c2) {
  b2 = K(4, null !== a.children ? a.children : [], a.key, b2);
  b2.expirationTime = c2;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function cf(a, b2) {
  a.didError = false;
  var c2 = a.earliestPendingTime;
  0 === c2 ? a.earliestPendingTime = a.latestPendingTime = b2 : c2 < b2 ? a.earliestPendingTime = b2 : a.latestPendingTime > b2 && (a.latestPendingTime = b2);
  df(b2, a);
}
function ef(a, b2) {
  a.didError = false;
  if (0 === b2)
    a.earliestPendingTime = 0, a.latestPendingTime = 0, a.earliestSuspendedTime = 0, a.latestSuspendedTime = 0, a.latestPingedTime = 0;
  else {
    b2 < a.latestPingedTime && (a.latestPingedTime = 0);
    var c2 = a.latestPendingTime;
    0 !== c2 && (c2 > b2 ? a.earliestPendingTime = a.latestPendingTime = 0 : a.earliestPendingTime > b2 && (a.earliestPendingTime = a.latestPendingTime));
    c2 = a.earliestSuspendedTime;
    0 === c2 ? cf(a, b2) : b2 < a.latestSuspendedTime ? (a.earliestSuspendedTime = 0, a.latestSuspendedTime = 0, a.latestPingedTime = 0, cf(a, b2)) : b2 > c2 && cf(a, b2);
  }
  df(0, a);
}
function ff(a, b2) {
  a.didError = false;
  a.latestPingedTime >= b2 && (a.latestPingedTime = 0);
  var c2 = a.earliestPendingTime, d2 = a.latestPendingTime;
  c2 === b2 ? a.earliestPendingTime = d2 === b2 ? a.latestPendingTime = 0 : d2 : d2 === b2 && (a.latestPendingTime = c2);
  c2 = a.earliestSuspendedTime;
  d2 = a.latestSuspendedTime;
  0 === c2 ? a.earliestSuspendedTime = a.latestSuspendedTime = b2 : c2 < b2 ? a.earliestSuspendedTime = b2 : d2 > b2 && (a.latestSuspendedTime = b2);
  df(b2, a);
}
function gf(a, b2) {
  var c2 = a.earliestPendingTime;
  a = a.earliestSuspendedTime;
  c2 > b2 && (b2 = c2);
  a > b2 && (b2 = a);
  return b2;
}
function df(a, b2) {
  var c2 = b2.earliestSuspendedTime, d2 = b2.latestSuspendedTime, e2 = b2.earliestPendingTime, f2 = b2.latestPingedTime;
  e2 = 0 !== e2 ? e2 : f2;
  0 === e2 && (0 === a || d2 < a) && (e2 = d2);
  a = e2;
  0 !== a && c2 > a && (a = c2);
  b2.nextExpirationTimeToWorkOn = e2;
  b2.expirationTime = a;
}
function L(a, b2) {
  if (a && a.defaultProps) {
    b2 = n$2({}, b2);
    a = a.defaultProps;
    for (var c2 in a)
      void 0 === b2[c2] && (b2[c2] = a[c2]);
  }
  return b2;
}
function hf(a) {
  var b2 = a._result;
  switch (a._status) {
    case 1:
      return b2;
    case 2:
      throw b2;
    case 0:
      throw b2;
    default:
      a._status = 0;
      b2 = a._ctor;
      b2 = b2();
      b2.then(function(b3) {
        0 === a._status && (b3 = b3.default, a._status = 1, a._result = b3);
      }, function(b3) {
        0 === a._status && (a._status = 2, a._result = b3);
      });
      switch (a._status) {
        case 1:
          return a._result;
        case 2:
          throw a._result;
      }
      a._result = b2;
      throw b2;
  }
}
var jf = new aa.Component().refs;
function kf(a, b2, c2, d2) {
  b2 = a.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : n$2({}, b2, c2);
  a.memoizedState = c2;
  d2 = a.updateQueue;
  null !== d2 && 0 === a.expirationTime && (d2.baseState = c2);
}
var tf = { isMounted: function(a) {
  return (a = a._reactInternalFiber) ? 2 === ed(a) : false;
}, enqueueSetState: function(a, b2, c2) {
  a = a._reactInternalFiber;
  var d2 = lf();
  d2 = mf(d2, a);
  var e2 = nf(d2);
  e2.payload = b2;
  void 0 !== c2 && null !== c2 && (e2.callback = c2);
  of();
  pf(a, e2);
  qf(a, d2);
}, enqueueReplaceState: function(a, b2, c2) {
  a = a._reactInternalFiber;
  var d2 = lf();
  d2 = mf(d2, a);
  var e2 = nf(d2);
  e2.tag = rf;
  e2.payload = b2;
  void 0 !== c2 && null !== c2 && (e2.callback = c2);
  of();
  pf(a, e2);
  qf(a, d2);
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternalFiber;
  var c2 = lf();
  c2 = mf(c2, a);
  var d2 = nf(c2);
  d2.tag = sf;
  void 0 !== b2 && null !== b2 && (d2.callback = b2);
  of();
  pf(a, d2);
  qf(a, c2);
} };
function uf(a, b2, c2, d2, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !dd(c2, d2) || !dd(e2, f2) : true;
}
function vf(a, b2, c2) {
  var d2 = false, e2 = He;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = M(f2) : (e2 = J(b2) ? Ie : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Je(a, e2) : He);
  b2 = new b2(c2, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = tf;
  a.stateNode = b2;
  b2._reactInternalFiber = a;
  d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function wf(a, b2, c2, d2) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a && tf.enqueueReplaceState(b2, b2.state, null);
}
function xf(a, b2, c2, d2) {
  var e2 = a.stateNode;
  e2.props = c2;
  e2.state = a.memoizedState;
  e2.refs = jf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = M(f2) : (f2 = J(b2) ? Ie : H.current, e2.context = Je(a, f2));
  f2 = a.updateQueue;
  null !== f2 && (yf(a, f2, c2, e2, d2), e2.state = a.memoizedState);
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kf(a, b2, f2, c2), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && tf.enqueueReplaceState(e2, e2.state, null), f2 = a.updateQueue, null !== f2 && (yf(a, f2, c2, e2, d2), e2.state = a.memoizedState));
  "function" === typeof e2.componentDidMount && (a.effectTag |= 4);
}
var zf = Array.isArray;
function Af(a, b2, c2) {
  a = c2.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c2._owner) {
      c2 = c2._owner;
      var d2 = void 0;
      c2 && (1 !== c2.tag ? x$1("309") : void 0, d2 = c2.stateNode);
      d2 ? void 0 : x$1("147", a);
      var e2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === e2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = d2.refs;
        b3 === jf && (b3 = d2.refs = {});
        null === a2 ? delete b3[e2] : b3[e2] = a2;
      };
      b2._stringRef = e2;
      return b2;
    }
    "string" !== typeof a ? x$1("284") : void 0;
    c2._owner ? void 0 : x$1("290", a);
  }
  return a;
}
function Bf(a, b2) {
  "textarea" !== a.type && x$1("31", "[object Object]" === Object.prototype.toString.call(b2) ? "object with keys {" + Object.keys(b2).join(", ") + "}" : b2, "");
}
function Cf(a) {
  function b2(b3, c3) {
    if (a) {
      var d3 = b3.lastEffect;
      null !== d3 ? (d3.nextEffect = c3, b3.lastEffect = c3) : b3.firstEffect = b3.lastEffect = c3;
      c3.nextEffect = null;
      c3.effectTag = 8;
    }
  }
  function c2(c3, d3) {
    if (!a)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3, c3) {
    a2 = Xe(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a)
      return c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.effectTag = 2, c3) : d3;
    b3.effectTag = 2;
    return c3;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.effectTag = 2);
    return b3;
  }
  function h2(a2, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = af(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function l2(a2, b3, c3, d3) {
    if (null !== b3 && b3.elementType === c3.type)
      return d3 = e2(b3, c3.props), d3.ref = Af(a2, b3, c3), d3.return = a2, d3;
    d3 = Ye(c3.type, c3.key, c3.props, null, a2.mode, d3);
    d3.ref = Af(a2, b3, c3);
    d3.return = a2;
    return d3;
  }
  function k2(a2, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = bf(c3, a2.mode, d3), b3.return = a2, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ze(c3, a2.mode, d3, f3), b3.return = a2, b3;
    b3 = e2(b3, c3);
    b3.return = a2;
    return b3;
  }
  function p2(a2, b3, c3) {
    if ("string" === typeof b3 || "number" === typeof b3)
      return b3 = af("" + b3, a2.mode, c3), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case Vb:
          return c3 = Ye(b3.type, b3.key, b3.props, null, a2.mode, c3), c3.ref = Af(a2, null, b3), c3.return = a2, c3;
        case Wb:
          return b3 = bf(b3, a2.mode, c3), b3.return = a2, b3;
      }
      if (zf(b3) || hc(b3))
        return b3 = Ze(b3, a2.mode, c3, null), b3.return = a2, b3;
      Bf(a2, b3);
    }
    return null;
  }
  function t2(a2, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a2, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case Vb:
          return c3.key === e3 ? c3.type === Xb ? m2(a2, b3, c3.props.children, d3, e3) : l2(a2, b3, c3, d3) : null;
        case Wb:
          return c3.key === e3 ? k2(a2, b3, c3, d3) : null;
      }
      if (zf(c3) || hc(c3))
        return null !== e3 ? null : m2(a2, b3, c3, d3, null);
      Bf(a2, c3);
    }
    return null;
  }
  function A2(a2, b3, c3, d3, e3) {
    if ("string" === typeof d3 || "number" === typeof d3)
      return a2 = a2.get(c3) || null, h2(b3, a2, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case Vb:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, d3.type === Xb ? m2(b3, a2, d3.props.children, e3, d3.key) : l2(b3, a2, d3, e3);
        case Wb:
          return a2 = a2.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a2, d3, e3);
      }
      if (zf(d3) || hc(d3))
        return a2 = a2.get(c3) || null, m2(b3, a2, d3, e3, null);
      Bf(b3, d3);
    }
    return null;
  }
  function v2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, q2 = g3, u2 = g3 = 0, B2 = null; null !== q2 && u2 < h3.length; u2++) {
      q2.index > u2 ? (B2 = q2, q2 = null) : B2 = q2.sibling;
      var w2 = t2(e3, q2, h3[u2], k3);
      if (null === w2) {
        null === q2 && (q2 = B2);
        break;
      }
      a && q2 && null === w2.alternate && b2(e3, q2);
      g3 = f2(w2, g3, u2);
      null === m3 ? l3 = w2 : m3.sibling = w2;
      m3 = w2;
      q2 = B2;
    }
    if (u2 === h3.length)
      return c2(e3, q2), l3;
    if (null === q2) {
      for (; u2 < h3.length; u2++)
        if (q2 = p2(e3, h3[u2], k3))
          g3 = f2(q2, g3, u2), null === m3 ? l3 = q2 : m3.sibling = q2, m3 = q2;
      return l3;
    }
    for (q2 = d2(e3, q2); u2 < h3.length; u2++)
      if (B2 = A2(q2, e3, u2, h3[u2], k3))
        a && null !== B2.alternate && q2.delete(null === B2.key ? u2 : B2.key), g3 = f2(B2, g3, u2), null === m3 ? l3 = B2 : m3.sibling = B2, m3 = B2;
    a && q2.forEach(function(a2) {
      return b2(e3, a2);
    });
    return l3;
  }
  function R2(e3, g3, h3, k3) {
    var l3 = hc(h3);
    "function" !== typeof l3 ? x$1("150") : void 0;
    h3 = l3.call(h3);
    null == h3 ? x$1("151") : void 0;
    for (var m3 = l3 = null, q2 = g3, u2 = g3 = 0, B2 = null, w2 = h3.next(); null !== q2 && !w2.done; u2++, w2 = h3.next()) {
      q2.index > u2 ? (B2 = q2, q2 = null) : B2 = q2.sibling;
      var v3 = t2(e3, q2, w2.value, k3);
      if (null === v3) {
        q2 || (q2 = B2);
        break;
      }
      a && q2 && null === v3.alternate && b2(e3, q2);
      g3 = f2(v3, g3, u2);
      null === m3 ? l3 = v3 : m3.sibling = v3;
      m3 = v3;
      q2 = B2;
    }
    if (w2.done)
      return c2(e3, q2), l3;
    if (null === q2) {
      for (; !w2.done; u2++, w2 = h3.next())
        w2 = p2(e3, w2.value, k3), null !== w2 && (g3 = f2(w2, g3, u2), null === m3 ? l3 = w2 : m3.sibling = w2, m3 = w2);
      return l3;
    }
    for (q2 = d2(e3, q2); !w2.done; u2++, w2 = h3.next())
      w2 = A2(q2, e3, u2, w2.value, k3), null !== w2 && (a && null !== w2.alternate && q2.delete(null === w2.key ? u2 : w2.key), g3 = f2(w2, g3, u2), null === m3 ? l3 = w2 : m3.sibling = w2, m3 = w2);
    a && q2.forEach(function(a2) {
      return b2(e3, a2);
    });
    return l3;
  }
  return function(a2, d3, f3, h3) {
    var k3 = "object" === typeof f3 && null !== f3 && f3.type === Xb && null === f3.key;
    k3 && (f3 = f3.props.children);
    var l3 = "object" === typeof f3 && null !== f3;
    if (l3)
      switch (f3.$$typeof) {
        case Vb:
          a: {
            l3 = f3.key;
            for (k3 = d3; null !== k3; ) {
              if (k3.key === l3)
                if (7 === k3.tag ? f3.type === Xb : k3.elementType === f3.type) {
                  c2(a2, k3.sibling);
                  d3 = e2(k3, f3.type === Xb ? f3.props.children : f3.props);
                  d3.ref = Af(a2, k3, f3);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, k3);
                  break;
                }
              else
                b2(a2, k3);
              k3 = k3.sibling;
            }
            f3.type === Xb ? (d3 = Ze(f3.props.children, a2.mode, h3, f3.key), d3.return = a2, a2 = d3) : (h3 = Ye(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Af(a2, d3, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case Wb:
          a: {
            for (k3 = f3.key; null !== d3; ) {
              if (d3.key === k3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a2, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c2(a2, d3);
                  break;
                }
              else
                b2(a2, d3);
              d3 = d3.sibling;
            }
            d3 = bf(f3, a2.mode, h3);
            d3.return = a2;
            a2 = d3;
          }
          return g2(a2);
      }
    if ("string" === typeof f3 || "number" === typeof f3)
      return f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a2, d3.sibling), d3 = e2(d3, f3), d3.return = a2, a2 = d3) : (c2(a2, d3), d3 = af(f3, a2.mode, h3), d3.return = a2, a2 = d3), g2(a2);
    if (zf(f3))
      return v2(a2, d3, f3, h3);
    if (hc(f3))
      return R2(a2, d3, f3, h3);
    l3 && Bf(a2, f3);
    if ("undefined" === typeof f3 && !k3)
      switch (a2.tag) {
        case 1:
        case 0:
          h3 = a2.type, x$1("152", h3.displayName || h3.name || "Component");
      }
    return c2(a2, d3);
  };
}
var Df = Cf(true), Ef = Cf(false), Ff = {}, N = { current: Ff }, Gf = { current: Ff }, Hf = { current: Ff };
function If(a) {
  a === Ff ? x$1("174") : void 0;
  return a;
}
function Jf(a, b2) {
  G(Hf, b2);
  G(Gf, a);
  G(N, Ff);
  var c2 = b2.nodeType;
  switch (c2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : he(null, "");
      break;
    default:
      c2 = 8 === c2 ? b2.parentNode : b2, b2 = c2.namespaceURI || null, c2 = c2.tagName, b2 = he(b2, c2);
  }
  F(N);
  G(N, b2);
}
function Kf(a) {
  F(N);
  F(Gf);
  F(Hf);
}
function Lf(a) {
  If(Hf.current);
  var b2 = If(N.current);
  var c2 = he(b2, a.type);
  b2 !== c2 && (G(Gf, a), G(N, c2));
}
function Mf(a) {
  Gf.current === a && (F(N), F(Gf));
}
var Nf = 0, Of = 2, Pf = 4, Qf = 8, Rf = 16, Sf = 32, Tf = 64, Uf = 128, Vf = Tb.ReactCurrentDispatcher, Wf = 0, Xf = null, O = null, P = null, Yf = null, Q = null, Zf = null, $f = 0, ag = null, bg = 0, cg = false, dg = null, eg = 0;
function fg() {
  x$1("321");
}
function gg(a, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a.length; c2++)
    if (!bd(a[c2], b2[c2]))
      return false;
  return true;
}
function hg(a, b2, c2, d2, e2, f2) {
  Wf = f2;
  Xf = b2;
  P = null !== a ? a.memoizedState : null;
  Vf.current = null === P ? ig : jg;
  b2 = c2(d2, e2);
  if (cg) {
    do
      cg = false, eg += 1, P = null !== a ? a.memoizedState : null, Zf = Yf, ag = Q = O = null, Vf.current = jg, b2 = c2(d2, e2);
    while (cg);
    dg = null;
    eg = 0;
  }
  Vf.current = kg;
  a = Xf;
  a.memoizedState = Yf;
  a.expirationTime = $f;
  a.updateQueue = ag;
  a.effectTag |= bg;
  a = null !== O && null !== O.next;
  Wf = 0;
  Zf = Q = Yf = P = O = Xf = null;
  $f = 0;
  ag = null;
  bg = 0;
  a ? x$1("300") : void 0;
  return b2;
}
function lg() {
  Vf.current = kg;
  Wf = 0;
  Zf = Q = Yf = P = O = Xf = null;
  $f = 0;
  ag = null;
  bg = 0;
  cg = false;
  dg = null;
  eg = 0;
}
function mg() {
  var a = { memoizedState: null, baseState: null, queue: null, baseUpdate: null, next: null };
  null === Q ? Yf = Q = a : Q = Q.next = a;
  return Q;
}
function ng() {
  if (null !== Zf)
    Q = Zf, Zf = Q.next, O = P, P = null !== O ? O.next : null;
  else {
    null === P ? x$1("310") : void 0;
    O = P;
    var a = { memoizedState: O.memoizedState, baseState: O.baseState, queue: O.queue, baseUpdate: O.baseUpdate, next: null };
    Q = null === Q ? Yf = a : Q.next = a;
    P = O.next;
  }
  return Q;
}
function og(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function pg(a) {
  var b2 = ng(), c2 = b2.queue;
  null === c2 ? x$1("311") : void 0;
  c2.lastRenderedReducer = a;
  if (0 < eg) {
    var d2 = c2.dispatch;
    if (null !== dg) {
      var e2 = dg.get(c2);
      if (void 0 !== e2) {
        dg.delete(c2);
        var f2 = b2.memoizedState;
        do
          f2 = a(f2, e2.action), e2 = e2.next;
        while (null !== e2);
        bd(f2, b2.memoizedState) || (qg = true);
        b2.memoizedState = f2;
        b2.baseUpdate === c2.last && (b2.baseState = f2);
        c2.lastRenderedState = f2;
        return [f2, d2];
      }
    }
    return [b2.memoizedState, d2];
  }
  d2 = c2.last;
  var g2 = b2.baseUpdate;
  f2 = b2.baseState;
  null !== g2 ? (null !== d2 && (d2.next = null), d2 = g2.next) : d2 = null !== d2 ? d2.next : null;
  if (null !== d2) {
    var h2 = e2 = null, l2 = d2, k2 = false;
    do {
      var m2 = l2.expirationTime;
      m2 < Wf ? (k2 || (k2 = true, h2 = g2, e2 = f2), m2 > $f && ($f = m2)) : f2 = l2.eagerReducer === a ? l2.eagerState : a(f2, l2.action);
      g2 = l2;
      l2 = l2.next;
    } while (null !== l2 && l2 !== d2);
    k2 || (h2 = g2, e2 = f2);
    bd(f2, b2.memoizedState) || (qg = true);
    b2.memoizedState = f2;
    b2.baseUpdate = h2;
    b2.baseState = e2;
    c2.lastRenderedState = f2;
  }
  return [b2.memoizedState, c2.dispatch];
}
function rg(a, b2, c2, d2) {
  a = { tag: a, create: b2, destroy: c2, deps: d2, next: null };
  null === ag ? (ag = { lastEffect: null }, ag.lastEffect = a.next = a) : (b2 = ag.lastEffect, null === b2 ? ag.lastEffect = a.next = a : (c2 = b2.next, b2.next = a, a.next = c2, ag.lastEffect = a));
  return a;
}
function sg(a, b2, c2, d2) {
  var e2 = mg();
  bg |= a;
  e2.memoizedState = rg(b2, c2, void 0, void 0 === d2 ? null : d2);
}
function tg(a, b2, c2, d2) {
  var e2 = ng();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && gg(d2, g2.deps)) {
      rg(Nf, c2, f2, d2);
      return;
    }
  }
  bg |= a;
  e2.memoizedState = rg(b2, c2, f2, d2);
}
function ug(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function vg() {
}
function wg(a, b2, c2) {
  25 > eg ? void 0 : x$1("301");
  var d2 = a.alternate;
  if (a === Xf || null !== d2 && d2 === Xf)
    if (cg = true, a = { expirationTime: Wf, action: c2, eagerReducer: null, eagerState: null, next: null }, null === dg && (dg = /* @__PURE__ */ new Map()), c2 = dg.get(b2), void 0 === c2)
      dg.set(b2, a);
    else {
      for (b2 = c2; null !== b2.next; )
        b2 = b2.next;
      b2.next = a;
    }
  else {
    of();
    var e2 = lf();
    e2 = mf(e2, a);
    var f2 = { expirationTime: e2, action: c2, eagerReducer: null, eagerState: null, next: null }, g2 = b2.last;
    if (null === g2)
      f2.next = f2;
    else {
      var h2 = g2.next;
      null !== h2 && (f2.next = h2);
      g2.next = f2;
    }
    b2.last = f2;
    if (0 === a.expirationTime && (null === d2 || 0 === d2.expirationTime) && (d2 = b2.lastRenderedReducer, null !== d2))
      try {
        var l2 = b2.lastRenderedState, k2 = d2(l2, c2);
        f2.eagerReducer = d2;
        f2.eagerState = k2;
        if (bd(k2, l2))
          return;
      } catch (m2) {
      } finally {
      }
    qf(a, e2);
  }
}
var kg = { readContext: M, useCallback: fg, useContext: fg, useEffect: fg, useImperativeHandle: fg, useLayoutEffect: fg, useMemo: fg, useReducer: fg, useRef: fg, useState: fg, useDebugValue: fg }, ig = {
  readContext: M,
  useCallback: function(a, b2) {
    mg().memoizedState = [a, void 0 === b2 ? null : b2];
    return a;
  },
  useContext: M,
  useEffect: function(a, b2) {
    return sg(516, Uf | Tf, a, b2);
  },
  useImperativeHandle: function(a, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
    return sg(4, Pf | Sf, ug.bind(null, b2, a), c2);
  },
  useLayoutEffect: function(a, b2) {
    return sg(4, Pf | Sf, a, b2);
  },
  useMemo: function(a, b2) {
    var c2 = mg();
    b2 = void 0 === b2 ? null : b2;
    a = a();
    c2.memoizedState = [a, b2];
    return a;
  },
  useReducer: function(a, b2, c2) {
    var d2 = mg();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a = d2.queue = { last: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
    a = a.dispatch = wg.bind(null, Xf, a);
    return [d2.memoizedState, a];
  },
  useRef: function(a) {
    var b2 = mg();
    a = { current: a };
    return b2.memoizedState = a;
  },
  useState: function(a) {
    var b2 = mg();
    "function" === typeof a && (a = a());
    b2.memoizedState = b2.baseState = a;
    a = b2.queue = {
      last: null,
      dispatch: null,
      lastRenderedReducer: og,
      lastRenderedState: a
    };
    a = a.dispatch = wg.bind(null, Xf, a);
    return [b2.memoizedState, a];
  },
  useDebugValue: vg
}, jg = { readContext: M, useCallback: function(a, b2) {
  var c2 = ng();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && gg(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a, b2];
  return a;
}, useContext: M, useEffect: function(a, b2) {
  return tg(516, Uf | Tf, a, b2);
}, useImperativeHandle: function(a, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a]) : null;
  return tg(4, Pf | Sf, ug.bind(null, b2, a), c2);
}, useLayoutEffect: function(a, b2) {
  return tg(4, Pf | Sf, a, b2);
}, useMemo: function(a, b2) {
  var c2 = ng();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && gg(b2, d2[1]))
    return d2[0];
  a = a();
  c2.memoizedState = [a, b2];
  return a;
}, useReducer: pg, useRef: function() {
  return ng().memoizedState;
}, useState: function(a) {
  return pg(og);
}, useDebugValue: vg }, xg = null, yg = null, zg = false;
function Ag(a, b2) {
  var c2 = K(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.type = "DELETED";
  c2.stateNode = b2;
  c2.return = a;
  c2.effectTag = 8;
  null !== a.lastEffect ? (a.lastEffect.nextEffect = c2, a.lastEffect = c2) : a.firstEffect = a.lastEffect = c2;
}
function Bg(a, b2) {
  switch (a.tag) {
    case 5:
      var c2 = a.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function Cg(a) {
  if (zg) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Bg(a, b2)) {
        b2 = De(c2);
        if (!b2 || !Bg(a, b2)) {
          a.effectTag |= 2;
          zg = false;
          xg = a;
          return;
        }
        Ag(xg, c2);
      }
      xg = a;
      yg = Ee(b2);
    } else
      a.effectTag |= 2, zg = false, xg = a;
  }
}
function Dg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 18 !== a.tag; )
    a = a.return;
  xg = a;
}
function Eg(a) {
  if (a !== xg)
    return false;
  if (!zg)
    return Dg(a), zg = true, false;
  var b2 = a.type;
  if (5 !== a.tag || "head" !== b2 && "body" !== b2 && !xe(b2, a.memoizedProps))
    for (b2 = yg; b2; )
      Ag(a, b2), b2 = De(b2);
  Dg(a);
  yg = xg ? De(a.stateNode) : null;
  return true;
}
function Fg() {
  yg = xg = null;
  zg = false;
}
var Gg = Tb.ReactCurrentOwner, qg = false;
function S(a, b2, c2, d2) {
  b2.child = null === a ? Ef(b2, null, c2, d2) : Df(b2, a.child, c2, d2);
}
function Hg(a, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Ig(b2, e2);
  d2 = hg(a, b2, c2, d2, f2, e2);
  if (null !== a && !qg)
    return b2.updateQueue = a.updateQueue, b2.effectTag &= -517, a.expirationTime <= e2 && (a.expirationTime = 0), Jg(a, b2, e2);
  b2.effectTag |= 1;
  S(a, b2, d2, e2);
  return b2.child;
}
function Kg(a, b2, c2, d2, e2, f2) {
  if (null === a) {
    var g2 = c2.type;
    if ("function" === typeof g2 && !Ve(g2) && void 0 === g2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = g2, Lg(a, b2, g2, d2, e2, f2);
    a = Ye(c2.type, null, d2, null, b2.mode, f2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  g2 = a.child;
  if (e2 < f2 && (e2 = g2.memoizedProps, c2 = c2.compare, c2 = null !== c2 ? c2 : dd, c2(e2, d2) && a.ref === b2.ref))
    return Jg(a, b2, f2);
  b2.effectTag |= 1;
  a = Xe(g2, d2);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function Lg(a, b2, c2, d2, e2, f2) {
  return null !== a && dd(a.memoizedProps, d2) && a.ref === b2.ref && (qg = false, e2 < f2) ? Jg(a, b2, f2) : Mg(a, b2, c2, d2, f2);
}
function Ng(a, b2) {
  var c2 = b2.ref;
  if (null === a && null !== c2 || null !== a && a.ref !== c2)
    b2.effectTag |= 128;
}
function Mg(a, b2, c2, d2, e2) {
  var f2 = J(c2) ? Ie : H.current;
  f2 = Je(b2, f2);
  Ig(b2, e2);
  c2 = hg(a, b2, c2, d2, f2, e2);
  if (null !== a && !qg)
    return b2.updateQueue = a.updateQueue, b2.effectTag &= -517, a.expirationTime <= e2 && (a.expirationTime = 0), Jg(a, b2, e2);
  b2.effectTag |= 1;
  S(a, b2, c2, e2);
  return b2.child;
}
function Og(a, b2, c2, d2, e2) {
  if (J(c2)) {
    var f2 = true;
    Oe(b2);
  } else
    f2 = false;
  Ig(b2, e2);
  if (null === b2.stateNode)
    null !== a && (a.alternate = null, b2.alternate = null, b2.effectTag |= 2), vf(b2, c2, d2), xf(b2, c2, d2, e2), d2 = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var l2 = g2.context, k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = M(k2) : (k2 = J(c2) ? Ie : H.current, k2 = Je(b2, k2));
    var m2 = c2.getDerivedStateFromProps, p2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    p2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || l2 !== k2) && wf(b2, g2, d2, k2);
    Pg = false;
    var t2 = b2.memoizedState;
    l2 = g2.state = t2;
    var A2 = b2.updateQueue;
    null !== A2 && (yf(b2, A2, d2, g2, e2), l2 = b2.memoizedState);
    h2 !== d2 || t2 !== l2 || I.current || Pg ? ("function" === typeof m2 && (kf(b2, c2, m2, d2), l2 = b2.memoizedState), (h2 = Pg || uf(b2, c2, h2, d2, t2, l2, k2)) ? (p2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.effectTag |= 4)) : ("function" === typeof g2.componentDidMount && (b2.effectTag |= 4), b2.memoizedProps = d2, b2.memoizedState = l2), g2.props = d2, g2.state = l2, g2.context = k2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.effectTag |= 4), d2 = false);
  } else
    g2 = b2.stateNode, h2 = b2.memoizedProps, g2.props = b2.type === b2.elementType ? h2 : L(b2.type, h2), l2 = g2.context, k2 = c2.contextType, "object" === typeof k2 && null !== k2 ? k2 = M(k2) : (k2 = J(c2) ? Ie : H.current, k2 = Je(b2, k2)), m2 = c2.getDerivedStateFromProps, (p2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || l2 !== k2) && wf(b2, g2, d2, k2), Pg = false, l2 = b2.memoizedState, t2 = g2.state = l2, A2 = b2.updateQueue, null !== A2 && (yf(b2, A2, d2, g2, e2), t2 = b2.memoizedState), h2 !== d2 || l2 !== t2 || I.current || Pg ? ("function" === typeof m2 && (kf(b2, c2, m2, d2), t2 = b2.memoizedState), (m2 = Pg || uf(b2, c2, h2, d2, l2, t2, k2)) ? (p2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, t2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, t2, k2)), "function" === typeof g2.componentDidUpdate && (b2.effectTag |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.effectTag |= 256)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && l2 === a.memoizedState || (b2.effectTag |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && l2 === a.memoizedState || (b2.effectTag |= 256), b2.memoizedProps = d2, b2.memoizedState = t2), g2.props = d2, g2.state = t2, g2.context = k2, d2 = m2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && l2 === a.memoizedState || (b2.effectTag |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && l2 === a.memoizedState || (b2.effectTag |= 256), d2 = false);
  return Qg(a, b2, c2, d2, f2, e2);
}
function Qg(a, b2, c2, d2, e2, f2) {
  Ng(a, b2);
  var g2 = 0 !== (b2.effectTag & 64);
  if (!d2 && !g2)
    return e2 && Pe(b2, c2, false), Jg(a, b2, f2);
  d2 = b2.stateNode;
  Gg.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.effectTag |= 1;
  null !== a && g2 ? (b2.child = Df(b2, a.child, null, f2), b2.child = Df(b2, null, h2, f2)) : S(a, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && Pe(b2, c2, true);
  return b2.child;
}
function Rg(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? Me(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && Me(a, b2.context, false);
  Jf(a, b2.containerInfo);
}
function Sg(a, b2, c2) {
  var d2 = b2.mode, e2 = b2.pendingProps, f2 = b2.memoizedState;
  if (0 === (b2.effectTag & 64)) {
    f2 = null;
    var g2 = false;
  } else
    f2 = { timedOutAt: null !== f2 ? f2.timedOutAt : 0 }, g2 = true, b2.effectTag &= -65;
  if (null === a)
    if (g2) {
      var h2 = e2.fallback;
      a = Ze(null, d2, 0, null);
      0 === (b2.mode & 1) && (a.child = null !== b2.memoizedState ? b2.child.child : b2.child);
      d2 = Ze(h2, d2, c2, null);
      a.sibling = d2;
      c2 = a;
      c2.return = d2.return = b2;
    } else
      c2 = d2 = Ef(b2, null, e2.children, c2);
  else
    null !== a.memoizedState ? (d2 = a.child, h2 = d2.sibling, g2 ? (c2 = e2.fallback, e2 = Xe(d2, d2.pendingProps), 0 === (b2.mode & 1) && (g2 = null !== b2.memoizedState ? b2.child.child : b2.child, g2 !== d2.child && (e2.child = g2)), d2 = e2.sibling = Xe(h2, c2, h2.expirationTime), c2 = e2, e2.childExpirationTime = 0, c2.return = d2.return = b2) : c2 = d2 = Df(b2, d2.child, e2.children, c2)) : (h2 = a.child, g2 ? (g2 = e2.fallback, e2 = Ze(null, d2, 0, null), e2.child = h2, 0 === (b2.mode & 1) && (e2.child = null !== b2.memoizedState ? b2.child.child : b2.child), d2 = e2.sibling = Ze(g2, d2, c2, null), d2.effectTag |= 2, c2 = e2, e2.childExpirationTime = 0, c2.return = d2.return = b2) : d2 = c2 = Df(b2, h2, e2.children, c2)), b2.stateNode = a.stateNode;
  b2.memoizedState = f2;
  b2.child = c2;
  return d2;
}
function Jg(a, b2, c2) {
  null !== a && (b2.contextDependencies = a.contextDependencies);
  if (b2.childExpirationTime < c2)
    return null;
  null !== a && b2.child !== a.child ? x$1("153") : void 0;
  if (null !== b2.child) {
    a = b2.child;
    c2 = Xe(a, a.pendingProps, a.expirationTime);
    b2.child = c2;
    for (c2.return = b2; null !== a.sibling; )
      a = a.sibling, c2 = c2.sibling = Xe(a, a.pendingProps, a.expirationTime), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function Tg(a, b2, c2) {
  var d2 = b2.expirationTime;
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || I.current)
      qg = true;
    else {
      if (d2 < c2) {
        qg = false;
        switch (b2.tag) {
          case 3:
            Rg(b2);
            Fg();
            break;
          case 5:
            Lf(b2);
            break;
          case 1:
            J(b2.type) && Oe(b2);
            break;
          case 4:
            Jf(b2, b2.stateNode.containerInfo);
            break;
          case 10:
            Ug(b2, b2.memoizedProps.value);
            break;
          case 13:
            if (null !== b2.memoizedState) {
              d2 = b2.child.childExpirationTime;
              if (0 !== d2 && d2 >= c2)
                return Sg(a, b2, c2);
              b2 = Jg(a, b2, c2);
              return null !== b2 ? b2.sibling : null;
            }
        }
        return Jg(a, b2, c2);
      }
    }
  else
    qg = false;
  b2.expirationTime = 0;
  switch (b2.tag) {
    case 2:
      d2 = b2.elementType;
      null !== a && (a.alternate = null, b2.alternate = null, b2.effectTag |= 2);
      a = b2.pendingProps;
      var e2 = Je(b2, H.current);
      Ig(b2, c2);
      e2 = hg(null, b2, d2, a, e2, c2);
      b2.effectTag |= 1;
      if ("object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof) {
        b2.tag = 1;
        lg();
        if (J(d2)) {
          var f2 = true;
          Oe(b2);
        } else
          f2 = false;
        b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null;
        var g2 = d2.getDerivedStateFromProps;
        "function" === typeof g2 && kf(b2, d2, g2, a);
        e2.updater = tf;
        b2.stateNode = e2;
        e2._reactInternalFiber = b2;
        xf(b2, d2, a, c2);
        b2 = Qg(null, b2, d2, true, f2, c2);
      } else
        b2.tag = 0, S(null, b2, e2, c2), b2 = b2.child;
      return b2;
    case 16:
      e2 = b2.elementType;
      null !== a && (a.alternate = null, b2.alternate = null, b2.effectTag |= 2);
      f2 = b2.pendingProps;
      a = hf(e2);
      b2.type = a;
      e2 = b2.tag = We(a);
      f2 = L(a, f2);
      g2 = void 0;
      switch (e2) {
        case 0:
          g2 = Mg(null, b2, a, f2, c2);
          break;
        case 1:
          g2 = Og(null, b2, a, f2, c2);
          break;
        case 11:
          g2 = Hg(null, b2, a, f2, c2);
          break;
        case 14:
          g2 = Kg(null, b2, a, L(a.type, f2), d2, c2);
          break;
        default:
          x$1("306", a, "");
      }
      return g2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : L(d2, e2), Mg(a, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : L(d2, e2), Og(a, b2, d2, e2, c2);
    case 3:
      Rg(b2);
      d2 = b2.updateQueue;
      null === d2 ? x$1("282") : void 0;
      e2 = b2.memoizedState;
      e2 = null !== e2 ? e2.element : null;
      yf(b2, d2, b2.pendingProps, null, c2);
      d2 = b2.memoizedState.element;
      if (d2 === e2)
        Fg(), b2 = Jg(a, b2, c2);
      else {
        e2 = b2.stateNode;
        if (e2 = (null === a || null === a.child) && e2.hydrate)
          yg = Ee(b2.stateNode.containerInfo), xg = b2, e2 = zg = true;
        e2 ? (b2.effectTag |= 2, b2.child = Ef(b2, null, d2, c2)) : (S(a, b2, d2, c2), Fg());
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Lf(b2), null === a && Cg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, xe(d2, e2) ? g2 = null : null !== f2 && xe(d2, f2) && (b2.effectTag |= 16), Ng(a, b2), 1 !== c2 && b2.mode & 1 && e2.hidden ? (b2.expirationTime = b2.childExpirationTime = 1, b2 = null) : (S(a, b2, g2, c2), b2 = b2.child), b2;
    case 6:
      return null === a && Cg(b2), null;
    case 13:
      return Sg(a, b2, c2);
    case 4:
      return Jf(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a ? b2.child = Df(b2, null, d2, c2) : S(a, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : L(d2, e2), Hg(a, b2, d2, e2, c2);
    case 7:
      return S(a, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return S(a, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return S(a, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        g2 = b2.memoizedProps;
        f2 = e2.value;
        Ug(b2, f2);
        if (null !== g2) {
          var h2 = g2.value;
          f2 = bd(h2, f2) ? 0 : ("function" === typeof d2._calculateChangedBits ? d2._calculateChangedBits(h2, f2) : 1073741823) | 0;
          if (0 === f2) {
            if (g2.children === e2.children && !I.current) {
              b2 = Jg(a, b2, c2);
              break a;
            }
          } else
            for (h2 = b2.child, null !== h2 && (h2.return = b2); null !== h2; ) {
              var l2 = h2.contextDependencies;
              if (null !== l2) {
                g2 = h2.child;
                for (var k2 = l2.first; null !== k2; ) {
                  if (k2.context === d2 && 0 !== (k2.observedBits & f2)) {
                    1 === h2.tag && (k2 = nf(c2), k2.tag = sf, pf(h2, k2));
                    h2.expirationTime < c2 && (h2.expirationTime = c2);
                    k2 = h2.alternate;
                    null !== k2 && k2.expirationTime < c2 && (k2.expirationTime = c2);
                    k2 = c2;
                    for (var m2 = h2.return; null !== m2; ) {
                      var p2 = m2.alternate;
                      if (m2.childExpirationTime < k2)
                        m2.childExpirationTime = k2, null !== p2 && p2.childExpirationTime < k2 && (p2.childExpirationTime = k2);
                      else if (null !== p2 && p2.childExpirationTime < k2)
                        p2.childExpirationTime = k2;
                      else
                        break;
                      m2 = m2.return;
                    }
                    l2.expirationTime < c2 && (l2.expirationTime = c2);
                    break;
                  }
                  k2 = k2.next;
                }
              } else
                g2 = 10 === h2.tag ? h2.type === b2.type ? null : h2.child : h2.child;
              if (null !== g2)
                g2.return = h2;
              else
                for (g2 = h2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  h2 = g2.sibling;
                  if (null !== h2) {
                    h2.return = g2.return;
                    g2 = h2;
                    break;
                  }
                  g2 = g2.return;
                }
              h2 = g2;
            }
        }
        S(a, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, f2 = b2.pendingProps, d2 = f2.children, Ig(b2, c2), e2 = M(e2, f2.unstable_observedBits), d2 = d2(e2), b2.effectTag |= 1, S(a, b2, d2, c2), b2.child;
    case 14:
      return e2 = b2.type, f2 = L(e2, b2.pendingProps), f2 = L(e2.type, f2), Kg(a, b2, e2, f2, d2, c2);
    case 15:
      return Lg(a, b2, b2.type, b2.pendingProps, d2, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : L(d2, e2), null !== a && (a.alternate = null, b2.alternate = null, b2.effectTag |= 2), b2.tag = 1, J(d2) ? (a = true, Oe(b2)) : a = false, Ig(b2, c2), vf(b2, d2, e2), xf(b2, d2, e2, c2), Qg(null, b2, d2, true, a, c2);
  }
  x$1("156");
}
var Vg = { current: null }, Wg = null, Xg = null, Yg = null;
function Ug(a, b2) {
  var c2 = a.type._context;
  G(Vg, c2._currentValue);
  c2._currentValue = b2;
}
function Zg(a) {
  var b2 = Vg.current;
  F(Vg);
  a.type._context._currentValue = b2;
}
function Ig(a, b2) {
  Wg = a;
  Yg = Xg = null;
  var c2 = a.contextDependencies;
  null !== c2 && c2.expirationTime >= b2 && (qg = true);
  a.contextDependencies = null;
}
function M(a, b2) {
  if (Yg !== a && false !== b2 && 0 !== b2) {
    if ("number" !== typeof b2 || 1073741823 === b2)
      Yg = a, b2 = 1073741823;
    b2 = { context: a, observedBits: b2, next: null };
    null === Xg ? (null === Wg ? x$1("308") : void 0, Xg = b2, Wg.contextDependencies = { first: b2, expirationTime: 0 }) : Xg = Xg.next = b2;
  }
  return a._currentValue;
}
var $g = 0, rf = 1, sf = 2, ah = 3, Pg = false;
function bh(a) {
  return { baseState: a, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
}
function ch(a) {
  return { baseState: a.baseState, firstUpdate: a.firstUpdate, lastUpdate: a.lastUpdate, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null };
}
function nf(a) {
  return { expirationTime: a, tag: $g, payload: null, callback: null, next: null, nextEffect: null };
}
function dh(a, b2) {
  null === a.lastUpdate ? a.firstUpdate = a.lastUpdate = b2 : (a.lastUpdate.next = b2, a.lastUpdate = b2);
}
function pf(a, b2) {
  var c2 = a.alternate;
  if (null === c2) {
    var d2 = a.updateQueue;
    var e2 = null;
    null === d2 && (d2 = a.updateQueue = bh(a.memoizedState));
  } else
    d2 = a.updateQueue, e2 = c2.updateQueue, null === d2 ? null === e2 ? (d2 = a.updateQueue = bh(a.memoizedState), e2 = c2.updateQueue = bh(c2.memoizedState)) : d2 = a.updateQueue = ch(e2) : null === e2 && (e2 = c2.updateQueue = ch(d2));
  null === e2 || d2 === e2 ? dh(d2, b2) : null === d2.lastUpdate || null === e2.lastUpdate ? (dh(d2, b2), dh(e2, b2)) : (dh(d2, b2), e2.lastUpdate = b2);
}
function eh(a, b2) {
  var c2 = a.updateQueue;
  c2 = null === c2 ? a.updateQueue = bh(a.memoizedState) : fh(a, c2);
  null === c2.lastCapturedUpdate ? c2.firstCapturedUpdate = c2.lastCapturedUpdate = b2 : (c2.lastCapturedUpdate.next = b2, c2.lastCapturedUpdate = b2);
}
function fh(a, b2) {
  var c2 = a.alternate;
  null !== c2 && b2 === c2.updateQueue && (b2 = a.updateQueue = ch(b2));
  return b2;
}
function gh(a, b2, c2, d2, e2, f2) {
  switch (c2.tag) {
    case rf:
      return a = c2.payload, "function" === typeof a ? a.call(f2, d2, e2) : a;
    case ah:
      a.effectTag = a.effectTag & -2049 | 64;
    case $g:
      a = c2.payload;
      e2 = "function" === typeof a ? a.call(f2, d2, e2) : a;
      if (null === e2 || void 0 === e2)
        break;
      return n$2({}, d2, e2);
    case sf:
      Pg = true;
  }
  return d2;
}
function yf(a, b2, c2, d2, e2) {
  Pg = false;
  b2 = fh(a, b2);
  for (var f2 = b2.baseState, g2 = null, h2 = 0, l2 = b2.firstUpdate, k2 = f2; null !== l2; ) {
    var m2 = l2.expirationTime;
    m2 < e2 ? (null === g2 && (g2 = l2, f2 = k2), h2 < m2 && (h2 = m2)) : (k2 = gh(a, b2, l2, k2, c2, d2), null !== l2.callback && (a.effectTag |= 32, l2.nextEffect = null, null === b2.lastEffect ? b2.firstEffect = b2.lastEffect = l2 : (b2.lastEffect.nextEffect = l2, b2.lastEffect = l2)));
    l2 = l2.next;
  }
  m2 = null;
  for (l2 = b2.firstCapturedUpdate; null !== l2; ) {
    var p2 = l2.expirationTime;
    p2 < e2 ? (null === m2 && (m2 = l2, null === g2 && (f2 = k2)), h2 < p2 && (h2 = p2)) : (k2 = gh(a, b2, l2, k2, c2, d2), null !== l2.callback && (a.effectTag |= 32, l2.nextEffect = null, null === b2.lastCapturedEffect ? b2.firstCapturedEffect = b2.lastCapturedEffect = l2 : (b2.lastCapturedEffect.nextEffect = l2, b2.lastCapturedEffect = l2)));
    l2 = l2.next;
  }
  null === g2 && (b2.lastUpdate = null);
  null === m2 ? b2.lastCapturedUpdate = null : a.effectTag |= 32;
  null === g2 && null === m2 && (f2 = k2);
  b2.baseState = f2;
  b2.firstUpdate = g2;
  b2.firstCapturedUpdate = m2;
  a.expirationTime = h2;
  a.memoizedState = k2;
}
function hh(a, b2, c2) {
  null !== b2.firstCapturedUpdate && (null !== b2.lastUpdate && (b2.lastUpdate.next = b2.firstCapturedUpdate, b2.lastUpdate = b2.lastCapturedUpdate), b2.firstCapturedUpdate = b2.lastCapturedUpdate = null);
  ih(b2.firstEffect, c2);
  b2.firstEffect = b2.lastEffect = null;
  ih(b2.firstCapturedEffect, c2);
  b2.firstCapturedEffect = b2.lastCapturedEffect = null;
}
function ih(a, b2) {
  for (; null !== a; ) {
    var c2 = a.callback;
    if (null !== c2) {
      a.callback = null;
      var d2 = b2;
      "function" !== typeof c2 ? x$1("191", c2) : void 0;
      c2.call(d2);
    }
    a = a.nextEffect;
  }
}
function jh(a, b2) {
  return { value: a, source: b2, stack: jc(b2) };
}
function kh(a) {
  a.effectTag |= 4;
}
var lh = void 0, mh = void 0, nh = void 0, oh = void 0;
lh = function(a, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
mh = function() {
};
nh = function(a, b2, c2, d2, e2) {
  var f2 = a.memoizedProps;
  if (f2 !== d2) {
    var g2 = b2.stateNode;
    If(N.current);
    a = null;
    switch (c2) {
      case "input":
        f2 = vc(g2, f2);
        d2 = vc(g2, d2);
        a = [];
        break;
      case "option":
        f2 = $d(g2, f2);
        d2 = $d(g2, d2);
        a = [];
        break;
      case "select":
        f2 = n$2({}, f2, { value: void 0 });
        d2 = n$2({}, d2, { value: void 0 });
        a = [];
        break;
      case "textarea":
        f2 = be(g2, f2);
        d2 = be(g2, d2);
        a = [];
        break;
      default:
        "function" !== typeof f2.onClick && "function" === typeof d2.onClick && (g2.onclick = te);
    }
    qe(c2, d2);
    g2 = c2 = void 0;
    var h2 = null;
    for (c2 in f2)
      if (!d2.hasOwnProperty(c2) && f2.hasOwnProperty(c2) && null != f2[c2])
        if ("style" === c2) {
          var l2 = f2[c2];
          for (g2 in l2)
            l2.hasOwnProperty(g2) && (h2 || (h2 = {}), h2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== c2 && "children" !== c2 && "suppressContentEditableWarning" !== c2 && "suppressHydrationWarning" !== c2 && "autoFocus" !== c2 && (ra.hasOwnProperty(c2) ? a || (a = []) : (a = a || []).push(c2, null));
    for (c2 in d2) {
      var k2 = d2[c2];
      l2 = null != f2 ? f2[c2] : void 0;
      if (d2.hasOwnProperty(c2) && k2 !== l2 && (null != k2 || null != l2))
        if ("style" === c2)
          if (l2) {
            for (g2 in l2)
              !l2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (h2 || (h2 = {}), h2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && l2[g2] !== k2[g2] && (h2 || (h2 = {}), h2[g2] = k2[g2]);
          } else
            h2 || (a || (a = []), a.push(c2, h2)), h2 = k2;
        else
          "dangerouslySetInnerHTML" === c2 ? (k2 = k2 ? k2.__html : void 0, l2 = l2 ? l2.__html : void 0, null != k2 && l2 !== k2 && (a = a || []).push(c2, "" + k2)) : "children" === c2 ? l2 === k2 || "string" !== typeof k2 && "number" !== typeof k2 || (a = a || []).push(c2, "" + k2) : "suppressContentEditableWarning" !== c2 && "suppressHydrationWarning" !== c2 && (ra.hasOwnProperty(c2) ? (null != k2 && se(e2, c2), a || l2 === k2 || (a = [])) : (a = a || []).push(c2, k2));
    }
    h2 && (a = a || []).push("style", h2);
    e2 = a;
    (b2.updateQueue = e2) && kh(b2);
  }
};
oh = function(a, b2, c2, d2) {
  c2 !== d2 && kh(b2);
};
var ph = "function" === typeof WeakSet ? WeakSet : Set;
function qh(a, b2) {
  var c2 = b2.source, d2 = b2.stack;
  null === d2 && null !== c2 && (d2 = jc(c2));
  null !== c2 && ic(c2.type);
  b2 = b2.value;
  null !== a && 1 === a.tag && ic(a.type);
  try {
    console.error(b2);
  } catch (e2) {
    setTimeout(function() {
      throw e2;
    });
  }
}
function rh(a) {
  var b2 = a.ref;
  if (null !== b2)
    if ("function" === typeof b2)
      try {
        b2(null);
      } catch (c2) {
        sh(a, c2);
      }
    else
      b2.current = null;
}
function th(a, b2, c2) {
  c2 = c2.updateQueue;
  c2 = null !== c2 ? c2.lastEffect : null;
  if (null !== c2) {
    var d2 = c2 = c2.next;
    do {
      if ((d2.tag & a) !== Nf) {
        var e2 = d2.destroy;
        d2.destroy = void 0;
        void 0 !== e2 && e2();
      }
      (d2.tag & b2) !== Nf && (e2 = d2.create, d2.destroy = e2());
      d2 = d2.next;
    } while (d2 !== c2);
  }
}
function uh(a, b2) {
  for (var c2 = a; ; ) {
    if (5 === c2.tag) {
      var d2 = c2.stateNode;
      if (b2)
        d2.style.display = "none";
      else {
        d2 = c2.stateNode;
        var e2 = c2.memoizedProps.style;
        e2 = void 0 !== e2 && null !== e2 && e2.hasOwnProperty("display") ? e2.display : null;
        d2.style.display = ne("display", e2);
      }
    } else if (6 === c2.tag)
      c2.stateNode.nodeValue = b2 ? "" : c2.memoizedProps;
    else if (13 === c2.tag && null !== c2.memoizedState) {
      d2 = c2.child.sibling;
      d2.return = c2;
      c2 = d2;
      continue;
    } else if (null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === a)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === a)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
}
function vh(a) {
  "function" === typeof Re && Re(a);
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      var b2 = a.updateQueue;
      if (null !== b2 && (b2 = b2.lastEffect, null !== b2)) {
        var c2 = b2 = b2.next;
        do {
          var d2 = c2.destroy;
          if (void 0 !== d2) {
            var e2 = a;
            try {
              d2();
            } catch (f2) {
              sh(e2, f2);
            }
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
      break;
    case 1:
      rh(a);
      b2 = a.stateNode;
      if ("function" === typeof b2.componentWillUnmount)
        try {
          b2.props = a.memoizedProps, b2.state = a.memoizedState, b2.componentWillUnmount();
        } catch (f2) {
          sh(a, f2);
        }
      break;
    case 5:
      rh(a);
      break;
    case 4:
      wh(a);
  }
}
function xh(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function yh(a) {
  a: {
    for (var b2 = a.return; null !== b2; ) {
      if (xh(b2)) {
        var c2 = b2;
        break a;
      }
      b2 = b2.return;
    }
    x$1("160");
    c2 = void 0;
  }
  var d2 = b2 = void 0;
  switch (c2.tag) {
    case 5:
      b2 = c2.stateNode;
      d2 = false;
      break;
    case 3:
      b2 = c2.stateNode.containerInfo;
      d2 = true;
      break;
    case 4:
      b2 = c2.stateNode.containerInfo;
      d2 = true;
      break;
    default:
      x$1("161");
  }
  c2.effectTag & 16 && (ke(b2, ""), c2.effectTag &= -17);
  a:
    b:
      for (c2 = a; ; ) {
        for (; null === c2.sibling; ) {
          if (null === c2.return || xh(c2.return)) {
            c2 = null;
            break a;
          }
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        for (c2 = c2.sibling; 5 !== c2.tag && 6 !== c2.tag && 18 !== c2.tag; ) {
          if (c2.effectTag & 2)
            continue b;
          if (null === c2.child || 4 === c2.tag)
            continue b;
          else
            c2.child.return = c2, c2 = c2.child;
        }
        if (!(c2.effectTag & 2)) {
          c2 = c2.stateNode;
          break a;
        }
      }
  for (var e2 = a; ; ) {
    if (5 === e2.tag || 6 === e2.tag)
      if (c2)
        if (d2) {
          var f2 = b2, g2 = e2.stateNode, h2 = c2;
          8 === f2.nodeType ? f2.parentNode.insertBefore(g2, h2) : f2.insertBefore(g2, h2);
        } else
          b2.insertBefore(e2.stateNode, c2);
      else
        d2 ? (g2 = b2, h2 = e2.stateNode, 8 === g2.nodeType ? (f2 = g2.parentNode, f2.insertBefore(h2, g2)) : (f2 = g2, f2.appendChild(h2)), g2 = g2._reactRootContainer, null !== g2 && void 0 !== g2 || null !== f2.onclick || (f2.onclick = te)) : b2.appendChild(e2.stateNode);
    else if (4 !== e2.tag && null !== e2.child) {
      e2.child.return = e2;
      e2 = e2.child;
      continue;
    }
    if (e2 === a)
      break;
    for (; null === e2.sibling; ) {
      if (null === e2.return || e2.return === a)
        return;
      e2 = e2.return;
    }
    e2.sibling.return = e2.return;
    e2 = e2.sibling;
  }
}
function wh(a) {
  for (var b2 = a, c2 = false, d2 = void 0, e2 = void 0; ; ) {
    if (!c2) {
      c2 = b2.return;
      a:
        for (; ; ) {
          null === c2 ? x$1("160") : void 0;
          switch (c2.tag) {
            case 5:
              d2 = c2.stateNode;
              e2 = false;
              break a;
            case 3:
              d2 = c2.stateNode.containerInfo;
              e2 = true;
              break a;
            case 4:
              d2 = c2.stateNode.containerInfo;
              e2 = true;
              break a;
          }
          c2 = c2.return;
        }
      c2 = true;
    }
    if (5 === b2.tag || 6 === b2.tag) {
      a:
        for (var f2 = b2, g2 = f2; ; )
          if (vh(g2), null !== g2.child && 4 !== g2.tag)
            g2.child.return = g2, g2 = g2.child;
          else {
            if (g2 === f2)
              break;
            for (; null === g2.sibling; ) {
              if (null === g2.return || g2.return === f2)
                break a;
              g2 = g2.return;
            }
            g2.sibling.return = g2.return;
            g2 = g2.sibling;
          }
      e2 ? (f2 = d2, g2 = b2.stateNode, 8 === f2.nodeType ? f2.parentNode.removeChild(g2) : f2.removeChild(g2)) : d2.removeChild(b2.stateNode);
    } else if (4 === b2.tag) {
      if (null !== b2.child) {
        d2 = b2.stateNode.containerInfo;
        e2 = true;
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
    } else if (vh(b2), null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return;
      b2 = b2.return;
      4 === b2.tag && (c2 = false);
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
}
function zh(a, b2) {
  switch (b2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      th(Pf, Qf, b2);
      break;
    case 1:
      break;
    case 5:
      var c2 = b2.stateNode;
      if (null != c2) {
        var d2 = b2.memoizedProps;
        a = null !== a ? a.memoizedProps : d2;
        var e2 = b2.type, f2 = b2.updateQueue;
        b2.updateQueue = null;
        null !== f2 && Ce(c2, f2, e2, a, d2);
      }
      break;
    case 6:
      null === b2.stateNode ? x$1("162") : void 0;
      b2.stateNode.nodeValue = b2.memoizedProps;
      break;
    case 3:
      break;
    case 12:
      break;
    case 13:
      c2 = b2.memoizedState;
      d2 = void 0;
      a = b2;
      null === c2 ? d2 = false : (d2 = true, a = b2.child, 0 === c2.timedOutAt && (c2.timedOutAt = lf()));
      null !== a && uh(a, d2);
      c2 = b2.updateQueue;
      if (null !== c2) {
        b2.updateQueue = null;
        var g2 = b2.stateNode;
        null === g2 && (g2 = b2.stateNode = new ph());
        c2.forEach(function(a2) {
          var c3 = Ah.bind(null, b2, a2);
          g2.has(a2) || (g2.add(a2), a2.then(c3, c3));
        });
      }
      break;
    case 17:
      break;
    default:
      x$1("163");
  }
}
var Bh = "function" === typeof WeakMap ? WeakMap : Map;
function Ch(a, b2, c2) {
  c2 = nf(c2);
  c2.tag = ah;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Dh(d2);
    qh(a, b2);
  };
  return c2;
}
function Eh(a, b2, c2) {
  c2 = nf(c2);
  c2.tag = ah;
  var d2 = a.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    "function" !== typeof d2 && (null === Fh ? Fh = /* @__PURE__ */ new Set([this]) : Fh.add(this));
    var c3 = b2.value, e3 = b2.stack;
    qh(a, b2);
    this.componentDidCatch(c3, { componentStack: null !== e3 ? e3 : "" });
  });
  return c2;
}
function Gh(a) {
  switch (a.tag) {
    case 1:
      J(a.type) && Ke();
      var b2 = a.effectTag;
      return b2 & 2048 ? (a.effectTag = b2 & -2049 | 64, a) : null;
    case 3:
      return Kf(), Le(), b2 = a.effectTag, 0 !== (b2 & 64) ? x$1("285") : void 0, a.effectTag = b2 & -2049 | 64, a;
    case 5:
      return Mf(a), null;
    case 13:
      return b2 = a.effectTag, b2 & 2048 ? (a.effectTag = b2 & -2049 | 64, a) : null;
    case 18:
      return null;
    case 4:
      return Kf(), null;
    case 10:
      return Zg(a), null;
    default:
      return null;
  }
}
var Hh = Tb.ReactCurrentDispatcher, Ih = Tb.ReactCurrentOwner, Jh = 1073741822, Kh = false, T = null, Lh = null, U = 0, Mh = -1, Nh = false, V = null, Oh = false, Ph = null, Qh = null, Rh = null, Fh = null;
function Sh() {
  if (null !== T)
    for (var a = T.return; null !== a; ) {
      var b2 = a;
      switch (b2.tag) {
        case 1:
          var c2 = b2.type.childContextTypes;
          null !== c2 && void 0 !== c2 && Ke();
          break;
        case 3:
          Kf();
          Le();
          break;
        case 5:
          Mf(b2);
          break;
        case 4:
          Kf();
          break;
        case 10:
          Zg(b2);
      }
      a = a.return;
    }
  Lh = null;
  U = 0;
  Mh = -1;
  Nh = false;
  T = null;
}
function Th() {
  for (; null !== V; ) {
    var a = V.effectTag;
    a & 16 && ke(V.stateNode, "");
    if (a & 128) {
      var b2 = V.alternate;
      null !== b2 && (b2 = b2.ref, null !== b2 && ("function" === typeof b2 ? b2(null) : b2.current = null));
    }
    switch (a & 14) {
      case 2:
        yh(V);
        V.effectTag &= -3;
        break;
      case 6:
        yh(V);
        V.effectTag &= -3;
        zh(V.alternate, V);
        break;
      case 4:
        zh(V.alternate, V);
        break;
      case 8:
        a = V, wh(a), a.return = null, a.child = null, a.memoizedState = null, a.updateQueue = null, a = a.alternate, null !== a && (a.return = null, a.child = null, a.memoizedState = null, a.updateQueue = null);
    }
    V = V.nextEffect;
  }
}
function Uh() {
  for (; null !== V; ) {
    if (V.effectTag & 256)
      a: {
        var a = V.alternate, b2 = V;
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            th(Of, Nf, b2);
            break a;
          case 1:
            if (b2.effectTag & 256 && null !== a) {
              var c2 = a.memoizedProps, d2 = a.memoizedState;
              a = b2.stateNode;
              b2 = a.getSnapshotBeforeUpdate(b2.elementType === b2.type ? c2 : L(b2.type, c2), d2);
              a.__reactInternalSnapshotBeforeUpdate = b2;
            }
            break a;
          case 3:
          case 5:
          case 6:
          case 4:
          case 17:
            break a;
          default:
            x$1("163");
        }
      }
    V = V.nextEffect;
  }
}
function Vh(a, b2) {
  for (; null !== V; ) {
    var c2 = V.effectTag;
    if (c2 & 36) {
      var d2 = V.alternate, e2 = V, f2 = b2;
      switch (e2.tag) {
        case 0:
        case 11:
        case 15:
          th(Rf, Sf, e2);
          break;
        case 1:
          var g2 = e2.stateNode;
          if (e2.effectTag & 4)
            if (null === d2)
              g2.componentDidMount();
            else {
              var h2 = e2.elementType === e2.type ? d2.memoizedProps : L(e2.type, d2.memoizedProps);
              g2.componentDidUpdate(h2, d2.memoizedState, g2.__reactInternalSnapshotBeforeUpdate);
            }
          d2 = e2.updateQueue;
          null !== d2 && hh(e2, d2, g2);
          break;
        case 3:
          d2 = e2.updateQueue;
          if (null !== d2) {
            g2 = null;
            if (null !== e2.child)
              switch (e2.child.tag) {
                case 5:
                  g2 = e2.child.stateNode;
                  break;
                case 1:
                  g2 = e2.child.stateNode;
              }
            hh(e2, d2, g2);
          }
          break;
        case 5:
          f2 = e2.stateNode;
          null === d2 && e2.effectTag & 4 && we(e2.type, e2.memoizedProps) && f2.focus();
          break;
        case 6:
          break;
        case 4:
          break;
        case 12:
          break;
        case 13:
          break;
        case 17:
          break;
        default:
          x$1("163");
      }
    }
    c2 & 128 && (e2 = V.ref, null !== e2 && (f2 = V.stateNode, "function" === typeof e2 ? e2(f2) : e2.current = f2));
    c2 & 512 && (Ph = a);
    V = V.nextEffect;
  }
}
function Wh(a, b2) {
  Rh = Qh = Ph = null;
  var c2 = W;
  W = true;
  do {
    if (b2.effectTag & 512) {
      var d2 = false, e2 = void 0;
      try {
        var f2 = b2;
        th(Uf, Nf, f2);
        th(Nf, Tf, f2);
      } catch (g2) {
        d2 = true, e2 = g2;
      }
      d2 && sh(b2, e2);
    }
    b2 = b2.nextEffect;
  } while (null !== b2);
  W = c2;
  c2 = a.expirationTime;
  0 !== c2 && Xh(a, c2);
  X || W || Yh(1073741823, false);
}
function of() {
  null !== Qh && Be(Qh);
  null !== Rh && Rh();
}
function Zh(a, b2) {
  Oh = Kh = true;
  a.current === b2 ? x$1("177") : void 0;
  var c2 = a.pendingCommitExpirationTime;
  0 === c2 ? x$1("261") : void 0;
  a.pendingCommitExpirationTime = 0;
  var d2 = b2.expirationTime, e2 = b2.childExpirationTime;
  ef(a, e2 > d2 ? e2 : d2);
  Ih.current = null;
  d2 = void 0;
  1 < b2.effectTag ? null !== b2.lastEffect ? (b2.lastEffect.nextEffect = b2, d2 = b2.firstEffect) : d2 = b2 : d2 = b2.firstEffect;
  ue = Bd;
  ve = Pd();
  Bd = false;
  for (V = d2; null !== V; ) {
    e2 = false;
    var f2 = void 0;
    try {
      Uh();
    } catch (h2) {
      e2 = true, f2 = h2;
    }
    e2 && (null === V ? x$1("178") : void 0, sh(V, f2), null !== V && (V = V.nextEffect));
  }
  for (V = d2; null !== V; ) {
    e2 = false;
    f2 = void 0;
    try {
      Th();
    } catch (h2) {
      e2 = true, f2 = h2;
    }
    e2 && (null === V ? x$1("178") : void 0, sh(V, f2), null !== V && (V = V.nextEffect));
  }
  Qd(ve);
  ve = null;
  Bd = !!ue;
  ue = null;
  a.current = b2;
  for (V = d2; null !== V; ) {
    e2 = false;
    f2 = void 0;
    try {
      Vh(a, c2);
    } catch (h2) {
      e2 = true, f2 = h2;
    }
    e2 && (null === V ? x$1("178") : void 0, sh(V, f2), null !== V && (V = V.nextEffect));
  }
  if (null !== d2 && null !== Ph) {
    var g2 = Wh.bind(null, a, d2);
    Qh = r$2.unstable_runWithPriority(r$2.unstable_NormalPriority, function() {
      return Ae(g2);
    });
    Rh = g2;
  }
  Kh = Oh = false;
  "function" === typeof Qe && Qe(b2.stateNode);
  c2 = b2.expirationTime;
  b2 = b2.childExpirationTime;
  b2 = b2 > c2 ? b2 : c2;
  0 === b2 && (Fh = null);
  $h(a, b2);
}
function ai(a) {
  for (; ; ) {
    var b2 = a.alternate, c2 = a.return, d2 = a.sibling;
    if (0 === (a.effectTag & 1024)) {
      T = a;
      a: {
        var e2 = b2;
        b2 = a;
        var f2 = U;
        var g2 = b2.pendingProps;
        switch (b2.tag) {
          case 2:
            break;
          case 16:
            break;
          case 15:
          case 0:
            break;
          case 1:
            J(b2.type) && Ke();
            break;
          case 3:
            Kf();
            Le();
            g2 = b2.stateNode;
            g2.pendingContext && (g2.context = g2.pendingContext, g2.pendingContext = null);
            if (null === e2 || null === e2.child)
              Eg(b2), b2.effectTag &= -3;
            mh(b2);
            break;
          case 5:
            Mf(b2);
            var h2 = If(Hf.current);
            f2 = b2.type;
            if (null !== e2 && null != b2.stateNode)
              nh(e2, b2, f2, g2, h2), e2.ref !== b2.ref && (b2.effectTag |= 128);
            else if (g2) {
              var l2 = If(N.current);
              if (Eg(b2)) {
                g2 = b2;
                e2 = g2.stateNode;
                var k2 = g2.type, m2 = g2.memoizedProps, p2 = h2;
                e2[Fa] = g2;
                e2[Ga] = m2;
                f2 = void 0;
                h2 = k2;
                switch (h2) {
                  case "iframe":
                  case "object":
                    E("load", e2);
                    break;
                  case "video":
                  case "audio":
                    for (k2 = 0; k2 < ab.length; k2++)
                      E(ab[k2], e2);
                    break;
                  case "source":
                    E("error", e2);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    E("error", e2);
                    E("load", e2);
                    break;
                  case "form":
                    E("reset", e2);
                    E("submit", e2);
                    break;
                  case "details":
                    E("toggle", e2);
                    break;
                  case "input":
                    wc(e2, m2);
                    E("invalid", e2);
                    se(p2, "onChange");
                    break;
                  case "select":
                    e2._wrapperState = { wasMultiple: !!m2.multiple };
                    E("invalid", e2);
                    se(p2, "onChange");
                    break;
                  case "textarea":
                    ce(e2, m2), E("invalid", e2), se(p2, "onChange");
                }
                qe(h2, m2);
                k2 = null;
                for (f2 in m2)
                  m2.hasOwnProperty(f2) && (l2 = m2[f2], "children" === f2 ? "string" === typeof l2 ? e2.textContent !== l2 && (k2 = ["children", l2]) : "number" === typeof l2 && e2.textContent !== "" + l2 && (k2 = ["children", "" + l2]) : ra.hasOwnProperty(f2) && null != l2 && se(p2, f2));
                switch (h2) {
                  case "input":
                    Rb(e2);
                    Ac(e2, m2, true);
                    break;
                  case "textarea":
                    Rb(e2);
                    ee(e2);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof m2.onClick && (e2.onclick = te);
                }
                f2 = k2;
                g2.updateQueue = f2;
                g2 = null !== f2 ? true : false;
                g2 && kh(b2);
              } else {
                m2 = b2;
                p2 = f2;
                e2 = g2;
                k2 = 9 === h2.nodeType ? h2 : h2.ownerDocument;
                l2 === fe.html && (l2 = ge(p2));
                l2 === fe.html ? "script" === p2 ? (e2 = k2.createElement("div"), e2.innerHTML = "<script><\/script>", k2 = e2.removeChild(e2.firstChild)) : "string" === typeof e2.is ? k2 = k2.createElement(p2, { is: e2.is }) : (k2 = k2.createElement(p2), "select" === p2 && (p2 = k2, e2.multiple ? p2.multiple = true : e2.size && (p2.size = e2.size))) : k2 = k2.createElementNS(l2, p2);
                e2 = k2;
                e2[Fa] = m2;
                e2[Ga] = g2;
                lh(e2, b2, false, false);
                p2 = e2;
                k2 = f2;
                m2 = g2;
                var t2 = h2, A2 = re(k2, m2);
                switch (k2) {
                  case "iframe":
                  case "object":
                    E("load", p2);
                    h2 = m2;
                    break;
                  case "video":
                  case "audio":
                    for (h2 = 0; h2 < ab.length; h2++)
                      E(ab[h2], p2);
                    h2 = m2;
                    break;
                  case "source":
                    E("error", p2);
                    h2 = m2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    E("error", p2);
                    E("load", p2);
                    h2 = m2;
                    break;
                  case "form":
                    E("reset", p2);
                    E("submit", p2);
                    h2 = m2;
                    break;
                  case "details":
                    E("toggle", p2);
                    h2 = m2;
                    break;
                  case "input":
                    wc(p2, m2);
                    h2 = vc(p2, m2);
                    E("invalid", p2);
                    se(t2, "onChange");
                    break;
                  case "option":
                    h2 = $d(p2, m2);
                    break;
                  case "select":
                    p2._wrapperState = { wasMultiple: !!m2.multiple };
                    h2 = n$2({}, m2, { value: void 0 });
                    E("invalid", p2);
                    se(t2, "onChange");
                    break;
                  case "textarea":
                    ce(p2, m2);
                    h2 = be(p2, m2);
                    E("invalid", p2);
                    se(t2, "onChange");
                    break;
                  default:
                    h2 = m2;
                }
                qe(k2, h2);
                l2 = void 0;
                var v2 = k2, R2 = p2, u2 = h2;
                for (l2 in u2)
                  if (u2.hasOwnProperty(l2)) {
                    var q2 = u2[l2];
                    "style" === l2 ? oe(R2, q2) : "dangerouslySetInnerHTML" === l2 ? (q2 = q2 ? q2.__html : void 0, null != q2 && je(R2, q2)) : "children" === l2 ? "string" === typeof q2 ? ("textarea" !== v2 || "" !== q2) && ke(R2, q2) : "number" === typeof q2 && ke(R2, "" + q2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ra.hasOwnProperty(l2) ? null != q2 && se(t2, l2) : null != q2 && tc(R2, l2, q2, A2));
                  }
                switch (k2) {
                  case "input":
                    Rb(p2);
                    Ac(p2, m2, false);
                    break;
                  case "textarea":
                    Rb(p2);
                    ee(p2);
                    break;
                  case "option":
                    null != m2.value && p2.setAttribute("value", "" + uc(m2.value));
                    break;
                  case "select":
                    h2 = p2;
                    h2.multiple = !!m2.multiple;
                    p2 = m2.value;
                    null != p2 ? ae(h2, !!m2.multiple, p2, false) : null != m2.defaultValue && ae(h2, !!m2.multiple, m2.defaultValue, true);
                    break;
                  default:
                    "function" === typeof h2.onClick && (p2.onclick = te);
                }
                (g2 = we(f2, g2)) && kh(b2);
                b2.stateNode = e2;
              }
              null !== b2.ref && (b2.effectTag |= 128);
            } else
              null === b2.stateNode ? x$1("166") : void 0;
            break;
          case 6:
            e2 && null != b2.stateNode ? oh(e2, b2, e2.memoizedProps, g2) : ("string" !== typeof g2 && (null === b2.stateNode ? x$1("166") : void 0), e2 = If(Hf.current), If(N.current), Eg(b2) ? (g2 = b2, f2 = g2.stateNode, e2 = g2.memoizedProps, f2[Fa] = g2, (g2 = f2.nodeValue !== e2) && kh(b2)) : (f2 = b2, g2 = (9 === e2.nodeType ? e2 : e2.ownerDocument).createTextNode(g2), g2[Fa] = b2, f2.stateNode = g2));
            break;
          case 11:
            break;
          case 13:
            g2 = b2.memoizedState;
            if (0 !== (b2.effectTag & 64)) {
              b2.expirationTime = f2;
              T = b2;
              break a;
            }
            g2 = null !== g2;
            f2 = null !== e2 && null !== e2.memoizedState;
            null !== e2 && !g2 && f2 && (e2 = e2.child.sibling, null !== e2 && (h2 = b2.firstEffect, null !== h2 ? (b2.firstEffect = e2, e2.nextEffect = h2) : (b2.firstEffect = b2.lastEffect = e2, e2.nextEffect = null), e2.effectTag = 8));
            if (g2 || f2)
              b2.effectTag |= 4;
            break;
          case 7:
            break;
          case 8:
            break;
          case 12:
            break;
          case 4:
            Kf();
            mh(b2);
            break;
          case 10:
            Zg(b2);
            break;
          case 9:
            break;
          case 14:
            break;
          case 17:
            J(b2.type) && Ke();
            break;
          case 18:
            break;
          default:
            x$1("156");
        }
        T = null;
      }
      b2 = a;
      if (1 === U || 1 !== b2.childExpirationTime) {
        g2 = 0;
        for (f2 = b2.child; null !== f2; )
          e2 = f2.expirationTime, h2 = f2.childExpirationTime, e2 > g2 && (g2 = e2), h2 > g2 && (g2 = h2), f2 = f2.sibling;
        b2.childExpirationTime = g2;
      }
      if (null !== T)
        return T;
      null !== c2 && 0 === (c2.effectTag & 1024) && (null === c2.firstEffect && (c2.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c2.lastEffect && (c2.lastEffect.nextEffect = a.firstEffect), c2.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c2.lastEffect ? c2.lastEffect.nextEffect = a : c2.firstEffect = a, c2.lastEffect = a));
    } else {
      a = Gh(a);
      if (null !== a)
        return a.effectTag &= 1023, a;
      null !== c2 && (c2.firstEffect = c2.lastEffect = null, c2.effectTag |= 1024);
    }
    if (null !== d2)
      return d2;
    if (null !== c2)
      a = c2;
    else
      break;
  }
  return null;
}
function bi(a) {
  var b2 = Tg(a.alternate, a, U);
  a.memoizedProps = a.pendingProps;
  null === b2 && (b2 = ai(a));
  Ih.current = null;
  return b2;
}
function ci(a, b2) {
  Kh ? x$1("243") : void 0;
  of();
  Kh = true;
  var c2 = Hh.current;
  Hh.current = kg;
  var d2 = a.nextExpirationTimeToWorkOn;
  if (d2 !== U || a !== Lh || null === T)
    Sh(), Lh = a, U = d2, T = Xe(Lh.current, null), a.pendingCommitExpirationTime = 0;
  var e2 = false;
  do {
    try {
      if (b2)
        for (; null !== T && !di(); )
          T = bi(T);
      else
        for (; null !== T; )
          T = bi(T);
    } catch (u2) {
      if (Yg = Xg = Wg = null, lg(), null === T)
        e2 = true, Dh(u2);
      else {
        null === T ? x$1("271") : void 0;
        var f2 = T, g2 = f2.return;
        if (null === g2)
          e2 = true, Dh(u2);
        else {
          a: {
            var h2 = a, l2 = g2, k2 = f2, m2 = u2;
            g2 = U;
            k2.effectTag |= 1024;
            k2.firstEffect = k2.lastEffect = null;
            if (null !== m2 && "object" === typeof m2 && "function" === typeof m2.then) {
              var p2 = m2;
              m2 = l2;
              var t2 = -1, A2 = -1;
              do {
                if (13 === m2.tag) {
                  var v2 = m2.alternate;
                  if (null !== v2 && (v2 = v2.memoizedState, null !== v2)) {
                    A2 = 10 * (1073741822 - v2.timedOutAt);
                    break;
                  }
                  v2 = m2.pendingProps.maxDuration;
                  if ("number" === typeof v2) {
                    if (0 >= v2)
                      t2 = 0;
                    else if (-1 === t2 || v2 < t2)
                      t2 = v2;
                  }
                }
                m2 = m2.return;
              } while (null !== m2);
              m2 = l2;
              do {
                if (v2 = 13 === m2.tag)
                  v2 = void 0 === m2.memoizedProps.fallback ? false : null === m2.memoizedState;
                if (v2) {
                  l2 = m2.updateQueue;
                  null === l2 ? (l2 = /* @__PURE__ */ new Set(), l2.add(p2), m2.updateQueue = l2) : l2.add(p2);
                  if (0 === (m2.mode & 1)) {
                    m2.effectTag |= 64;
                    k2.effectTag &= -1957;
                    1 === k2.tag && (null === k2.alternate ? k2.tag = 17 : (g2 = nf(1073741823), g2.tag = sf, pf(k2, g2)));
                    k2.expirationTime = 1073741823;
                    break a;
                  }
                  k2 = h2;
                  l2 = g2;
                  var R2 = k2.pingCache;
                  null === R2 ? (R2 = k2.pingCache = new Bh(), v2 = /* @__PURE__ */ new Set(), R2.set(p2, v2)) : (v2 = R2.get(p2), void 0 === v2 && (v2 = /* @__PURE__ */ new Set(), R2.set(p2, v2)));
                  v2.has(l2) || (v2.add(l2), k2 = ei.bind(null, k2, p2, l2), p2.then(k2, k2));
                  -1 === t2 ? h2 = 1073741823 : (-1 === A2 && (A2 = 10 * (1073741822 - gf(h2, g2)) - 5e3), h2 = A2 + t2);
                  0 <= h2 && Mh < h2 && (Mh = h2);
                  m2.effectTag |= 2048;
                  m2.expirationTime = g2;
                  break a;
                }
                m2 = m2.return;
              } while (null !== m2);
              m2 = Error((ic(k2.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + jc(k2));
            }
            Nh = true;
            m2 = jh(m2, k2);
            h2 = l2;
            do {
              switch (h2.tag) {
                case 3:
                  h2.effectTag |= 2048;
                  h2.expirationTime = g2;
                  g2 = Ch(h2, m2, g2);
                  eh(h2, g2);
                  break a;
                case 1:
                  if (t2 = m2, A2 = h2.type, k2 = h2.stateNode, 0 === (h2.effectTag & 64) && ("function" === typeof A2.getDerivedStateFromError || null !== k2 && "function" === typeof k2.componentDidCatch && (null === Fh || !Fh.has(k2)))) {
                    h2.effectTag |= 2048;
                    h2.expirationTime = g2;
                    g2 = Eh(h2, t2, g2);
                    eh(h2, g2);
                    break a;
                  }
              }
              h2 = h2.return;
            } while (null !== h2);
          }
          T = ai(f2);
          continue;
        }
      }
    }
    break;
  } while (1);
  Kh = false;
  Hh.current = c2;
  Yg = Xg = Wg = null;
  lg();
  if (e2)
    Lh = null, a.finishedWork = null;
  else if (null !== T)
    a.finishedWork = null;
  else {
    c2 = a.current.alternate;
    null === c2 ? x$1("281") : void 0;
    Lh = null;
    if (Nh) {
      e2 = a.latestPendingTime;
      f2 = a.latestSuspendedTime;
      g2 = a.latestPingedTime;
      if (0 !== e2 && e2 < d2 || 0 !== f2 && f2 < d2 || 0 !== g2 && g2 < d2) {
        ff(a, d2);
        fi(a, c2, d2, a.expirationTime, -1);
        return;
      }
      if (!a.didError && b2) {
        a.didError = true;
        d2 = a.nextExpirationTimeToWorkOn = d2;
        b2 = a.expirationTime = 1073741823;
        fi(a, c2, d2, b2, -1);
        return;
      }
    }
    b2 && -1 !== Mh ? (ff(a, d2), b2 = 10 * (1073741822 - gf(a, d2)), b2 < Mh && (Mh = b2), b2 = 10 * (1073741822 - lf()), b2 = Mh - b2, fi(a, c2, d2, a.expirationTime, 0 > b2 ? 0 : b2)) : (a.pendingCommitExpirationTime = d2, a.finishedWork = c2);
  }
}
function sh(a, b2) {
  for (var c2 = a.return; null !== c2; ) {
    switch (c2.tag) {
      case 1:
        var d2 = c2.stateNode;
        if ("function" === typeof c2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Fh || !Fh.has(d2))) {
          a = jh(b2, a);
          a = Eh(c2, a, 1073741823);
          pf(c2, a);
          qf(c2, 1073741823);
          return;
        }
        break;
      case 3:
        a = jh(b2, a);
        a = Ch(c2, a, 1073741823);
        pf(c2, a);
        qf(c2, 1073741823);
        return;
    }
    c2 = c2.return;
  }
  3 === a.tag && (c2 = jh(b2, a), c2 = Ch(a, c2, 1073741823), pf(a, c2), qf(a, 1073741823));
}
function mf(a, b2) {
  var c2 = r$2.unstable_getCurrentPriorityLevel(), d2 = void 0;
  if (0 === (b2.mode & 1))
    d2 = 1073741823;
  else if (Kh && !Oh)
    d2 = U;
  else {
    switch (c2) {
      case r$2.unstable_ImmediatePriority:
        d2 = 1073741823;
        break;
      case r$2.unstable_UserBlockingPriority:
        d2 = 1073741822 - 10 * (((1073741822 - a + 15) / 10 | 0) + 1);
        break;
      case r$2.unstable_NormalPriority:
        d2 = 1073741822 - 25 * (((1073741822 - a + 500) / 25 | 0) + 1);
        break;
      case r$2.unstable_LowPriority:
      case r$2.unstable_IdlePriority:
        d2 = 1;
        break;
      default:
        x$1("313");
    }
    null !== Lh && d2 === U && --d2;
  }
  c2 === r$2.unstable_UserBlockingPriority && (0 === gi || d2 < gi) && (gi = d2);
  return d2;
}
function ei(a, b2, c2) {
  var d2 = a.pingCache;
  null !== d2 && d2.delete(b2);
  if (null !== Lh && U === c2)
    Lh = null;
  else if (b2 = a.earliestSuspendedTime, d2 = a.latestSuspendedTime, 0 !== b2 && c2 <= b2 && c2 >= d2) {
    a.didError = false;
    b2 = a.latestPingedTime;
    if (0 === b2 || b2 > c2)
      a.latestPingedTime = c2;
    df(c2, a);
    c2 = a.expirationTime;
    0 !== c2 && Xh(a, c2);
  }
}
function Ah(a, b2) {
  var c2 = a.stateNode;
  null !== c2 && c2.delete(b2);
  b2 = lf();
  b2 = mf(b2, a);
  a = hi(a, b2);
  null !== a && (cf(a, b2), b2 = a.expirationTime, 0 !== b2 && Xh(a, b2));
}
function hi(a, b2) {
  a.expirationTime < b2 && (a.expirationTime = b2);
  var c2 = a.alternate;
  null !== c2 && c2.expirationTime < b2 && (c2.expirationTime = b2);
  var d2 = a.return, e2 = null;
  if (null === d2 && 3 === a.tag)
    e2 = a.stateNode;
  else
    for (; null !== d2; ) {
      c2 = d2.alternate;
      d2.childExpirationTime < b2 && (d2.childExpirationTime = b2);
      null !== c2 && c2.childExpirationTime < b2 && (c2.childExpirationTime = b2);
      if (null === d2.return && 3 === d2.tag) {
        e2 = d2.stateNode;
        break;
      }
      d2 = d2.return;
    }
  return e2;
}
function qf(a, b2) {
  a = hi(a, b2);
  null !== a && (!Kh && 0 !== U && b2 > U && Sh(), cf(a, b2), Kh && !Oh && Lh === a || Xh(a, a.expirationTime), ii > ji && (ii = 0, x$1("185")));
}
function ki(a, b2, c2, d2, e2) {
  return r$2.unstable_runWithPriority(r$2.unstable_ImmediatePriority, function() {
    return a(b2, c2, d2, e2);
  });
}
var li = null, Y = null, mi = 0, ni = void 0, W = false, oi = null, Z = 0, gi = 0, pi = false, qi = null, X = false, ri = false, si = null, ti = r$2.unstable_now(), ui = 1073741822 - (ti / 10 | 0), vi = ui, ji = 50, ii = 0, wi = null;
function xi() {
  ui = 1073741822 - ((r$2.unstable_now() - ti) / 10 | 0);
}
function yi(a, b2) {
  if (0 !== mi) {
    if (b2 < mi)
      return;
    null !== ni && r$2.unstable_cancelCallback(ni);
  }
  mi = b2;
  a = r$2.unstable_now() - ti;
  ni = r$2.unstable_scheduleCallback(zi, { timeout: 10 * (1073741822 - b2) - a });
}
function fi(a, b2, c2, d2, e2) {
  a.expirationTime = d2;
  0 !== e2 || di() ? 0 < e2 && (a.timeoutHandle = ye(Ai.bind(null, a, b2, c2), e2)) : (a.pendingCommitExpirationTime = c2, a.finishedWork = b2);
}
function Ai(a, b2, c2) {
  a.pendingCommitExpirationTime = c2;
  a.finishedWork = b2;
  xi();
  vi = ui;
  Bi(a, c2);
}
function $h(a, b2) {
  a.expirationTime = b2;
  a.finishedWork = null;
}
function lf() {
  if (W)
    return vi;
  Ci();
  if (0 === Z || 1 === Z)
    xi(), vi = ui;
  return vi;
}
function Xh(a, b2) {
  null === a.nextScheduledRoot ? (a.expirationTime = b2, null === Y ? (li = Y = a, a.nextScheduledRoot = a) : (Y = Y.nextScheduledRoot = a, Y.nextScheduledRoot = li)) : b2 > a.expirationTime && (a.expirationTime = b2);
  W || (X ? ri && (oi = a, Z = 1073741823, Di(a, 1073741823, false)) : 1073741823 === b2 ? Yh(1073741823, false) : yi(a, b2));
}
function Ci() {
  var a = 0, b2 = null;
  if (null !== Y)
    for (var c2 = Y, d2 = li; null !== d2; ) {
      var e2 = d2.expirationTime;
      if (0 === e2) {
        null === c2 || null === Y ? x$1("244") : void 0;
        if (d2 === d2.nextScheduledRoot) {
          li = Y = d2.nextScheduledRoot = null;
          break;
        } else if (d2 === li)
          li = e2 = d2.nextScheduledRoot, Y.nextScheduledRoot = e2, d2.nextScheduledRoot = null;
        else if (d2 === Y) {
          Y = c2;
          Y.nextScheduledRoot = li;
          d2.nextScheduledRoot = null;
          break;
        } else
          c2.nextScheduledRoot = d2.nextScheduledRoot, d2.nextScheduledRoot = null;
        d2 = c2.nextScheduledRoot;
      } else {
        e2 > a && (a = e2, b2 = d2);
        if (d2 === Y)
          break;
        if (1073741823 === a)
          break;
        c2 = d2;
        d2 = d2.nextScheduledRoot;
      }
    }
  oi = b2;
  Z = a;
}
var Ei = false;
function di() {
  return Ei ? true : r$2.unstable_shouldYield() ? Ei = true : false;
}
function zi() {
  try {
    if (!di() && null !== li) {
      xi();
      var a = li;
      do {
        var b2 = a.expirationTime;
        0 !== b2 && ui <= b2 && (a.nextExpirationTimeToWorkOn = ui);
        a = a.nextScheduledRoot;
      } while (a !== li);
    }
    Yh(0, true);
  } finally {
    Ei = false;
  }
}
function Yh(a, b2) {
  Ci();
  if (b2)
    for (xi(), vi = ui; null !== oi && 0 !== Z && a <= Z && !(Ei && ui > Z); )
      Di(oi, Z, ui > Z), Ci(), xi(), vi = ui;
  else
    for (; null !== oi && 0 !== Z && a <= Z; )
      Di(oi, Z, false), Ci();
  b2 && (mi = 0, ni = null);
  0 !== Z && yi(oi, Z);
  ii = 0;
  wi = null;
  if (null !== si)
    for (a = si, si = null, b2 = 0; b2 < a.length; b2++) {
      var c2 = a[b2];
      try {
        c2._onComplete();
      } catch (d2) {
        pi || (pi = true, qi = d2);
      }
    }
  if (pi)
    throw a = qi, qi = null, pi = false, a;
}
function Bi(a, b2) {
  W ? x$1("253") : void 0;
  oi = a;
  Z = b2;
  Di(a, b2, false);
  Yh(1073741823, false);
}
function Di(a, b2, c2) {
  W ? x$1("245") : void 0;
  W = true;
  if (c2) {
    var d2 = a.finishedWork;
    null !== d2 ? Fi(a, d2, b2) : (a.finishedWork = null, d2 = a.timeoutHandle, -1 !== d2 && (a.timeoutHandle = -1, ze(d2)), ci(a, c2), d2 = a.finishedWork, null !== d2 && (di() ? a.finishedWork = d2 : Fi(a, d2, b2)));
  } else
    d2 = a.finishedWork, null !== d2 ? Fi(a, d2, b2) : (a.finishedWork = null, d2 = a.timeoutHandle, -1 !== d2 && (a.timeoutHandle = -1, ze(d2)), ci(a, c2), d2 = a.finishedWork, null !== d2 && Fi(a, d2, b2));
  W = false;
}
function Fi(a, b2, c2) {
  var d2 = a.firstBatch;
  if (null !== d2 && d2._expirationTime >= c2 && (null === si ? si = [d2] : si.push(d2), d2._defer)) {
    a.finishedWork = b2;
    a.expirationTime = 0;
    return;
  }
  a.finishedWork = null;
  a === wi ? ii++ : (wi = a, ii = 0);
  r$2.unstable_runWithPriority(r$2.unstable_ImmediatePriority, function() {
    Zh(a, b2);
  });
}
function Dh(a) {
  null === oi ? x$1("246") : void 0;
  oi.expirationTime = 0;
  pi || (pi = true, qi = a);
}
function Gi(a, b2) {
  var c2 = X;
  X = true;
  try {
    return a(b2);
  } finally {
    (X = c2) || W || Yh(1073741823, false);
  }
}
function Hi(a, b2) {
  if (X && !ri) {
    ri = true;
    try {
      return a(b2);
    } finally {
      ri = false;
    }
  }
  return a(b2);
}
function Ii(a, b2, c2) {
  X || W || 0 === gi || (Yh(gi, false), gi = 0);
  var d2 = X;
  X = true;
  try {
    return r$2.unstable_runWithPriority(r$2.unstable_UserBlockingPriority, function() {
      return a(b2, c2);
    });
  } finally {
    (X = d2) || W || Yh(1073741823, false);
  }
}
function Ji(a, b2, c2, d2, e2) {
  var f2 = b2.current;
  a:
    if (c2) {
      c2 = c2._reactInternalFiber;
      b: {
        2 === ed(c2) && 1 === c2.tag ? void 0 : x$1("170");
        var g2 = c2;
        do {
          switch (g2.tag) {
            case 3:
              g2 = g2.stateNode.context;
              break b;
            case 1:
              if (J(g2.type)) {
                g2 = g2.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          g2 = g2.return;
        } while (null !== g2);
        x$1("171");
        g2 = void 0;
      }
      if (1 === c2.tag) {
        var h2 = c2.type;
        if (J(h2)) {
          c2 = Ne(c2, h2, g2);
          break a;
        }
      }
      c2 = g2;
    } else
      c2 = He;
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = e2;
  e2 = nf(d2);
  e2.payload = { element: a };
  b2 = void 0 === b2 ? null : b2;
  null !== b2 && (e2.callback = b2);
  of();
  pf(f2, e2);
  qf(f2, d2);
  return d2;
}
function Ki(a, b2, c2, d2) {
  var e2 = b2.current, f2 = lf();
  e2 = mf(f2, e2);
  return Ji(a, b2, c2, e2, d2);
}
function Li(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function Mi(a, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: Wb, key: null == d2 ? null : "" + d2, children: a, containerInfo: b2, implementation: c2 };
}
Ab = function(a, b2, c2) {
  switch (b2) {
    case "input":
      yc(a, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a && d2.form === a.form) {
            var e2 = Ka(d2);
            e2 ? void 0 : x$1("90");
            Sb(d2);
            yc(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      de(a, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && ae(a, !!c2.multiple, b2, false);
  }
};
function Ni(a) {
  var b2 = 1073741822 - 25 * (((1073741822 - lf() + 500) / 25 | 0) + 1);
  b2 >= Jh && (b2 = Jh - 1);
  this._expirationTime = Jh = b2;
  this._root = a;
  this._callbacks = this._next = null;
  this._hasChildren = this._didComplete = false;
  this._children = null;
  this._defer = true;
}
Ni.prototype.render = function(a) {
  this._defer ? void 0 : x$1("250");
  this._hasChildren = true;
  this._children = a;
  var b2 = this._root._internalRoot, c2 = this._expirationTime, d2 = new Oi();
  Ji(a, b2, null, c2, d2._onCommit);
  return d2;
};
Ni.prototype.then = function(a) {
  if (this._didComplete)
    a();
  else {
    var b2 = this._callbacks;
    null === b2 && (b2 = this._callbacks = []);
    b2.push(a);
  }
};
Ni.prototype.commit = function() {
  var a = this._root._internalRoot, b2 = a.firstBatch;
  this._defer && null !== b2 ? void 0 : x$1("251");
  if (this._hasChildren) {
    var c2 = this._expirationTime;
    if (b2 !== this) {
      this._hasChildren && (c2 = this._expirationTime = b2._expirationTime, this.render(this._children));
      for (var d2 = null, e2 = b2; e2 !== this; )
        d2 = e2, e2 = e2._next;
      null === d2 ? x$1("251") : void 0;
      d2._next = e2._next;
      this._next = b2;
      a.firstBatch = this;
    }
    this._defer = false;
    Bi(a, c2);
    b2 = this._next;
    this._next = null;
    b2 = a.firstBatch = b2;
    null !== b2 && b2._hasChildren && b2.render(b2._children);
  } else
    this._next = null, this._defer = false;
};
Ni.prototype._onComplete = function() {
  if (!this._didComplete) {
    this._didComplete = true;
    var a = this._callbacks;
    if (null !== a)
      for (var b2 = 0; b2 < a.length; b2++)
        (0, a[b2])();
  }
};
function Oi() {
  this._callbacks = null;
  this._didCommit = false;
  this._onCommit = this._onCommit.bind(this);
}
Oi.prototype.then = function(a) {
  if (this._didCommit)
    a();
  else {
    var b2 = this._callbacks;
    null === b2 && (b2 = this._callbacks = []);
    b2.push(a);
  }
};
Oi.prototype._onCommit = function() {
  if (!this._didCommit) {
    this._didCommit = true;
    var a = this._callbacks;
    if (null !== a)
      for (var b2 = 0; b2 < a.length; b2++) {
        var c2 = a[b2];
        "function" !== typeof c2 ? x$1("191", c2) : void 0;
        c2();
      }
  }
};
function Pi(a, b2, c2) {
  b2 = K(3, null, null, b2 ? 3 : 0);
  a = { current: b2, containerInfo: a, pendingChildren: null, pingCache: null, earliestPendingTime: 0, latestPendingTime: 0, earliestSuspendedTime: 0, latestSuspendedTime: 0, latestPingedTime: 0, didError: false, pendingCommitExpirationTime: 0, finishedWork: null, timeoutHandle: -1, context: null, pendingContext: null, hydrate: c2, nextExpirationTimeToWorkOn: 0, expirationTime: 0, firstBatch: null, nextScheduledRoot: null };
  this._internalRoot = b2.stateNode = a;
}
Pi.prototype.render = function(a, b2) {
  var c2 = this._internalRoot, d2 = new Oi();
  b2 = void 0 === b2 ? null : b2;
  null !== b2 && d2.then(b2);
  Ki(a, c2, null, d2._onCommit);
  return d2;
};
Pi.prototype.unmount = function(a) {
  var b2 = this._internalRoot, c2 = new Oi();
  a = void 0 === a ? null : a;
  null !== a && c2.then(a);
  Ki(null, b2, null, c2._onCommit);
  return c2;
};
Pi.prototype.legacy_renderSubtreeIntoContainer = function(a, b2, c2) {
  var d2 = this._internalRoot, e2 = new Oi();
  c2 = void 0 === c2 ? null : c2;
  null !== c2 && e2.then(c2);
  Ki(b2, d2, a, e2._onCommit);
  return e2;
};
Pi.prototype.createBatch = function() {
  var a = new Ni(this), b2 = a._expirationTime, c2 = this._internalRoot, d2 = c2.firstBatch;
  if (null === d2)
    c2.firstBatch = a, a._next = null;
  else {
    for (c2 = null; null !== d2 && d2._expirationTime >= b2; )
      c2 = d2, d2 = d2._next;
    a._next = d2;
    null !== c2 && (c2._next = a);
  }
  return a;
};
function Qi(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
Gb = Gi;
Hb = Ii;
Ib = function() {
  W || 0 === gi || (Yh(gi, false), gi = 0);
};
function Ri(a, b2) {
  b2 || (b2 = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b2 = !(!b2 || 1 !== b2.nodeType || !b2.hasAttribute("data-reactroot")));
  if (!b2)
    for (var c2; c2 = a.lastChild; )
      a.removeChild(c2);
  return new Pi(a, false, b2);
}
function Si(a, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    if ("function" === typeof e2) {
      var g2 = e2;
      e2 = function() {
        var a2 = Li(f2._internalRoot);
        g2.call(a2);
      };
    }
    null != a ? f2.legacy_renderSubtreeIntoContainer(a, b2, e2) : f2.render(b2, e2);
  } else {
    f2 = c2._reactRootContainer = Ri(c2, d2);
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = Li(f2._internalRoot);
        h2.call(a2);
      };
    }
    Hi(function() {
      null != a ? f2.legacy_renderSubtreeIntoContainer(a, b2, e2) : f2.render(b2, e2);
    });
  }
  return Li(f2._internalRoot);
}
function Ti(a, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  Qi(b2) ? void 0 : x$1("200");
  return Mi(a, b2, null, c2);
}
var Vi = { createPortal: Ti, findDOMNode: function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternalFiber;
  void 0 === b2 && ("function" === typeof a.render ? x$1("188") : x$1("268", Object.keys(a)));
  a = hd(b2);
  a = null === a ? null : a.stateNode;
  return a;
}, hydrate: function(a, b2, c2) {
  Qi(b2) ? void 0 : x$1("200");
  return Si(null, a, b2, true, c2);
}, render: function(a, b2, c2) {
  Qi(b2) ? void 0 : x$1("200");
  return Si(null, a, b2, false, c2);
}, unstable_renderSubtreeIntoContainer: function(a, b2, c2, d2) {
  Qi(c2) ? void 0 : x$1("200");
  null == a || void 0 === a._reactInternalFiber ? x$1("38") : void 0;
  return Si(a, b2, c2, false, d2);
}, unmountComponentAtNode: function(a) {
  Qi(a) ? void 0 : x$1("40");
  return a._reactRootContainer ? (Hi(function() {
    Si(null, null, a, false, function() {
      a._reactRootContainer = null;
    });
  }), true) : false;
}, unstable_createPortal: function() {
  return Ti.apply(void 0, arguments);
}, unstable_batchedUpdates: Gi, unstable_interactiveUpdates: Ii, flushSync: function(a, b2) {
  W ? x$1("187") : void 0;
  var c2 = X;
  X = true;
  try {
    return ki(a, b2);
  } finally {
    X = c2, Yh(1073741823, false);
  }
}, unstable_createRoot: Ui, unstable_flushControlled: function(a) {
  var b2 = X;
  X = true;
  try {
    ki(a);
  } finally {
    (X = b2) || W || Yh(1073741823, false);
  }
}, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { Events: [Ia, Ja, Ka, Ba.injectEventPluginsByName, pa, Qa, function(a) {
  ya(a, Pa);
}, Eb, Fb, Dd, Da] } };
function Ui(a, b2) {
  Qi(a) ? void 0 : x$1("299", "unstable_createRoot");
  return new Pi(a, true, null != b2 && true === b2.hydrate);
}
(function(a) {
  var b2 = a.findFiberByHostInstance;
  return Te(n$2({}, a, { overrideProps: null, currentDispatcherRef: Tb.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = hd(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: function(a2) {
    return b2 ? b2(a2) : null;
  } }));
})({ findFiberByHostInstance: Ha, bundleType: 0, version: "16.8.6", rendererPackageName: "react-dom" });
var Wi = { default: Vi }, Xi = Wi && Vi || Wi;
var reactDom_production_min = Xi.default || Xi;
(function(module) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module.exports = reactDom_production_min;
  }
})(reactDom);
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDom.exports);
const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactDOM
}, [reactDom.exports]);
const index$8 = "";
const queryRE = /\?.*$/;
const hashRE = /#.*$/;
const cleanUrl = (url2) => url2.replace(hashRE, "").replace(queryRE, "");
const isJsx = (lang) => /^[j|t]sx$/.test(lang);
function hasReact(str) {
  return /ReactDOM\.render/.test(str);
}
function isTypes(str) {
  return /renderType\$\(.+\)/.test(str);
}
const isCSSLang = (lang) => /^(css|less|sass|scss|styl|stylus|postcss)$/.test(lang);
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$3(subClass, superClass);
}
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function isAbsolute(pathname) {
  return pathname.charAt(0) === "/";
}
function spliceOne(list2, index2) {
  for (var i = index2, k2 = i + 1, n2 = list2.length; k2 < n2; i += 1, k2 += 1) {
    list2[i] = list2[k2];
  }
  list2.pop();
}
function resolvePathname(to, from) {
  if (from === void 0)
    from = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from && from.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length)
    return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];
    if (part === ".") {
      spliceOne(fromParts, i);
    } else if (part === "..") {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }
  if (!mustEndAbs)
    for (; up--; up)
      fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/")
    result += "/";
  return result;
}
function valueOf(obj) {
  return obj.valueOf ? obj.valueOf() : Object.prototype.valueOf.call(obj);
}
function valueEqual(a, b2) {
  if (a === b2)
    return true;
  if (a == null || b2 == null)
    return false;
  if (Array.isArray(a)) {
    return Array.isArray(b2) && a.length === b2.length && a.every(function(item, index2) {
      return valueEqual(item, b2[index2]);
    });
  }
  if (typeof a === "object" || typeof b2 === "object") {
    var aValue = valueOf(a);
    var bValue = valueOf(b2);
    if (aValue !== a || bValue !== b2)
      return valueEqual(aValue, bValue);
    return Object.keys(Object.assign({}, a, b2)).every(function(key2) {
      return valueEqual(a[key2], b2[key2]);
    });
  }
  return false;
}
var isProduction = true;
var prefix = "Invariant failed";
function invariant(condition, message2) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message2 === "function" ? message2() : message2;
  var value2 = provided ? prefix + ": " + provided : prefix;
  throw new Error(value2);
}
function addLeadingSlash$1(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function stripLeadingSlash(path) {
  return path.charAt(0) === "/" ? path.substr(1) : path;
}
function hasBasename(path, prefix2) {
  return path.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path.charAt(prefix2.length)) !== -1;
}
function stripBasename$1(path, prefix2) {
  return hasBasename(path, prefix2) ? path.substr(prefix2.length) : path;
}
function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === "/" ? path.slice(0, -1) : path;
}
function parsePath(path) {
  var pathname = path || "/";
  var search2 = "";
  var hash = "";
  var hashIndex = pathname.indexOf("#");
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }
  var searchIndex = pathname.indexOf("?");
  if (searchIndex !== -1) {
    search2 = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }
  return {
    pathname,
    search: search2 === "?" ? "" : search2,
    hash: hash === "#" ? "" : hash
  };
}
function createPath(location2) {
  var pathname = location2.pathname, search2 = location2.search, hash = location2.hash;
  var path = pathname || "/";
  if (search2 && search2 !== "?")
    path += search2.charAt(0) === "?" ? search2 : "?" + search2;
  if (hash && hash !== "#")
    path += hash.charAt(0) === "#" ? hash : "#" + hash;
  return path;
}
function createLocation(path, state, key2, currentLocation) {
  var location2;
  if (typeof path === "string") {
    location2 = parsePath(path);
    location2.state = state;
  } else {
    location2 = _extends$2({}, path);
    if (location2.pathname === void 0)
      location2.pathname = "";
    if (location2.search) {
      if (location2.search.charAt(0) !== "?")
        location2.search = "?" + location2.search;
    } else {
      location2.search = "";
    }
    if (location2.hash) {
      if (location2.hash.charAt(0) !== "#")
        location2.hash = "#" + location2.hash;
    } else {
      location2.hash = "";
    }
    if (state !== void 0 && location2.state === void 0)
      location2.state = state;
  }
  try {
    location2.pathname = decodeURI(location2.pathname);
  } catch (e2) {
    if (e2 instanceof URIError) {
      throw new URIError('Pathname "' + location2.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e2;
    }
  }
  if (key2)
    location2.key = key2;
  if (currentLocation) {
    if (!location2.pathname) {
      location2.pathname = currentLocation.pathname;
    } else if (location2.pathname.charAt(0) !== "/") {
      location2.pathname = resolvePathname(location2.pathname, currentLocation.pathname);
    }
  } else {
    if (!location2.pathname) {
      location2.pathname = "/";
    }
  }
  return location2;
}
function locationsAreEqual(a, b2) {
  return a.pathname === b2.pathname && a.search === b2.search && a.hash === b2.hash && a.key === b2.key && valueEqual(a.state, b2.state);
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt)
        prompt = null;
    };
  }
  function confirmTransitionTo(location2, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location2, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners2 = [];
  function appendListener(fn) {
    var isActive2 = true;
    function listener() {
      if (isActive2)
        fn.apply(void 0, arguments);
    }
    listeners2.push(listener);
    return function() {
      isActive2 = false;
      listeners2 = listeners2.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners2.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message2, callback) {
  callback(window.confirm(message2));
}
function supportsHistory() {
  var ua2 = window.navigator.userAgent;
  if ((ua2.indexOf("Android 2.") !== -1 || ua2.indexOf("Android 4.0") !== -1) && ua2.indexOf("Mobile Safari") !== -1 && ua2.indexOf("Chrome") === -1 && ua2.indexOf("Windows Phone") === -1)
    return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e2) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant(false) : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename2 = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key2 = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname = _window$location.pathname, search2 = _window$location.search, hash = _window$location.hash;
    var path = pathname + search2 + hash;
    if (basename2)
      path = stripBasename$1(path, basename2);
    return createLocation(path, state, key2);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event))
      return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location2) {
    return basename2 + createPath(location2);
  }
  function push(path, state) {
    var action = "PUSH";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location2);
      var key2 = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key: key2,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location2.key);
          allKeys = nextKeys;
          setState({
            action,
            location: location2
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var href = createHref(location2);
      var key2 = location2.key, state2 = location2.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key: key2,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1)
            allKeys[prevIndex] = location2.key;
          setState({
            action,
            location: location2
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go(n2) {
    globalHistory.go(n2);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener)
        window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === "!" ? path : "!/" + stripLeadingSlash(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === "!" ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$1
  },
  slash: {
    encodePath: addLeadingSlash$1,
    decodePath: addLeadingSlash$1
  }
};
function stripHash(url2) {
  var hashIndex = url2.indexOf("#");
  return hashIndex === -1 ? url2 : url2.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path) {
  window.location.hash = path;
}
function replaceHashPath(path) {
  window.location.replace(stripHash(window.location.href) + "#" + path);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant(false) : void 0;
  var globalHistory = window.history;
  supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename2 = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path2 = decodePath2(getHashPath());
    if (basename2)
      path2 = stripBasename$1(path2, basename2);
    return createLocation(path2);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a, b2) {
    return a.pathname === b2.pathname && a.search === b2.search && a.hash === b2.hash;
  }
  function handleHashChange() {
    var path2 = getHashPath();
    var encodedPath2 = encodePath2(path2);
    if (path2 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location2 = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location2))
        return;
      if (ignorePath === createPath(location2))
        return;
      ignorePath = null;
      handlePop(location2);
    }
  }
  function handlePop(location2) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
        if (ok2) {
          setState({
            action,
            location: location2
          });
        } else {
          revertPop(location2);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1)
      toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1)
      fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path = getHashPath();
  var encodedPath = encodePath2(path);
  if (path !== encodedPath)
    replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location2) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename2 + createPath(location2));
  }
  function push(path2, state) {
    var action = "PUSH";
    var location2 = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename2 + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action,
          location: location2
        });
      } else {
        setState();
      }
    });
  }
  function replace(path2, state) {
    var action = "REPLACE";
    var location2 = createLocation(path2, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var path3 = createPath(location2);
      var encodedPath2 = encodePath2(basename2 + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1)
        allPaths[prevIndex] = path3;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n2) {
    globalHistory.go(n2);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp(n2, lowerBound, upperBound) {
  return Math.min(Math.max(n2, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index2 = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path, state) {
    var action = "PUSH";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location2);
      } else {
        nextEntries.push(location2);
      }
      setState({
        action,
        location: location2,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace(path, state) {
    var action = "REPLACE";
    var location2 = createLocation(path, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (!ok2)
        return;
      history.entries[history.index] = location2;
      setState({
        action,
        location: location2
      });
    });
  }
  function go(n2) {
    var nextIndex = clamp(history.index + n2, 0, history.entries.length - 1);
    var action = "POP";
    var location2 = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location2, action, getUserConfirmation, function(ok2) {
      if (ok2) {
        setState({
          action,
          location: location2,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n2) {
    var nextIndex = history.index + n2;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index2],
    index: index2,
    entries,
    createHref,
    push,
    replace,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key2 = "__global_unique_id__";
  return commonjsGlobal[key2] = (commonjsGlobal[key2] || 0) + 1;
}
function objectIs(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function createEventEmitter(value2) {
  var handlers = [];
  return {
    on: function on(handler2) {
      handlers.push(handler2);
    },
    off: function off(handler2) {
      handlers = handlers.filter(function(h2) {
        return h2 !== handler2;
      });
    },
    get: function get2() {
      return value2;
    },
    set: function set2(newValue, changedBits) {
      value2 = newValue;
      handlers.forEach(function(handler2) {
        return handler2(value2, changedBits);
      });
    }
  };
}
function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider = /* @__PURE__ */ function(_Component) {
    _inheritsLoose$1(Provider2, _Component);
    function Provider2() {
      var _this;
      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider2.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render2() {
      return this.props.children;
    };
    return Provider2;
  }(react.exports.Component);
  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = propTypes.exports.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_Component2) {
    _inheritsLoose$1(Consumer2, _Component2);
    function Consumer2() {
      var _this2;
      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render2() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(react.exports.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = propTypes.exports.object, _Consumer$contextType);
  return {
    Provider,
    Consumer
  };
}
var index$7 = React$a.createContext || createReactContext;
var pathToRegexp$1 = { exports: {} };
var isarray$1 = Array.isArray || function(arr) {
  return Object.prototype.toString.call(arr) == "[object Array]";
};
var isarray = isarray$1;
pathToRegexp$1.exports = pathToRegexp;
pathToRegexp$1.exports.parse = parse$8;
pathToRegexp$1.exports.compile = compile;
pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;
var PATH_REGEXP = new RegExp([
  "(\\\\.)",
  "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
].join("|"), "g");
function parse$8(str, options) {
  var tokens = [];
  var key2 = 0;
  var index2 = 0;
  var path = "";
  var defaultDelimiter = options && options.delimiter || "/";
  var res;
  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m2 = res[0];
    var escaped = res[1];
    var offset3 = res.index;
    path += str.slice(index2, offset3);
    index2 = offset3 + m2.length;
    if (escaped) {
      path += escaped[1];
      continue;
    }
    var next = str[index2];
    var prefix2 = res[2];
    var name2 = res[3];
    var capture2 = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];
    if (path) {
      tokens.push(path);
      path = "";
    }
    var partial = prefix2 != null && next != null && next !== prefix2;
    var repeat = modifier === "+" || modifier === "*";
    var optional = modifier === "?" || modifier === "*";
    var delimiter = res[2] || defaultDelimiter;
    var pattern4 = capture2 || group;
    tokens.push({
      name: name2 || key2++,
      prefix: prefix2 || "",
      delimiter,
      optional,
      repeat,
      partial,
      asterisk: !!asterisk,
      pattern: pattern4 ? escapeGroup(pattern4) : asterisk ? ".*" : "[^" + escapeString(delimiter) + "]+?"
    });
  }
  if (index2 < str.length) {
    path += str.substr(index2);
  }
  if (path) {
    tokens.push(path);
  }
  return tokens;
}
function compile(str, options) {
  return tokensToFunction(parse$8(str, options), options);
}
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function tokensToFunction(tokens, options) {
  var matches = new Array(tokens.length);
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === "object") {
      matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags(options));
    }
  }
  return function(obj, opts) {
    var path = "";
    var data2 = obj || {};
    var options2 = opts || {};
    var encode2 = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value2 = data2[token.name];
      var segment;
      if (value2 == null) {
        if (token.optional) {
          if (token.partial) {
            path += token.prefix;
          }
          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }
      if (isarray(value2)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value2) + "`");
        }
        if (value2.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }
        for (var j = 0; j < value2.length; j++) {
          segment = encode2(value2[j]);
          if (!matches[i2].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + "`");
          }
          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }
        continue;
      }
      segment = token.asterisk ? encodeAsterisk(value2) : encode2(value2);
      if (!matches[i2].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }
      path += token.prefix + segment;
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
}
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, "\\$1");
}
function attachKeys(re2, keys2) {
  re2.keys = keys2;
  return re2;
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys2) {
  var groups = path.source.match(/\((?!\?)/g);
  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys2.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }
  return attachKeys(path, keys2);
}
function arrayToRegexp(path, keys2, options) {
  var parts = [];
  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys2, options).source);
  }
  var regexp4 = new RegExp("(?:" + parts.join("|") + ")", flags(options));
  return attachKeys(regexp4, keys2);
}
function stringToRegexp(path, keys2, options) {
  return tokensToRegExp(parse$8(path, options), keys2, options);
}
function tokensToRegExp(tokens, keys2, options) {
  if (!isarray(keys2)) {
    options = keys2 || options;
    keys2 = [];
  }
  options = options || {};
  var strict = options.strict;
  var end = options.end !== false;
  var route = "";
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (typeof token === "string") {
      route += escapeString(token);
    } else {
      var prefix2 = escapeString(token.prefix);
      var capture2 = "(?:" + token.pattern + ")";
      keys2.push(token);
      if (token.repeat) {
        capture2 += "(?:" + prefix2 + capture2 + ")*";
      }
      if (token.optional) {
        if (!token.partial) {
          capture2 = "(?:" + prefix2 + "(" + capture2 + "))?";
        } else {
          capture2 = prefix2 + "(" + capture2 + ")?";
        }
      } else {
        capture2 = prefix2 + "(" + capture2 + ")";
      }
      route += capture2;
    }
  }
  var delimiter = escapeString(options.delimiter || "/");
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + "(?:" + delimiter + "(?=$))?";
  }
  if (end) {
    route += "$";
  } else {
    route += strict && endsWithDelimiter ? "" : "(?=" + delimiter + "|$)";
  }
  return attachKeys(new RegExp("^" + route, flags(options)), keys2);
}
function pathToRegexp(path, keys2, options) {
  if (!isarray(keys2)) {
    options = keys2 || options;
    keys2 = [];
  }
  options = options || {};
  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys2);
  }
  if (isarray(path)) {
    return arrayToRegexp(path, keys2, options);
  }
  return stringToRegexp(path, keys2, options);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e$1 = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h$1 = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b ? Symbol.for("react.forward_ref") : 60112, p$1 = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r$1 = b ? Symbol.for("react.memo") : 60115, t$1 = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a) {
  if ("object" === typeof a && null !== a) {
    var u2 = a.$$typeof;
    switch (u2) {
      case c:
        switch (a = a.type, a) {
          case l:
          case m:
          case e$1:
          case g:
          case f:
          case p$1:
            return a;
          default:
            switch (a = a && a.$$typeof, a) {
              case k:
              case n$1:
              case t$1:
              case r$1:
              case h$1:
                return a;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
function A(a) {
  return z(a) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h$1;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n$1;
reactIs_production_min.Fragment = e$1;
reactIs_production_min.Lazy = t$1;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p$1;
reactIs_production_min.isAsyncMode = function(a) {
  return A(a) || z(a) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a) {
  return z(a) === k;
};
reactIs_production_min.isContextProvider = function(a) {
  return z(a) === h$1;
};
reactIs_production_min.isElement = function(a) {
  return "object" === typeof a && null !== a && a.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a) {
  return z(a) === n$1;
};
reactIs_production_min.isFragment = function(a) {
  return z(a) === e$1;
};
reactIs_production_min.isLazy = function(a) {
  return z(a) === t$1;
};
reactIs_production_min.isMemo = function(a) {
  return z(a) === r$1;
};
reactIs_production_min.isPortal = function(a) {
  return z(a) === d;
};
reactIs_production_min.isProfiler = function(a) {
  return z(a) === g;
};
reactIs_production_min.isStrictMode = function(a) {
  return z(a) === f;
};
reactIs_production_min.isSuspense = function(a) {
  return z(a) === p$1;
};
reactIs_production_min.isValidElementType = function(a) {
  return "string" === typeof a || "function" === typeof a || a === e$1 || a === m || a === g || a === f || a === p$1 || a === q || "object" === typeof a && null !== a && (a.$$typeof === t$1 || a.$$typeof === r$1 || a.$$typeof === h$1 || a.$$typeof === k || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
};
reactIs_production_min.typeOf = z;
(function(module) {
  {
    module.exports = reactIs_production_min;
  }
})(reactIs$1);
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var reactIs = reactIs$1.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var createNamedContext = function createNamedContext2(name2) {
  var context2 = index$7();
  context2.displayName = name2;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var context = /* @__PURE__ */ createNamedContext("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location2) {
        _this._pendingLocation = location2;
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location2) {
        if (_this2._isMounted) {
          _this2.setState({
            location: location2
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render2() {
    return /* @__PURE__ */ React$a.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ React$a.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(React$a.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(MemoryRouter, _React$Component);
  function MemoryRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter.prototype;
  _proto.render = function render2() {
    return /* @__PURE__ */ React$a.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter;
})(React$a.Component);
var Lifecycle = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount)
      this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate)
      this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount)
      this.props.onUnmount.call(this, this);
  };
  _proto.render = function render2() {
    return null;
  };
  return Lifecycle2;
}(React$a.Component);
var cache$1 = {};
var cacheLimit = 1e4;
var cacheCount = 0;
function compilePath(path) {
  if (cache$1[path])
    return cache$1[path];
  var generator = pathToRegexp$1.exports.compile(path);
  if (cacheCount < cacheLimit) {
    cache$1[path] = generator;
    cacheCount++;
  }
  return generator;
}
function generatePath(path, params) {
  if (path === void 0) {
    path = "/";
  }
  if (params === void 0) {
    params = {};
  }
  return path === "/" ? path : compilePath(path)(params, {
    pretty: true
  });
}
function Redirect(_ref) {
  var computedMatch = _ref.computedMatch, to = _ref.to, _ref$push = _ref.push, push = _ref$push === void 0 ? false : _ref$push;
  return /* @__PURE__ */ React$a.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var history = context2.history, staticContext = context2.staticContext;
    var method4 = push ? history.push : history.replace;
    var location2 = createLocation(computedMatch ? typeof to === "string" ? generatePath(to, computedMatch.params) : _extends$2({}, to, {
      pathname: generatePath(to.pathname, computedMatch.params)
    }) : to);
    if (staticContext) {
      method4(location2);
      return null;
    }
    return /* @__PURE__ */ React$a.createElement(Lifecycle, {
      onMount: function onMount() {
        method4(location2);
      },
      onUpdate: function onUpdate(self2, prevProps) {
        var prevLocation = createLocation(prevProps.to);
        if (!locationsAreEqual(prevLocation, _extends$2({}, location2, {
          key: prevLocation.key
        }))) {
          method4(location2);
        }
      },
      to
    });
  });
}
var cache$1$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1$1[cacheKey] || (cache$1$1[cacheKey] = {});
  if (pathCache[path])
    return pathCache[path];
  var keys2 = [];
  var regexp4 = pathToRegexp$1.exports(path, keys2, options);
  var result = {
    regexp: regexp4,
    keys: keys2
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths = [].concat(path);
  return paths.reduce(function(matched, path2) {
    if (!path2 && path2 !== "")
      return null;
    if (matched)
      return matched;
    var _compilePath = compilePath$1(path2, {
      end: exact,
      strict,
      sensitive
    }), regexp4 = _compilePath.regexp, keys2 = _compilePath.keys;
    var match2 = regexp4.exec(pathname);
    if (!match2)
      return null;
    var url2 = match2[0], values = match2.slice(1);
    var isExact = pathname === url2;
    if (exact && !isExact)
      return null;
    return {
      path: path2,
      url: path2 === "/" && url2 === "" ? "/" : url2,
      isExact,
      params: keys2.reduce(function(memo, key2, index2) {
        memo[key2.name] = values[index2];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children) {
  return React$a.Children.count(children) === 0;
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render2() {
    var _this = this;
    return /* @__PURE__ */ React$a.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? invariant(false) : void 0;
      var location2 = _this.props.location || context$1.location;
      var match2 = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location2.pathname, _this.props) : context$1.match;
      var props = _extends$2({}, context$1, {
        location: location2,
        match: match2
      });
      var _this$props = _this.props, children = _this$props.children, component = _this$props.component, render3 = _this$props.render;
      if (Array.isArray(children) && isEmptyChildren(children)) {
        children = null;
      }
      return /* @__PURE__ */ React$a.createElement(context.Provider, {
        value: props
      }, props.match ? children ? typeof children === "function" ? children(props) : children : component ? /* @__PURE__ */ React$a.createElement(component, props) : render3 ? render3(props) : null : typeof children === "function" ? children(props) : null);
    });
  };
  return Route2;
}(React$a.Component);
function addLeadingSlash(path) {
  return path.charAt(0) === "/" ? path : "/" + path;
}
function addBasename(basename2, location2) {
  if (!basename2)
    return location2;
  return _extends$2({}, location2, {
    pathname: addLeadingSlash(basename2) + location2.pathname
  });
}
function stripBasename(basename2, location2) {
  if (!basename2)
    return location2;
  var base = addLeadingSlash(basename2);
  if (location2.pathname.indexOf(base) !== 0)
    return location2;
  return _extends$2({}, location2, {
    pathname: location2.pathname.substr(base.length)
  });
}
function createURL(location2) {
  return typeof location2 === "string" ? location2 : createPath(location2);
}
function staticHandler(methodName) {
  return function() {
    invariant(false);
  };
}
function noop$4() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(StaticRouter, _React$Component);
  function StaticRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location2) {
      return _this.navigateTo(location2, "PUSH");
    };
    _this.handleReplace = function(location2) {
      return _this.navigateTo(location2, "REPLACE");
    };
    _this.handleListen = function() {
      return noop$4;
    };
    _this.handleBlock = function() {
      return noop$4;
    };
    return _this;
  }
  var _proto = StaticRouter.prototype;
  _proto.navigateTo = function navigateTo(location2, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename2 = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename2, createLocation(location2));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render2() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename2 = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location2 = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose$2(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path) {
        return addLeadingSlash(basename2 + createURL(path));
      },
      action: "POP",
      location: stripBasename(basename2, createLocation(location2)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ React$a.createElement(Router, _extends$2({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter;
})(React$a.Component);
var Switch$3 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render2() {
    var _this = this;
    return /* @__PURE__ */ React$a.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant(false) : void 0;
      var location2 = _this.props.location || context2.location;
      var element, match2;
      React$a.Children.forEach(_this.props.children, function(child) {
        if (match2 == null && /* @__PURE__ */ React$a.isValidElement(child)) {
          element = child;
          var path = child.props.path || child.props.from;
          match2 = path ? matchPath(location2.pathname, _extends$2({}, child.props, {
            path
          })) : context2.match;
        }
      });
      return match2 ? /* @__PURE__ */ React$a.cloneElement(element, {
        location: location2,
        computedMatch: match2
      }) : null;
    });
  };
  return Switch2;
}(React$a.Component);
var useContext = React$a.useContext;
function useLocation() {
  return useContext(context).location;
}
function useRouteMatch(path) {
  var location2 = useLocation();
  var match2 = useContext(context).match;
  return path ? matchPath(location2.pathname, path) : match2;
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose$1(BrowserRouter, _React$Component);
  function BrowserRouter() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter.prototype;
  _proto.render = function render2() {
    return /* @__PURE__ */ React$a.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter;
})(React$a.Component);
var HashRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose$1(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render2() {
    return /* @__PURE__ */ React$a.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
}(React$a.Component);
var resolveToLocation = function resolveToLocation2(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};
var forwardRefShim = function forwardRefShim2(C2) {
  return C2;
};
var forwardRef = React$a.forwardRef;
if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var LinkAnchor = forwardRef(function(_ref, forwardedRef) {
  var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose$2(_ref, ["innerRef", "navigate", "onClick"]);
  var target = rest.target;
  var props = _extends$2({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick)
          _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }
      if (!event.defaultPrevented && event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
        event.preventDefault();
        navigate();
      }
    }
  });
  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  return /* @__PURE__ */ React$a.createElement("a", props);
});
var Link$2 = forwardRef(function(_ref2, forwardedRef) {
  var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose$2(_ref2, ["component", "replace", "to", "innerRef"]);
  return /* @__PURE__ */ React$a.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var history = context2.history;
    var location2 = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
    var href = location2 ? history.createHref(location2) : "";
    var props = _extends$2({}, rest, {
      href,
      navigate: function navigate() {
        var location3 = resolveToLocation(to, context2.location);
        var isDuplicateNavigation = createPath(context2.location) === createPath(normalizeToLocation(location3));
        var method4 = replace || isDuplicateNavigation ? history.replace : history.push;
        method4(location3);
      }
    });
    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return /* @__PURE__ */ React$a.createElement(component, props);
  });
});
var forwardRefShim$1 = function forwardRefShim3(C2) {
  return C2;
};
var forwardRef$1 = React$a.forwardRef;
if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}
function joinClassnames() {
  for (var _len = arguments.length, classnames2 = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames2[_key] = arguments[_key];
  }
  return classnames2.filter(function(i) {
    return i;
  }).join(" ");
}
forwardRef$1(function(_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose$2(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return /* @__PURE__ */ React$a.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant(false) : void 0;
    var currentLocation = locationProp || context2.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path = toLocation.pathname;
    var escapedPath = path && path.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match2 = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact,
      sensitive,
      strict
    }) : null;
    var isActive2 = !!(isActiveProp ? isActiveProp(match2, currentLocation) : match2);
    var className = typeof classNameProp === "function" ? classNameProp(isActive2) : classNameProp;
    var style2 = typeof styleProp === "function" ? styleProp(isActive2) : styleProp;
    if (isActive2) {
      className = joinClassnames(className, activeClassName);
      style2 = _extends$2({}, style2, activeStyle);
    }
    var props = _extends$2({
      "aria-current": isActive2 && ariaCurrent || null,
      className,
      style: style2,
      to: toLocation
    }, rest);
    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return /* @__PURE__ */ React$a.createElement(Link$2, props);
  });
});
function addRegistry(file, fn) {
  var _a;
  (_a = window.HotReloadRegister$) == null ? void 0 : _a.call(window, file, fn);
}
function useRoute() {
  const { url: route } = useRouteMatch();
  return { route };
}
class ModuleLoadError extends Error {
}
function useAsyncImport(path, cb2 = ({ default: Comp }) => Comp) {
  const [Module, setModule] = react.exports.useState();
  react.exports.useMemo(async () => {
    var _a, _b;
    try {
      const setNewModule = (newModule) => {
        const Comp = cb2(newModule);
        setModule(() => Comp);
      };
      const cUrl = cleanUrl(path);
      if (!window.RuntimeModuleMap$[cUrl]) {
        window.RuntimeModuleMap$[cUrl] = (cb22) => {
          cb22 && cb22(cUrl);
          return import(
            /* @vite-ignore */
            cUrl
          );
        };
      }
      const result = await ((_b = (_a = window.RuntimeModuleMap$)[cUrl]) == null ? void 0 : _b.call(_a, (filePath) => {
        addRegistry(filePath, setNewModule);
      }));
      setNewModule(result);
    } catch (e2) {
      console.error(`Load module ${path} error:`, e2);
      setModule({
        error: new ModuleLoadError([
          `Please make sure follow files exist in your project`,
          `-  ${path}`
        ].join("\n"))
      });
    }
  }, [path]);
  return Module;
}
function useRouteMap() {
  const flatRouteMap = (tree) => {
    const result = [];
    tree.forEach((child) => {
      if (Array.isArray(child.children)) {
        result.push(...flatRouteMap(child.children));
      } else {
        result.push(child);
      }
    });
    return result;
  };
  return useAsyncImport(`/route-map.json`, ({ default: items }) => ({
    ...items,
    flattenRoutes: flatRouteMap(items.tree)
  }));
}
function useComponentInfo() {
  return useAsyncImport(`/package.json`, ({ default: packageInfo }) => {
    var _a, _b;
    const packageName = packageInfo.name;
    const packageVersion = packageInfo.version;
    const registry = (((_a = packageInfo.publishConfig) == null ? void 0 : _a.registry) || "https://npmjs.com").replace("registry.", "");
    return {
      packageName,
      packageVersion,
      registry,
      npmLink: `${registry}/package/${packageName}/v/${packageVersion}`,
      logo: (_b = packageInfo.componentConfig) == null ? void 0 : _b.logo
    };
  });
}
function useMarkdown() {
  const { route } = useRoute();
  const readmeFile = route.replace(".html", ".md");
  const disposeArr = react.exports.useRef([]);
  react.exports.useEffect(() => () => {
    let fn;
    while (fn = disposeArr.current.pop()) {
      fn();
    }
  }, []);
  const results = useAsyncImport(readmeFile, ({ default: packageInfo }) => {
    return packageInfo;
  });
  if (results == null ? void 0 : results.error) {
    return results;
  }
  let moduleMap;
  if (results) {
    const styleModules = results.modules.filter(({ lang }) => isCSSLang(lang));
    moduleMap = results.modules.reduce((previousValue, currentValue) => {
      if (!isJsx(currentValue.lang)) {
        return previousValue;
      }
      const sourceKey = currentValue.sourcesContent.trim();
      return Object.assign(previousValue, {
        [sourceKey]: (...args) => {
          currentValue.load(...args);
          styleModules.forEach((mod) => {
            mod.load();
          });
        }
      });
    }, {});
  }
  if (!results) {
    return null;
  }
  let error;
  return {
    error,
    content: results.content,
    pathHash: results.pathHash,
    moduleMap
  };
}
var immutable = extend$2;
var hasOwnProperty$c = Object.prototype.hasOwnProperty;
function extend$2() {
  var target = {};
  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key2 in source) {
      if (hasOwnProperty$c.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
var bail_1 = bail$1;
function bail$1(err) {
  if (err) {
    throw err;
  }
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer$3 = function isBuffer(obj) {
  return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
};
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty$3 = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;
var isArray$7 = function isArray(arr) {
  if (typeof Array.isArray === "function") {
    return Array.isArray(arr);
  }
  return toStr.call(arr) === "[object Array]";
};
var isPlainObject = function isPlainObject2(obj) {
  if (!obj || toStr.call(obj) !== "[object Object]") {
    return false;
  }
  var hasOwnConstructor = hasOwn.call(obj, "constructor");
  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }
  var key2;
  for (key2 in obj) {
  }
  return typeof key2 === "undefined" || hasOwn.call(obj, key2);
};
var setProperty = function setProperty2(target, options) {
  if (defineProperty$3 && options.name === "__proto__") {
    defineProperty$3(target, options.name, {
      enumerable: true,
      configurable: true,
      value: options.newValue,
      writable: true
    });
  } else {
    target[options.name] = options.newValue;
  }
};
var getProperty = function getProperty2(obj, name2) {
  if (name2 === "__proto__") {
    if (!hasOwn.call(obj, name2)) {
      return void 0;
    } else if (gOPD) {
      return gOPD(obj, name2).value;
    }
  }
  return obj[name2];
};
var extend$1 = function extend() {
  var options, name2, src, copy2, copyIsArray, clone2;
  var target = arguments[0];
  var i = 1;
  var length = arguments.length;
  var deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[1] || {};
    i = 2;
  }
  if (target == null || typeof target !== "object" && typeof target !== "function") {
    target = {};
  }
  for (; i < length; ++i) {
    options = arguments[i];
    if (options != null) {
      for (name2 in options) {
        src = getProperty(target, name2);
        copy2 = getProperty(options, name2);
        if (target !== copy2) {
          if (deep && copy2 && (isPlainObject(copy2) || (copyIsArray = isArray$7(copy2)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && isArray$7(src) ? src : [];
            } else {
              clone2 = src && isPlainObject(src) ? src : {};
            }
            setProperty(target, { name: name2, newValue: extend(deep, clone2, copy2) });
          } else if (typeof copy2 !== "undefined") {
            setProperty(target, { name: name2, newValue: copy2 });
          }
        }
      }
    }
  }
  return target;
};
var isPlainObj = (value2) => {
  if (Object.prototype.toString.call(value2) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value2);
  return prototype === null || prototype === Object.prototype;
};
var slice$2 = [].slice;
var wrap_1 = wrap$2;
function wrap$2(fn, callback) {
  var invoked;
  return wrapped;
  function wrapped() {
    var params = slice$2.call(arguments, 0);
    var callback2 = fn.length > params.length;
    var result;
    if (callback2) {
      params.push(done);
    }
    try {
      result = fn.apply(null, params);
    } catch (error) {
      if (callback2 && invoked) {
        throw error;
      }
      return done(error);
    }
    if (!callback2) {
      if (result && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done() {
    if (!invoked) {
      invoked = true;
      callback.apply(null, arguments);
    }
  }
  function then(value2) {
    done(null, value2);
  }
}
var wrap$1 = wrap_1;
var trough_1 = trough$1;
trough$1.wrap = wrap$1;
var slice$1 = [].slice;
function trough$1() {
  var fns = [];
  var middleware = {};
  middleware.run = run;
  middleware.use = use;
  return middleware;
  function run() {
    var index2 = -1;
    var input = slice$1.call(arguments, 0, -1);
    var done = arguments[arguments.length - 1];
    if (typeof done !== "function") {
      throw new Error("Expected function as last argument, not " + done);
    }
    next.apply(null, [null].concat(input));
    function next(err) {
      var fn = fns[++index2];
      var params = slice$1.call(arguments, 0);
      var values = params.slice(1);
      var length = input.length;
      var pos = -1;
      if (err) {
        done(err);
        return;
      }
      while (++pos < length) {
        if (values[pos] === null || values[pos] === void 0) {
          values[pos] = input[pos];
        }
      }
      input = values;
      if (fn) {
        wrap$1(fn, next).apply(null, input);
      } else {
        done.apply(null, [null].concat(input));
      }
    }
  }
  function use(fn) {
    if (typeof fn !== "function") {
      throw new Error("Expected `fn` to be a function, not " + fn);
    }
    fns.push(fn);
    return middleware;
  }
}
var vfile$1 = { exports: {} };
var own$8 = {}.hasOwnProperty;
var unistUtilStringifyPosition = stringify$5;
function stringify$5(value2) {
  if (!value2 || typeof value2 !== "object") {
    return "";
  }
  if (own$8.call(value2, "position") || own$8.call(value2, "type")) {
    return position(value2.position);
  }
  if (own$8.call(value2, "start") || own$8.call(value2, "end")) {
    return position(value2);
  }
  if (own$8.call(value2, "line") || own$8.call(value2, "column")) {
    return point(value2);
  }
  return "";
}
function point(point2) {
  if (!point2 || typeof point2 !== "object") {
    point2 = {};
  }
  return index$6(point2.line) + ":" + index$6(point2.column);
}
function position(pos) {
  if (!pos || typeof pos !== "object") {
    pos = {};
  }
  return point(pos.start) + "-" + point(pos.end);
}
function index$6(value2) {
  return value2 && typeof value2 === "number" ? value2 : 1;
}
var stringify$4 = unistUtilStringifyPosition;
var vfileMessage = VMessage$1;
function VMessagePrototype() {
}
VMessagePrototype.prototype = Error.prototype;
VMessage$1.prototype = new VMessagePrototype();
var proto$2 = VMessage$1.prototype;
proto$2.file = "";
proto$2.name = "";
proto$2.reason = "";
proto$2.message = "";
proto$2.stack = "";
proto$2.fatal = null;
proto$2.column = null;
proto$2.line = null;
function VMessage$1(reason, position2, origin) {
  var parts;
  var range3;
  var location2;
  if (typeof position2 === "string") {
    origin = position2;
    position2 = null;
  }
  parts = parseOrigin(origin);
  range3 = stringify$4(position2) || "1:1";
  location2 = {
    start: { line: null, column: null },
    end: { line: null, column: null }
  };
  if (position2 && position2.position) {
    position2 = position2.position;
  }
  if (position2) {
    if (position2.start) {
      location2 = position2;
      position2 = position2.start;
    } else {
      location2.start = position2;
    }
  }
  if (reason.stack) {
    this.stack = reason.stack;
    reason = reason.message;
  }
  this.message = reason;
  this.name = range3;
  this.reason = reason;
  this.line = position2 ? position2.line : null;
  this.column = position2 ? position2.column : null;
  this.location = location2;
  this.source = parts[0];
  this.ruleId = parts[1];
}
function parseOrigin(origin) {
  var result = [null, null];
  var index2;
  if (typeof origin === "string") {
    index2 = origin.indexOf(":");
    if (index2 === -1) {
      result[1] = origin;
    } else {
      result[0] = origin.slice(0, index2);
      result[1] = origin.slice(index2 + 1);
    }
  }
  return result;
}
var minpath_browser = {};
minpath_browser.basename = basename;
minpath_browser.dirname = dirname;
minpath_browser.extname = extname;
minpath_browser.join = join;
minpath_browser.sep = "/";
function basename(path, ext) {
  var start = 0;
  var end = -1;
  var index2;
  var firstNonSlashEnd;
  var seenNonSlash;
  var extIndex;
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath$1(path);
  index2 = path.length;
  if (ext === void 0 || !ext.length || ext.length > path.length) {
    while (index2--) {
      if (path.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path.slice(start, end);
  }
  if (ext === path) {
    return "";
  }
  firstNonSlashEnd = -1;
  extIndex = ext.length - 1;
  while (index2--) {
    if (path.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path.length;
  }
  return path.slice(start, end);
}
function dirname(path) {
  var end;
  var unmatchedSlash;
  var index2;
  assertPath$1(path);
  if (!path.length) {
    return ".";
  }
  end = -1;
  index2 = path.length;
  while (--index2) {
    if (path.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path.charCodeAt(0) === 47 ? "//" : path.slice(0, end);
}
function extname(path) {
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var preDotState = 0;
  var unmatchedSlash;
  var code;
  var index2;
  assertPath$1(path);
  index2 = path.length;
  while (index2--) {
    code = path.charCodeAt(index2);
    if (code === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path.slice(startDot, end);
}
function join() {
  var index2 = -1;
  var joined;
  while (++index2 < arguments.length) {
    assertPath$1(arguments[index2]);
    if (arguments[index2]) {
      joined = joined === void 0 ? arguments[index2] : joined + "/" + arguments[index2];
    }
  }
  return joined === void 0 ? "." : normalize$5(joined);
}
function normalize$5(path) {
  var absolute;
  var value2;
  assertPath$1(path);
  absolute = path.charCodeAt(0) === 47;
  value2 = normalizeString(path, !absolute);
  if (!value2.length && !absolute) {
    value2 = ".";
  }
  if (value2.length && path.charCodeAt(path.length - 1) === 47) {
    value2 += "/";
  }
  return absolute ? "/" + value2 : value2;
}
function normalizeString(path, allowAboveRoot) {
  var result = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var index2 = -1;
  var code;
  var lastSlashIndex;
  while (++index2 <= path.length) {
    if (index2 < path.length) {
      code = path.charCodeAt(index2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === index2 - 1 || dots === 1)
        ;
      else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length) {
          result += "/" + path.slice(lastSlash + 1, index2);
        } else {
          result = path.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath$1(path) {
  if (typeof path !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
  }
}
var minproc_browser = {};
minproc_browser.cwd = cwd;
function cwd() {
  return "/";
}
var p = minpath_browser;
var proc = minproc_browser;
var buffer$1 = isBuffer$3;
var core$1 = VFile$1;
var own$7 = {}.hasOwnProperty;
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
VFile$1.prototype.toString = toString$4;
Object.defineProperty(VFile$1.prototype, "path", { get: getPath, set: setPath });
Object.defineProperty(VFile$1.prototype, "dirname", {
  get: getDirname,
  set: setDirname
});
Object.defineProperty(VFile$1.prototype, "basename", {
  get: getBasename,
  set: setBasename
});
Object.defineProperty(VFile$1.prototype, "extname", {
  get: getExtname,
  set: setExtname
});
Object.defineProperty(VFile$1.prototype, "stem", { get: getStem, set: setStem });
function VFile$1(options) {
  var prop;
  var index2;
  if (!options) {
    options = {};
  } else if (typeof options === "string" || buffer$1(options)) {
    options = { contents: options };
  } else if ("message" in options && "messages" in options) {
    return options;
  }
  if (!(this instanceof VFile$1)) {
    return new VFile$1(options);
  }
  this.data = {};
  this.messages = [];
  this.history = [];
  this.cwd = proc.cwd();
  index2 = -1;
  while (++index2 < order.length) {
    prop = order[index2];
    if (own$7.call(options, prop)) {
      this[prop] = options[prop];
    }
  }
  for (prop in options) {
    if (order.indexOf(prop) < 0) {
      this[prop] = options[prop];
    }
  }
}
function getPath() {
  return this.history[this.history.length - 1];
}
function setPath(path) {
  assertNonEmpty(path, "path");
  if (this.path !== path) {
    this.history.push(path);
  }
}
function getDirname() {
  return typeof this.path === "string" ? p.dirname(this.path) : void 0;
}
function setDirname(dirname2) {
  assertPath(this.path, "dirname");
  this.path = p.join(dirname2 || "", this.basename);
}
function getBasename() {
  return typeof this.path === "string" ? p.basename(this.path) : void 0;
}
function setBasename(basename2) {
  assertNonEmpty(basename2, "basename");
  assertPart(basename2, "basename");
  this.path = p.join(this.dirname || "", basename2);
}
function getExtname() {
  return typeof this.path === "string" ? p.extname(this.path) : void 0;
}
function setExtname(extname2) {
  assertPart(extname2, "extname");
  assertPath(this.path, "extname");
  if (extname2) {
    if (extname2.charCodeAt(0) !== 46) {
      throw new Error("`extname` must start with `.`");
    }
    if (extname2.indexOf(".", 1) > -1) {
      throw new Error("`extname` cannot contain multiple dots");
    }
  }
  this.path = p.join(this.dirname, this.stem + (extname2 || ""));
}
function getStem() {
  return typeof this.path === "string" ? p.basename(this.path, this.extname) : void 0;
}
function setStem(stem) {
  assertNonEmpty(stem, "stem");
  assertPart(stem, "stem");
  this.path = p.join(this.dirname || "", stem + (this.extname || ""));
}
function toString$4(encoding) {
  return (this.contents || "").toString(encoding);
}
function assertPart(part, name2) {
  if (part && part.indexOf(p.sep) > -1) {
    throw new Error("`" + name2 + "` cannot be a path: did not expect `" + p.sep + "`");
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath(path, name2) {
  if (!path) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
var VMessage = vfileMessage;
var VFile = core$1;
var lib$1 = VFile;
VFile.prototype.message = message$1;
VFile.prototype.info = info$1;
VFile.prototype.fail = fail;
function message$1(reason, position2, origin) {
  var message2 = new VMessage(reason, position2, origin);
  if (this.path) {
    message2.name = this.path + ":" + message2.name;
    message2.file = this.path;
  }
  message2.fatal = false;
  this.messages.push(message2);
  return message2;
}
function fail() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = true;
  throw message2;
}
function info$1() {
  var message2 = this.message.apply(this, arguments);
  message2.fatal = null;
  return message2;
}
(function(module) {
  module.exports = lib$1;
})(vfile$1);
var bail = bail_1;
var buffer = isBuffer$3;
var extend2 = extend$1;
var plain = isPlainObj;
var trough = trough_1;
var vfile = vfile$1.exports;
var unified_1 = unified$1().freeze();
var slice = [].slice;
var own$6 = {}.hasOwnProperty;
var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
function pipelineParse(p2, ctx2) {
  ctx2.tree = p2.parse(ctx2.file);
}
function pipelineRun(p2, ctx2, next) {
  p2.run(ctx2.tree, ctx2.file, done);
  function done(error, tree, file) {
    if (error) {
      next(error);
    } else {
      ctx2.tree = tree;
      ctx2.file = file;
      next();
    }
  }
}
function pipelineStringify(p2, ctx2) {
  var result = p2.stringify(ctx2.tree, ctx2.file);
  if (result === void 0 || result === null)
    ;
  else if (typeof result === "string" || buffer(result)) {
    if ("value" in ctx2.file) {
      ctx2.file.value = result;
    }
    ctx2.file.contents = result;
  } else {
    ctx2.file.result = result;
  }
}
function unified$1() {
  var attachers = [];
  var transformers = trough();
  var namespace = {};
  var freezeIndex = -1;
  var frozen;
  processor.data = data2;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse2;
  processor.stringify = stringify2;
  processor.run = run;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    var destination = unified$1();
    var index2 = -1;
    while (++index2 < attachers.length) {
      destination.use.apply(null, attachers[index2]);
    }
    destination.data(extend2(true, {}, namespace));
    return destination;
  }
  function freeze() {
    var values;
    var transformer;
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      values = attachers[freezeIndex];
      if (values[1] === false) {
        continue;
      }
      if (values[1] === true) {
        values[1] = void 0;
      }
      transformer = values[0].apply(processor, values.slice(1));
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Infinity;
    return processor;
  }
  function data2(key2, value2) {
    if (typeof key2 === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key2] = value2;
        return processor;
      }
      return own$6.call(namespace, key2) && namespace[key2] || null;
    }
    if (key2) {
      assertUnfrozen("data", frozen);
      namespace = key2;
      return processor;
    }
    return namespace;
  }
  function use(value2) {
    var settings;
    assertUnfrozen("use", frozen);
    if (value2 === null || value2 === void 0)
      ;
    else if (typeof value2 === "function") {
      addPlugin.apply(null, arguments);
    } else if (typeof value2 === "object") {
      if ("length" in value2) {
        addList(value2);
      } else {
        addPreset(value2);
      }
    } else {
      throw new Error("Expected usable value, not `" + value2 + "`");
    }
    if (settings) {
      namespace.settings = extend2(namespace.settings || {}, settings);
    }
    return processor;
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = extend2(settings || {}, result.settings);
      }
    }
    function add(value3) {
      if (typeof value3 === "function") {
        addPlugin(value3);
      } else if (typeof value3 === "object") {
        if ("length" in value3) {
          addPlugin.apply(null, value3);
        } else {
          addPreset(value3);
        }
      } else {
        throw new Error("Expected usable value, not `" + value3 + "`");
      }
    }
    function addList(plugins) {
      var index2 = -1;
      if (plugins === null || plugins === void 0)
        ;
      else if (typeof plugins === "object" && "length" in plugins) {
        while (++index2 < plugins.length) {
          add(plugins[index2]);
        }
      } else {
        throw new Error("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value3) {
      var entry = find2(plugin);
      if (entry) {
        if (plain(entry[1]) && plain(value3)) {
          value3 = extend2(true, entry[1], value3);
        }
        entry[1] = value3;
      } else {
        attachers.push(slice.call(arguments));
      }
    }
  }
  function find2(plugin) {
    var index2 = -1;
    while (++index2 < attachers.length) {
      if (attachers[index2][0] === plugin) {
        return attachers[index2];
      }
    }
  }
  function parse2(doc) {
    var file = vfile(doc);
    var Parser;
    freeze();
    Parser = processor.Parser;
    assertParser("parse", Parser);
    if (newable(Parser, "parse")) {
      return new Parser(String(file), file).parse();
    }
    return Parser(String(file), file);
  }
  function run(node, file, cb2) {
    assertNode(node);
    freeze();
    if (!cb2 && typeof file === "function") {
      cb2 = file;
      file = null;
    }
    if (!cb2) {
      return new Promise(executor);
    }
    executor(null, cb2);
    function executor(resolve, reject) {
      transformers.run(node, vfile(file), done);
      function done(error, tree, file2) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          cb2(null, tree, file2);
        }
      }
    }
  }
  function runSync(node, file) {
    var result;
    var complete;
    run(node, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      complete = true;
      result = tree;
      bail(error);
    }
  }
  function stringify2(node, doc) {
    var file = vfile(doc);
    var Compiler;
    freeze();
    Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node);
    if (newable(Compiler, "compile")) {
      return new Compiler(node, file).compile();
    }
    return Compiler(node, file);
  }
  function process2(doc, cb2) {
    freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!cb2) {
      return new Promise(executor);
    }
    executor(null, cb2);
    function executor(resolve, reject) {
      var file = vfile(doc);
      pipeline.run(processor, { file }, done);
      function done(error) {
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(file);
        } else {
          cb2(null, file);
        }
      }
    }
  }
  function processSync(doc) {
    var file;
    var complete;
    freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    file = vfile(doc);
    process2(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value2, name2) {
  return typeof value2 === "function" && value2.prototype && (keys$2(value2.prototype) || name2 in value2.prototype);
}
function keys$2(value2) {
  var key2;
  for (key2 in value2) {
    return true;
  }
  return false;
}
function assertParser(name2, Parser) {
  if (typeof Parser !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler(name2, Compiler) {
  if (typeof Compiler !== "function") {
    throw new Error("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error("Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.");
  }
}
function assertNode(node) {
  if (!node || typeof node.type !== "string") {
    throw new Error("Expected node, got `" + node + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error("`" + name2 + "` finished async. Use `" + asyncName + "` instead");
  }
}
var mdastUtilFromMarkdown = { exports: {} };
var mdastUtilToString = toString$3;
function toString$3(node) {
  return node && (node.value || node.alt || node.title || "children" in node && all(node.children) || "length" in node && all(node)) || "";
}
function all(values) {
  var result = [];
  var index2 = -1;
  while (++index2 < values.length) {
    result[index2] = toString$3(values[index2]);
  }
  return result.join("");
}
var assign$5 = Object.assign;
var assign_1 = assign$5;
var own$5 = {}.hasOwnProperty;
var hasOwnProperty$b = own$5;
function normalizeIdentifier$3(value2) {
  return value2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
var normalizeIdentifier_1 = normalizeIdentifier$3;
var fromCharCode$5 = String.fromCharCode;
var fromCharCode_1 = fromCharCode$5;
var fromCharCode$4 = fromCharCode_1;
function safeFromInt$1(value2, base) {
  var code = parseInt(value2, base);
  if (code < 9 || code === 11 || code > 13 && code < 32 || code > 126 && code < 160 || code > 55295 && code < 57344 || code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || code > 1114111) {
    return "\uFFFD";
  }
  return fromCharCode$4(code);
}
var safeFromInt_1 = safeFromInt$1;
var content$3 = {};
function markdownLineEnding$k(code) {
  return code < -2;
}
var markdownLineEnding_1 = markdownLineEnding$k;
function markdownSpace$a(code) {
  return code === -2 || code === -1 || code === 32;
}
var markdownSpace_1 = markdownSpace$a;
var markdownSpace$9 = markdownSpace_1;
function spaceFactory(effects, ok2, type4, max) {
  var limit2 = max ? max - 1 : Infinity;
  var size = 0;
  return start;
  function start(code) {
    if (markdownSpace$9(code)) {
      effects.enter(type4);
      return prefix2(code);
    }
    return ok2(code);
  }
  function prefix2(code) {
    if (markdownSpace$9(code) && size++ < limit2) {
      effects.consume(code);
      return prefix2;
    }
    effects.exit(type4);
    return ok2(code);
  }
}
var factorySpace$h = spaceFactory;
Object.defineProperty(content$3, "__esModule", { value: true });
var markdownLineEnding$j = markdownLineEnding_1;
var factorySpace$g = factorySpace$h;
var tokenize$2 = initializeContent;
function initializeContent(effects) {
  var contentStart = effects.attempt(this.parser.constructs.contentInitial, afterContentStartConstruct, paragraphInitial);
  var previous2;
  return contentStart;
  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$g(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code) {
    effects.enter("paragraph");
    return lineStart(code);
  }
  function lineStart(code) {
    var token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous2
    });
    if (previous2) {
      previous2.next = token;
    }
    previous2 = token;
    return data2(code);
  }
  function data2(code) {
    if (code === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code);
      return;
    }
    if (markdownLineEnding$j(code)) {
      effects.consume(code);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code);
    return data2;
  }
}
content$3.tokenize = tokenize$2;
var document$3 = {};
var markdownLineEnding$i = markdownLineEnding_1;
var factorySpace$f = factorySpace$h;
var partialBlankLine$4 = {
  tokenize: tokenizePartialBlankLine,
  partial: true
};
function tokenizePartialBlankLine(effects, ok2, nok) {
  return factorySpace$f(effects, afterWhitespace, "linePrefix");
  function afterWhitespace(code) {
    return code === null || markdownLineEnding$i(code) ? ok2(code) : nok(code);
  }
}
var partialBlankLine_1 = partialBlankLine$4;
Object.defineProperty(document$3, "__esModule", { value: true });
var markdownLineEnding$h = markdownLineEnding_1;
var factorySpace$e = factorySpace$h;
var partialBlankLine$3 = partialBlankLine_1;
var tokenize$1 = initializeDocument;
var containerConstruct = {
  tokenize: tokenizeContainer
};
var lazyFlowConstruct = {
  tokenize: tokenizeLazyFlow
};
function initializeDocument(effects) {
  var self2 = this;
  var stack = [];
  var continued = 0;
  var inspectConstruct = {
    tokenize: tokenizeInspect,
    partial: true
  };
  var inspectResult;
  var childFlow;
  var childToken;
  return start;
  function start(code) {
    if (continued < stack.length) {
      self2.containerState = stack[continued][1];
      return effects.attempt(stack[continued][0].continuation, documentContinue, documentContinued)(code);
    }
    return documentContinued(code);
  }
  function documentContinue(code) {
    continued++;
    return start(code);
  }
  function documentContinued(code) {
    if (inspectResult && inspectResult.flowContinue) {
      return flowStart(code);
    }
    self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
    self2.containerState = {};
    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);
  }
  function containerContinue(code) {
    stack.push([self2.currentConstruct, self2.containerState]);
    self2.containerState = void 0;
    return documentContinued(code);
  }
  function flowStart(code) {
    if (code === null) {
      exitContainers(0, true);
      effects.consume(code);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code);
  }
  function flowContinue(code) {
    if (code === null) {
      continueFlow(effects.exit("chunkFlow"));
      return flowStart(code);
    }
    if (markdownLineEnding$h(code)) {
      effects.consume(code);
      continueFlow(effects.exit("chunkFlow"));
      return effects.check(inspectConstruct, documentAfterPeek);
    }
    effects.consume(code);
    return flowContinue;
  }
  function documentAfterPeek(code) {
    exitContainers(inspectResult.continued, inspectResult && inspectResult.flowEnd);
    continued = 0;
    return start(code);
  }
  function continueFlow(token) {
    if (childToken)
      childToken.next = token;
    childToken = token;
    childFlow.lazy = inspectResult && inspectResult.lazy;
    childFlow.defineSkip(token.start);
    childFlow.write(self2.sliceStream(token));
  }
  function exitContainers(size, end) {
    var index2 = stack.length;
    if (childFlow && end) {
      childFlow.write([null]);
      childToken = childFlow = void 0;
    }
    while (index2-- > size) {
      self2.containerState = stack[index2][1];
      stack[index2][0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function tokenizeInspect(effects2, ok2) {
    var subcontinued = 0;
    inspectResult = {};
    return inspectStart;
    function inspectStart(code) {
      if (subcontinued < stack.length) {
        self2.containerState = stack[subcontinued][1];
        return effects2.attempt(stack[subcontinued][0].continuation, inspectContinue, inspectLess)(code);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        inspectResult.flowContinue = true;
        return inspectDone(code);
      }
      self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
      self2.containerState = {};
      return effects2.attempt(containerConstruct, inspectFlowEnd, inspectDone)(code);
    }
    function inspectContinue(code) {
      subcontinued++;
      return self2.containerState._closeFlow ? inspectFlowEnd(code) : inspectStart(code);
    }
    function inspectLess(code) {
      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
        self2.containerState = {};
        return effects2.attempt(containerConstruct, inspectFlowEnd, effects2.attempt(lazyFlowConstruct, inspectFlowEnd, effects2.check(partialBlankLine$3, inspectFlowEnd, inspectLazy)))(code);
      }
      return inspectFlowEnd(code);
    }
    function inspectLazy(code) {
      subcontinued = stack.length;
      inspectResult.lazy = true;
      inspectResult.flowContinue = true;
      return inspectDone(code);
    }
    function inspectFlowEnd(code) {
      inspectResult.flowEnd = true;
      return inspectDone(code);
    }
    function inspectDone(code) {
      inspectResult.continued = subcontinued;
      self2.interrupt = self2.containerState = void 0;
      return ok2(code);
    }
  }
}
function tokenizeContainer(effects, ok2, nok) {
  return factorySpace$e(effects, effects.attempt(this.parser.constructs.document, ok2, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
}
function tokenizeLazyFlow(effects, ok2, nok) {
  return factorySpace$e(effects, effects.lazy(this.parser.constructs.flow, ok2, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
}
document$3.tokenize = tokenize$1;
var flow$2 = {};
function sizeChunks$2(chunks) {
  var index2 = -1;
  var size = 0;
  while (++index2 < chunks.length) {
    size += typeof chunks[index2] === "string" ? chunks[index2].length : 1;
  }
  return size;
}
var sizeChunks_1 = sizeChunks$2;
var sizeChunks$1 = sizeChunks_1;
function prefixSize$4(events, type4) {
  var tail = events[events.length - 1];
  if (!tail || tail[1].type !== type4)
    return 0;
  return sizeChunks$1(tail[2].sliceStream(tail[1]));
}
var prefixSize_1 = prefixSize$4;
var splice$3 = [].splice;
var splice_1 = splice$3;
var splice$2 = splice_1;
function chunkedSplice$8(list2, start, remove, items) {
  var end = list2.length;
  var chunkStart = 0;
  var parameters;
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    splice$2.apply(list2, parameters);
  } else {
    if (remove)
      splice$2.apply(list2, [start, remove]);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start, 0);
      splice$2.apply(list2, parameters);
      chunkStart += 1e4;
      start += 1e4;
    }
  }
}
var chunkedSplice_1 = chunkedSplice$8;
var assign$4 = assign_1;
function shallow$6(object4) {
  return assign$4({}, object4);
}
var shallow_1 = shallow$6;
var assign$3 = assign_1;
var chunkedSplice$7 = chunkedSplice_1;
var shallow$5 = shallow_1;
function subtokenize$2(events) {
  var jumps = {};
  var index2 = -1;
  var event;
  var lineIndex;
  var otherIndex;
  var otherEvent;
  var parameters;
  var subevents;
  var more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1].isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        assign$3(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container || event[1]._movePreviousLineEndings) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = shallow$5(events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        chunkedSplice$7(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  var token = events[eventIndex][1];
  var context2 = events[eventIndex][2];
  var startPosition = eventIndex - 1;
  var startPositions = [];
  var tokenizer = token._tokenizer || context2.parser[token.contentType](token.start);
  var childEvents = tokenizer.events;
  var jumps = [];
  var gaps = {};
  var stream;
  var previous2;
  var index2;
  var entered;
  var end;
  var adjust;
  while (token) {
    while (events[++startPosition][1] !== token) {
    }
    startPositions.push(startPosition);
    if (!token._tokenizer) {
      stream = context2.sliceStream(token);
      if (!token.next) {
        stream.push(null);
      }
      if (previous2) {
        tokenizer.defineSkip(token.start);
      }
      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (token.isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous2 = token;
    token = token.next;
  }
  token = previous2;
  index2 = childEvents.length;
  while (index2--) {
    if (childEvents[index2][0] === "enter") {
      entered = true;
    } else if (entered && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line) {
      add(childEvents.slice(index2 + 1, end));
      token._tokenizer = token.next = void 0;
      token = token.previous;
      end = index2 + 1;
    }
  }
  tokenizer.events = token._tokenizer = token.next = void 0;
  add(childEvents.slice(0, end));
  index2 = -1;
  adjust = 0;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
  function add(slice2) {
    var start = startPositions.pop();
    jumps.unshift([start, start + slice2.length - 1]);
    chunkedSplice$7(events, start, 2, slice2);
  }
}
var subtokenize_1 = subtokenize$2;
var markdownLineEnding$g = markdownLineEnding_1;
var prefixSize$3 = prefixSize_1;
var subtokenize$1 = subtokenize_1;
var factorySpace$d = factorySpace$h;
var content$2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent,
  interruptible: true,
  lazy: true
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize$1(events);
  return events;
}
function tokenizeContent(effects, ok2) {
  var previous2;
  return start;
  function start(code) {
    effects.enter("content");
    previous2 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return data2(code);
  }
  function data2(code) {
    if (code === null) {
      return contentEnd(code);
    }
    if (markdownLineEnding$g(code)) {
      return effects.check(continuationConstruct, contentContinue, contentEnd)(code);
    }
    effects.consume(code);
    return data2;
  }
  function contentEnd(code) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok2(code);
  }
  function contentContinue(code) {
    effects.consume(code);
    effects.exit("chunkContent");
    previous2 = previous2.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous2
    });
    return data2;
  }
}
function tokenizeContinuation(effects, ok2, nok) {
  var self2 = this;
  return startLookahead;
  function startLookahead(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$d(effects, prefixed, "linePrefix");
  }
  function prefixed(code) {
    if (code === null || markdownLineEnding$g(code)) {
      return nok(code);
    }
    if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize$3(self2.events, "linePrefix") < 4) {
      return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code);
    }
    return ok2(code);
  }
}
var content_1 = content$2;
Object.defineProperty(flow$2, "__esModule", { value: true });
var content$1 = content_1;
var factorySpace$c = factorySpace$h;
var partialBlankLine$2 = partialBlankLine_1;
var tokenize = initializeFlow;
function initializeFlow(effects) {
  var self2 = this;
  var initial = effects.attempt(partialBlankLine$2, atBlankEnding, effects.attempt(this.parser.constructs.flowInitial, afterConstruct, factorySpace$c(effects, effects.attempt(this.parser.constructs.flow, afterConstruct, effects.attempt(content$1, afterConstruct)), "linePrefix")));
  return initial;
  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}
flow$2.tokenize = tokenize;
var text$4 = {};
Object.defineProperty(text$4, "__esModule", { value: true });
var assign$2 = assign_1;
var shallow$4 = shallow_1;
var text$3 = initializeFactory("text");
var string$2 = initializeFactory("string");
var resolver = {
  resolveAll: createResolver()
};
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(field === "text" ? resolveAllLineSuffixes : void 0)
  };
  function initializeText(effects) {
    var self2 = this;
    var constructs2 = this.parser.constructs[field];
    var text2 = effects.attempt(constructs2, start, notText);
    return start;
    function start(code) {
      return atBreak(code) ? text2(code) : notText(code);
    }
    function notText(code) {
      if (code === null) {
        effects.consume(code);
        return;
      }
      effects.enter("data");
      effects.consume(code);
      return data2;
    }
    function data2(code) {
      if (atBreak(code)) {
        effects.exit("data");
        return text2(code);
      }
      effects.consume(code);
      return data2;
    }
    function atBreak(code) {
      var list2 = constructs2[code];
      var index2 = -1;
      if (code === null) {
        return true;
      }
      if (list2) {
        while (++index2 < list2.length) {
          if (!list2[index2].previous || list2[index2].previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context2) {
    var index2 = -1;
    var enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context2) : events;
  }
}
function resolveAllLineSuffixes(events, context2) {
  var eventIndex = -1;
  var chunks;
  var data2;
  var chunk;
  var index2;
  var bufferIndex;
  var size;
  var tabs;
  var token;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      data2 = events[eventIndex - 1][1];
      chunks = context2.sliceStream(data2);
      index2 = chunks.length;
      bufferIndex = -1;
      size = 0;
      tabs = void 0;
      while (index2--) {
        chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex)
            break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1)
          ;
        else {
          index2++;
          break;
        }
      }
      if (size) {
        token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data2.end.line,
            column: data2.end.column - size,
            offset: data2.end.offset - size,
            _index: data2.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: shallow$4(data2.end)
        };
        data2.end = shallow$4(token.start);
        if (data2.start.offset === data2.end.offset) {
          assign$2(data2, token);
        } else {
          events.splice(eventIndex, 0, ["enter", token, context2], ["exit", token, context2]);
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}
text$4.resolver = resolver;
text$4.string = string$2;
text$4.text = text$3;
function miniflat$3(value2) {
  return value2 === null || value2 === void 0 ? [] : "length" in value2 ? value2 : [value2];
}
var miniflat_1 = miniflat$3;
var hasOwnProperty$a = hasOwnProperty$b;
var chunkedSplice$6 = chunkedSplice_1;
var miniflat$2 = miniflat_1;
function combineExtensions$1(extensions) {
  var all2 = {};
  var index2 = -1;
  while (++index2 < extensions.length) {
    extension$1(all2, extensions[index2]);
  }
  return all2;
}
function extension$1(all2, extension2) {
  var hook;
  var left;
  var right;
  var code;
  for (hook in extension2) {
    left = hasOwnProperty$a.call(all2, hook) ? all2[hook] : all2[hook] = {};
    right = extension2[hook];
    for (code in right) {
      left[code] = constructs$2(miniflat$2(right[code]), hasOwnProperty$a.call(left, code) ? left[code] : []);
    }
  }
}
function constructs$2(list2, existing) {
  var index2 = -1;
  var before = [];
  while (++index2 < list2.length) {
    (list2[index2].add === "after" ? existing : before).push(list2[index2]);
  }
  chunkedSplice$6(existing, 0, 0, before);
  return existing;
}
var combineExtensions_1 = combineExtensions$1;
var chunkedSplice$5 = chunkedSplice_1;
function chunkedPush$3(list2, items) {
  if (list2.length) {
    chunkedSplice$5(list2, list2.length, 0, items);
    return list2;
  }
  return items;
}
var chunkedPush_1 = chunkedPush$3;
function resolveAll$3(constructs2, events, context2) {
  var called = [];
  var index2 = -1;
  var resolve;
  while (++index2 < constructs2.length) {
    resolve = constructs2[index2].resolveAll;
    if (resolve && called.indexOf(resolve) < 0) {
      events = resolve(events, context2);
      called.push(resolve);
    }
  }
  return events;
}
var resolveAll_1 = resolveAll$3;
var fromCharCode$3 = fromCharCode_1;
function serializeChunks$1(chunks) {
  var index2 = -1;
  var result = [];
  var chunk;
  var value2;
  var atTab;
  while (++index2 < chunks.length) {
    chunk = chunks[index2];
    if (typeof chunk === "string") {
      value2 = chunk;
    } else if (chunk === -5) {
      value2 = "\r";
    } else if (chunk === -4) {
      value2 = "\n";
    } else if (chunk === -3) {
      value2 = "\r\n";
    } else if (chunk === -2) {
      value2 = "	";
    } else if (chunk === -1) {
      if (atTab)
        continue;
      value2 = " ";
    } else {
      value2 = fromCharCode$3(chunk);
    }
    atTab = chunk === -2;
    result.push(value2);
  }
  return result.join("");
}
var serializeChunks_1 = serializeChunks$1;
function sliceChunks$1(chunks, token) {
  var startIndex = token.start._index;
  var startBufferIndex = token.start._bufferIndex;
  var endIndex = token.end._index;
  var endBufferIndex = token.end._bufferIndex;
  var view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      view[0] = view[0].slice(startBufferIndex);
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
var sliceChunks_1 = sliceChunks$1;
var assign$1 = assign_1;
var markdownLineEnding$f = markdownLineEnding_1;
var chunkedPush$2 = chunkedPush_1;
var chunkedSplice$4 = chunkedSplice_1;
var miniflat$1 = miniflat_1;
var resolveAll$2 = resolveAll_1;
var serializeChunks = serializeChunks_1;
var shallow$3 = shallow_1;
var sliceChunks = sliceChunks_1;
function createTokenizer$1(parser2, initialize, from) {
  var point2 = from ? shallow$3(from) : {
    line: 1,
    column: 1,
    offset: 0
  };
  var columnStart = {};
  var resolveAllConstructs = [];
  var chunks = [];
  var stack = [];
  var effects = {
    consume,
    enter,
    exit: exit2,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    }),
    lazy: constructFactory(onsuccessfulcheck, {
      lazy: true
    })
  };
  var context2 = {
    previous: null,
    events: [],
    parser: parser2,
    sliceStream,
    sliceSerialize,
    now: now2,
    defineSkip: skip,
    write
  };
  var state = initialize.tokenize.call(context2, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  point2._index = 0;
  point2._bufferIndex = -1;
  return context2;
  function write(slice2) {
    chunks = chunkedPush$2(chunks, slice2);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context2.events = resolveAll$2(resolveAllConstructs, context2.events, context2);
    return context2.events;
  }
  function sliceSerialize(token) {
    return serializeChunks(sliceStream(token));
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now2() {
    return shallow$3(point2);
  }
  function skip(value2) {
    columnStart[value2.line] = value2.column;
    accountForPotentialSkip();
  }
  function main() {
    var chunkIndex;
    var chunk;
    while (point2._index < chunks.length) {
      chunk = chunks[point2._index];
      if (typeof chunk === "string") {
        chunkIndex = point2._index;
        if (point2._bufferIndex < 0) {
          point2._bufferIndex = 0;
        }
        while (point2._index === chunkIndex && point2._bufferIndex < chunk.length) {
          go(chunk.charCodeAt(point2._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }
  function go(code) {
    state = state(code);
  }
  function consume(code) {
    if (markdownLineEnding$f(code)) {
      point2.line++;
      point2.column = 1;
      point2.offset += code === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code !== -1) {
      point2.column++;
      point2.offset++;
    }
    if (point2._bufferIndex < 0) {
      point2._index++;
    } else {
      point2._bufferIndex++;
      if (point2._bufferIndex === chunks[point2._index].length) {
        point2._bufferIndex = -1;
        point2._index++;
      }
    }
    context2.previous = code;
  }
  function enter(type4, fields) {
    var token = fields || {};
    token.type = type4;
    token.start = now2();
    context2.events.push(["enter", token, context2]);
    stack.push(token);
    return token;
  }
  function exit2(type4) {
    var token = stack.pop();
    token.end = now2();
    context2.events.push(["exit", token, context2]);
    return token;
  }
  function onsuccessfulconstruct(construct, info2) {
    addResult(construct, info2.from);
  }
  function onsuccessfulcheck(construct, info2) {
    info2.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      var listOfConstructs;
      var constructIndex;
      var currentConstruct;
      var info2;
      return constructs2.tokenize || "length" in constructs2 ? handleListOfConstructs(miniflat$1(constructs2)) : handleMapOfConstructs;
      function handleMapOfConstructs(code) {
        if (code in constructs2 || null in constructs2) {
          return handleListOfConstructs(constructs2.null ? miniflat$1(constructs2[code]).concat(miniflat$1(constructs2.null)) : constructs2[code])(code);
        }
        return bogusState(code);
      }
      function handleListOfConstructs(list2) {
        listOfConstructs = list2;
        constructIndex = 0;
        return handleConstruct(list2[constructIndex]);
      }
      function handleConstruct(construct) {
        return start;
        function start(code) {
          info2 = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context2.currentConstruct = construct;
          }
          if (construct.name && context2.parser.constructs.disable.null.indexOf(construct.name) > -1) {
            return nok();
          }
          return construct.tokenize.call(fields ? assign$1({}, context2, fields) : context2, effects, ok2, nok)(code);
        }
      }
      function ok2(code) {
        onreturn(currentConstruct, info2);
        return returnState;
      }
      function nok(code) {
        info2.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      chunkedSplice$4(context2.events, from2, context2.events.length - from2, construct.resolve(context2.events.slice(from2), context2));
    }
    if (construct.resolveTo) {
      context2.events = construct.resolveTo(context2.events, context2);
    }
  }
  function store() {
    var startPoint = now2();
    var startPrevious = context2.previous;
    var startCurrentConstruct = context2.currentConstruct;
    var startEventsIndex = context2.events.length;
    var startStack = Array.from(stack);
    return {
      restore: restore2,
      from: startEventsIndex
    };
    function restore2() {
      point2 = startPoint;
      context2.previous = startPrevious;
      context2.currentConstruct = startCurrentConstruct;
      context2.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point2.line in columnStart && point2.column < 2) {
      point2.column = columnStart[point2.line];
      point2.offset += columnStart[point2.line] - 1;
    }
  }
}
var createTokenizer_1 = createTokenizer$1;
var constructs$1 = {};
function markdownLineEndingOrSpace$8(code) {
  return code < 0 || code === 32;
}
var markdownLineEndingOrSpace_1 = markdownLineEndingOrSpace$8;
var unicodePunctuation$2 = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var unicodePunctuationRegex$2 = unicodePunctuation$2;
var fromCharCode$2 = fromCharCode_1;
function regexCheck$9(regex) {
  return check;
  function check(code) {
    return regex.test(fromCharCode$2(code));
  }
}
var regexCheck_1 = regexCheck$9;
var unicodePunctuationRegex$1 = unicodePunctuationRegex$2;
var regexCheck$8 = regexCheck_1;
var unicodePunctuation$1 = regexCheck$8(unicodePunctuationRegex$1);
var unicodePunctuation_1 = unicodePunctuation$1;
var regexCheck$7 = regexCheck_1;
var unicodeWhitespace$1 = regexCheck$7(/\s/);
var unicodeWhitespace_1 = unicodeWhitespace$1;
var markdownLineEndingOrSpace$7 = markdownLineEndingOrSpace_1;
var unicodePunctuation = unicodePunctuation_1;
var unicodeWhitespace = unicodeWhitespace_1;
function classifyCharacter$1(code) {
  if (code === null || markdownLineEndingOrSpace$7(code) || unicodeWhitespace(code)) {
    return 1;
  }
  if (unicodePunctuation(code)) {
    return 2;
  }
}
var classifyCharacter_1 = classifyCharacter$1;
function movePoint$1(point2, offset3) {
  point2.column += offset3;
  point2.offset += offset3;
  point2._bufferIndex += offset3;
  return point2;
}
var movePoint_1 = movePoint$1;
var chunkedPush$1 = chunkedPush_1;
var chunkedSplice$3 = chunkedSplice_1;
var classifyCharacter = classifyCharacter_1;
var movePoint = movePoint_1;
var resolveAll$1 = resolveAll_1;
var shallow$2 = shallow_1;
var attention$1 = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context2) {
  var index2 = -1;
  var open;
  var group;
  var text2;
  var openingSequence;
  var closingSequence;
  var use;
  var nextEvents;
  var offset3;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && context2.sliceSerialize(events[open][1]).charCodeAt(0) === context2.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: movePoint(shallow$2(events[open][1].end), -use),
            end: shallow$2(events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: shallow$2(events[index2][1].start),
            end: movePoint(shallow$2(events[index2][1].start), use)
          };
          text2 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: shallow$2(events[open][1].end),
            end: shallow$2(events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: shallow$2(openingSequence.start),
            end: shallow$2(closingSequence.end)
          };
          events[open][1].end = shallow$2(openingSequence.start);
          events[index2][1].start = shallow$2(closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = chunkedPush$1(nextEvents, [
              ["enter", events[open][1], context2],
              ["exit", events[open][1], context2]
            ]);
          }
          nextEvents = chunkedPush$1(nextEvents, [
            ["enter", group, context2],
            ["enter", openingSequence, context2],
            ["exit", openingSequence, context2],
            ["enter", text2, context2]
          ]);
          nextEvents = chunkedPush$1(nextEvents, resolveAll$1(context2.parser.constructs.insideSpan.null, events.slice(open + 1, index2), context2));
          nextEvents = chunkedPush$1(nextEvents, [
            ["exit", text2, context2],
            ["enter", closingSequence, context2],
            ["exit", closingSequence, context2],
            ["exit", group, context2]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset3 = 2;
            nextEvents = chunkedPush$1(nextEvents, [
              ["enter", events[index2][1], context2],
              ["exit", events[index2][1], context2]
            ]);
          } else {
            offset3 = 0;
          }
          chunkedSplice$3(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset3 - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok2) {
  var before = classifyCharacter(this.previous);
  var marker;
  return start;
  function start(code) {
    effects.enter("attentionSequence");
    marker = code;
    return sequence(code);
  }
  function sequence(code) {
    var token;
    var after;
    var open;
    var close3;
    if (code === marker) {
      effects.consume(code);
      return sequence;
    }
    token = effects.exit("attentionSequence");
    after = classifyCharacter(code);
    open = !after || after === 2 && before;
    close3 = !before || before === 2 && after;
    token._open = marker === 42 ? open : open && (before || !close3);
    token._close = marker === 42 ? close3 : close3 && (after || !open);
    return ok2(code);
  }
}
var attention_1 = attention$1;
var regexCheck$6 = regexCheck_1;
var asciiAlpha$3 = regexCheck$6(/[A-Za-z]/);
var asciiAlpha_1 = asciiAlpha$3;
var regexCheck$5 = regexCheck_1;
var asciiAlphanumeric$4 = regexCheck$5(/[\dA-Za-z]/);
var asciiAlphanumeric_1 = asciiAlphanumeric$4;
var regexCheck$4 = regexCheck_1;
var asciiAtext$1 = regexCheck$4(/[#-'*+\--9=?A-Z^-~]/);
var asciiAtext_1 = asciiAtext$1;
function asciiControl$2(code) {
  return code < 32 || code === 127;
}
var asciiControl_1 = asciiControl$2;
var asciiAlpha$2 = asciiAlpha_1;
var asciiAlphanumeric$3 = asciiAlphanumeric_1;
var asciiAtext = asciiAtext_1;
var asciiControl$1 = asciiControl_1;
var autolink$1 = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok2, nok) {
  var size = 1;
  return start;
  function start(code) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code) {
    if (asciiAlpha$2(code)) {
      effects.consume(code);
      return schemeOrEmailAtext;
    }
    return asciiAtext(code) ? emailAtext(code) : nok(code);
  }
  function schemeOrEmailAtext(code) {
    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric$3(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);
  }
  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code);
      return urlInside;
    }
    if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric$3(code)) && size++ < 32) {
      effects.consume(code);
      return schemeInsideOrEmailAtext;
    }
    return emailAtext(code);
  }
  function urlInside(code) {
    if (code === 62) {
      effects.exit("autolinkProtocol");
      return end(code);
    }
    if (code === 32 || code === 60 || asciiControl$1(code)) {
      return nok(code);
    }
    effects.consume(code);
    return urlInside;
  }
  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot;
    }
    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext;
    }
    return nok(code);
  }
  function emailAtSignOrDot(code) {
    return asciiAlphanumeric$3(code) ? emailLabel(code) : nok(code);
  }
  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      return end(code);
    }
    return emailValue(code);
  }
  function emailValue(code) {
    if ((code === 45 || asciiAlphanumeric$3(code)) && size++ < 63) {
      effects.consume(code);
      return code === 45 ? emailValue : emailLabel;
    }
    return nok(code);
  }
  function end(code) {
    effects.enter("autolinkMarker");
    effects.consume(code);
    effects.exit("autolinkMarker");
    effects.exit("autolink");
    return ok2;
  }
}
var autolink_1 = autolink$1;
var markdownSpace$8 = markdownSpace_1;
var factorySpace$b = factorySpace$h;
var blockQuote$1 = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok2, nok) {
  var self2 = this;
  return start;
  function start(code) {
    if (code === 62) {
      if (!self2.containerState.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        self2.containerState.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    if (markdownSpace$8(code)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok2;
    }
    effects.exit("blockQuotePrefix");
    return ok2(code);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
  return factorySpace$b(effects, effects.attempt(blockQuote$1, ok2, nok), "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
}
function exit(effects) {
  effects.exit("blockQuote");
}
var blockQuote_1 = blockQuote$1;
var regexCheck$3 = regexCheck_1;
var asciiPunctuation$1 = regexCheck$3(/[!-/:-@[-`{-~]/);
var asciiPunctuation_1 = asciiPunctuation$1;
var asciiPunctuation = asciiPunctuation_1;
var characterEscape$1 = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code);
    effects.exit("escapeMarker");
    return open;
  }
  function open(code) {
    if (asciiPunctuation(code)) {
      effects.enter("characterEscapeValue");
      effects.consume(code);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok2;
    }
    return nok(code);
  }
}
var characterEscape_1 = characterEscape$1;
var el;
var semicolon$1 = 59;
var decodeEntity_browser = decodeEntity$2;
function decodeEntity$2(characters) {
  var entity = "&" + characters + ";";
  var char;
  el = el || document.createElement("i");
  el.innerHTML = entity;
  char = el.textContent;
  if (char.charCodeAt(char.length - 1) === semicolon$1 && characters !== "semi") {
    return false;
  }
  return char === entity ? false : char;
}
var regexCheck$2 = regexCheck_1;
var asciiDigit$2 = regexCheck$2(/\d/);
var asciiDigit_1 = asciiDigit$2;
var regexCheck$1 = regexCheck_1;
var asciiHexDigit$1 = regexCheck$1(/[\dA-Fa-f]/);
var asciiHexDigit_1 = asciiHexDigit$1;
var decodeEntity$1 = decodeEntity_browser;
var asciiAlphanumeric$2 = asciiAlphanumeric_1;
var asciiDigit$1 = asciiDigit_1;
var asciiHexDigit = asciiHexDigit_1;
function _interopDefaultLegacy(e2) {
  return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { default: e2 };
}
var decodeEntity__default = /* @__PURE__ */ _interopDefaultLegacy(decodeEntity$1);
var characterReference$1 = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok2, nok) {
  var self2 = this;
  var size = 0;
  var max;
  var test;
  return start;
  function start(code) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code) {
    if (code === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric$2;
    return value2(code);
  }
  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value2;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit$1;
    return value2(code);
  }
  function value2(code) {
    var token;
    if (code === 59 && size) {
      token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric$2 && !decodeEntity__default["default"](self2.sliceSerialize(token))) {
        return nok(code);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok2;
    }
    if (test(code) && size++ < max) {
      effects.consume(code);
      return value2;
    }
    return nok(code);
  }
}
var characterReference_1 = characterReference$1;
var markdownLineEnding$e = markdownLineEnding_1;
var markdownLineEndingOrSpace$6 = markdownLineEndingOrSpace_1;
var prefixSize$2 = prefixSize_1;
var factorySpace$a = factorySpace$h;
var codeFenced$1 = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok2, nok) {
  var self2 = this;
  var closingFenceConstruct = {
    tokenize: tokenizeClosingFence,
    partial: true
  };
  var initialPrefix = prefixSize$2(this.events, "linePrefix");
  var sizeOpen = 0;
  var marker;
  return start;
  function start(code) {
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    marker = code;
    return sequenceOpen(code);
  }
  function sequenceOpen(code) {
    if (code === marker) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeFencedFenceSequence");
    return sizeOpen < 3 ? nok(code) : factorySpace$a(effects, infoOpen, "whitespace")(code);
  }
  function infoOpen(code) {
    if (code === null || markdownLineEnding$e(code)) {
      return openAfter(code);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info2(code);
  }
  function info2(code) {
    if (code === null || markdownLineEndingOrSpace$6(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace$a(effects, infoAfter, "whitespace")(code);
    }
    if (code === 96 && code === marker)
      return nok(code);
    effects.consume(code);
    return info2;
  }
  function infoAfter(code) {
    if (code === null || markdownLineEnding$e(code)) {
      return openAfter(code);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code);
  }
  function meta(code) {
    if (code === null || markdownLineEnding$e(code)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return openAfter(code);
    }
    if (code === 96 && code === marker)
      return nok(code);
    effects.consume(code);
    return meta;
  }
  function openAfter(code) {
    effects.exit("codeFencedFence");
    return self2.interrupt ? ok2(code) : content2(code);
  }
  function content2(code) {
    if (code === null) {
      return after(code);
    }
    if (markdownLineEnding$e(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace$a(effects, content2, "linePrefix", initialPrefix + 1) : content2);
    }
    effects.enter("codeFlowValue");
    return contentContinue(code);
  }
  function contentContinue(code) {
    if (code === null || markdownLineEnding$e(code)) {
      effects.exit("codeFlowValue");
      return content2(code);
    }
    effects.consume(code);
    return contentContinue;
  }
  function after(code) {
    effects.exit("codeFenced");
    return ok2(code);
  }
  function tokenizeClosingFence(effects2, ok3, nok2) {
    var size = 0;
    return factorySpace$a(effects2, closingSequenceStart, "linePrefix", this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
    function closingSequenceStart(code) {
      effects2.enter("codeFencedFence");
      effects2.enter("codeFencedFenceSequence");
      return closingSequence(code);
    }
    function closingSequence(code) {
      if (code === marker) {
        effects2.consume(code);
        size++;
        return closingSequence;
      }
      if (size < sizeOpen)
        return nok2(code);
      effects2.exit("codeFencedFenceSequence");
      return factorySpace$a(effects2, closingSequenceEnd, "whitespace")(code);
    }
    function closingSequenceEnd(code) {
      if (code === null || markdownLineEnding$e(code)) {
        effects2.exit("codeFencedFence");
        return ok3(code);
      }
      return nok2(code);
    }
  }
}
var codeFenced_1 = codeFenced$1;
var markdownLineEnding$d = markdownLineEnding_1;
var chunkedSplice$2 = chunkedSplice_1;
var prefixSize$1 = prefixSize_1;
var factorySpace$9 = factorySpace$h;
var codeIndented$1 = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented,
  resolve: resolveCodeIndented
};
var indentedContentConstruct = {
  tokenize: tokenizeIndentedContent,
  partial: true
};
function resolveCodeIndented(events, context2) {
  var code = {
    type: "codeIndented",
    start: events[0][1].start,
    end: events[events.length - 1][1].end
  };
  chunkedSplice$2(events, 0, 0, [["enter", code, context2]]);
  chunkedSplice$2(events, events.length, 0, [["exit", code, context2]]);
  return events;
}
function tokenizeCodeIndented(effects, ok2, nok) {
  return effects.attempt(indentedContentConstruct, afterPrefix, nok);
  function afterPrefix(code) {
    if (code === null) {
      return ok2(code);
    }
    if (markdownLineEnding$d(code)) {
      return effects.attempt(indentedContentConstruct, afterPrefix, ok2)(code);
    }
    effects.enter("codeFlowValue");
    return content2(code);
  }
  function content2(code) {
    if (code === null || markdownLineEnding$d(code)) {
      effects.exit("codeFlowValue");
      return afterPrefix(code);
    }
    effects.consume(code);
    return content2;
  }
}
function tokenizeIndentedContent(effects, ok2, nok) {
  var self2 = this;
  return factorySpace$9(effects, afterPrefix, "linePrefix", 4 + 1);
  function afterPrefix(code) {
    if (markdownLineEnding$d(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace$9(effects, afterPrefix, "linePrefix", 4 + 1);
    }
    return prefixSize$1(self2.events, "linePrefix") < 4 ? nok(code) : ok2(code);
  }
}
var codeIndented_1 = codeIndented$1;
var markdownLineEnding$c = markdownLineEnding_1;
var codeText$1 = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  var tailExitIndex = events.length - 4;
  var headEnterIndex = 3;
  var index2;
  var enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[tailExitIndex][1].type = events[headEnterIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code) {
  return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok2, nok) {
  var sizeOpen = 0;
  var size;
  var token;
  return start;
  function start(code) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return openingSequence(code);
  }
  function openingSequence(code) {
    if (code === 96) {
      effects.consume(code);
      sizeOpen++;
      return openingSequence;
    }
    effects.exit("codeTextSequence");
    return gap(code);
  }
  function gap(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return closingSequence(code);
    }
    if (code === 32) {
      effects.enter("space");
      effects.consume(code);
      effects.exit("space");
      return gap;
    }
    if (markdownLineEnding$c(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return gap;
    }
    effects.enter("codeTextData");
    return data2(code);
  }
  function data2(code) {
    if (code === null || code === 32 || code === 96 || markdownLineEnding$c(code)) {
      effects.exit("codeTextData");
      return gap(code);
    }
    effects.consume(code);
    return data2;
  }
  function closingSequence(code) {
    if (code === 96) {
      effects.consume(code);
      size++;
      return closingSequence;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok2(code);
    }
    token.type = "codeTextData";
    return data2(code);
  }
}
var codeText_1 = codeText$1;
var asciiControl = asciiControl_1;
var markdownLineEndingOrSpace$5 = markdownLineEndingOrSpace_1;
var markdownLineEnding$b = markdownLineEnding_1;
function destinationFactory(effects, ok2, nok, type4, literalType, literalMarkerType, rawType, stringType, max) {
  var limit2 = max || Infinity;
  var balance = 0;
  return start;
  function start(code) {
    if (code === 60) {
      effects.enter(type4);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return destinationEnclosedBefore;
    }
    if (asciiControl(code) || code === 41) {
      return nok(code);
    }
    effects.enter(type4);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationRaw(code);
  }
  function destinationEnclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type4);
      return ok2;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return destinationEnclosed(code);
  }
  function destinationEnclosed(code) {
    if (code === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return destinationEnclosedBefore(code);
    }
    if (code === null || code === 60 || markdownLineEnding$b(code)) {
      return nok(code);
    }
    effects.consume(code);
    return code === 92 ? destinationEnclosedEscape : destinationEnclosed;
  }
  function destinationEnclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code);
      return destinationEnclosed;
    }
    return destinationEnclosed(code);
  }
  function destinationRaw(code) {
    if (code === 40) {
      if (++balance > limit2)
        return nok(code);
      effects.consume(code);
      return destinationRaw;
    }
    if (code === 41) {
      if (!balance--) {
        effects.exit("chunkString");
        effects.exit(stringType);
        effects.exit(rawType);
        effects.exit(type4);
        return ok2(code);
      }
      effects.consume(code);
      return destinationRaw;
    }
    if (code === null || markdownLineEndingOrSpace$5(code)) {
      if (balance)
        return nok(code);
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type4);
      return ok2(code);
    }
    if (asciiControl(code))
      return nok(code);
    effects.consume(code);
    return code === 92 ? destinationRawEscape : destinationRaw;
  }
  function destinationRawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code);
      return destinationRaw;
    }
    return destinationRaw(code);
  }
}
var factoryDestination$2 = destinationFactory;
var markdownLineEnding$a = markdownLineEnding_1;
var markdownSpace$7 = markdownSpace_1;
function labelFactory(effects, ok2, nok, type4, markerType, stringType) {
  var self2 = this;
  var size = 0;
  var data2;
  return start;
  function start(code) {
    effects.enter(type4);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code) {
    if (code === null || code === 91 || code === 93 && !data2 || code === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs || size > 999) {
      return nok(code);
    }
    if (code === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type4);
      return ok2;
    }
    if (markdownLineEnding$a(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return label(code);
  }
  function label(code) {
    if (code === null || code === 91 || code === 93 || markdownLineEnding$a(code) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code);
    }
    effects.consume(code);
    data2 = data2 || !markdownSpace$7(code);
    return code === 92 ? labelEscape : label;
  }
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return label;
    }
    return label(code);
  }
}
var factoryLabel$2 = labelFactory;
var markdownLineEnding$9 = markdownLineEnding_1;
var markdownSpace$6 = markdownSpace_1;
var factorySpace$8 = factorySpace$h;
function whitespaceFactory(effects, ok2) {
  var seen;
  return start;
  function start(code) {
    if (markdownLineEnding$9(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      seen = true;
      return start;
    }
    if (markdownSpace$6(code)) {
      return factorySpace$8(effects, start, seen ? "linePrefix" : "lineSuffix")(code);
    }
    return ok2(code);
  }
}
var factoryWhitespace$2 = whitespaceFactory;
var markdownLineEnding$8 = markdownLineEnding_1;
var factorySpace$7 = factorySpace$h;
function titleFactory(effects, ok2, nok, type4, markerType, stringType) {
  var marker;
  return start;
  function start(code) {
    effects.enter(type4);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    marker = code === 40 ? 41 : code;
    return atFirstTitleBreak;
  }
  function atFirstTitleBreak(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type4);
      return ok2;
    }
    effects.enter(stringType);
    return atTitleBreak(code);
  }
  function atTitleBreak(code) {
    if (code === marker) {
      effects.exit(stringType);
      return atFirstTitleBreak(marker);
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding$8(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return factorySpace$7(effects, atTitleBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return title(code);
  }
  function title(code) {
    if (code === marker || code === null || markdownLineEnding$8(code)) {
      effects.exit("chunkString");
      return atTitleBreak(code);
    }
    effects.consume(code);
    return code === 92 ? titleEscape : title;
  }
  function titleEscape(code) {
    if (code === marker || code === 92) {
      effects.consume(code);
      return title;
    }
    return title(code);
  }
}
var factoryTitle$2 = titleFactory;
var markdownLineEnding$7 = markdownLineEnding_1;
var markdownLineEndingOrSpace$4 = markdownLineEndingOrSpace_1;
var normalizeIdentifier$2 = normalizeIdentifier_1;
var factoryDestination$1 = factoryDestination$2;
var factoryLabel$1 = factoryLabel$2;
var factorySpace$6 = factorySpace$h;
var factoryWhitespace$1 = factoryWhitespace$2;
var factoryTitle$1 = factoryTitle$2;
var definition$1 = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleConstruct = {
  tokenize: tokenizeTitle,
  partial: true
};
function tokenizeDefinition(effects, ok2, nok) {
  var self2 = this;
  var identifier;
  return start;
  function start(code) {
    effects.enter("definition");
    return factoryLabel$1.call(self2, effects, labelAfter, nok, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(code);
  }
  function labelAfter(code) {
    identifier = normalizeIdentifier$2(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1));
    if (code === 58) {
      effects.enter("definitionMarker");
      effects.consume(code);
      effects.exit("definitionMarker");
      return factoryWhitespace$1(effects, factoryDestination$1(effects, effects.attempt(titleConstruct, factorySpace$6(effects, after, "whitespace"), factorySpace$6(effects, after, "whitespace")), nok, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString"));
    }
    return nok(code);
  }
  function after(code) {
    if (code === null || markdownLineEnding$7(code)) {
      effects.exit("definition");
      if (self2.parser.defined.indexOf(identifier) < 0) {
        self2.parser.defined.push(identifier);
      }
      return ok2(code);
    }
    return nok(code);
  }
}
function tokenizeTitle(effects, ok2, nok) {
  return start;
  function start(code) {
    return markdownLineEndingOrSpace$4(code) ? factoryWhitespace$1(effects, before)(code) : nok(code);
  }
  function before(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle$1(effects, factorySpace$6(effects, after, "whitespace"), nok, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(code);
    }
    return nok(code);
  }
  function after(code) {
    return code === null || markdownLineEnding$7(code) ? ok2(code) : nok(code);
  }
}
var definition_1 = definition$1;
var markdownLineEnding$6 = markdownLineEnding_1;
var hardBreakEscape$1 = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("hardBreakEscape");
    effects.enter("escapeMarker");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (markdownLineEnding$6(code)) {
      effects.exit("escapeMarker");
      effects.exit("hardBreakEscape");
      return ok2(code);
    }
    return nok(code);
  }
}
var hardBreakEscape_1 = hardBreakEscape$1;
var markdownLineEnding$5 = markdownLineEnding_1;
var markdownLineEndingOrSpace$3 = markdownLineEndingOrSpace_1;
var markdownSpace$5 = markdownSpace_1;
var chunkedSplice$1 = chunkedSplice_1;
var factorySpace$5 = factorySpace$h;
var headingAtx$1 = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context2) {
  var contentEnd = events.length - 2;
  var contentStart = 3;
  var content2;
  var text2;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content2 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text2 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    chunkedSplice$1(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content2, context2],
      ["enter", text2, context2],
      ["exit", text2, context2],
      ["exit", content2, context2]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
  var self2 = this;
  var size = 0;
  return start;
  function start(code) {
    effects.enter("atxHeading");
    effects.enter("atxHeadingSequence");
    return fenceOpenInside(code);
  }
  function fenceOpenInside(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code);
      return fenceOpenInside;
    }
    if (code === null || markdownLineEndingOrSpace$3(code)) {
      effects.exit("atxHeadingSequence");
      return self2.interrupt ? ok2(code) : headingBreak(code);
    }
    return nok(code);
  }
  function headingBreak(code) {
    if (code === 35) {
      effects.enter("atxHeadingSequence");
      return sequence(code);
    }
    if (code === null || markdownLineEnding$5(code)) {
      effects.exit("atxHeading");
      return ok2(code);
    }
    if (markdownSpace$5(code)) {
      return factorySpace$5(effects, headingBreak, "whitespace")(code);
    }
    effects.enter("atxHeadingText");
    return data2(code);
  }
  function sequence(code) {
    if (code === 35) {
      effects.consume(code);
      return sequence;
    }
    effects.exit("atxHeadingSequence");
    return headingBreak(code);
  }
  function data2(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace$3(code)) {
      effects.exit("atxHeadingText");
      return headingBreak(code);
    }
    effects.consume(code);
    return data2;
  }
}
var headingAtx_1 = headingAtx$1;
var basics = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlBlockNames$1 = basics;
var raws = ["pre", "script", "style", "textarea"];
var htmlRawNames$1 = raws;
var asciiAlpha$1 = asciiAlpha_1;
var asciiAlphanumeric$1 = asciiAlphanumeric_1;
var markdownLineEnding$4 = markdownLineEnding_1;
var markdownLineEndingOrSpace$2 = markdownLineEndingOrSpace_1;
var markdownSpace$4 = markdownSpace_1;
var fromCharCode$1 = fromCharCode_1;
var htmlBlockNames = htmlBlockNames$1;
var htmlRawNames = htmlRawNames$1;
var partialBlankLine$1 = partialBlankLine_1;
var htmlFlow$1 = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var nextBlankConstruct = {
  tokenize: tokenizeNextBlank,
  partial: true
};
function resolveToHtmlFlow(events) {
  var index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
  var self2 = this;
  var kind;
  var startTag;
  var buffer2;
  var index2;
  var marker;
  return start;
  function start(code) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationStart;
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      kind = 3;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      buffer2 = fromCharCode$1(code);
      startTag = true;
      return tagName;
    }
    return nok(code);
  }
  function declarationStart(code) {
    if (code === 45) {
      effects.consume(code);
      kind = 2;
      return commentOpenInside;
    }
    if (code === 91) {
      effects.consume(code);
      kind = 5;
      buffer2 = "CDATA[";
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      kind = 4;
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code);
  }
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return self2.interrupt ? ok2 : continuationDeclarationInside;
    }
    return nok(code);
  }
  function cdataOpenInside(code) {
    if (code === buffer2.charCodeAt(index2++)) {
      effects.consume(code);
      return index2 === buffer2.length ? self2.interrupt ? ok2 : continuation : cdataOpenInside;
    }
    return nok(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha$1(code)) {
      effects.consume(code);
      buffer2 = fromCharCode$1(code);
      return tagName;
    }
    return nok(code);
  }
  function tagName(code) {
    if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace$2(code)) {
      if (code !== 47 && startTag && htmlRawNames.indexOf(buffer2.toLowerCase()) > -1) {
        kind = 1;
        return self2.interrupt ? ok2(code) : continuation(code);
      }
      if (htmlBlockNames.indexOf(buffer2.toLowerCase()) > -1) {
        kind = 6;
        if (code === 47) {
          effects.consume(code);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok2(code) : continuation(code);
      }
      kind = 7;
      return self2.interrupt ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);
    }
    if (code === 45 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      buffer2 += fromCharCode$1(code);
      return tagName;
    }
    return nok(code);
  }
  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code);
      return self2.interrupt ? ok2 : continuation;
    }
    return nok(code);
  }
  function completeClosingTagAfter(code) {
    if (markdownSpace$4(code)) {
      effects.consume(code);
      return completeClosingTagAfter;
    }
    return completeEnd(code);
  }
  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code);
      return completeEnd;
    }
    if (code === 58 || code === 95 || asciiAlpha$1(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    if (markdownSpace$4(code)) {
      effects.consume(code);
      return completeAttributeNameBefore;
    }
    return completeEnd(code);
  }
  function completeAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric$1(code)) {
      effects.consume(code);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code);
  }
  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    if (markdownSpace$4(code)) {
      effects.consume(code);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code);
  }
  function completeAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace$4(code)) {
      effects.consume(code);
      return completeAttributeValueBefore;
    }
    marker = void 0;
    return completeAttributeValueUnquoted(code);
  }
  function completeAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      return completeAttributeValueQuotedAfter;
    }
    if (code === null || markdownLineEnding$4(code)) {
      return nok(code);
    }
    effects.consume(code);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace$2(code)) {
      return completeAttributeNameAfter(code);
    }
    effects.consume(code);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace$4(code)) {
      return completeAttributeNameBefore(code);
    }
    return nok(code);
  }
  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code);
      return completeAfter;
    }
    return nok(code);
  }
  function completeAfter(code) {
    if (markdownSpace$4(code)) {
      effects.consume(code);
      return completeAfter;
    }
    return code === null || markdownLineEnding$4(code) ? continuation(code) : nok(code);
  }
  function continuation(code) {
    if (code === 45 && kind === 2) {
      effects.consume(code);
      return continuationCommentInside;
    }
    if (code === 60 && kind === 1) {
      effects.consume(code);
      return continuationRawTagOpen;
    }
    if (code === 62 && kind === 4) {
      effects.consume(code);
      return continuationClose;
    }
    if (code === 63 && kind === 3) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    if (code === 93 && kind === 5) {
      effects.consume(code);
      return continuationCharacterDataInside;
    }
    if (markdownLineEnding$4(code) && (kind === 6 || kind === 7)) {
      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code);
    }
    if (code === null || markdownLineEnding$4(code)) {
      return continuationAtLineEnding(code);
    }
    effects.consume(code);
    return continuation;
  }
  function continuationAtLineEnding(code) {
    effects.exit("htmlFlowData");
    return htmlContinueStart(code);
  }
  function htmlContinueStart(code) {
    if (code === null) {
      return done(code);
    }
    if (markdownLineEnding$4(code)) {
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return htmlContinueStart;
    }
    effects.enter("htmlFlowData");
    return continuation(code);
  }
  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationRawEndTag(code) {
    if (code === 62 && htmlRawNames.indexOf(buffer2.toLowerCase()) > -1) {
      effects.consume(code);
      return continuationClose;
    }
    if (asciiAlpha$1(code) && buffer2.length < 8) {
      effects.consume(code);
      buffer2 += fromCharCode$1(code);
      return continuationRawEndTag;
    }
    return continuation(code);
  }
  function continuationCharacterDataInside(code) {
    if (code === 93) {
      effects.consume(code);
      return continuationDeclarationInside;
    }
    return continuation(code);
  }
  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code);
      return continuationClose;
    }
    return continuation(code);
  }
  function continuationClose(code) {
    if (code === null || markdownLineEnding$4(code)) {
      effects.exit("htmlFlowData");
      return done(code);
    }
    effects.consume(code);
    return continuationClose;
  }
  function done(code) {
    effects.exit("htmlFlow");
    return ok2(code);
  }
}
function tokenizeNextBlank(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.exit("htmlFlowData");
    effects.enter("lineEndingBlank");
    effects.consume(code);
    effects.exit("lineEndingBlank");
    return effects.attempt(partialBlankLine$1, ok2, nok);
  }
}
var htmlFlow_1 = htmlFlow$1;
var asciiAlpha = asciiAlpha_1;
var asciiAlphanumeric = asciiAlphanumeric_1;
var markdownLineEnding$3 = markdownLineEnding_1;
var markdownLineEndingOrSpace$1 = markdownLineEndingOrSpace_1;
var markdownSpace$3 = markdownSpace_1;
var factorySpace$4 = factorySpace$h;
var htmlText$1 = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok2, nok) {
  var self2 = this;
  var marker;
  var buffer2;
  var index2;
  var returnState;
  return start;
  function start(code) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code);
    return open;
  }
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen;
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart;
    }
    if (code === 63) {
      effects.consume(code);
      return instruction;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagOpen;
    }
    return nok(code);
  }
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentOpen;
    }
    if (code === 91) {
      effects.consume(code);
      buffer2 = "CDATA[";
      index2 = 0;
      return cdataOpen;
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return declaration;
    }
    return nok(code);
  }
  function commentOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentStart;
    }
    return nok(code);
  }
  function commentStart(code) {
    if (code === null || code === 62) {
      return nok(code);
    }
    if (code === 45) {
      effects.consume(code);
      return commentStartDash;
    }
    return comment(code);
  }
  function commentStartDash(code) {
    if (code === null || code === 62) {
      return nok(code);
    }
    return comment(code);
  }
  function comment(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 45) {
      effects.consume(code);
      return commentClose;
    }
    if (markdownLineEnding$3(code)) {
      returnState = comment;
      return atLineEnding(code);
    }
    effects.consume(code);
    return comment;
  }
  function commentClose(code) {
    if (code === 45) {
      effects.consume(code);
      return end;
    }
    return comment(code);
  }
  function cdataOpen(code) {
    if (code === buffer2.charCodeAt(index2++)) {
      effects.consume(code);
      return index2 === buffer2.length ? cdata : cdataOpen;
    }
    return nok(code);
  }
  function cdata(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataClose;
    }
    if (markdownLineEnding$3(code)) {
      returnState = cdata;
      return atLineEnding(code);
    }
    effects.consume(code);
    return cdata;
  }
  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function cdataEnd(code) {
    if (code === 62) {
      return end(code);
    }
    if (code === 93) {
      effects.consume(code);
      return cdataEnd;
    }
    return cdata(code);
  }
  function declaration(code) {
    if (code === null || code === 62) {
      return end(code);
    }
    if (markdownLineEnding$3(code)) {
      returnState = declaration;
      return atLineEnding(code);
    }
    effects.consume(code);
    return declaration;
  }
  function instruction(code) {
    if (code === null) {
      return nok(code);
    }
    if (code === 63) {
      effects.consume(code);
      return instructionClose;
    }
    if (markdownLineEnding$3(code)) {
      returnState = instruction;
      return atLineEnding(code);
    }
    effects.consume(code);
    return instruction;
  }
  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code);
  }
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagClose;
    }
    return nok(code);
  }
  function tagClose(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagClose;
    }
    return tagCloseBetween(code);
  }
  function tagCloseBetween(code) {
    if (markdownLineEnding$3(code)) {
      returnState = tagCloseBetween;
      return atLineEnding(code);
    }
    if (markdownSpace$3(code)) {
      effects.consume(code);
      return tagCloseBetween;
    }
    return end(code);
  }
  function tagOpen(code) {
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpen;
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace$1(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code);
      return end;
    }
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding$3(code)) {
      returnState = tagOpenBetween;
      return atLineEnding(code);
    }
    if (markdownSpace$3(code)) {
      effects.consume(code);
      return tagOpenBetween;
    }
    return end(code);
  }
  function tagOpenAttributeName(code) {
    if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code);
  }
  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding$3(code)) {
      returnState = tagOpenAttributeNameAfter;
      return atLineEnding(code);
    }
    if (markdownSpace$3(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code);
  }
  function tagOpenAttributeValueBefore(code) {
    if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
      return nok(code);
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding$3(code)) {
      returnState = tagOpenAttributeValueBefore;
      return atLineEnding(code);
    }
    if (markdownSpace$3(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code);
    marker = void 0;
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code === null) {
      return nok(code);
    }
    if (markdownLineEnding$3(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return atLineEnding(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 62 || code === 47 || markdownLineEndingOrSpace$1(code)) {
      return tagOpenBetween(code);
    }
    return nok(code);
  }
  function tagOpenAttributeValueUnquoted(code) {
    if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
      return nok(code);
    }
    if (code === 62 || markdownLineEndingOrSpace$1(code)) {
      return tagOpenBetween(code);
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted;
  }
  function atLineEnding(code) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$4(effects, afterPrefix, "linePrefix", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4);
  }
  function afterPrefix(code) {
    effects.enter("htmlTextData");
    return returnState(code);
  }
  function end(code) {
    if (code === 62) {
      effects.consume(code);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok2;
    }
    return nok(code);
  }
}
var htmlText_1 = htmlText$1;
var markdownLineEndingOrSpace = markdownLineEndingOrSpace_1;
var chunkedPush = chunkedPush_1;
var chunkedSplice = chunkedSplice_1;
var normalizeIdentifier$1 = normalizeIdentifier_1;
var resolveAll = resolveAll_1;
var shallow$1 = shallow_1;
var factoryDestination = factoryDestination$2;
var factoryLabel = factoryLabel$2;
var factoryTitle = factoryTitle$2;
var factoryWhitespace = factoryWhitespace$2;
var labelEnd$3 = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var fullReferenceConstruct = {
  tokenize: tokenizeFullReference
};
var collapsedReferenceConstruct = {
  tokenize: tokenizeCollapsedReference
};
function resolveAllLabelEnd(events) {
  var index2 = -1;
  var token;
  while (++index2 < events.length) {
    token = events[index2][1];
    if (!token._used && (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd")) {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context2) {
  var index2 = events.length;
  var offset3 = 0;
  var group;
  var label;
  var text2;
  var token;
  var open;
  var close3;
  var media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close3) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset3 = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close3 = index2;
    }
  }
  group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: shallow$1(events[open][1].start),
    end: shallow$1(events[events.length - 1][1].end)
  };
  label = {
    type: "label",
    start: shallow$1(events[open][1].start),
    end: shallow$1(events[close3][1].end)
  };
  text2 = {
    type: "labelText",
    start: shallow$1(events[open + offset3 + 2][1].end),
    end: shallow$1(events[close3 - 2][1].start)
  };
  media = [
    ["enter", group, context2],
    ["enter", label, context2]
  ];
  media = chunkedPush(media, events.slice(open + 1, open + offset3 + 3));
  media = chunkedPush(media, [["enter", text2, context2]]);
  media = chunkedPush(media, resolveAll(context2.parser.constructs.insideSpan.null, events.slice(open + offset3 + 4, close3 - 3), context2));
  media = chunkedPush(media, [
    ["exit", text2, context2],
    events[close3 - 2],
    events[close3 - 1],
    ["exit", label, context2]
  ]);
  media = chunkedPush(media, events.slice(close3 + 1));
  media = chunkedPush(media, [["exit", group, context2]]);
  chunkedSplice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
  var self2 = this;
  var index2 = self2.events.length;
  var labelStart;
  var defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start;
  function start(code) {
    if (!labelStart) {
      return nok(code);
    }
    if (labelStart._inactive)
      return balanced(code);
    defined = self2.parser.defined.indexOf(normalizeIdentifier$1(self2.sliceSerialize({
      start: labelStart.end,
      end: self2.now()
    }))) > -1;
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return afterLabelEnd;
  }
  function afterLabelEnd(code) {
    if (code === 40) {
      return effects.attempt(resourceConstruct, ok2, defined ? ok2 : balanced)(code);
    }
    if (code === 91) {
      return effects.attempt(fullReferenceConstruct, ok2, defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced)(code);
    }
    return defined ? ok2(code) : balanced(code);
  }
  function balanced(code) {
    labelStart._balanced = true;
    return nok(code);
  }
}
function tokenizeResource(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code);
    effects.exit("resourceMarker");
    return factoryWhitespace(effects, open);
  }
  function open(code) {
    if (code === 41) {
      return end(code);
    }
    return factoryDestination(effects, destinationAfter, nok, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 3)(code);
  }
  function destinationAfter(code) {
    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);
  }
  function between(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(effects, factoryWhitespace(effects, end), nok, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(code);
    }
    return end(code);
  }
  function end(code) {
    if (code === 41) {
      effects.enter("resourceMarker");
      effects.consume(code);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok2;
    }
    return nok(code);
  }
}
function tokenizeFullReference(effects, ok2, nok) {
  var self2 = this;
  return start;
  function start(code) {
    return factoryLabel.call(self2, effects, afterLabel, nok, "reference", "referenceMarker", "referenceString")(code);
  }
  function afterLabel(code) {
    return self2.parser.defined.indexOf(normalizeIdentifier$1(self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1))) < 0 ? nok(code) : ok2(code);
  }
}
function tokenizeCollapsedReference(effects, ok2, nok) {
  return start;
  function start(code) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code);
    effects.exit("referenceMarker");
    return open;
  }
  function open(code) {
    if (code === 93) {
      effects.enter("referenceMarker");
      effects.consume(code);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok2;
    }
    return nok(code);
  }
}
var labelEnd_1 = labelEnd$3;
var labelEnd$2 = labelEnd_1;
var labelStartImage$1 = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd$2.resolveAll
};
function tokenizeLabelStartImage(effects, ok2, nok) {
  var self2 = this;
  return start;
  function start(code) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code) {
    if (code === 91) {
      effects.enter("labelMarker");
      effects.consume(code);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code);
  }
  function after(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok2(code);
  }
}
var labelStartImage_1 = labelStartImage$1;
var labelEnd$1 = labelEnd_1;
var labelStartLink$1 = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd$1.resolveAll
};
function tokenizeLabelStartLink(effects, ok2, nok) {
  var self2 = this;
  return start;
  function start(code) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code) {
    return code === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code) : ok2(code);
  }
}
var labelStartLink_1 = labelStartLink$1;
var factorySpace$3 = factorySpace$h;
var lineEnding$1 = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok2) {
  return start;
  function start(code) {
    effects.enter("lineEnding");
    effects.consume(code);
    effects.exit("lineEnding");
    return factorySpace$3(effects, ok2, "linePrefix");
  }
}
var lineEnding_1 = lineEnding$1;
var markdownLineEnding$2 = markdownLineEnding_1;
var markdownSpace$2 = markdownSpace_1;
var factorySpace$2 = factorySpace$h;
var thematicBreak$2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok2, nok) {
  var size = 0;
  var marker;
  return start;
  function start(code) {
    effects.enter("thematicBreak");
    marker = code;
    return atBreak(code);
  }
  function atBreak(code) {
    if (code === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code);
    }
    if (markdownSpace$2(code)) {
      return factorySpace$2(effects, atBreak, "whitespace")(code);
    }
    if (size < 3 || code !== null && !markdownLineEnding$2(code)) {
      return nok(code);
    }
    effects.exit("thematicBreak");
    return ok2(code);
  }
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return atBreak(code);
  }
}
var thematicBreak_1 = thematicBreak$2;
var asciiDigit = asciiDigit_1;
var markdownSpace$1 = markdownSpace_1;
var prefixSize = prefixSize_1;
var sizeChunks = sizeChunks_1;
var factorySpace$1 = factorySpace$h;
var partialBlankLine = partialBlankLine_1;
var thematicBreak$1 = thematicBreak_1;
var list$1 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok2, nok) {
  var self2 = this;
  var initialSize = prefixSize(self2.events, "linePrefix");
  var size = 0;
  return start;
  function start(code) {
    var kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code === 42 || code === 45 ? effects.check(thematicBreak$1, nok, atMarker)(code) : atMarker(code);
      }
      if (!self2.interrupt || code === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code);
      }
    }
    return nok(code);
  }
  function inside(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {
      effects.exit("listItemValue");
      return atMarker(code);
    }
    return nok(code);
  }
  function atMarker(code) {
    effects.enter("listItemMarker");
    effects.consume(code);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code;
    return effects.check(partialBlankLine, self2.interrupt ? nok : onBlank, effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix));
  }
  function onBlank(code) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code);
  }
  function otherPrefix(code) {
    if (markdownSpace$1(code)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code);
  }
  function endOfPrefix(code) {
    self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
    return ok2(code);
  }
}
function tokenizeListContinuation(effects, ok2, nok) {
  var self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(partialBlankLine, onBlank, notBlank);
  function onBlank(code) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace$1(effects, ok2, "listItemIndent", self2.containerState.size + 1)(code);
  }
  function notBlank(code) {
    if (self2.containerState.furtherBlankLines || !markdownSpace$1(code)) {
      self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code);
    }
    self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code);
  }
  function notInCurrentItem(code) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace$1(effects, effects.attempt(list$1, ok2, nok), "linePrefix", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4)(code);
  }
}
function tokenizeIndent(effects, ok2, nok) {
  var self2 = this;
  return factorySpace$1(effects, afterPrefix, "listItemIndent", self2.containerState.size + 1);
  function afterPrefix(code) {
    return prefixSize(self2.events, "listItemIndent") === self2.containerState.size ? ok2(code) : nok(code);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
  var self2 = this;
  return factorySpace$1(effects, afterPrefix, "listItemPrefixWhitespace", self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4 + 1);
  function afterPrefix(code) {
    return markdownSpace$1(code) || !prefixSize(self2.events, "listItemPrefixWhitespace") ? nok(code) : ok2(code);
  }
}
var list_1 = list$1;
var markdownLineEnding$1 = markdownLineEnding_1;
var shallow = shallow_1;
var factorySpace = factorySpace$h;
var setextUnderline$1 = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context2) {
  var index2 = events.length;
  var content2;
  var text2;
  var definition2;
  var heading;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content2 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text2 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition2 && events[index2][1].type === "definition") {
        definition2 = index2;
      }
    }
  }
  heading = {
    type: "setextHeading",
    start: shallow(events[text2][1].start),
    end: shallow(events[events.length - 1][1].end)
  };
  events[text2][1].type = "setextHeadingText";
  if (definition2) {
    events.splice(text2, 0, ["enter", heading, context2]);
    events.splice(definition2 + 1, 0, ["exit", events[content2][1], context2]);
    events[content2][1].end = shallow(events[definition2][1].end);
  } else {
    events[content2][1] = heading;
  }
  events.push(["exit", heading, context2]);
  return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
  var self2 = this;
  var index2 = self2.events.length;
  var marker;
  var paragraph;
  while (index2--) {
    if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
      paragraph = self2.events[index2][1].type === "paragraph";
      break;
    }
  }
  return start;
  function start(code) {
    if (!self2.lazy && (self2.interrupt || paragraph)) {
      effects.enter("setextHeadingLine");
      effects.enter("setextHeadingLineSequence");
      marker = code;
      return closingSequence(code);
    }
    return nok(code);
  }
  function closingSequence(code) {
    if (code === marker) {
      effects.consume(code);
      return closingSequence;
    }
    effects.exit("setextHeadingLineSequence");
    return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code);
  }
  function closingSequenceEnd(code) {
    if (code === null || markdownLineEnding$1(code)) {
      effects.exit("setextHeadingLine");
      return ok2(code);
    }
    return nok(code);
  }
}
var setextUnderline_1 = setextUnderline$1;
Object.defineProperty(constructs$1, "__esModule", { value: true });
var text$1 = text$4;
var attention = attention_1;
var autolink = autolink_1;
var blockQuote = blockQuote_1;
var characterEscape = characterEscape_1;
var characterReference = characterReference_1;
var codeFenced = codeFenced_1;
var codeIndented = codeIndented_1;
var codeText = codeText_1;
var definition = definition_1;
var hardBreakEscape = hardBreakEscape_1;
var headingAtx = headingAtx_1;
var htmlFlow = htmlFlow_1;
var htmlText = htmlText_1;
var labelEnd = labelEnd_1;
var labelStartImage = labelStartImage_1;
var labelStartLink = labelStartLink_1;
var lineEnding = lineEnding_1;
var list = list_1;
var setextUnderline = setextUnderline_1;
var thematicBreak = thematicBreak_1;
var document$2 = {
  42: list,
  43: list,
  45: list,
  48: list,
  49: list,
  50: list,
  51: list,
  52: list,
  53: list,
  54: list,
  55: list,
  56: list,
  57: list,
  62: blockQuote
};
var contentInitial = {
  91: definition
};
var flowInitial = {
  "-2": codeIndented,
  "-1": codeIndented,
  32: codeIndented
};
var flow$1 = {
  35: headingAtx,
  42: thematicBreak,
  45: [setextUnderline, thematicBreak],
  60: htmlFlow,
  61: setextUnderline,
  95: thematicBreak,
  96: codeFenced,
  126: codeFenced
};
var string$1 = {
  38: characterReference,
  92: characterEscape
};
var text$2 = {
  "-5": lineEnding,
  "-4": lineEnding,
  "-3": lineEnding,
  33: labelStartImage,
  38: characterReference,
  42: attention,
  60: [autolink, htmlText],
  91: labelStartLink,
  92: [hardBreakEscape, characterEscape],
  93: labelEnd,
  95: attention,
  96: codeText
};
var insideSpan = {
  null: [attention, text$1.resolver]
};
var disable = {
  null: []
};
constructs$1.contentInitial = contentInitial;
constructs$1.disable = disable;
constructs$1.document = document$2;
constructs$1.flow = flow$1;
constructs$1.flowInitial = flowInitial;
constructs$1.insideSpan = insideSpan;
constructs$1.string = string$1;
constructs$1.text = text$2;
var content = content$3;
var document$1 = document$3;
var flow = flow$2;
var text = text$4;
var combineExtensions = combineExtensions_1;
var createTokenizer = createTokenizer_1;
var miniflat = miniflat_1;
var constructs = constructs$1;
function parse$7(options) {
  var settings = options || {};
  var parser2 = {
    defined: [],
    constructs: combineExtensions([constructs].concat(miniflat(settings.extensions))),
    content: create2(content),
    document: create2(document$1),
    flow: create2(flow),
    string: create2(text.string),
    text: create2(text.text)
  };
  return parser2;
  function create2(initializer) {
    return creator;
    function creator(from) {
      return createTokenizer(parser2, initializer, from);
    }
  }
}
var parse_1 = parse$7;
var search$1 = /[\0\t\n\r]/g;
function preprocess() {
  var start = true;
  var column = 1;
  var buffer2 = "";
  var atCarriageReturn;
  return preprocessor2;
  function preprocessor2(value2, encoding, end) {
    var chunks = [];
    var match2;
    var next;
    var startPosition;
    var endPosition;
    var code;
    value2 = buffer2 + value2.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start) {
      if (value2.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = void 0;
    }
    while (startPosition < value2.length) {
      search$1.lastIndex = startPosition;
      match2 = search$1.exec(value2);
      endPosition = match2 ? match2.index : value2.length;
      code = value2.charCodeAt(endPosition);
      if (!match2) {
        buffer2 = value2.slice(startPosition);
        break;
      }
      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value2.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        if (code === 0) {
          chunks.push(65533);
          column++;
        } else if (code === 9) {
          next = Math.ceil(column / 4) * 4;
          chunks.push(-2);
          while (column++ < next)
            chunks.push(-1);
        } else if (code === 10) {
          chunks.push(-4);
          column = 1;
        } else {
          atCarriageReturn = true;
          column = 1;
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn)
        chunks.push(-5);
      if (buffer2)
        chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}
var preprocess_1 = preprocess;
var subtokenize = subtokenize_1;
function postprocess$1(events) {
  while (!subtokenize(events)) {
  }
  return events;
}
var postprocess_1 = postprocess$1;
var dist = fromMarkdown$1;
var toString$2 = mdastUtilToString;
var assign = assign_1;
var own$4 = hasOwnProperty$b;
var normalizeIdentifier = normalizeIdentifier_1;
var safeFromInt = safeFromInt_1;
var parser = parse_1;
var preprocessor = preprocess_1;
var postprocess = postprocess_1;
var decode$1 = decodeEntity_browser;
var stringifyPosition = unistUtilStringifyPosition;
function fromMarkdown$1(value2, encoding, options) {
  if (typeof encoding !== "string") {
    options = encoding;
    encoding = void 0;
  }
  return compiler(options)(postprocess(parser(options).document().write(preprocessor()(value2, encoding, true))));
}
function compiler(options) {
  var settings = options || {};
  var config = configure({
    transforms: [],
    canContainEols: [
      "emphasis",
      "fragment",
      "heading",
      "paragraph",
      "strong"
    ],
    enter: {
      autolink: opener2(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener2(heading),
      blockQuote: opener2(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener2(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener2(codeFlow, buffer2),
      codeText: opener2(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener2(definition2),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener2(emphasis),
      hardBreakEscape: opener2(hardBreak),
      hardBreakTrailing: opener2(hardBreak),
      htmlFlow: opener2(html2, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener2(html2, buffer2),
      htmlTextData: onenterdata,
      image: opener2(image),
      label: buffer2,
      link: opener2(link),
      listItem: opener2(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener2(list2, onenterlistordered),
      listUnordered: opener2(list2),
      paragraph: opener2(paragraph),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener2(heading),
      strong: opener2(strong),
      thematicBreak: opener2(thematicBreak2)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  }, settings.mdastExtensions || []);
  var data2 = {};
  return compile2;
  function compile2(events) {
    var tree = { type: "root", children: [] };
    var stack = [tree];
    var tokenStack = [];
    var listStack = [];
    var index2 = -1;
    var handler2;
    var listStart;
    var context2 = {
      stack,
      tokenStack,
      config,
      enter,
      exit: exit2,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          listStart = listStack.pop(index2);
          index2 = prepareList(events, listStart, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      handler2 = config[events[index2][0]];
      if (own$4.call(handler2, events[index2][1].type)) {
        handler2[events[index2][1].type].call(assign({ sliceSerialize: events[index2][2].sliceSerialize }, context2), events[index2][1]);
      }
    }
    if (tokenStack.length) {
      throw new Error("Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
        start: tokenStack[tokenStack.length - 1].start,
        end: tokenStack[tokenStack.length - 1].end
      }) + ") is still open");
    }
    tree.position = {
      start: point2(events.length ? events[0][1].start : { line: 1, column: 1, offset: 0 }),
      end: point2(events.length ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 })
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start, length) {
    var index2 = start - 1;
    var containerBalance = -1;
    var listSpread = false;
    var listItem2;
    var tailIndex;
    var lineIndex;
    var tailEvent;
    var event;
    var firstBlankLineIndex;
    var atMarker;
    while (++index2 <= length) {
      event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace")
        ;
      else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem2) {
          tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit")
                continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent")
              ;
            else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem2._spread = true;
          }
          listItem2.end = point2(lineIndex ? events[lineIndex][1].start : event[1].end);
          events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem2 = {
            type: "listItem",
            _spread: false,
            start: point2(event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem2, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length;
  }
  function setData(key2, value2) {
    data2[key2] = value2;
  }
  function getData(key2) {
    return data2[key2];
  }
  function point2(d2) {
    return { line: d2.line, column: d2.column, offset: d2.offset };
  }
  function opener2(create2, and) {
    return open;
    function open(token) {
      enter.call(this, create2(token), token);
      if (and)
        and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({ type: "fragment", children: [] });
  }
  function enter(node, token) {
    this.stack[this.stack.length - 1].children.push(node);
    this.stack.push(node);
    this.tokenStack.push(token);
    node.position = { start: point2(token.start) };
    return node;
  }
  function closer(and) {
    return close3;
    function close3(token) {
      if (and)
        and.call(this, token);
      exit2.call(this, token);
    }
  }
  function exit2(token) {
    var node = this.stack.pop();
    var open = this.tokenStack.pop();
    if (!open) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): it\u2019s not open");
    } else if (open.type !== token.type) {
      throw new Error("Cannot close `" + token.type + "` (" + stringifyPosition({ start: token.start, end: token.end }) + "): a different token (`" + open.type + "`, " + stringifyPosition({ start: open.start, end: open.end }) + ") is open");
    }
    node.position.end = point2(token.end);
    return node;
  }
  function resume() {
    return toString$2(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      this.stack[this.stack.length - 2].start = parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].lang = data3;
  }
  function onexitcodefencedfencemeta() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].meta = data3;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside"))
      return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].value = data3;
  }
  function onexitdefinitionlabelstring(token) {
    var label = this.resume();
    this.stack[this.stack.length - 1].label = label;
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].title = data3;
  }
  function onexitdefinitiondestinationstring() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].url = data3;
  }
  function onexitatxheadingsequence(token) {
    if (!this.stack[this.stack.length - 1].depth) {
      this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).length;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    this.stack[this.stack.length - 1].depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    var siblings = this.stack[this.stack.length - 1].children;
    var tail = siblings[siblings.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text2();
      tail.position = { start: point2(token.start) };
      this.stack[this.stack.length - 1].children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    var tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    var context2 = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      context2.children[context2.children.length - 1].position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.indexOf(context2.type) > -1) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].value = data3;
  }
  function onexithtmltext() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].value = data3;
  }
  function onexitcodetext() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].value = data3;
  }
  function onexitlink() {
    var context2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context2.type += "Reference";
      context2.referenceType = getData("referenceType") || "shortcut";
      delete context2.url;
      delete context2.title;
    } else {
      delete context2.identifier;
      delete context2.label;
      delete context2.referenceType;
    }
    setData("referenceType");
  }
  function onexitimage() {
    var context2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      context2.type += "Reference";
      context2.referenceType = getData("referenceType") || "shortcut";
      delete context2.url;
      delete context2.title;
    } else {
      delete context2.identifier;
      delete context2.label;
      delete context2.referenceType;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    this.stack[this.stack.length - 2].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
  }
  function onexitlabel() {
    var fragment = this.stack[this.stack.length - 1];
    var value2 = this.resume();
    this.stack[this.stack.length - 1].label = value2;
    setData("inReference", true);
    if (this.stack[this.stack.length - 1].type === "link") {
      this.stack[this.stack.length - 1].children = fragment.children;
    } else {
      this.stack[this.stack.length - 1].alt = value2;
    }
  }
  function onexitresourcedestinationstring() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].url = data3;
  }
  function onexitresourcetitlestring() {
    var data3 = this.resume();
    this.stack[this.stack.length - 1].title = data3;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    var label = this.resume();
    this.stack[this.stack.length - 1].label = label;
    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    var data3 = this.sliceSerialize(token);
    var type4 = getData("characterReferenceType");
    var value2;
    var tail;
    if (type4) {
      value2 = safeFromInt(data3, type4 === "characterReferenceMarkerNumeric" ? 10 : 16);
      setData("characterReferenceType");
    } else {
      value2 = decode$1(data3);
    }
    tail = this.stack.pop();
    tail.value += value2;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    this.stack[this.stack.length - 1].url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return { type: "blockquote", children: [] };
  }
  function codeFlow() {
    return { type: "code", lang: null, meta: null, value: "" };
  }
  function codeText2() {
    return { type: "inlineCode", value: "" };
  }
  function definition2() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis() {
    return { type: "emphasis", children: [] };
  }
  function heading() {
    return { type: "heading", depth: void 0, children: [] };
  }
  function hardBreak() {
    return { type: "break" };
  }
  function html2() {
    return { type: "html", value: "" };
  }
  function image() {
    return { type: "image", title: null, url: "", alt: null };
  }
  function link() {
    return { type: "link", title: null, url: "", children: [] };
  }
  function list2(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      spread: token._spread,
      children: []
    };
  }
  function listItem(token) {
    return {
      type: "listItem",
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph() {
    return { type: "paragraph", children: [] };
  }
  function strong() {
    return { type: "strong", children: [] };
  }
  function text2() {
    return { type: "text", value: "" };
  }
  function thematicBreak2() {
    return { type: "thematicBreak" };
  }
}
function configure(config, extensions) {
  var index2 = -1;
  while (++index2 < extensions.length) {
    extension(config, extensions[index2]);
  }
  return config;
}
function extension(config, extension2) {
  var key2;
  var left;
  for (key2 in extension2) {
    left = own$4.call(config, key2) ? config[key2] : config[key2] = {};
    if (key2 === "canContainEols" || key2 === "transforms") {
      config[key2] = [].concat(left, extension2[key2]);
    } else {
      Object.assign(left, extension2[key2]);
    }
  }
}
(function(module) {
  module.exports = dist;
})(mdastUtilFromMarkdown);
var remarkParse = parse$6;
var fromMarkdown = mdastUtilFromMarkdown.exports;
function parse$6(options) {
  var self2 = this;
  this.Parser = parse2;
  function parse2(doc) {
    return fromMarkdown(doc, Object.assign({}, self2.data("settings"), options, {
      extensions: self2.data("micromarkExtensions") || [],
      mdastExtensions: self2.data("fromMarkdownExtensions") || []
    }));
  }
}
var unistUtilVisitParents$1 = visitParents$2;
function visitParents$2(tree, type4, visitor) {
  var stack = [];
  if (typeof type4 === "function") {
    visitor = type4;
    type4 = null;
  }
  one(tree);
  function one(node) {
    var result;
    if (!type4 || node.type === type4) {
      result = visitor(node, stack.concat());
    }
    if (node.children && result !== false) {
      return all2(node.children, node);
    }
    return result;
  }
  function all2(children, parent) {
    var length = children.length;
    var index2 = -1;
    var child;
    stack.push(parent);
    while (++index2 < length) {
      child = children[index2];
      if (child && one(child) === false) {
        return false;
      }
    }
    stack.pop();
    return true;
  }
}
var visitWithParents = unistUtilVisitParents$1;
function addListMetadata$1() {
  return function(ast) {
    visitWithParents(ast, "list", function(listNode, parents) {
      var depth = 0, i, n2;
      for (i = 0, n2 = parents.length; i < n2; i++) {
        if (parents[i].type === "list")
          depth += 1;
      }
      for (i = 0, n2 = listNode.children.length; i < n2; i++) {
        var child = listNode.children[i];
        child.index = i;
        child.ordered = listNode.ordered;
      }
      listNode.depth = depth;
    });
    return ast;
  };
}
var mdastAddListMetadata = addListMetadata$1;
var convert_1 = convert$1;
function convert$1(test) {
  if (test == null) {
    return ok;
  }
  if (typeof test === "string") {
    return typeFactory(test);
  }
  if (typeof test === "object") {
    return "length" in test ? anyFactory(test) : allFactory(test);
  }
  if (typeof test === "function") {
    return test;
  }
  throw new Error("Expected function, string, or object as test");
}
function allFactory(test) {
  return all2;
  function all2(node) {
    var key2;
    for (key2 in test) {
      if (node[key2] !== test[key2])
        return false;
    }
    return true;
  }
}
function anyFactory(tests2) {
  var checks2 = [];
  var index2 = -1;
  while (++index2 < tests2.length) {
    checks2[index2] = convert$1(tests2[index2]);
  }
  return any3;
  function any3() {
    var index3 = -1;
    while (++index3 < checks2.length) {
      if (checks2[index3].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  }
}
function typeFactory(test) {
  return type4;
  function type4(node) {
    return Boolean(node && node.type === test);
  }
}
function ok() {
  return true;
}
var color_browser = identity;
function identity(d2) {
  return d2;
}
var unistUtilVisitParents = visitParents$1;
var convert = convert_1;
var color = color_browser;
var CONTINUE$1 = true;
var SKIP$1 = "skip";
var EXIT$1 = false;
visitParents$1.CONTINUE = CONTINUE$1;
visitParents$1.SKIP = SKIP$1;
visitParents$1.EXIT = EXIT$1;
function visitParents$1(tree, test, visitor, reverse) {
  var step;
  var is;
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  is = convert(test);
  step = reverse ? -1 : 1;
  factory2(tree, null, [])();
  function factory2(node, index2, parents) {
    var value2 = typeof node === "object" && node !== null ? node : {};
    var name2;
    if (typeof value2.type === "string") {
      name2 = typeof value2.tagName === "string" ? value2.tagName : typeof value2.name === "string" ? value2.name : void 0;
      visit2.displayName = "node (" + color(value2.type + (name2 ? "<" + name2 + ">" : "")) + ")";
    }
    return visit2;
    function visit2() {
      var grandparents = parents.concat(node);
      var result = [];
      var subresult;
      var offset3;
      if (!test || is(node, index2, parents[parents.length - 1] || null)) {
        result = toResult(visitor(node, parents));
        if (result[0] === EXIT$1) {
          return result;
        }
      }
      if (node.children && result[0] !== SKIP$1) {
        offset3 = (reverse ? node.children.length : -1) + step;
        while (offset3 > -1 && offset3 < node.children.length) {
          subresult = factory2(node.children[offset3], offset3, grandparents)();
          if (subresult[0] === EXIT$1) {
            return subresult;
          }
          offset3 = typeof subresult[1] === "number" ? subresult[1] : offset3 + step;
        }
      }
      return result;
    }
  }
}
function toResult(value2) {
  if (value2 !== null && typeof value2 === "object" && "length" in value2) {
    return value2;
  }
  if (typeof value2 === "number") {
    return [CONTINUE$1, value2];
  }
  return [value2];
}
var unistUtilVisit = visit$4;
var visitParents = unistUtilVisitParents;
var CONTINUE = visitParents.CONTINUE;
var SKIP = visitParents.SKIP;
var EXIT = visitParents.EXIT;
visit$4.CONTINUE = CONTINUE;
visit$4.SKIP = SKIP;
visit$4.EXIT = EXIT;
function visit$4(tree, test, visitor, reverse) {
  if (typeof test === "function" && typeof visitor !== "function") {
    reverse = visitor;
    visitor = test;
    test = null;
  }
  visitParents(tree, test, overload, reverse);
  function overload(node, parents) {
    var parent = parents[parents.length - 1];
    var index2 = parent ? parent.children.indexOf(node) : null;
    return visitor(node, index2, parent);
  }
}
var visit$3 = unistUtilVisit;
var type$2 = "virtualHtml";
var selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\s*\/?>$/i;
var simpleTagRe = /^<(\/?)([a-z]+)\s*>$/;
var naiveHtml$1 = function(tree) {
  var open;
  var currentParent;
  visit$3(tree, "html", function(node, index2, parent) {
    if (currentParent !== parent) {
      open = [];
      currentParent = parent;
    }
    var selfClosing = getSelfClosing(node);
    if (selfClosing) {
      parent.children.splice(index2, 1, {
        type: type$2,
        tag: selfClosing,
        position: node.position
      });
      return true;
    }
    var current = getSimpleTag(node);
    if (!current) {
      return true;
    }
    var matching = findAndPull(open, current.tag);
    if (matching) {
      parent.children.splice(index2, 0, virtual(current, matching, parent));
    } else if (!current.opening) {
      open.push(current);
    }
    return true;
  }, true);
  return tree;
};
function findAndPull(open, matchingTag) {
  var i = open.length;
  while (i--) {
    if (open[i].tag === matchingTag) {
      return open.splice(i, 1)[0];
    }
  }
  return false;
}
function getSimpleTag(node, parent) {
  var match2 = node.value.match(simpleTagRe);
  return match2 ? {
    tag: match2[2],
    opening: !match2[1],
    node
  } : false;
}
function getSelfClosing(node) {
  var match2 = node.value.match(selfClosingRe);
  return match2 ? match2[1] : false;
}
function virtual(fromNode, toNode, parent) {
  var fromIndex = parent.children.indexOf(fromNode.node);
  var toIndex = parent.children.indexOf(toNode.node);
  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);
  var children = extracted.slice(1, -1);
  return {
    type: type$2,
    children,
    tag: fromNode.tag,
    position: {
      start: fromNode.node.position.start,
      end: toNode.node.position.end,
      indent: []
    }
  };
}
var disallowNode$1 = {};
var visit$2 = unistUtilVisit;
var splice$1 = [].splice;
disallowNode$1.ofType = function(types2, mode) {
  return ifNotMatch(allow, mode);
  function allow(node, index2, parent) {
    return !types2.includes(node.type);
  }
};
disallowNode$1.ifNotMatch = ifNotMatch;
function ifNotMatch(allow, mode) {
  return transform;
  function transform(tree) {
    visit$2(tree, filter);
    return tree;
  }
  function filter(node, index2, parent) {
    if (parent && !allow(node, index2, parent)) {
      var parameters = [index2, 1];
      if (mode === "unwrap" && node.children) {
        parameters = parameters.concat(node.children);
      }
      splice$1.apply(parent.children, parameters);
      return index2;
    }
  }
}
var React$9 = react.exports;
var xtend$3 = immutable;
var ReactIs = reactIs$1.exports;
function astToReact$1(node, options) {
  var parent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var renderer = options.renderers[node.type];
  if (!node.position) {
    node.position = {
      start: {
        line: null,
        column: null,
        offset: null
      },
      end: {
        line: null,
        column: null,
        offset: null
      }
    };
  }
  var pos = node.position.start;
  var key2 = [node.type, pos.line, pos.column, index2].join("-");
  if (!ReactIs.isValidElementType(renderer)) {
    throw new Error("Renderer for type `".concat(node.type, "` not defined or is not renderable"));
  }
  var nodeProps = getNodeProps(node, key2, options, renderer, parent, index2);
  return React$9.createElement(renderer, nodeProps, nodeProps.children || resolveChildren() || void 0);
  function resolveChildren() {
    return node.children && node.children.map(function(childNode, i) {
      return astToReact$1(childNode, options, {
        node,
        props: nodeProps
      }, i);
    });
  }
}
function getNodeProps(node, key2, opts, renderer, parent, index2) {
  var props = {
    key: key2
  };
  var isSimpleRenderer = typeof renderer === "string" || renderer === React$9.Fragment;
  if (opts.sourcePos && node.position) {
    props["data-sourcepos"] = flattenPosition(node.position);
  }
  if (opts.rawSourcePos && !isSimpleRenderer) {
    props.sourcePosition = node.position;
  }
  if (opts.includeNodeIndex && parent.node && parent.node.children && !isSimpleRenderer) {
    props.index = parent.node.children.indexOf(node);
    props.parentChildCount = parent.node.children.length;
  }
  var ref = node.identifier !== null && node.identifier !== void 0 ? opts.definitions[node.identifier.toUpperCase()] || {} : null;
  switch (node.type) {
    case "root":
      assignDefined(props, {
        className: opts.className
      });
      break;
    case "text":
      props.nodeKey = key2;
      props.children = node.value;
      break;
    case "heading":
      props.level = node.depth;
      break;
    case "list":
      props.start = node.start;
      props.ordered = node.ordered;
      props.spread = node.spread;
      props.depth = node.depth;
      break;
    case "listItem":
      props.checked = node.checked;
      props.spread = node.spread;
      props.ordered = node.ordered;
      props.index = node.index;
      props.children = getListItemChildren(node, parent).map(function(childNode, i) {
        return astToReact$1(childNode, opts, {
          node,
          props
        }, i);
      });
      break;
    case "definition":
      assignDefined(props, {
        identifier: node.identifier,
        title: node.title,
        url: node.url
      });
      break;
    case "code":
      assignDefined(props, {
        language: node.lang && node.lang.split(/\s/, 1)[0]
      });
      break;
    case "inlineCode":
      props.children = node.value;
      props.inline = true;
      break;
    case "link":
      assignDefined(props, {
        title: node.title || void 0,
        target: typeof opts.linkTarget === "function" ? opts.linkTarget(node.url, node.children, node.title) : opts.linkTarget,
        href: opts.transformLinkUri ? opts.transformLinkUri(node.url, node.children, node.title) : node.url
      });
      break;
    case "image":
      assignDefined(props, {
        src: opts.transformImageUri ? opts.transformImageUri(node.url, node.children, node.title, node.alt) : node.url,
        alt: node.alt || "",
        title: node.title || void 0
      });
      break;
    case "linkReference":
      assignDefined(props, xtend$3(ref, {
        href: opts.transformLinkUri ? opts.transformLinkUri(ref.href) : ref.href
      }));
      break;
    case "imageReference":
      assignDefined(props, {
        src: opts.transformImageUri && ref.href ? opts.transformImageUri(ref.href, node.children, ref.title, node.alt) : ref.href,
        alt: node.alt || "",
        title: ref.title || void 0
      });
      break;
    case "table":
    case "tableHead":
    case "tableBody":
      props.columnAlignment = node.align;
      break;
    case "tableRow":
      props.isHeader = parent.node.type === "tableHead";
      props.columnAlignment = parent.props.columnAlignment;
      break;
    case "tableCell":
      assignDefined(props, {
        isHeader: parent.props.isHeader,
        align: parent.props.columnAlignment[index2]
      });
      break;
    case "virtualHtml":
      props.tag = node.tag;
      break;
    case "html":
      props.isBlock = node.position.start.line !== node.position.end.line;
      props.allowDangerousHtml = opts.allowDangerousHtml;
      props.escapeHtml = opts.escapeHtml;
      props.skipHtml = opts.skipHtml;
      break;
    case "parsedHtml": {
      var parsedChildren;
      if (node.children) {
        parsedChildren = node.children.map(function(child, i) {
          return astToReact$1(child, opts, {
            node,
            props
          }, i);
        });
      }
      props.allowDangerousHtml = opts.allowDangerousHtml;
      props.escapeHtml = opts.escapeHtml;
      props.skipHtml = opts.skipHtml;
      props.element = node.element ? mergeNodeChildren(node, parsedChildren) : null;
      break;
    }
    default:
      assignDefined(props, xtend$3(node, {
        type: void 0,
        position: void 0,
        children: void 0
      }));
  }
  if (!isSimpleRenderer && node.value) {
    props.value = node.value;
  }
  if (!isSimpleRenderer) {
    props.node = node;
  }
  return props;
}
function assignDefined(target, attrs) {
  for (var key2 in attrs) {
    if (typeof attrs[key2] !== "undefined") {
      target[key2] = attrs[key2];
    }
  }
}
function mergeNodeChildren(node, parsedChildren) {
  var el2 = node.element;
  if (Array.isArray(el2)) {
    var Fragment = React$9.Fragment || "div";
    return React$9.createElement(Fragment, null, el2);
  }
  if (el2.props.children || parsedChildren) {
    var children = React$9.Children.toArray(el2.props.children).concat(parsedChildren);
    return React$9.cloneElement(el2, null, children);
  }
  return React$9.cloneElement(el2, null);
}
function flattenPosition(pos) {
  return [pos.start.line, ":", pos.start.column, "-", pos.end.line, ":", pos.end.column].map(String).join("");
}
function getListItemChildren(node, parent) {
  var loose = parent && parent.node ? listLoose(parent.node) : listItemLoose(node);
  return loose ? node.children : unwrapParagraphs(node);
}
function unwrapParagraphs(node) {
  return node.children.reduce(function(array4, child) {
    return array4.concat(child.type === "paragraph" ? child.children : [child]);
  }, []);
}
function listLoose(node) {
  var children = node.children;
  var loose = node.spread;
  var index2 = -1;
  while (!loose && ++index2 < children.length) {
    loose = listItemLoose(children[index2]);
  }
  return loose;
}
function listItemLoose(node) {
  var spread = node.spread;
  return spread === void 0 || spread === null ? node.children.length > 1 : spread;
}
var astToReact_1 = astToReact$1;
var visit$1 = unistUtilVisit;
var wrapTableRows$1 = function(node) {
  visit$1(node, "table", wrap);
  return node;
};
function wrap(table) {
  var children = table.children;
  table.children = [{
    type: "tableHead",
    align: table.align,
    children: [children[0]],
    position: children[0].position
  }];
  if (children.length > 1) {
    table.children.push({
      type: "tableBody",
      align: table.align,
      children: children.slice(1),
      position: {
        start: children[1].position.start,
        end: children[children.length - 1].position.end
      }
    });
  }
}
var visit = unistUtilVisit;
var getDefinitions$1 = function getDefinitions(tree) {
  var definitions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  visit(tree, "definition", function(node) {
    var identifier = node.identifier.toUpperCase();
    if (identifier in definitions)
      return;
    definitions[identifier] = {
      href: node.url,
      title: node.title
    };
  });
  return definitions;
};
var protocols = ["http", "https", "mailto", "tel"];
var uriTransformer$1 = function uriTransformer(uri) {
  var url2 = (uri || "").trim();
  var first = url2.charAt(0);
  if (first === "#" || first === "/") {
    return url2;
  }
  var colon = url2.indexOf(":");
  if (colon === -1) {
    return url2;
  }
  var length = protocols.length;
  var index2 = -1;
  while (++index2 < length) {
    var protocol = protocols[index2];
    if (colon === protocol.length && url2.slice(0, protocol.length).toLowerCase() === protocol) {
      return url2;
    }
  }
  index2 = url2.indexOf("?");
  if (index2 !== -1 && colon > index2) {
    return url2;
  }
  index2 = url2.indexOf("#");
  if (index2 !== -1 && colon > index2) {
    return url2;
  }
  return "javascript:void(0)";
};
var xtend$2 = immutable;
var React$8 = react.exports;
var supportsStringRender = parseInt((React$8.version || "16").slice(0, 2), 10) >= 16;
var createElement$1 = React$8.createElement;
var renderers = {
  break: "br",
  paragraph: "p",
  emphasis: "em",
  strong: "strong",
  thematicBreak: "hr",
  blockquote: "blockquote",
  delete: "del",
  link: "a",
  image: "img",
  linkReference: "a",
  imageReference: "img",
  table: SimpleRenderer.bind(null, "table"),
  tableHead: SimpleRenderer.bind(null, "thead"),
  tableBody: SimpleRenderer.bind(null, "tbody"),
  tableRow: SimpleRenderer.bind(null, "tr"),
  tableCell: TableCell,
  root: Root,
  text: TextRenderer,
  list: List$4,
  listItem: ListItem,
  definition: NullRenderer,
  heading: Heading,
  inlineCode: InlineCode,
  code: CodeBlock,
  html: Html,
  virtualHtml: VirtualHtml,
  parsedHtml: ParsedHtml
};
function TextRenderer(props) {
  var children = props.children || "";
  return supportsStringRender ? children : createElement$1("span", null, children);
}
function Root(props) {
  var className = props.className;
  var root2 = !className && React$8.Fragment || "div";
  return createElement$1(root2, className ? {
    className
  } : null, props.children);
}
function SimpleRenderer(tag, props) {
  return createElement$1(tag, getCoreProps(props), props.children);
}
function TableCell(props) {
  var style2 = props.align ? {
    textAlign: props.align
  } : void 0;
  var coreProps = getCoreProps(props);
  return createElement$1(props.isHeader ? "th" : "td", style2 ? xtend$2({
    style: style2
  }, coreProps) : coreProps, props.children);
}
function Heading(props) {
  return createElement$1("h".concat(props.level), getCoreProps(props), props.children);
}
function List$4(props) {
  var attrs = getCoreProps(props);
  if (props.start !== null && props.start !== 1 && props.start !== void 0) {
    attrs.start = props.start.toString();
  }
  return createElement$1(props.ordered ? "ol" : "ul", attrs, props.children);
}
function ListItem(props) {
  var checkbox = null;
  if (props.checked !== null && props.checked !== void 0) {
    var checked = props.checked;
    checkbox = createElement$1("input", {
      type: "checkbox",
      checked,
      readOnly: true
    });
  }
  return createElement$1("li", getCoreProps(props), checkbox, props.children);
}
function CodeBlock(props) {
  var className = props.language && "language-".concat(props.language);
  var code = createElement$1("code", className ? {
    className
  } : null, props.value);
  return createElement$1("pre", getCoreProps(props), code);
}
function InlineCode(props) {
  return createElement$1("code", getCoreProps(props), props.children);
}
function Html(props) {
  if (props.skipHtml) {
    return null;
  }
  var dangerous = props.allowDangerousHtml || props.escapeHtml === false;
  var tag = props.isBlock ? "div" : "span";
  if (!dangerous) {
    return createElement$1(React$8.Fragment || tag, null, props.value);
  }
  var nodeProps = {
    dangerouslySetInnerHTML: {
      __html: props.value
    }
  };
  return createElement$1(tag, nodeProps);
}
function ParsedHtml(props) {
  return props["data-sourcepos"] ? React$8.cloneElement(props.element, {
    "data-sourcepos": props["data-sourcepos"]
  }) : props.element;
}
function VirtualHtml(props) {
  return createElement$1(props.tag, getCoreProps(props), props.children);
}
function NullRenderer() {
  return null;
}
function getCoreProps(props) {
  var source = props["data-sourcepos"];
  return source ? {
    "data-sourcepos": source
  } : {};
}
var symbols$1 = {};
var HtmlParser = "__RMD_HTML_PARSER__";
symbols$1.HtmlParser = typeof Symbol === "undefined" ? HtmlParser : Symbol(HtmlParser);
var xtend$1 = immutable;
var unified = unified_1;
var parse$5 = remarkParse;
var PropTypes = propTypes.exports;
var addListMetadata = mdastAddListMetadata;
var naiveHtml = naiveHtml$1;
var disallowNode = disallowNode$1;
var astToReact = astToReact_1;
var wrapTableRows = wrapTableRows$1;
var getDefinitions2 = getDefinitions$1;
var uriTransformer2 = uriTransformer$1;
var defaultRenderers = renderers;
var symbols = symbols$1;
var allTypes = Object.keys(defaultRenderers);
var ReactMarkdown = function ReactMarkdown2(props) {
  var src = props.source || props.children || "";
  if (props.allowedTypes && props.disallowedTypes) {
    throw new Error("Only one of `allowedTypes` and `disallowedTypes` should be defined");
  }
  var renderers2 = xtend$1(defaultRenderers, props.renderers);
  var processor = unified().use(parse$5).use(props.plugins || []);
  var tree = processor.runSync(processor.parse(src));
  var renderProps = xtend$1(props, {
    renderers: renderers2,
    definitions: getDefinitions2(tree)
  });
  determineAstToReactTransforms(props).forEach(function(transform) {
    tree = transform(tree, renderProps);
  });
  return tree;
};
function determineAstToReactTransforms(props) {
  var transforms = [wrapTableRows, addListMetadata()];
  var disallowedTypes = props.disallowedTypes;
  if (props.allowedTypes) {
    disallowedTypes = allTypes.filter(function(type4) {
      return type4 !== "root" && props.allowedTypes.indexOf(type4) === -1;
    });
  }
  var removalMethod = props.unwrapDisallowed ? "unwrap" : "remove";
  if (disallowedTypes && disallowedTypes.length > 0) {
    transforms.push(disallowNode.ofType(disallowedTypes, removalMethod));
  }
  if (props.allowNode) {
    transforms.push(disallowNode.ifNotMatch(props.allowNode, removalMethod));
  }
  var renderHtml = (props.allowDangerousHtml || props.escapeHtml === false) && !props.skipHtml;
  var hasHtmlParser = (props.astPlugins || []).some(function(transform) {
    return transform.identity === symbols.HtmlParser;
  });
  if (renderHtml && !hasHtmlParser) {
    transforms.push(naiveHtml);
  }
  if (props.astPlugins) {
    transforms = transforms.concat(props.astPlugins);
  }
  transforms.push(astToReact);
  return transforms;
}
ReactMarkdown.defaultProps = {
  transformLinkUri: uriTransformer2
};
ReactMarkdown.propTypes = {
  className: PropTypes.string,
  source: PropTypes.string,
  children: PropTypes.string,
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  escapeHtml: PropTypes.bool,
  allowDangerousHtml: PropTypes.bool,
  skipHtml: PropTypes.bool,
  allowNode: PropTypes.func,
  allowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
  disallowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  astPlugins: PropTypes.arrayOf(PropTypes.func),
  unwrapDisallowed: PropTypes.bool,
  renderers: PropTypes.object,
  plugins: PropTypes.array
};
ReactMarkdown.types = allTypes;
ReactMarkdown.renderers = defaultRenderers;
ReactMarkdown.uriTransformer = uriTransformer2;
var reactMarkdown = ReactMarkdown;
const index$5 = "";
var Component = {};
var toggleSelection$1 = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range3) {
        selection.addRange(range3);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent$1 = toggleSelection$1;
var clipboardToIE11Formatting$1 = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage$1 = "Copy to clipboard: #{key}, Enter";
function format$3(message2) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message2.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$2(text2, options) {
  var debug, message2, reselectPrevious, range3, selection, mark2, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent$1();
    range3 = document.createRange();
    selection = document.getSelection();
    mark2 = document.createElement("span");
    mark2.textContent = text2;
    mark2.ariaHidden = "true";
    mark2.style.all = "unset";
    mark2.style.position = "fixed";
    mark2.style.top = 0;
    mark2.style.clip = "rect(0, 0, 0, 0)";
    mark2.style.whiteSpace = "pre";
    mark2.style.webkitUserSelect = "text";
    mark2.style.MozUserSelect = "text";
    mark2.style.msUserSelect = "text";
    mark2.style.userSelect = "text";
    mark2.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting$1[options.format] || clipboardToIE11Formatting$1["default"];
          window.clipboardData.setData(format2, text2);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text2);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark2);
    range3.selectNodeContents(mark2);
    selection.addRange(range3);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text2);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message2 = format$3("message" in options ? options.message : defaultMessage$1);
      window.prompt(message2, text2);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range3);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark2) {
      document.body.removeChild(mark2);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard$2 = copy$2;
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$6(obj);
}
Object.defineProperty(Component, "__esModule", {
  value: true
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault$8(react.exports);
var _copyToClipboard = _interopRequireDefault$8(copyToClipboard$2);
var _excluded$D = ["text", "onCopy", "options", "children"];
function _interopRequireDefault$8(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function ownKeys$6(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key2) {
      _defineProperty$6(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call2) {
  if (call2 && (_typeof$6(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _defineProperty$6(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
var CopyToClipboard$1 = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits$2(CopyToClipboard2, _React$PureComponent);
  var _super = _createSuper$2(CopyToClipboard2);
  function CopyToClipboard2() {
    var _this;
    _classCallCheck$3(this, CopyToClipboard2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$2(_this), "onClick", function(event) {
      var _this$props = _this.props, text2 = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
      var elem = _react["default"].Children.only(children);
      var result = (0, _copyToClipboard["default"])(text2, options);
      if (onCopy) {
        onCopy(text2, result);
      }
      if (elem && elem.props && typeof elem.props.onClick === "function") {
        elem.props.onClick(event);
      }
    });
    return _this;
  }
  _createClass$3(CopyToClipboard2, [{
    key: "render",
    value: function render2() {
      var _this$props2 = this.props;
      _this$props2.text;
      _this$props2.onCopy;
      _this$props2.options;
      var children = _this$props2.children, props = _objectWithoutProperties$2(_this$props2, _excluded$D);
      var elem = _react["default"].Children.only(children);
      return /* @__PURE__ */ _react["default"].cloneElement(elem, _objectSpread$4(_objectSpread$4({}, props), {}, {
        onClick: this.onClick
      }));
    }
  }]);
  return CopyToClipboard2;
}(_react["default"].PureComponent);
Component.CopyToClipboard = CopyToClipboard$1;
_defineProperty$6(CopyToClipboard$1, "defaultProps", {
  onCopy: void 0,
  options: void 0
});
var _require = Component, CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
var objectWithoutProperties = { exports: {} };
var objectWithoutPropertiesLoose = { exports: {} };
var hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  if (hasRequiredObjectWithoutPropertiesLoose)
    return objectWithoutPropertiesLoose.exports;
  hasRequiredObjectWithoutPropertiesLoose = 1;
  (function(module) {
    function _objectWithoutPropertiesLoose2(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key2, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key2 = sourceKeys[i];
        if (excluded.indexOf(key2) >= 0)
          continue;
        target[key2] = source[key2];
      }
      return target;
    }
    module.exports = _objectWithoutPropertiesLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutPropertiesLoose);
  return objectWithoutPropertiesLoose.exports;
}
var hasRequiredObjectWithoutProperties;
function requireObjectWithoutProperties() {
  if (hasRequiredObjectWithoutProperties)
    return objectWithoutProperties.exports;
  hasRequiredObjectWithoutProperties = 1;
  (function(module) {
    var objectWithoutPropertiesLoose2 = requireObjectWithoutPropertiesLoose();
    function _objectWithoutProperties2(source, excluded) {
      if (source == null)
        return {};
      var target = objectWithoutPropertiesLoose2(source, excluded);
      var key2, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key2 = sourceSymbolKeys[i];
          if (excluded.indexOf(key2) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key2))
            continue;
          target[key2] = source[key2];
        }
      }
      return target;
    }
    module.exports = _objectWithoutProperties2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutProperties);
  return objectWithoutProperties.exports;
}
var objectWithoutPropertiesExports = requireObjectWithoutProperties();
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$3(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread();
}
var defineProperty$2 = { exports: {} };
var hasRequiredDefineProperty;
function requireDefineProperty() {
  if (hasRequiredDefineProperty)
    return defineProperty$2.exports;
  hasRequiredDefineProperty = 1;
  (function(module) {
    function _defineProperty2(obj, key2, value2) {
      if (key2 in obj) {
        Object.defineProperty(obj, key2, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key2] = value2;
      }
      return obj;
    }
    module.exports = _defineProperty2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(defineProperty$2);
  return defineProperty$2.exports;
}
var definePropertyExports = requireDefineProperty();
function ownKeys$5(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key2) {
      definePropertyExports(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function powerSetPermutations(arr) {
  var arrLength = arr.length;
  if (arrLength === 0 || arrLength === 1)
    return arr;
  if (arrLength === 2) {
    return [arr[0], arr[1], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength === 3) {
    return [arr[0], arr[1], arr[2], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
  if (arrLength >= 4) {
    return [arr[0], arr[1], arr[2], arr[3], "".concat(arr[0], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3]), "".concat(arr[3], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[0], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[0], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[1], ".").concat(arr[2], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[1], ".").concat(arr[3], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[0], ".").concat(arr[3], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[3]), "".concat(arr[2], ".").concat(arr[1], ".").concat(arr[3], ".").concat(arr[0]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[2], ".").concat(arr[3], ".").concat(arr[1], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[1], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[0], ".").concat(arr[2], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[0], ".").concat(arr[2]), "".concat(arr[3], ".").concat(arr[1], ".").concat(arr[2], ".").concat(arr[0]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[0], ".").concat(arr[1]), "".concat(arr[3], ".").concat(arr[2], ".").concat(arr[1], ".").concat(arr[0])];
  }
}
var classNameCombinations = {};
function getClassNameCombinations(classNames2) {
  if (classNames2.length === 0 || classNames2.length === 1)
    return classNames2;
  var key2 = classNames2.join(".");
  if (!classNameCombinations[key2]) {
    classNameCombinations[key2] = powerSetPermutations(classNames2);
  }
  return classNameCombinations[key2];
}
function createStyleObject(classNames2) {
  var elementStyle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var stylesheet = arguments.length > 2 ? arguments[2] : void 0;
  var nonTokenClassNames = classNames2.filter(function(className) {
    return className !== "token";
  });
  var classNamesCombinations = getClassNameCombinations(nonTokenClassNames);
  return classNamesCombinations.reduce(function(styleObject, className) {
    return _objectSpread$3(_objectSpread$3({}, styleObject), stylesheet[className]);
  }, elementStyle);
}
function createClassNameString(classNames2) {
  return classNames2.join(" ");
}
function createChildren(stylesheet, useInlineStyles) {
  var childrenCount = 0;
  return function(children) {
    childrenCount += 1;
    return children.map(function(child, i) {
      return createElement({
        node: child,
        stylesheet,
        useInlineStyles,
        key: "code-segment-".concat(childrenCount, "-").concat(i)
      });
    });
  };
}
function createElement(_ref) {
  var node = _ref.node, stylesheet = _ref.stylesheet, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, useInlineStyles = _ref.useInlineStyles, key2 = _ref.key;
  var properties = node.properties, type4 = node.type, TagName = node.tagName, value2 = node.value;
  if (type4 === "text") {
    return value2;
  } else if (TagName) {
    var childrenCreator = createChildren(stylesheet, useInlineStyles);
    var props;
    if (!useInlineStyles) {
      props = _objectSpread$3(_objectSpread$3({}, properties), {}, {
        className: createClassNameString(properties.className)
      });
    } else {
      var allStylesheetSelectors = Object.keys(stylesheet).reduce(function(classes, selector) {
        selector.split(".").forEach(function(className2) {
          if (!classes.includes(className2))
            classes.push(className2);
        });
        return classes;
      }, []);
      var startingClassName = properties.className && properties.className.includes("token") ? ["token"] : [];
      var className = properties.className && startingClassName.concat(properties.className.filter(function(className2) {
        return !allStylesheetSelectors.includes(className2);
      }));
      props = _objectSpread$3(_objectSpread$3({}, properties), {}, {
        className: createClassNameString(className) || void 0,
        style: createStyleObject(properties.className, Object.assign({}, properties.style, style2), stylesheet)
      });
    }
    var children = childrenCreator(node.children);
    return /* @__PURE__ */ React$a.createElement(TagName, _extends$2({
      key: key2
    }, props), children);
  }
}
const checkForListedLanguage = function(astGenerator, language) {
  var langs = astGenerator.listLanguages();
  return langs.indexOf(language) !== -1;
};
var _excluded$C = ["language", "children", "style", "customStyle", "codeTagProps", "useInlineStyles", "showLineNumbers", "showInlineLineNumbers", "startingLineNumber", "lineNumberContainerStyle", "lineNumberStyle", "wrapLines", "wrapLongLines", "lineProps", "renderer", "PreTag", "CodeTag", "code", "astGenerator"];
function ownKeys$4(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key2) {
      definePropertyExports(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
var newLineRegex = /\n/g;
function getNewLines(str) {
  return str.match(newLineRegex);
}
function getAllLineNumbers(_ref) {
  var lines = _ref.lines, startingLineNumber = _ref.startingLineNumber, style2 = _ref.style;
  return lines.map(function(_, i) {
    var number4 = i + startingLineNumber;
    return /* @__PURE__ */ React$a.createElement("span", {
      key: "line-".concat(i),
      className: "react-syntax-highlighter-line-number",
      style: typeof style2 === "function" ? style2(number4) : style2
    }, "".concat(number4, "\n"));
  });
}
function AllLineNumbers(_ref2) {
  var codeString = _ref2.codeString, codeStyle = _ref2.codeStyle, _ref2$containerStyle = _ref2.containerStyle, containerStyle = _ref2$containerStyle === void 0 ? {
    "float": "left",
    paddingRight: "10px"
  } : _ref2$containerStyle, _ref2$numberStyle = _ref2.numberStyle, numberStyle = _ref2$numberStyle === void 0 ? {} : _ref2$numberStyle, startingLineNumber = _ref2.startingLineNumber;
  return /* @__PURE__ */ React$a.createElement("code", {
    style: Object.assign({}, codeStyle, containerStyle)
  }, getAllLineNumbers({
    lines: codeString.replace(/\n$/, "").split("\n"),
    style: numberStyle,
    startingLineNumber
  }));
}
function getEmWidthOfNumber(num) {
  return "".concat(num.toString().length, ".25em");
}
function getInlineLineNumber(lineNumber, inlineLineNumberStyle) {
  return {
    type: "element",
    tagName: "span",
    properties: {
      key: "line-number--".concat(lineNumber),
      className: ["comment", "linenumber", "react-syntax-highlighter-line-number"],
      style: inlineLineNumberStyle
    },
    children: [{
      type: "text",
      value: lineNumber
    }]
  };
}
function assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber) {
  var defaultLineNumberStyle = {
    display: "inline-block",
    minWidth: getEmWidthOfNumber(largestLineNumber),
    paddingRight: "1em",
    textAlign: "right",
    userSelect: "none"
  };
  var customLineNumberStyle = typeof lineNumberStyle === "function" ? lineNumberStyle(lineNumber) : lineNumberStyle;
  var assembledStyle = _objectSpread$2(_objectSpread$2({}, defaultLineNumberStyle), customLineNumberStyle);
  return assembledStyle;
}
function createLineElement(_ref3) {
  var children = _ref3.children, lineNumber = _ref3.lineNumber, lineNumberStyle = _ref3.lineNumberStyle, largestLineNumber = _ref3.largestLineNumber, showInlineLineNumbers = _ref3.showInlineLineNumbers, _ref3$lineProps = _ref3.lineProps, lineProps = _ref3$lineProps === void 0 ? {} : _ref3$lineProps, _ref3$className = _ref3.className, className = _ref3$className === void 0 ? [] : _ref3$className, showLineNumbers = _ref3.showLineNumbers, wrapLongLines = _ref3.wrapLongLines;
  var properties = typeof lineProps === "function" ? lineProps(lineNumber) : lineProps;
  properties["className"] = className;
  if (lineNumber && showInlineLineNumbers) {
    var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber, largestLineNumber);
    children.unshift(getInlineLineNumber(lineNumber, inlineLineNumberStyle));
  }
  if (wrapLongLines & showLineNumbers) {
    properties.style = _objectSpread$2(_objectSpread$2({}, properties.style), {}, {
      display: "flex"
    });
  }
  return {
    type: "element",
    tagName: "span",
    properties,
    children
  };
}
function flattenCodeTree(tree) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var newTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  for (var i = 0; i < tree.length; i++) {
    var node = tree[i];
    if (node.type === "text") {
      newTree.push(createLineElement({
        children: [node],
        className: _toConsumableArray(new Set(className))
      }));
    } else if (node.children) {
      var classNames2 = className.concat(node.properties.className);
      flattenCodeTree(node.children, classNames2).forEach(function(i2) {
        return newTree.push(i2);
      });
    }
  }
  return newTree;
}
function processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines) {
  var _ref4;
  var tree = flattenCodeTree(codeTree.value);
  var newTree = [];
  var lastLineBreakIndex = -1;
  var index2 = 0;
  function createWrappedLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return createLineElement({
      children: children2,
      lineNumber: lineNumber2,
      lineNumberStyle,
      largestLineNumber,
      showInlineLineNumbers,
      lineProps,
      className,
      showLineNumbers,
      wrapLongLines
    });
  }
  function createUnwrappedLine(children2, lineNumber2) {
    if (showLineNumbers && lineNumber2 && showInlineLineNumbers) {
      var inlineLineNumberStyle = assembleLineNumberStyles(lineNumberStyle, lineNumber2, largestLineNumber);
      children2.unshift(getInlineLineNumber(lineNumber2, inlineLineNumberStyle));
    }
    return children2;
  }
  function createLine(children2, lineNumber2) {
    var className = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return wrapLines || className.length > 0 ? createWrappedLine(children2, lineNumber2, className) : createUnwrappedLine(children2, lineNumber2);
  }
  var _loop = function _loop2() {
    var node = tree[index2];
    var value2 = node.children[0].value;
    var newLines = getNewLines(value2);
    if (newLines) {
      var splitValue = value2.split("\n");
      splitValue.forEach(function(text2, i) {
        var lineNumber2 = showLineNumbers && newTree.length + startingLineNumber;
        var newChild = {
          type: "text",
          value: "".concat(text2, "\n")
        };
        if (i === 0) {
          var _children = tree.slice(lastLineBreakIndex + 1, index2).concat(createLineElement({
            children: [newChild],
            className: node.properties.className
          }));
          var _line = createLine(_children, lineNumber2);
          newTree.push(_line);
        } else if (i === splitValue.length - 1) {
          var stringChild = tree[index2 + 1] && tree[index2 + 1].children && tree[index2 + 1].children[0];
          var lastLineInPreviousSpan = {
            type: "text",
            value: "".concat(text2)
          };
          if (stringChild) {
            var newElem = createLineElement({
              children: [lastLineInPreviousSpan],
              className: node.properties.className
            });
            tree.splice(index2 + 1, 0, newElem);
          } else {
            var _children2 = [lastLineInPreviousSpan];
            var _line2 = createLine(_children2, lineNumber2, node.properties.className);
            newTree.push(_line2);
          }
        } else {
          var _children3 = [newChild];
          var _line3 = createLine(_children3, lineNumber2, node.properties.className);
          newTree.push(_line3);
        }
      });
      lastLineBreakIndex = index2;
    }
    index2++;
  };
  while (index2 < tree.length) {
    _loop();
  }
  if (lastLineBreakIndex !== tree.length - 1) {
    var children = tree.slice(lastLineBreakIndex + 1, tree.length);
    if (children && children.length) {
      var lineNumber = showLineNumbers && newTree.length + startingLineNumber;
      var line = createLine(children, lineNumber);
      newTree.push(line);
    }
  }
  return wrapLines ? newTree : (_ref4 = []).concat.apply(_ref4, newTree);
}
function defaultRenderer(_ref5) {
  var rows = _ref5.rows, stylesheet = _ref5.stylesheet, useInlineStyles = _ref5.useInlineStyles;
  return rows.map(function(node, i) {
    return createElement({
      node,
      stylesheet,
      useInlineStyles,
      key: "code-segement".concat(i)
    });
  });
}
function isHighlightJs(astGenerator) {
  return astGenerator && typeof astGenerator.highlightAuto !== "undefined";
}
function getCodeTree(_ref6) {
  var astGenerator = _ref6.astGenerator, language = _ref6.language, code = _ref6.code, defaultCodeValue = _ref6.defaultCodeValue;
  if (isHighlightJs(astGenerator)) {
    var hasLanguage = checkForListedLanguage(astGenerator, language);
    if (language === "text") {
      return {
        value: defaultCodeValue,
        language: "text"
      };
    } else if (hasLanguage) {
      return astGenerator.highlight(language, code);
    } else {
      return astGenerator.highlightAuto(code);
    }
  }
  try {
    return language && language !== "text" ? {
      value: astGenerator.highlight(code, language)
    } : {
      value: defaultCodeValue
    };
  } catch (e2) {
    return {
      value: defaultCodeValue
    };
  }
}
function highlight$1(defaultAstGenerator, defaultStyle) {
  return function SyntaxHighlighter2(_ref7) {
    var language = _ref7.language, children = _ref7.children, _ref7$style = _ref7.style, style2 = _ref7$style === void 0 ? defaultStyle : _ref7$style, _ref7$customStyle = _ref7.customStyle, customStyle = _ref7$customStyle === void 0 ? {} : _ref7$customStyle, _ref7$codeTagProps = _ref7.codeTagProps, codeTagProps = _ref7$codeTagProps === void 0 ? {
      className: language ? "language-".concat(language) : void 0,
      style: _objectSpread$2(_objectSpread$2({}, style2['code[class*="language-"]']), style2['code[class*="language-'.concat(language, '"]')])
    } : _ref7$codeTagProps, _ref7$useInlineStyles = _ref7.useInlineStyles, useInlineStyles = _ref7$useInlineStyles === void 0 ? true : _ref7$useInlineStyles, _ref7$showLineNumbers = _ref7.showLineNumbers, showLineNumbers = _ref7$showLineNumbers === void 0 ? false : _ref7$showLineNumbers, _ref7$showInlineLineN = _ref7.showInlineLineNumbers, showInlineLineNumbers = _ref7$showInlineLineN === void 0 ? true : _ref7$showInlineLineN, _ref7$startingLineNum = _ref7.startingLineNumber, startingLineNumber = _ref7$startingLineNum === void 0 ? 1 : _ref7$startingLineNum, lineNumberContainerStyle = _ref7.lineNumberContainerStyle, _ref7$lineNumberStyle = _ref7.lineNumberStyle, lineNumberStyle = _ref7$lineNumberStyle === void 0 ? {} : _ref7$lineNumberStyle, wrapLines = _ref7.wrapLines, _ref7$wrapLongLines = _ref7.wrapLongLines, wrapLongLines = _ref7$wrapLongLines === void 0 ? false : _ref7$wrapLongLines, _ref7$lineProps = _ref7.lineProps, lineProps = _ref7$lineProps === void 0 ? {} : _ref7$lineProps, renderer = _ref7.renderer, _ref7$PreTag = _ref7.PreTag, PreTag = _ref7$PreTag === void 0 ? "pre" : _ref7$PreTag, _ref7$CodeTag = _ref7.CodeTag, CodeTag = _ref7$CodeTag === void 0 ? "code" : _ref7$CodeTag, _ref7$code = _ref7.code, code = _ref7$code === void 0 ? (Array.isArray(children) ? children[0] : children) || "" : _ref7$code, astGenerator = _ref7.astGenerator, rest = objectWithoutPropertiesExports(_ref7, _excluded$C);
    astGenerator = astGenerator || defaultAstGenerator;
    var allLineNumbers = showLineNumbers ? /* @__PURE__ */ React$a.createElement(AllLineNumbers, {
      containerStyle: lineNumberContainerStyle,
      codeStyle: codeTagProps.style || {},
      numberStyle: lineNumberStyle,
      startingLineNumber,
      codeString: code
    }) : null;
    var defaultPreStyle = style2.hljs || style2['pre[class*="language-"]'] || {
      backgroundColor: "#fff"
    };
    var generatorClassName = isHighlightJs(astGenerator) ? "hljs" : "prismjs";
    var preProps = useInlineStyles ? Object.assign({}, rest, {
      style: Object.assign({}, defaultPreStyle, customStyle)
    }) : Object.assign({}, rest, {
      className: rest.className ? "".concat(generatorClassName, " ").concat(rest.className) : generatorClassName,
      style: Object.assign({}, customStyle)
    });
    if (wrapLongLines) {
      codeTagProps.style = _objectSpread$2(_objectSpread$2({}, codeTagProps.style), {}, {
        whiteSpace: "pre-wrap"
      });
    } else {
      codeTagProps.style = _objectSpread$2(_objectSpread$2({}, codeTagProps.style), {}, {
        whiteSpace: "pre"
      });
    }
    if (!astGenerator) {
      return /* @__PURE__ */ React$a.createElement(PreTag, preProps, allLineNumbers, /* @__PURE__ */ React$a.createElement(CodeTag, codeTagProps, code));
    }
    if (wrapLines === void 0 && renderer || wrapLongLines)
      wrapLines = true;
    renderer = renderer || defaultRenderer;
    var defaultCodeValue = [{
      type: "text",
      value: code
    }];
    var codeTree = getCodeTree({
      astGenerator,
      language,
      code,
      defaultCodeValue
    });
    if (codeTree.language === null) {
      codeTree.value = defaultCodeValue;
    }
    var largestLineNumber = codeTree.value.length + startingLineNumber;
    var rows = processLines(codeTree, wrapLines, lineProps, showLineNumbers, showInlineLineNumbers, startingLineNumber, largestLineNumber, lineNumberStyle, wrapLongLines);
    return /* @__PURE__ */ React$a.createElement(PreTag, preProps, /* @__PURE__ */ React$a.createElement(CodeTag, codeTagProps, !showInlineLineNumbers && allLineNumbers, renderer({
      rows,
      stylesheet: style2,
      useInlineStyles
    })));
  };
}
var hastscript = { exports: {} };
var schema$1 = Schema$3;
var proto$1 = Schema$3.prototype;
proto$1.space = null;
proto$1.normal = {};
proto$1.property = {};
function Schema$3(property, normal, space2) {
  this.property = property;
  this.normal = normal;
  if (space2) {
    this.space = space2;
  }
}
var xtend = immutable;
var Schema$2 = schema$1;
var merge_1 = merge$1;
function merge$1(definitions) {
  var length = definitions.length;
  var property = [];
  var normal = [];
  var index2 = -1;
  var info2;
  var space2;
  while (++index2 < length) {
    info2 = definitions[index2];
    property.push(info2.property);
    normal.push(info2.normal);
    space2 = info2.space;
  }
  return new Schema$2(xtend.apply(null, property), xtend.apply(null, normal), space2);
}
var normalize_1 = normalize$4;
function normalize$4(value2) {
  return value2.toLowerCase();
}
var info = Info$2;
var proto = Info$2.prototype;
proto.space = null;
proto.attribute = null;
proto.property = null;
proto.boolean = false;
proto.booleanish = false;
proto.overloadedBoolean = false;
proto.number = false;
proto.commaSeparated = false;
proto.spaceSeparated = false;
proto.commaOrSpaceSeparated = false;
proto.mustUseProperty = false;
proto.defined = false;
function Info$2(property, attribute) {
  this.property = property;
  this.attribute = attribute;
}
var types$4 = {};
var powers = 0;
types$4.boolean = increment();
types$4.booleanish = increment();
types$4.overloadedBoolean = increment();
types$4.number = increment();
types$4.spaceSeparated = increment();
types$4.commaSeparated = increment();
types$4.commaOrSpaceSeparated = increment();
function increment() {
  return Math.pow(2, ++powers);
}
var Info$1 = info;
var types$3 = types$4;
var definedInfo = DefinedInfo$2;
DefinedInfo$2.prototype = new Info$1();
DefinedInfo$2.prototype.defined = true;
var checks = [
  "boolean",
  "booleanish",
  "overloadedBoolean",
  "number",
  "commaSeparated",
  "spaceSeparated",
  "commaOrSpaceSeparated"
];
var checksLength = checks.length;
function DefinedInfo$2(property, attribute, mask, space2) {
  var index2 = -1;
  var check;
  mark(this, "space", space2);
  Info$1.call(this, property, attribute);
  while (++index2 < checksLength) {
    check = checks[index2];
    mark(this, check, (mask & types$3[check]) === types$3[check]);
  }
}
function mark(values, key2, value2) {
  if (value2) {
    values[key2] = value2;
  }
}
var normalize$3 = normalize_1;
var Schema$1 = schema$1;
var DefinedInfo$1 = definedInfo;
var create_1 = create$6;
function create$6(definition2) {
  var space2 = definition2.space;
  var mustUseProperty = definition2.mustUseProperty || [];
  var attributes2 = definition2.attributes || {};
  var props = definition2.properties;
  var transform = definition2.transform;
  var property = {};
  var normal = {};
  var prop;
  var info2;
  for (prop in props) {
    info2 = new DefinedInfo$1(prop, transform(attributes2, prop), props[prop], space2);
    if (mustUseProperty.indexOf(prop) !== -1) {
      info2.mustUseProperty = true;
    }
    property[prop] = info2;
    normal[normalize$3(prop)] = prop;
    normal[normalize$3(info2.attribute)] = prop;
  }
  return new Schema$1(property, normal, space2);
}
var create$5 = create_1;
var xlink$1 = create$5({
  space: "xlink",
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function xlinkTransform(_, prop) {
  return "xlink:" + prop.slice(5).toLowerCase();
}
var create$4 = create_1;
var xml$1 = create$4({
  space: "xml",
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function xmlTransform(_, prop) {
  return "xml:" + prop.slice(3).toLowerCase();
}
var caseSensitiveTransform_1 = caseSensitiveTransform$1;
function caseSensitiveTransform$1(attributes2, attribute) {
  return attribute in attributes2 ? attributes2[attribute] : attribute;
}
var caseSensitiveTransform = caseSensitiveTransform_1;
var caseInsensitiveTransform_1 = caseInsensitiveTransform$2;
function caseInsensitiveTransform$2(attributes2, property) {
  return caseSensitiveTransform(attributes2, property.toLowerCase());
}
var create$3 = create_1;
var caseInsensitiveTransform$1 = caseInsensitiveTransform_1;
var xmlns$1 = create$3({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform$1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
});
var types$2 = types$4;
var create$2 = create_1;
var booleanish$1 = types$2.booleanish;
var number$2 = types$2.number;
var spaceSeparated$1 = types$2.spaceSeparated;
var aria$1 = create$2({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$1,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$1,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$1,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$1,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$1,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$1,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$1,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});
function ariaTransform(_, prop) {
  return prop === "role" ? prop : "aria-" + prop.slice(4).toLowerCase();
}
var types$1 = types$4;
var create$1 = create_1;
var caseInsensitiveTransform = caseInsensitiveTransform_1;
var boolean = types$1.boolean;
var overloadedBoolean = types$1.overloadedBoolean;
var booleanish = types$1.booleanish;
var number$1 = types$1.number;
var spaceSeparated = types$1.spaceSeparated;
var commaSeparated = types$1.commaSeparated;
var html$2 = create$1({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number$1 | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number$1,
    hidden: boolean,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    align: null,
    aLink: null,
    archive: spaceSeparated,
    axis: null,
    background: null,
    bgColor: null,
    border: number$1,
    borderColor: null,
    bottomMargin: number$1,
    cellPadding: null,
    cellSpacing: null,
    char: null,
    charOff: null,
    classId: null,
    clear: null,
    code: null,
    codeBase: null,
    codeType: null,
    color: null,
    compact: boolean,
    declare: boolean,
    event: null,
    face: null,
    frame: null,
    frameBorder: null,
    hSpace: number$1,
    leftMargin: number$1,
    link: null,
    longDesc: null,
    lowSrc: null,
    marginHeight: number$1,
    marginWidth: number$1,
    noResize: boolean,
    noHref: boolean,
    noShade: boolean,
    noWrap: boolean,
    object: null,
    profile: null,
    prompt: null,
    rev: null,
    rightMargin: number$1,
    rules: null,
    scheme: null,
    scrolling: booleanish,
    standby: null,
    summary: null,
    text: null,
    topMargin: number$1,
    valueType: null,
    version: null,
    vAlign: null,
    vLink: null,
    vSpace: number$1,
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
});
var merge = merge_1;
var xlink = xlink$1;
var xml = xml$1;
var xmlns = xmlns$1;
var aria = aria$1;
var html$1 = html$2;
var html_1$1 = merge([xml, xlink, xmlns, aria, html$1]);
var normalize$2 = normalize_1;
var DefinedInfo = definedInfo;
var Info = info;
var data = "data";
var find_1 = find$1;
var valid = /^data[-\w.:]+$/i;
var dash = /-[a-z]/g;
var cap = /[A-Z]/g;
function find$1(schema2, value2) {
  var normal = normalize$2(value2);
  var prop = value2;
  var Type = Info;
  if (normal in schema2.normal) {
    return schema2.property[schema2.normal[normal]];
  }
  if (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value2)) {
    if (value2.charAt(4) === "-") {
      prop = datasetToProperty(value2);
    } else {
      value2 = datasetToAttribute(value2);
    }
    Type = DefinedInfo;
  }
  return new Type(prop, value2);
}
function datasetToProperty(attribute) {
  var value2 = attribute.slice(5).replace(dash, camelcase);
  return data + value2.charAt(0).toUpperCase() + value2.slice(1);
}
function datasetToAttribute(property) {
  var value2 = property.slice(4);
  if (dash.test(value2)) {
    return property;
  }
  value2 = value2.replace(cap, kebab);
  if (value2.charAt(0) !== "-") {
    value2 = "-" + value2;
  }
  return data + value2;
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var hastUtilParseSelector = parse$4;
var search = /[#.]/g;
function parse$4(selector, defaultTagName) {
  var value2 = selector || "";
  var name2 = defaultTagName || "div";
  var props = {};
  var start = 0;
  var subvalue;
  var previous2;
  var match2;
  while (start < value2.length) {
    search.lastIndex = start;
    match2 = search.exec(value2);
    subvalue = value2.slice(start, match2 ? match2.index : value2.length);
    if (subvalue) {
      if (!previous2) {
        name2 = subvalue;
      } else if (previous2 === "#") {
        props.id = subvalue;
      } else if (props.className) {
        props.className.push(subvalue);
      } else {
        props.className = [subvalue];
      }
      start += subvalue.length;
    }
    if (match2) {
      previous2 = match2[0];
      start++;
    }
  }
  return { type: "element", tagName: name2, properties: props, children: [] };
}
var spaceSeparatedTokens = {};
spaceSeparatedTokens.parse = parse$3;
spaceSeparatedTokens.stringify = stringify$3;
var empty$1 = "";
var space$2 = " ";
var whiteSpace = /[ \t\n\r\f]+/g;
function parse$3(value2) {
  var input = String(value2 || empty$1).trim();
  return input === empty$1 ? [] : input.split(whiteSpace);
}
function stringify$3(values) {
  return values.join(space$2).trim();
}
var commaSeparatedTokens = {};
commaSeparatedTokens.parse = parse$2;
commaSeparatedTokens.stringify = stringify$2;
var comma = ",";
var space$1 = " ";
var empty = "";
function parse$2(value2) {
  var values = [];
  var input = String(value2 || empty);
  var index2 = input.indexOf(comma);
  var lastIndex = 0;
  var end = false;
  var val;
  while (!end) {
    if (index2 === -1) {
      index2 = input.length;
      end = true;
    }
    val = input.slice(lastIndex, index2).trim();
    if (val || !end) {
      values.push(val);
    }
    lastIndex = index2 + 1;
    index2 = input.indexOf(comma, lastIndex);
  }
  return values;
}
function stringify$2(values, options) {
  var settings = options || {};
  var left = settings.padLeft === false ? empty : space$1;
  var right = settings.padRight ? space$1 : empty;
  if (values[values.length - 1] === empty) {
    values = values.concat(empty);
  }
  return values.join(right + comma + left).trim();
}
var find = find_1;
var normalize$1 = normalize_1;
var parseSelector = hastUtilParseSelector;
var spaces = spaceSeparatedTokens.parse;
var commas = commaSeparatedTokens.parse;
var factory_1 = factory$1;
var own$3 = {}.hasOwnProperty;
function factory$1(schema2, defaultTagName, caseSensitive) {
  var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
  return h2;
  function h2(selector, properties) {
    var node = parseSelector(selector, defaultTagName);
    var children = Array.prototype.slice.call(arguments, 2);
    var name2 = node.tagName.toLowerCase();
    var property;
    node.tagName = adjust && own$3.call(adjust, name2) ? adjust[name2] : name2;
    if (properties && isChildren(properties, node)) {
      children.unshift(properties);
      properties = null;
    }
    if (properties) {
      for (property in properties) {
        addProperty(node.properties, property, properties[property]);
      }
    }
    addChild(node.children, children);
    if (node.tagName === "template") {
      node.content = { type: "root", children: node.children };
      node.children = [];
    }
    return node;
  }
  function addProperty(properties, key2, value2) {
    var info2;
    var property;
    var result;
    if (value2 === null || value2 === void 0 || value2 !== value2) {
      return;
    }
    info2 = find(schema2, key2);
    property = info2.property;
    result = value2;
    if (typeof result === "string") {
      if (info2.spaceSeparated) {
        result = spaces(result);
      } else if (info2.commaSeparated) {
        result = commas(result);
      } else if (info2.commaOrSpaceSeparated) {
        result = spaces(commas(result).join(" "));
      }
    }
    if (property === "style" && typeof value2 !== "string") {
      result = style$1(result);
    }
    if (property === "className" && properties.className) {
      result = properties.className.concat(result);
    }
    properties[property] = parsePrimitives(info2, property, result);
  }
}
function isChildren(value2, node) {
  return typeof value2 === "string" || "length" in value2 || isNode(node.tagName, value2);
}
function isNode(tagName, value2) {
  var type4 = value2.type;
  if (tagName === "input" || !type4 || typeof type4 !== "string") {
    return false;
  }
  if (typeof value2.children === "object" && "length" in value2.children) {
    return true;
  }
  type4 = type4.toLowerCase();
  if (tagName === "button") {
    return type4 !== "menu" && type4 !== "submit" && type4 !== "reset" && type4 !== "button";
  }
  return "value" in value2;
}
function addChild(nodes, value2) {
  var index2;
  var length;
  if (typeof value2 === "string" || typeof value2 === "number") {
    nodes.push({ type: "text", value: String(value2) });
    return;
  }
  if (typeof value2 === "object" && "length" in value2) {
    index2 = -1;
    length = value2.length;
    while (++index2 < length) {
      addChild(nodes, value2[index2]);
    }
    return;
  }
  if (typeof value2 !== "object" || !("type" in value2)) {
    throw new Error("Expected node, nodes, or string, got `" + value2 + "`");
  }
  nodes.push(value2);
}
function parsePrimitives(info2, name2, value2) {
  var index2;
  var length;
  var result;
  if (typeof value2 !== "object" || !("length" in value2)) {
    return parsePrimitive(info2, name2, value2);
  }
  length = value2.length;
  index2 = -1;
  result = [];
  while (++index2 < length) {
    result[index2] = parsePrimitive(info2, name2, value2[index2]);
  }
  return result;
}
function parsePrimitive(info2, name2, value2) {
  var result = value2;
  if (info2.number || info2.positiveNumber) {
    if (!isNaN(result) && result !== "") {
      result = Number(result);
    }
  } else if (info2.boolean || info2.overloadedBoolean) {
    if (typeof result === "string" && (result === "" || normalize$1(value2) === normalize$1(name2))) {
      result = true;
    }
  }
  return result;
}
function style$1(value2) {
  var result = [];
  var key2;
  for (key2 in value2) {
    result.push([key2, value2[key2]].join(": "));
  }
  return result.join("; ");
}
function createAdjustMap(values) {
  var length = values.length;
  var index2 = -1;
  var result = {};
  var value2;
  while (++index2 < length) {
    value2 = values[index2];
    result[value2.toLowerCase()] = value2;
  }
  return result;
}
var schema = html_1$1;
var factory = factory_1;
var html = factory(schema, "div");
html.displayName = "html";
var html_1 = html;
(function(module) {
  module.exports = html_1;
})(hastscript);
const AElig = "\xC6";
const AMP = "&";
const Aacute = "\xC1";
const Acirc = "\xC2";
const Agrave = "\xC0";
const Aring = "\xC5";
const Atilde = "\xC3";
const Auml = "\xC4";
const COPY = "\xA9";
const Ccedil = "\xC7";
const ETH = "\xD0";
const Eacute = "\xC9";
const Ecirc = "\xCA";
const Egrave = "\xC8";
const Euml = "\xCB";
const GT = ">";
const Iacute = "\xCD";
const Icirc = "\xCE";
const Igrave = "\xCC";
const Iuml = "\xCF";
const LT = "<";
const Ntilde = "\xD1";
const Oacute = "\xD3";
const Ocirc = "\xD4";
const Ograve = "\xD2";
const Oslash = "\xD8";
const Otilde = "\xD5";
const Ouml = "\xD6";
const QUOT = '"';
const REG = "\xAE";
const THORN = "\xDE";
const Uacute = "\xDA";
const Ucirc = "\xDB";
const Ugrave = "\xD9";
const Uuml = "\xDC";
const Yacute = "\xDD";
const aacute = "\xE1";
const acirc = "\xE2";
const acute = "\xB4";
const aelig = "\xE6";
const agrave = "\xE0";
const amp = "&";
const aring = "\xE5";
const atilde = "\xE3";
const auml = "\xE4";
const brvbar = "\xA6";
const ccedil = "\xE7";
const cedil = "\xB8";
const cent = "\xA2";
const copy$1 = "\xA9";
const curren = "\xA4";
const deg = "\xB0";
const divide = "\xF7";
const eacute = "\xE9";
const ecirc = "\xEA";
const egrave = "\xE8";
const eth = "\xF0";
const euml = "\xEB";
const frac12 = "\xBD";
const frac14 = "\xBC";
const frac34 = "\xBE";
const gt = ">";
const iacute = "\xED";
const icirc = "\xEE";
const iexcl = "\xA1";
const igrave = "\xEC";
const iquest = "\xBF";
const iuml = "\xEF";
const laquo = "\xAB";
const lt = "<";
const macr = "\xAF";
const micro = "\xB5";
const middot = "\xB7";
const nbsp = "\xA0";
const not = "\xAC";
const ntilde = "\xF1";
const oacute = "\xF3";
const ocirc = "\xF4";
const ograve = "\xF2";
const ordf = "\xAA";
const ordm = "\xBA";
const oslash = "\xF8";
const otilde = "\xF5";
const ouml = "\xF6";
const para = "\xB6";
const plusmn = "\xB1";
const pound = "\xA3";
const quot = '"';
const raquo = "\xBB";
const reg = "\xAE";
const sect = "\xA7";
const shy = "\xAD";
const sup1 = "\xB9";
const sup2 = "\xB2";
const sup3 = "\xB3";
const szlig = "\xDF";
const thorn = "\xFE";
const times = "\xD7";
const uacute = "\xFA";
const ucirc = "\xFB";
const ugrave = "\xF9";
const uml = "\xA8";
const uuml = "\xFC";
const yacute = "\xFD";
const yen = "\xA5";
const yuml = "\xFF";
const require$$0 = {
  AElig,
  AMP,
  Aacute,
  Acirc,
  Agrave,
  Aring,
  Atilde,
  Auml,
  COPY,
  Ccedil,
  ETH,
  Eacute,
  Ecirc,
  Egrave,
  Euml,
  GT,
  Iacute,
  Icirc,
  Igrave,
  Iuml,
  LT,
  Ntilde,
  Oacute,
  Ocirc,
  Ograve,
  Oslash,
  Otilde,
  Ouml,
  QUOT,
  REG,
  THORN,
  Uacute,
  Ucirc,
  Ugrave,
  Uuml,
  Yacute,
  aacute,
  acirc,
  acute,
  aelig,
  agrave,
  amp,
  aring,
  atilde,
  auml,
  brvbar,
  ccedil,
  cedil,
  cent,
  copy: copy$1,
  curren,
  deg,
  divide,
  eacute,
  ecirc,
  egrave,
  eth,
  euml,
  frac12,
  frac14,
  frac34,
  gt,
  iacute,
  icirc,
  iexcl,
  igrave,
  iquest,
  iuml,
  laquo,
  lt,
  macr,
  micro,
  middot,
  nbsp,
  not,
  ntilde,
  oacute,
  ocirc,
  ograve,
  ordf,
  ordm,
  oslash,
  otilde,
  ouml,
  para,
  plusmn,
  pound,
  quot,
  raquo,
  reg,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  thorn,
  times,
  uacute,
  ucirc,
  ugrave,
  uml,
  uuml,
  yacute,
  yen,
  yuml
};
const require$$1 = {
  "0": "\uFFFD",
  "128": "\u20AC",
  "130": "\u201A",
  "131": "\u0192",
  "132": "\u201E",
  "133": "\u2026",
  "134": "\u2020",
  "135": "\u2021",
  "136": "\u02C6",
  "137": "\u2030",
  "138": "\u0160",
  "139": "\u2039",
  "140": "\u0152",
  "142": "\u017D",
  "145": "\u2018",
  "146": "\u2019",
  "147": "\u201C",
  "148": "\u201D",
  "149": "\u2022",
  "150": "\u2013",
  "151": "\u2014",
  "152": "\u02DC",
  "153": "\u2122",
  "154": "\u0161",
  "155": "\u203A",
  "156": "\u0153",
  "158": "\u017E",
  "159": "\u0178"
};
var isDecimal = decimal$2;
function decimal$2(character) {
  var code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 48 && code <= 57;
}
var isHexadecimal = hexadecimal$1;
function hexadecimal$1(character) {
  var code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
}
var isAlphabetical = alphabetical$1;
function alphabetical$1(character) {
  var code = typeof character === "string" ? character.charCodeAt(0) : character;
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
var alphabetical = isAlphabetical;
var decimal$1 = isDecimal;
var isAlphanumerical = alphanumerical$1;
function alphanumerical$1(character) {
  return alphabetical(character) || decimal$1(character);
}
var legacy = require$$0;
var invalid = require$$1;
var decimal = isDecimal;
var hexadecimal = isHexadecimal;
var alphanumerical = isAlphanumerical;
var decodeEntity = decodeEntity_browser;
var parseEntities_1 = parseEntities;
var own$2 = {}.hasOwnProperty;
var fromCharCode = String.fromCharCode;
var noop$3 = Function.prototype;
var defaults = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: false,
  nonTerminated: true
};
var tab = 9;
var lineFeed = 10;
var formFeed = 12;
var space = 32;
var ampersand = 38;
var semicolon = 59;
var lessThan = 60;
var equalsTo = 61;
var numberSign = 35;
var uppercaseX = 88;
var lowercaseX = 120;
var replacementCharacter = 65533;
var name = "named";
var hexa = "hexadecimal";
var deci = "decimal";
var bases = {};
bases[hexa] = 16;
bases[deci] = 10;
var tests = {};
tests[name] = alphanumerical;
tests[deci] = decimal;
tests[hexa] = hexadecimal;
var namedNotTerminated = 1;
var numericNotTerminated = 2;
var namedEmpty = 3;
var numericEmpty = 4;
var namedUnknown = 5;
var numericDisallowed = 6;
var numericProhibited = 7;
var messages$1 = {};
messages$1[namedNotTerminated] = "Named character references must be terminated by a semicolon";
messages$1[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
messages$1[namedEmpty] = "Named character references cannot be empty";
messages$1[numericEmpty] = "Numeric character references cannot be empty";
messages$1[namedUnknown] = "Named character references must be known";
messages$1[numericDisallowed] = "Numeric character references cannot be disallowed";
messages$1[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function parseEntities(value2, options) {
  var settings = {};
  var option;
  var key2;
  if (!options) {
    options = {};
  }
  for (key2 in defaults) {
    option = options[key2];
    settings[key2] = option === null || option === void 0 ? defaults[key2] : option;
  }
  if (settings.position.indent || settings.position.start) {
    settings.indent = settings.position.indent || [];
    settings.position = settings.position.start;
  }
  return parse$1(value2, settings);
}
function parse$1(value2, settings) {
  var additional = settings.additional;
  var nonTerminated = settings.nonTerminated;
  var handleText = settings.text;
  var handleReference = settings.reference;
  var handleWarning = settings.warning;
  var textContext = settings.textContext;
  var referenceContext = settings.referenceContext;
  var warningContext = settings.warningContext;
  var pos = settings.position;
  var indent = settings.indent || [];
  var length = value2.length;
  var index2 = 0;
  var lines = -1;
  var column = pos.column || 1;
  var line = pos.line || 1;
  var queue = "";
  var result = [];
  var entityCharacters;
  var namedEntity;
  var terminated;
  var characters;
  var character;
  var reference;
  var following;
  var warning3;
  var reason;
  var output;
  var entity;
  var begin;
  var start;
  var type4;
  var test;
  var prev;
  var next;
  var diff;
  var end;
  if (typeof additional === "string") {
    additional = additional.charCodeAt(0);
  }
  prev = now2();
  warning3 = handleWarning ? parseError : noop$3;
  index2--;
  length++;
  while (++index2 < length) {
    if (character === lineFeed) {
      column = indent[lines] || 1;
    }
    character = value2.charCodeAt(index2);
    if (character === ampersand) {
      following = value2.charCodeAt(index2 + 1);
      if (following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      start = index2 + 1;
      begin = start;
      end = start;
      if (following === numberSign) {
        end = ++begin;
        following = value2.charCodeAt(end);
        if (following === uppercaseX || following === lowercaseX) {
          type4 = hexa;
          end = ++begin;
        } else {
          type4 = deci;
        }
      } else {
        type4 = name;
      }
      entityCharacters = "";
      entity = "";
      characters = "";
      test = tests[type4];
      end--;
      while (++end < length) {
        following = value2.charCodeAt(end);
        if (!test(following)) {
          break;
        }
        characters += fromCharCode(following);
        if (type4 === name && own$2.call(legacy, characters)) {
          entityCharacters = characters;
          entity = legacy[characters];
        }
      }
      terminated = value2.charCodeAt(end) === semicolon;
      if (terminated) {
        end++;
        namedEntity = type4 === name ? decodeEntity(characters) : false;
        if (namedEntity) {
          entityCharacters = characters;
          entity = namedEntity;
        }
      }
      diff = 1 + end - start;
      if (!terminated && !nonTerminated)
        ;
      else if (!characters) {
        if (type4 !== name) {
          warning3(numericEmpty, diff);
        }
      } else if (type4 === name) {
        if (terminated && !entity) {
          warning3(namedUnknown, 1);
        } else {
          if (entityCharacters !== characters) {
            end = begin + entityCharacters.length;
            diff = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            reason = entityCharacters ? namedNotTerminated : namedEmpty;
            if (settings.attribute) {
              following = value2.charCodeAt(end);
              if (following === equalsTo) {
                warning3(reason, diff);
                entity = null;
              } else if (alphanumerical(following)) {
                entity = null;
              } else {
                warning3(reason, diff);
              }
            } else {
              warning3(reason, diff);
            }
          }
        }
        reference = entity;
      } else {
        if (!terminated) {
          warning3(numericNotTerminated, diff);
        }
        reference = parseInt(characters, bases[type4]);
        if (prohibited(reference)) {
          warning3(numericProhibited, diff);
          reference = fromCharCode(replacementCharacter);
        } else if (reference in invalid) {
          warning3(numericDisallowed, diff);
          reference = invalid[reference];
        } else {
          output = "";
          if (disallowed(reference)) {
            warning3(numericDisallowed, diff);
          }
          if (reference > 65535) {
            reference -= 65536;
            output += fromCharCode(reference >>> (10 & 1023) | 55296);
            reference = 56320 | reference & 1023;
          }
          reference = output + fromCharCode(reference);
        }
      }
      if (reference) {
        flush();
        prev = now2();
        index2 = end - 1;
        column += end - start + 1;
        result.push(reference);
        next = now2();
        next.offset++;
        if (handleReference) {
          handleReference.call(referenceContext, reference, { start: prev, end: next }, value2.slice(start - 1, end));
        }
        prev = next;
      } else {
        characters = value2.slice(start - 1, end);
        queue += characters;
        column += characters.length;
        index2 = end - 1;
      }
    } else {
      if (character === 10) {
        line++;
        lines++;
        column = 0;
      }
      if (character === character) {
        queue += fromCharCode(character);
        column++;
      } else {
        flush();
      }
    }
  }
  return result.join("");
  function now2() {
    return {
      line,
      column,
      offset: index2 + (pos.offset || 0)
    };
  }
  function parseError(code, offset3) {
    var position2 = now2();
    position2.column += offset3;
    position2.offset += offset3;
    handleWarning.call(warningContext, messages$1[code], position2, code);
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (handleText) {
        handleText.call(textContext, queue, { start: prev, end: now2() });
      }
      queue = "";
    }
  }
}
function prohibited(code) {
  return code >= 55296 && code <= 57343 || code > 1114111;
}
function disallowed(code) {
  return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
}
var prismCore = { exports: {} };
(function(module) {
  var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
    var uniqueId = 0;
    var plainTextGrammar = {};
    var _ = {
      manual: _self2.Prism && _self2.Prism.manual,
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      util: {
        encode: function encode2(tokens) {
          if (tokens instanceof Token) {
            return new Token(tokens.type, encode2(tokens.content), tokens.alias);
          } else if (Array.isArray(tokens)) {
            return tokens.map(encode2);
          } else {
            return tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          }
        },
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        objId: function(obj) {
          if (!obj["__id"]) {
            Object.defineProperty(obj, "__id", { value: ++uniqueId });
          }
          return obj["__id"];
        },
        clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone2;
          var id2;
          switch (_.util.type(o)) {
            case "Object":
              id2 = _.util.objId(o);
              if (visited[id2]) {
                return visited[id2];
              }
              clone2 = {};
              visited[id2] = clone2;
              for (var key2 in o) {
                if (o.hasOwnProperty(key2)) {
                  clone2[key2] = deepClone(o[key2], visited);
                }
              }
              return clone2;
            case "Array":
              id2 = _.util.objId(o);
              if (visited[id2]) {
                return visited[id2];
              }
              clone2 = [];
              visited[id2] = clone2;
              o.forEach(function(v2, i) {
                clone2[i] = deepClone(v2, visited);
              });
              return clone2;
            default:
              return o;
          }
        },
        getLanguage: function(element) {
          while (element) {
            var m2 = lang.exec(element.className);
            if (m2) {
              return m2[1].toLowerCase();
            }
            element = element.parentElement;
          }
          return "none";
        },
        setLanguage: function(element, language) {
          element.className = element.className.replace(RegExp(lang, "gi"), "");
          element.classList.add("language-" + language);
        },
        currentScript: function() {
          if (typeof document === "undefined") {
            return null;
          }
          if ("currentScript" in document && 1 < 2) {
            return document.currentScript;
          }
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts) {
                if (scripts[i].src == src) {
                  return scripts[i];
                }
              }
            }
            return null;
          }
        },
        isActive: function(element, className, defaultActivation) {
          var no = "no-" + className;
          while (element) {
            var classList = element.classList;
            if (classList.contains(className)) {
              return true;
            }
            if (classList.contains(no)) {
              return false;
            }
            element = element.parentElement;
          }
          return !!defaultActivation;
        }
      },
      languages: {
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        extend: function(id2, redef) {
          var lang2 = _.util.clone(_.languages[id2]);
          for (var key2 in redef) {
            lang2[key2] = redef[key2];
          }
          return lang2;
        },
        insertBefore: function(inside, before, insert, root2) {
          root2 = root2 || _.languages;
          var grammar = root2[inside];
          var ret = {};
          for (var token in grammar) {
            if (grammar.hasOwnProperty(token)) {
              if (token == before) {
                for (var newToken in insert) {
                  if (insert.hasOwnProperty(newToken)) {
                    ret[newToken] = insert[newToken];
                  }
                }
              }
              if (!insert.hasOwnProperty(token)) {
                ret[token] = grammar[token];
              }
            }
          }
          var old = root2[inside];
          root2[inside] = ret;
          _.languages.DFS(_.languages, function(key2, value2) {
            if (value2 === old && key2 != inside) {
              this[key2] = ret;
            }
          });
          return ret;
        },
        DFS: function DFS(o, callback, type4, visited) {
          visited = visited || {};
          var objId = _.util.objId;
          for (var i in o) {
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type4 || i);
              var property = o[i];
              var propertyType = _.util.type(property);
              if (propertyType === "Object" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, null, visited);
              } else if (propertyType === "Array" && !visited[objId(property)]) {
                visited[objId(property)] = true;
                DFS(property, callback, i, visited);
              }
            }
          }
        }
      },
      plugins: {},
      highlightAll: function(async, callback) {
        _.highlightAllUnder(document, async, callback);
      },
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _.hooks.run("before-highlightall", env);
        env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
        _.hooks.run("before-all-elements-highlight", env);
        for (var i = 0, element; element = env.elements[i++]; ) {
          _.highlightElement(element, async === true, env.callback);
        }
      },
      highlightElement: function(element, async, callback) {
        var language = _.util.getLanguage(element);
        var grammar = _.languages[language];
        _.util.setLanguage(element, language);
        var parent = element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre") {
          _.util.setLanguage(parent, language);
        }
        var code = element.textContent;
        var env = {
          element,
          language,
          grammar,
          code
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode;
          _.hooks.run("before-insert", env);
          env.element.innerHTML = env.highlightedCode;
          _.hooks.run("after-highlight", env);
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
        }
        _.hooks.run("before-sanity-check", env);
        parent = env.element.parentElement;
        if (parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex")) {
          parent.setAttribute("tabindex", "0");
        }
        if (!env.code) {
          _.hooks.run("complete", env);
          callback && callback.call(env.element);
          return;
        }
        _.hooks.run("before-highlight", env);
        if (!env.grammar) {
          insertHighlightedCode(_.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          };
          worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: true
          }));
        } else {
          insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
        }
      },
      highlight: function(text2, grammar, language) {
        var env = {
          code: text2,
          grammar,
          language
        };
        _.hooks.run("before-tokenize", env);
        if (!env.grammar) {
          throw new Error('The language "' + env.language + '" has no grammar.');
        }
        env.tokens = _.tokenize(env.code, env.grammar);
        _.hooks.run("after-tokenize", env);
        return Token.stringify(_.util.encode(env.tokens), env.language);
      },
      tokenize: function(text2, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token in rest) {
            grammar[token] = rest[token];
          }
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        addAfter(tokenList, tokenList.head, text2);
        matchGrammar(text2, tokenList, grammar, tokenList.head, 0);
        return toArray2(tokenList);
      },
      hooks: {
        all: {},
        add: function(name2, callback) {
          var hooks = _.hooks.all;
          hooks[name2] = hooks[name2] || [];
          hooks[name2].push(callback);
        },
        run: function(name2, env) {
          var callbacks = _.hooks.all[name2];
          if (!callbacks || !callbacks.length) {
            return;
          }
          for (var i = 0, callback; callback = callbacks[i++]; ) {
            callback(env);
          }
        }
      },
      Token
    };
    _self2.Prism = _;
    function Token(type4, content2, alias2, matchedStr) {
      this.type = type4;
      this.content = content2;
      this.alias = alias2;
      this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify2(o, language) {
      if (typeof o == "string") {
        return o;
      }
      if (Array.isArray(o)) {
        var s = "";
        o.forEach(function(e2) {
          s += stringify2(e2, language);
        });
        return s;
      }
      var env = {
        type: o.type,
        content: stringify2(o.content, language),
        tag: "span",
        classes: ["token", o.type],
        attributes: {},
        language
      };
      var aliases = o.alias;
      if (aliases) {
        if (Array.isArray(aliases)) {
          Array.prototype.push.apply(env.classes, aliases);
        } else {
          env.classes.push(aliases);
        }
      }
      _.hooks.run("wrap", env);
      var attributes2 = "";
      for (var name2 in env.attributes) {
        attributes2 += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
      }
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes2 + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern4, pos, text2, lookbehind) {
      pattern4.lastIndex = pos;
      var match2 = pattern4.exec(text2);
      if (match2 && lookbehind && match2[1]) {
        var lookbehindLength = match2[1].length;
        match2.index += lookbehindLength;
        match2[0] = match2[0].slice(lookbehindLength);
      }
      return match2;
    }
    function matchGrammar(text2, tokenList, grammar, startNode, startPos, rematch) {
      for (var token in grammar) {
        if (!grammar.hasOwnProperty(token) || !grammar[token]) {
          continue;
        }
        var patterns = grammar[token];
        patterns = Array.isArray(patterns) ? patterns : [patterns];
        for (var j = 0; j < patterns.length; ++j) {
          if (rematch && rematch.cause == token + "," + j) {
            return;
          }
          var patternObj = patterns[j];
          var inside = patternObj.inside;
          var lookbehind = !!patternObj.lookbehind;
          var greedy = !!patternObj.greedy;
          var alias2 = patternObj.alias;
          if (greedy && !patternObj.pattern.global) {
            var flags2 = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
            patternObj.pattern = RegExp(patternObj.pattern.source, flags2 + "g");
          }
          var pattern4 = patternObj.pattern || patternObj;
          for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
            if (rematch && pos >= rematch.reach) {
              break;
            }
            var str = currentNode.value;
            if (tokenList.length > text2.length) {
              return;
            }
            if (str instanceof Token) {
              continue;
            }
            var removeCount = 1;
            var match2;
            if (greedy) {
              match2 = matchPattern(pattern4, pos, text2, lookbehind);
              if (!match2 || match2.index >= text2.length) {
                break;
              }
              var from = match2.index;
              var to = match2.index + match2[0].length;
              var p2 = pos;
              p2 += currentNode.value.length;
              while (from >= p2) {
                currentNode = currentNode.next;
                p2 += currentNode.value.length;
              }
              p2 -= currentNode.value.length;
              pos = p2;
              if (currentNode.value instanceof Token) {
                continue;
              }
              for (var k2 = currentNode; k2 !== tokenList.tail && (p2 < to || typeof k2.value === "string"); k2 = k2.next) {
                removeCount++;
                p2 += k2.value.length;
              }
              removeCount--;
              str = text2.slice(pos, p2);
              match2.index -= pos;
            } else {
              match2 = matchPattern(pattern4, 0, str, lookbehind);
              if (!match2) {
                continue;
              }
            }
            var from = match2.index;
            var matchStr = match2[0];
            var before = str.slice(0, from);
            var after = str.slice(from + matchStr.length);
            var reach = pos + str.length;
            if (rematch && reach > rematch.reach) {
              rematch.reach = reach;
            }
            var removeFrom = currentNode.prev;
            if (before) {
              removeFrom = addAfter(tokenList, removeFrom, before);
              pos += before.length;
            }
            removeRange(tokenList, removeFrom, removeCount);
            var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias2, matchStr);
            currentNode = addAfter(tokenList, removeFrom, wrapped);
            if (after) {
              addAfter(tokenList, currentNode, after);
            }
            if (removeCount > 1) {
              var nestedRematch = {
                cause: token + "," + j,
                reach
              };
              matchGrammar(text2, tokenList, grammar, currentNode.prev, pos, nestedRematch);
              if (rematch && nestedRematch.reach > rematch.reach) {
                rematch.reach = nestedRematch.reach;
              }
            }
          }
        }
      }
    }
    function LinkedList() {
      var head = { value: null, prev: null, next: null };
      var tail = { value: null, prev: head, next: null };
      head.next = tail;
      this.head = head;
      this.tail = tail;
      this.length = 0;
    }
    function addAfter(list2, node, value2) {
      var next = node.next;
      var newNode = { value: value2, prev: node, next };
      node.next = newNode;
      next.prev = newNode;
      list2.length++;
      return newNode;
    }
    function removeRange(list2, node, count) {
      var next = node.next;
      for (var i = 0; i < count && next !== list2.tail; i++) {
        next = next.next;
      }
      node.next = next;
      next.prev = node;
      list2.length -= i;
    }
    function toArray2(list2) {
      var array4 = [];
      var node = list2.head.next;
      while (node !== list2.tail) {
        array4.push(node.value);
        node = node.next;
      }
      return array4;
    }
    if (!_self2.document) {
      if (!_self2.addEventListener) {
        return _;
      }
      if (!_.disableWorkerMessageHandler) {
        _self2.addEventListener("message", function(evt) {
          var message2 = JSON.parse(evt.data);
          var lang2 = message2.language;
          var code = message2.code;
          var immediateClose = message2.immediateClose;
          _self2.postMessage(_.highlight(code, _.languages[lang2], lang2));
          if (immediateClose) {
            _self2.close();
          }
        }, false);
      }
      return _;
    }
    var script = _.util.currentScript();
    if (script) {
      _.filename = script.src;
      if (script.hasAttribute("data-manual")) {
        _.manual = true;
      }
    }
    function highlightAutomaticallyCallback() {
      if (!_.manual) {
        _.highlightAll();
      }
    }
    if (!_.manual) {
      var readyState = document.readyState;
      if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
        document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
      } else {
        if (window.requestAnimationFrame) {
          window.requestAnimationFrame(highlightAutomaticallyCallback);
        } else {
          window.setTimeout(highlightAutomaticallyCallback, 16);
        }
      }
    }
    return _;
  }(_self);
  if (module.exports) {
    module.exports = Prism2;
  }
  if (typeof commonjsGlobal$1 !== "undefined") {
    commonjsGlobal$1.Prism = Prism2;
  }
})(prismCore);
var markup_1 = markup$1;
markup$1.displayName = "markup";
markup$1.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
function markup$1(Prism2) {
  Prism2.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: true
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: true
    },
    doctype: {
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: true,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: true,
          greedy: true,
          inside: null
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: true
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: true
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: true,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  };
  Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
  Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
  Prism2.hooks.add("wrap", function(env) {
    if (env.type === "entity") {
      env.attributes["title"] = env.content.value.replace(/&amp;/, "&");
    }
  });
  Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
    value: function addInlined(tagName, lang) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: true,
        inside: Prism2.languages[lang]
      };
      includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang] = {
        pattern: /[\s\S]+/,
        inside: Prism2.languages[lang]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return tagName;
        }), "i"),
        lookbehind: true,
        greedy: true,
        inside
      };
      Prism2.languages.insertBefore("markup", "cdata", def);
    }
  });
  Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
    value: function(attrName, lang) {
      Prism2.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(/(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"),
        lookbehind: true,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: true,
                alias: [lang, "language-" + lang],
                inside: Prism2.languages[lang]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  });
  Prism2.languages.html = Prism2.languages.markup;
  Prism2.languages.mathml = Prism2.languages.markup;
  Prism2.languages.svg = Prism2.languages.markup;
  Prism2.languages.xml = Prism2.languages.extend("markup", {});
  Prism2.languages.ssml = Prism2.languages.xml;
  Prism2.languages.atom = Prism2.languages.xml;
  Prism2.languages.rss = Prism2.languages.xml;
}
var css_1 = css$2;
css$2.displayName = "css";
css$2.aliases = [];
function css$2(Prism2) {
  (function(Prism3) {
    var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism3.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: true,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: true
          }
        }
      },
      url: {
        pattern: RegExp("\\burl\\((?:" + string3.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: true,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + string3.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ")*(?=\\s*\\{)"),
        lookbehind: true
      },
      string: {
        pattern: string3,
        greedy: true
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: true
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: true
      },
      punctuation: /[(){};:,]/
    };
    Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
    var markup2 = Prism3.languages.markup;
    if (markup2) {
      markup2.tag.addInlined("style", "css");
      markup2.tag.addAttribute("style", "css");
    }
  })(Prism2);
}
var clike_1 = clike$1;
clike$1.displayName = "clike";
clike$1.aliases = [];
function clike$1(Prism2) {
  Prism2.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: true,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  };
}
var javascript_1 = javascript;
javascript.displayName = "javascript";
javascript.aliases = ["js"];
function javascript(Prism2) {
  Prism2.languages.javascript = Prism2.languages.extend("clike", {
    "class-name": [
      Prism2.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: true
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: true
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: true
      }
    ],
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source),
      lookbehind: true
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  });
  Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
  Prism2.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
      lookbehind: true,
      greedy: true,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: true,
          alias: "language-regex",
          inside: Prism2.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: true,
        inside: Prism2.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  });
  Prism2.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: true,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: true,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: true,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism2.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: true,
      greedy: true,
      alias: "property"
    }
  });
  Prism2.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: true,
      alias: "property"
    }
  });
  if (Prism2.languages.markup) {
    Prism2.languages.markup.tag.addInlined("script", "javascript");
    Prism2.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript");
  }
  Prism2.languages.js = Prism2.languages.javascript;
}
var ctx = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof commonjsGlobal$1 === "object" ? commonjsGlobal$1 : {};
var restore = capture();
ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
var h = hastscript.exports;
var decode = parseEntities_1;
var Prism = prismCore.exports;
var markup = markup_1;
var css$1 = css_1;
var clike = clike_1;
var js = javascript_1;
restore();
var own$1 = {}.hasOwnProperty;
function Refractor() {
}
Refractor.prototype = Prism;
var refract = new Refractor();
var core = refract;
refract.highlight = highlight;
refract.register = register;
refract.alias = alias;
refract.registered = registered;
refract.listLanguages = listLanguages;
register(markup);
register(css$1);
register(clike);
register(js);
refract.util.encode = encode;
refract.Token.stringify = stringify$1;
function register(grammar) {
  if (typeof grammar !== "function" || !grammar.displayName) {
    throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
  }
  if (refract.languages[grammar.displayName] === void 0) {
    grammar(refract);
  }
}
function alias(name2, alias2) {
  var languages = refract.languages;
  var map = name2;
  var key2;
  var list2;
  var length;
  var index2;
  if (alias2) {
    map = {};
    map[name2] = alias2;
  }
  for (key2 in map) {
    list2 = map[key2];
    list2 = typeof list2 === "string" ? [list2] : list2;
    length = list2.length;
    index2 = -1;
    while (++index2 < length) {
      languages[list2[index2]] = languages[key2];
    }
  }
}
function highlight(value2, name2) {
  var sup = Prism.highlight;
  var grammar;
  if (typeof value2 !== "string") {
    throw new Error("Expected `string` for `value`, got `" + value2 + "`");
  }
  if (refract.util.type(name2) === "Object") {
    grammar = name2;
    name2 = null;
  } else {
    if (typeof name2 !== "string") {
      throw new Error("Expected `string` for `name`, got `" + name2 + "`");
    }
    if (own$1.call(refract.languages, name2)) {
      grammar = refract.languages[name2];
    } else {
      throw new Error("Unknown language: `" + name2 + "` is not registered");
    }
  }
  return sup.call(this, value2, grammar, name2);
}
function registered(language) {
  if (typeof language !== "string") {
    throw new Error("Expected `string` for `language`, got `" + language + "`");
  }
  return own$1.call(refract.languages, language);
}
function listLanguages() {
  var languages = refract.languages;
  var list2 = [];
  var language;
  for (language in languages) {
    if (own$1.call(languages, language) && typeof languages[language] === "object") {
      list2.push(language);
    }
  }
  return list2;
}
function stringify$1(value2, language, parent) {
  var env;
  if (typeof value2 === "string") {
    return { type: "text", value: value2 };
  }
  if (refract.util.type(value2) === "Array") {
    return stringifyAll(value2, language);
  }
  env = {
    type: value2.type,
    content: refract.Token.stringify(value2.content, language, parent),
    tag: "span",
    classes: ["token", value2.type],
    attributes: {},
    language,
    parent
  };
  if (value2.alias) {
    env.classes = env.classes.concat(value2.alias);
  }
  refract.hooks.run("wrap", env);
  return h(env.tag + "." + env.classes.join("."), attributes$1(env.attributes), env.content);
}
function stringifyAll(values, language) {
  var result = [];
  var length = values.length;
  var index2 = -1;
  var value2;
  while (++index2 < length) {
    value2 = values[index2];
    if (value2 !== "" && value2 !== null && value2 !== void 0) {
      result.push(value2);
    }
  }
  index2 = -1;
  length = result.length;
  while (++index2 < length) {
    value2 = result[index2];
    result[index2] = refract.Token.stringify(value2, language, result);
  }
  return result;
}
function encode(tokens) {
  return tokens;
}
function attributes$1(attrs) {
  var key2;
  for (key2 in attrs) {
    attrs[key2] = decode(attrs[key2]);
  }
  return attrs;
}
function capture() {
  var defined = "Prism" in ctx;
  var current = defined ? ctx.Prism : void 0;
  return restore2;
  function restore2() {
    if (defined) {
      ctx.Prism = current;
    } else {
      delete ctx.Prism;
    }
    defined = void 0;
    current = void 0;
  }
}
var SyntaxHighlighter = highlight$1(core, {});
SyntaxHighlighter.registerLanguage = function(_, language) {
  return core.register(language);
};
SyntaxHighlighter.alias = function(name2, aliases) {
  return core.alias(name2, aliases);
};
const SyntaxHighlighter$1 = SyntaxHighlighter;
var jsx_1 = jsx;
jsx.displayName = "jsx";
jsx.aliases = [];
function jsx(Prism2) {
  (function(Prism3) {
    var javascript2 = Prism3.util.clone(Prism3.languages.javascript);
    var space2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
    var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
    var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
    function re2(source, flags2) {
      source = source.replace(/<S>/g, function() {
        return space2;
      }).replace(/<BRACES>/g, function() {
        return braces;
      }).replace(/<SPREAD>/g, function() {
        return spread;
      });
      return RegExp(source, flags2);
    }
    spread = re2(spread).source;
    Prism3.languages.jsx = Prism3.languages.extend("markup", javascript2);
    Prism3.languages.jsx.tag.pattern = re2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source);
    Prism3.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
    Prism3.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
    Prism3.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
    Prism3.languages.jsx.tag.inside["comment"] = javascript2["comment"];
    Prism3.languages.insertBefore("inside", "attr-name", {
      spread: {
        pattern: re2(/<SPREAD>/.source),
        inside: Prism3.languages.jsx
      }
    }, Prism3.languages.jsx.tag);
    Prism3.languages.insertBefore("inside", "special-attr", {
      script: {
        pattern: re2(/=<BRACES>/.source),
        alias: "language-javascript",
        inside: {
          "script-punctuation": {
            pattern: /^=(?=\{)/,
            alias: "punctuation"
          },
          rest: Prism3.languages.jsx
        }
      }
    }, Prism3.languages.jsx.tag);
    var stringifyToken = function(token) {
      if (!token) {
        return "";
      }
      if (typeof token === "string") {
        return token;
      }
      if (typeof token.content === "string") {
        return token.content;
      }
      return token.content.map(stringifyToken).join("");
    };
    var walkTokens = function(tokens) {
      var openedTags = [];
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var notTagNorBrace = false;
        if (typeof token !== "string") {
          if (token.type === "tag" && token.content[0] && token.content[0].type === "tag") {
            if (token.content[0].content[0].content === "</") {
              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {
                openedTags.pop();
              }
            } else {
              if (token.content[token.content.length - 1].content === "/>")
                ;
              else {
                openedTags.push({
                  tagName: stringifyToken(token.content[0].content[1]),
                  openedBraces: 0
                });
              }
            }
          } else if (openedTags.length > 0 && token.type === "punctuation" && token.content === "{") {
            openedTags[openedTags.length - 1].openedBraces++;
          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === "punctuation" && token.content === "}") {
            openedTags[openedTags.length - 1].openedBraces--;
          } else {
            notTagNorBrace = true;
          }
        }
        if (notTagNorBrace || typeof token === "string") {
          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
            var plainText = stringifyToken(token);
            if (i < tokens.length - 1 && (typeof tokens[i + 1] === "string" || tokens[i + 1].type === "plain-text")) {
              plainText += stringifyToken(tokens[i + 1]);
              tokens.splice(i + 1, 1);
            }
            if (i > 0 && (typeof tokens[i - 1] === "string" || tokens[i - 1].type === "plain-text")) {
              plainText = stringifyToken(tokens[i - 1]) + plainText;
              tokens.splice(i - 1, 1);
              i--;
            }
            tokens[i] = new Prism3.Token("plain-text", plainText, null, plainText);
          }
        }
        if (token.content && typeof token.content !== "string") {
          walkTokens(token.content);
        }
      }
    };
    Prism3.hooks.add("after-tokenize", function(env) {
      if (env.language !== "jsx" && env.language !== "tsx") {
        return;
      }
      walkTokens(env.tokens);
    });
  })(Prism2);
}
var typescript_1 = typescript;
typescript.displayName = "typescript";
typescript.aliases = ["ts"];
function typescript(Prism2) {
  (function(Prism3) {
    Prism3.languages.typescript = Prism3.languages.extend("javascript", {
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
        lookbehind: true,
        greedy: true,
        inside: null
      },
      builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
    });
    Prism3.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/);
    delete Prism3.languages.typescript["parameter"];
    delete Prism3.languages.typescript["literal-property"];
    var typeInside = Prism3.languages.extend("typescript", {});
    delete typeInside["class-name"];
    Prism3.languages.typescript["class-name"].inside = typeInside;
    Prism3.languages.insertBefore("typescript", "function", {
      decorator: {
        pattern: /@[$\w\xA0-\uFFFF]+/,
        inside: {
          at: {
            pattern: /^@/,
            alias: "operator"
          },
          function: /^[\s\S]+/
        }
      },
      "generic-function": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
        greedy: true,
        inside: {
          function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
          generic: {
            pattern: /<[\s\S]+/,
            alias: "class-name",
            inside: typeInside
          }
        }
      }
    });
    Prism3.languages.ts = Prism3.languages.typescript;
  })(Prism2);
}
var refractorJsx = jsx_1;
var refractorTypescript = typescript_1;
var tsx_1 = tsx;
tsx.displayName = "tsx";
tsx.aliases = [];
function tsx(Prism2) {
  Prism2.register(refractorJsx);
  Prism2.register(refractorTypescript);
  (function(Prism3) {
    var typescript2 = Prism3.util.clone(Prism3.languages.typescript);
    Prism3.languages.tsx = Prism3.languages.extend("jsx", typescript2);
    delete Prism3.languages.tsx["parameter"];
    delete Prism3.languages.tsx["literal-property"];
    var tag = Prism3.languages.tsx.tag;
    tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
    tag.lookbehind = true;
  })(Prism2);
}
const tsx$1 = tsx_1;
var scss_1 = scss;
scss.displayName = "scss";
scss.aliases = [];
function scss(Prism2) {
  Prism2.languages.scss = Prism2.languages.extend("css", {
    comment: {
      pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
      lookbehind: true
    },
    atrule: {
      pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
      inside: {
        rule: /@[\w-]+/
      }
    },
    url: /(?:[-a-z]+-)?url(?=\()/i,
    selector: {
      pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
      inside: {
        parent: {
          pattern: /&/,
          alias: "important"
        },
        placeholder: /%[-\w]+/,
        variable: /\$[-\w]+|#\{\$[-\w]+\}/
      }
    },
    property: {
      pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
      inside: {
        variable: /\$[-\w]+|#\{\$[-\w]+\}/
      }
    }
  });
  Prism2.languages.insertBefore("scss", "atrule", {
    keyword: [
      /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
      {
        pattern: /( )(?:from|through)(?= )/,
        lookbehind: true
      }
    ]
  });
  Prism2.languages.insertBefore("scss", "important", {
    variable: /\$[-\w]+|#\{\$[-\w]+\}/
  });
  Prism2.languages.insertBefore("scss", "function", {
    "module-modifier": {
      pattern: /\b(?:as|hide|show|with)\b/i,
      alias: "keyword"
    },
    placeholder: {
      pattern: /%[-\w]+/,
      alias: "selector"
    },
    statement: {
      pattern: /\B!(?:default|optional)\b/i,
      alias: "keyword"
    },
    boolean: /\b(?:false|true)\b/,
    null: {
      pattern: /\bnull\b/,
      alias: "keyword"
    },
    operator: {
      pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
      lookbehind: true
    }
  });
  Prism2.languages.scss["atrule"].inside.rest = Prism2.languages.scss;
}
const scss$1 = scss_1;
var less_1 = less;
less.displayName = "less";
less.aliases = [];
function less(Prism2) {
  Prism2.languages.less = Prism2.languages.extend("css", {
    comment: [
      /\/\*[\s\S]*?\*\//,
      {
        pattern: /(^|[^\\])\/\/.*/,
        lookbehind: true
      }
    ],
    atrule: {
      pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
      inside: {
        punctuation: /[:()]/
      }
    },
    selector: {
      pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
      inside: {
        variable: /@+[\w-]+/
      }
    },
    property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
    operator: /[+\-*\/]/
  });
  Prism2.languages.insertBefore("less", "property", {
    variable: [
      {
        pattern: /@[\w-]+\s*:/,
        inside: {
          punctuation: /:/
        }
      },
      /@@?[\w-]+/
    ],
    "mixin-usage": {
      pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
      lookbehind: true,
      alias: "function"
    }
  });
}
const less$1 = less_1;
var json_1 = json;
json.displayName = "json";
json.aliases = ["webmanifest"];
function json(Prism2) {
  Prism2.languages.json = {
    property: {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
      lookbehind: true,
      greedy: true
    },
    string: {
      pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
      lookbehind: true,
      greedy: true
    },
    comment: {
      pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
      greedy: true
    },
    number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
    punctuation: /[{}[\],]/,
    operator: /:/,
    boolean: /\b(?:false|true)\b/,
    null: {
      pattern: /\bnull\b/,
      alias: "keyword"
    }
  };
  Prism2.languages.webmanifest = Prism2.languages.json;
}
const json$1 = json_1;
const index$4 = "";
SyntaxHighlighter$1.registerLanguage("jsx", tsx$1);
SyntaxHighlighter$1.registerLanguage("json", json$1);
SyntaxHighlighter$1.registerLanguage("tsx", tsx$1);
SyntaxHighlighter$1.registerLanguage("scss", scss$1);
SyntaxHighlighter$1.registerLanguage("less", less$1);
function HighLighter({ lang, children }) {
  const [copied, setCopied] = react.exports.useState(false);
  return /* @__PURE__ */ React$a.createElement("div", {
    className: `code-pane language-${lang}`
  }, /* @__PURE__ */ React$a.createElement(lib.CopyToClipboard, {
    text: children,
    onCopy: () => setCopied(true)
  }, /* @__PURE__ */ React$a.createElement("span", {
    className: "icon-copy"
  }, copied ? "Copied !" : "Copy")), /* @__PURE__ */ React$a.createElement(SyntaxHighlighter$1, {
    language: lang,
    useInlineStyles: false
  }, children));
}
HighLighter.registerLanguage = SyntaxHighlighter$1.registerLanguage;
var createUpdateEffect = function createUpdateEffect2(hook) {
  return function(effect, deps) {
    var isMounted = react.exports.useRef(false);
    hook(function() {
      return function() {
        isMounted.current = false;
      };
    }, []);
    hook(function() {
      if (!isMounted.current) {
        isMounted.current = true;
      } else {
        return effect();
      }
    }, deps);
  };
};
var isFunction$3 = function isFunction(value2) {
  return typeof value2 === "function";
};
var isUndef = function isUndef2(value2) {
  return typeof value2 === "undefined";
};
function useMemoizedFn(fn) {
  var fnRef = react.exports.useRef(fn);
  fnRef.current = react.exports.useMemo(function() {
    return fn;
  }, [fn]);
  var memoizedFn = react.exports.useRef();
  if (!memoizedFn.current) {
    memoizedFn.current = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return fnRef.current.apply(this, args);
    };
  }
  return memoizedFn.current;
}
const useUpdateEffect = createUpdateEffect(react.exports.useEffect);
var __read$b = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$7 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$b(arguments[i]));
  }
  return ar;
};
var useAutoRunPlugin = function useAutoRunPlugin2(fetchInstance, _a) {
  var manual = _a.manual, _b = _a.ready, ready = _b === void 0 ? true : _b, _c = _a.defaultParams, defaultParams = _c === void 0 ? [] : _c, _d = _a.refreshDeps, refreshDeps = _d === void 0 ? [] : _d, refreshDepsAction = _a.refreshDepsAction;
  var hasAutoRun = react.exports.useRef(false);
  hasAutoRun.current = false;
  useUpdateEffect(function() {
    if (!manual && ready) {
      hasAutoRun.current = true;
      fetchInstance.run.apply(fetchInstance, __spread$7(defaultParams));
    }
  }, [ready]);
  useUpdateEffect(function() {
    if (hasAutoRun.current) {
      return;
    }
    if (!manual) {
      hasAutoRun.current = true;
      if (refreshDepsAction) {
        refreshDepsAction();
      } else {
        fetchInstance.refresh();
      }
    }
  }, __spread$7(refreshDeps));
  return {
    onBefore: function onBefore() {
      if (!ready) {
        return {
          stopNow: true
        };
      }
    }
  };
};
useAutoRunPlugin.onInit = function(_a) {
  var _b = _a.ready, ready = _b === void 0 ? true : _b, manual = _a.manual;
  return {
    loading: !manual && ready
  };
};
const useAutoRunPlugin$1 = useAutoRunPlugin;
function depsAreSame(oldDeps, deps) {
  if (oldDeps === deps)
    return true;
  for (var i = 0; i < oldDeps.length; i++) {
    if (!Object.is(oldDeps[i], deps[i]))
      return false;
  }
  return true;
}
function useCreation(factory2, deps) {
  var current = react.exports.useRef({
    deps,
    obj: void 0,
    initialized: false
  }).current;
  if (current.initialized === false || !depsAreSame(current.deps, deps)) {
    current.deps = deps;
    current.obj = factory2();
    current.initialized = true;
  }
  return current.obj;
}
function useLatest(value2) {
  var ref = react.exports.useRef(value2);
  ref.current = value2;
  return ref;
}
var useUnmount = function useUnmount2(fn) {
  var fnRef = useLatest(fn);
  react.exports.useEffect(function() {
    return function() {
      fnRef.current();
    };
  }, []);
};
const useUnmount$1 = useUnmount;
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s) {
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
      }
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var cache = /* @__PURE__ */ new Map();
var setCache = function setCache2(key2, cacheTime, cachedData) {
  var currentCache = cache.get(key2);
  if (currentCache === null || currentCache === void 0 ? void 0 : currentCache.timer) {
    clearTimeout(currentCache.timer);
  }
  var timer = void 0;
  if (cacheTime > -1) {
    timer = setTimeout(function() {
      cache["delete"](key2);
    }, cacheTime);
  }
  cache.set(key2, __assign$2(__assign$2({}, cachedData), {
    timer
  }));
};
var getCache = function getCache2(key2) {
  return cache.get(key2);
};
var cachePromise = /* @__PURE__ */ new Map();
var getCachePromise = function getCachePromise2(cacheKey) {
  return cachePromise.get(cacheKey);
};
var setCachePromise = function setCachePromise2(cacheKey, promise) {
  cachePromise.set(cacheKey, promise);
  promise.then(function(res) {
    cachePromise["delete"](cacheKey);
    return res;
  })["catch"](function() {
    cachePromise["delete"](cacheKey);
  });
};
var listeners$2 = {};
var trigger = function trigger2(key2, data2) {
  if (listeners$2[key2]) {
    listeners$2[key2].forEach(function(item) {
      return item(data2);
    });
  }
};
var subscribe$2 = function subscribe(key2, listener) {
  if (!listeners$2[key2]) {
    listeners$2[key2] = [];
  }
  listeners$2[key2].push(listener);
  return function unsubscribe2() {
    var index2 = listeners$2[key2].indexOf(listener);
    listeners$2[key2].splice(index2, 1);
  };
};
var __read$a = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$6 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$a(arguments[i]));
  }
  return ar;
};
var useCachePlugin = function useCachePlugin2(fetchInstance, _a) {
  var cacheKey = _a.cacheKey, _b = _a.cacheTime, cacheTime = _b === void 0 ? 5 * 60 * 1e3 : _b, _c = _a.staleTime, staleTime = _c === void 0 ? 0 : _c, customSetCache = _a.setCache, customGetCache = _a.getCache;
  var unSubscribeRef = react.exports.useRef();
  var currentPromiseRef = react.exports.useRef();
  var _setCache = function _setCache2(key2, cachedData) {
    if (customSetCache) {
      customSetCache(cachedData);
    } else {
      setCache(key2, cacheTime, cachedData);
    }
    trigger(key2, cachedData.data);
  };
  var _getCache = function _getCache2(key2, params) {
    if (params === void 0) {
      params = [];
    }
    if (customGetCache) {
      return customGetCache(params);
    }
    return getCache(key2);
  };
  useCreation(function() {
    if (!cacheKey) {
      return;
    }
    var cacheData = _getCache(cacheKey);
    if (cacheData && Object.hasOwnProperty.call(cacheData, "data")) {
      fetchInstance.state.data = cacheData.data;
      fetchInstance.state.params = cacheData.params;
      if (staleTime === -1 || new Date().getTime() - cacheData.time <= staleTime) {
        fetchInstance.state.loading = false;
      }
    }
    unSubscribeRef.current = subscribe$2(cacheKey, function(data2) {
      fetchInstance.setState({
        data: data2
      });
    });
  }, []);
  useUnmount$1(function() {
    var _a2;
    (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
  });
  if (!cacheKey) {
    return {};
  }
  return {
    onBefore: function onBefore(params) {
      var cacheData = _getCache(cacheKey, params);
      if (!cacheData || !Object.hasOwnProperty.call(cacheData, "data")) {
        return {};
      }
      if (staleTime === -1 || new Date().getTime() - cacheData.time <= staleTime) {
        return {
          loading: false,
          data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data,
          returnNow: true
        };
      } else {
        return {
          data: cacheData === null || cacheData === void 0 ? void 0 : cacheData.data
        };
      }
    },
    onRequest: function onRequest(service, args) {
      var servicePromise = getCachePromise(cacheKey);
      if (servicePromise && servicePromise !== currentPromiseRef.current) {
        return {
          servicePromise
        };
      }
      servicePromise = service.apply(void 0, __spread$6(args));
      currentPromiseRef.current = servicePromise;
      setCachePromise(cacheKey, servicePromise);
      return {
        servicePromise
      };
    },
    onSuccess: function onSuccess(data2, params) {
      var _a2;
      if (cacheKey) {
        (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
        _setCache(cacheKey, {
          data: data2,
          params,
          time: new Date().getTime()
        });
        unSubscribeRef.current = subscribe$2(cacheKey, function(d2) {
          fetchInstance.setState({
            data: d2
          });
        });
      }
    },
    onMutate: function onMutate(data2) {
      var _a2;
      if (cacheKey) {
        (_a2 = unSubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unSubscribeRef);
        _setCache(cacheKey, {
          data: data2,
          params: fetchInstance.state.params,
          time: new Date().getTime()
        });
        unSubscribeRef.current = subscribe$2(cacheKey, function(d2) {
          fetchInstance.setState({
            data: d2
          });
        });
      }
    }
  };
};
const useCachePlugin$1 = useCachePlugin;
function isObject$7(value2) {
  var type4 = typeof value2;
  return value2 != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$7;
var freeGlobal$1 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$9 = freeGlobal || freeSelf || Function("return this")();
var _root = root$9;
var root$8 = _root;
var now$2 = function() {
  return root$8.Date.now();
};
var now_1 = now$2;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string3) {
  var index2 = string3.length;
  while (index2-- && reWhitespace.test(string3.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
}
var _baseTrim = baseTrim$1;
var root$7 = _root;
var Symbol$5 = root$7.Symbol;
var _Symbol = Symbol$5;
var Symbol$4 = _Symbol;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol$4 ? Symbol$4.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString$1(value2) {
  return nativeObjectToString.call(value2);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$5(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
var _baseGetTag = baseGetTag$5;
function isObjectLike$5(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_1 = isObjectLike$5;
var baseGetTag$4 = _baseGetTag, isObjectLike$4 = isObjectLike_1;
var symbolTag$1 = "[object Symbol]";
function isSymbol$4(value2) {
  return typeof value2 == "symbol" || isObjectLike$4(value2) && baseGetTag$4(value2) == symbolTag$1;
}
var isSymbol_1 = isSymbol$4;
var baseTrim = _baseTrim, isObject$6 = isObject_1, isSymbol$3 = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol$3(value2)) {
    return NAN;
  }
  if (isObject$6(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject$6(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var toNumber_1 = toNumber$2;
var isObject$5 = isObject_1, now$1 = now_1, toNumber$1 = toNumber_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  wait = toNumber$1(wait) || 0;
  if (isObject$5(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber$1(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel2() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel2;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var __read$9 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$5 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$9(arguments[i]));
  }
  return ar;
};
var useDebouncePlugin = function useDebouncePlugin2(fetchInstance, _a) {
  var debounceWait = _a.debounceWait, debounceLeading = _a.debounceLeading, debounceTrailing = _a.debounceTrailing, debounceMaxWait = _a.debounceMaxWait;
  var debouncedRef = react.exports.useRef();
  var options = react.exports.useMemo(function() {
    var ret = {};
    if (debounceLeading !== void 0) {
      ret.leading = debounceLeading;
    }
    if (debounceTrailing !== void 0) {
      ret.trailing = debounceTrailing;
    }
    if (debounceMaxWait !== void 0) {
      ret.maxWait = debounceMaxWait;
    }
    return ret;
  }, [debounceLeading, debounceTrailing, debounceMaxWait]);
  react.exports.useEffect(function() {
    if (debounceWait) {
      var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
      debouncedRef.current = debounce_1(function(callback) {
        callback();
      }, debounceWait, options);
      fetchInstance.runAsync = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve, reject) {
          var _a2;
          (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(debouncedRef, function() {
            _originRunAsync_1.apply(void 0, __spread$5(args)).then(resolve)["catch"](reject);
          });
        });
      };
      return function() {
        var _a2;
        (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
        fetchInstance.runAsync = _originRunAsync_1;
      };
    }
  }, [debounceWait, options]);
  if (!debounceWait) {
    return {};
  }
  return {
    onCancel: function onCancel() {
      var _a2;
      (_a2 = debouncedRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
    }
  };
};
const useDebouncePlugin$1 = useDebouncePlugin;
var useLoadingDelayPlugin = function useLoadingDelayPlugin2(fetchInstance, _a) {
  var loadingDelay = _a.loadingDelay;
  var timerRef = react.exports.useRef();
  if (!loadingDelay) {
    return {};
  }
  var cancelTimeout = function cancelTimeout2() {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  };
  return {
    onBefore: function onBefore() {
      cancelTimeout();
      timerRef.current = setTimeout(function() {
        fetchInstance.setState({
          loading: true
        });
      }, loadingDelay);
      return {
        loading: false
      };
    },
    onFinally: function onFinally() {
      cancelTimeout();
    },
    onCancel: function onCancel() {
      cancelTimeout();
    }
  };
};
const useLoadingDelayPlugin$1 = useLoadingDelayPlugin;
var isBrowser$1 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
const isBrowser$2 = isBrowser$1;
function isDocumentVisible() {
  if (isBrowser$2) {
    return document.visibilityState !== "hidden";
  }
  return true;
}
var listeners$1 = [];
function subscribe$1(listener) {
  listeners$1.push(listener);
  return function unsubscribe2() {
    var index2 = listeners$1.indexOf(listener);
    listeners$1.splice(index2, 1);
  };
}
if (isBrowser$2) {
  var revalidate$1 = function revalidate() {
    if (!isDocumentVisible())
      return;
    for (var i = 0; i < listeners$1.length; i++) {
      var listener = listeners$1[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate$1, false);
}
var usePollingPlugin = function usePollingPlugin2(fetchInstance, _a) {
  var pollingInterval = _a.pollingInterval, _b = _a.pollingWhenHidden, pollingWhenHidden = _b === void 0 ? true : _b, _c = _a.pollingErrorRetryCount, pollingErrorRetryCount = _c === void 0 ? -1 : _c;
  var timerRef = react.exports.useRef();
  var unsubscribeRef = react.exports.useRef();
  var countRef = react.exports.useRef(0);
  var stopPolling = function stopPolling2() {
    var _a2;
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    (_a2 = unsubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unsubscribeRef);
  };
  useUpdateEffect(function() {
    if (!pollingInterval) {
      stopPolling();
    }
  }, [pollingInterval]);
  if (!pollingInterval) {
    return {};
  }
  return {
    onBefore: function onBefore() {
      stopPolling();
    },
    onError: function onError() {
      countRef.current += 1;
    },
    onSuccess: function onSuccess() {
      countRef.current = 0;
    },
    onFinally: function onFinally() {
      if (pollingErrorRetryCount === -1 || pollingErrorRetryCount !== -1 && countRef.current <= pollingErrorRetryCount) {
        timerRef.current = setTimeout(function() {
          if (!pollingWhenHidden && !isDocumentVisible()) {
            unsubscribeRef.current = subscribe$1(function() {
              fetchInstance.refresh();
            });
          } else {
            fetchInstance.refresh();
          }
        }, pollingInterval);
      } else {
        countRef.current = 0;
      }
    },
    onCancel: function onCancel() {
      stopPolling();
    }
  };
};
const usePollingPlugin$1 = usePollingPlugin;
var __read$8 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$4 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$8(arguments[i]));
  }
  return ar;
};
function limit(fn, timespan) {
  var pending = false;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (pending)
      return;
    pending = true;
    fn.apply(void 0, __spread$4(args));
    setTimeout(function() {
      pending = false;
    }, timespan);
  };
}
function isOnline() {
  if (isBrowser$2 && typeof navigator.onLine !== "undefined") {
    return navigator.onLine;
  }
  return true;
}
var listeners = [];
function subscribe2(listener) {
  listeners.push(listener);
  return function unsubscribe2() {
    var index2 = listeners.indexOf(listener);
    listeners.splice(index2, 1);
  };
}
if (isBrowser$2) {
  var revalidate = function revalidate2() {
    if (!isDocumentVisible() || !isOnline())
      return;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
  };
  window.addEventListener("visibilitychange", revalidate, false);
  window.addEventListener("focus", revalidate, false);
}
var useRefreshOnWindowFocusPlugin = function useRefreshOnWindowFocusPlugin2(fetchInstance, _a) {
  var refreshOnWindowFocus = _a.refreshOnWindowFocus, _b = _a.focusTimespan, focusTimespan = _b === void 0 ? 5e3 : _b;
  var unsubscribeRef = react.exports.useRef();
  var stopSubscribe = function stopSubscribe2() {
    var _a2;
    (_a2 = unsubscribeRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(unsubscribeRef);
  };
  react.exports.useEffect(function() {
    if (refreshOnWindowFocus) {
      var limitRefresh_1 = limit(fetchInstance.refresh.bind(fetchInstance), focusTimespan);
      unsubscribeRef.current = subscribe2(function() {
        limitRefresh_1();
      });
    }
    return function() {
      stopSubscribe();
    };
  }, [refreshOnWindowFocus, focusTimespan]);
  useUnmount$1(function() {
    stopSubscribe();
  });
  return {};
};
const useRefreshOnWindowFocusPlugin$1 = useRefreshOnWindowFocusPlugin;
var useRetryPlugin = function useRetryPlugin2(fetchInstance, _a) {
  var retryInterval = _a.retryInterval, retryCount = _a.retryCount;
  var timerRef = react.exports.useRef();
  var countRef = react.exports.useRef(0);
  var triggerByRetry = react.exports.useRef(false);
  if (!retryCount) {
    return {};
  }
  return {
    onBefore: function onBefore() {
      if (!triggerByRetry.current) {
        countRef.current = 0;
      }
      triggerByRetry.current = false;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    },
    onSuccess: function onSuccess() {
      countRef.current = 0;
    },
    onError: function onError() {
      countRef.current += 1;
      if (retryCount === -1 || countRef.current <= retryCount) {
        var timeout = retryInterval !== null && retryInterval !== void 0 ? retryInterval : Math.min(1e3 * Math.pow(2, countRef.current), 3e4);
        timerRef.current = setTimeout(function() {
          triggerByRetry.current = true;
          fetchInstance.refresh();
        }, timeout);
      } else {
        countRef.current = 0;
      }
    },
    onCancel: function onCancel() {
      countRef.current = 0;
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    }
  };
};
const useRetryPlugin$1 = useRetryPlugin;
var debounce = debounce_1, isObject$4 = isObject_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function throttle$1(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  if (isObject$4(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle$1;
var __read$7 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$3 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$7(arguments[i]));
  }
  return ar;
};
var useThrottlePlugin = function useThrottlePlugin2(fetchInstance, _a) {
  var throttleWait = _a.throttleWait, throttleLeading = _a.throttleLeading, throttleTrailing = _a.throttleTrailing;
  var throttledRef = react.exports.useRef();
  var options = {};
  if (throttleLeading !== void 0) {
    options.leading = throttleLeading;
  }
  if (throttleTrailing !== void 0) {
    options.trailing = throttleTrailing;
  }
  react.exports.useEffect(function() {
    if (throttleWait) {
      var _originRunAsync_1 = fetchInstance.runAsync.bind(fetchInstance);
      throttledRef.current = throttle_1(function(callback) {
        callback();
      }, throttleWait, options);
      fetchInstance.runAsync = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve, reject) {
          var _a2;
          (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.call(throttledRef, function() {
            _originRunAsync_1.apply(void 0, __spread$3(args)).then(resolve)["catch"](reject);
          });
        });
      };
      return function() {
        var _a2;
        fetchInstance.runAsync = _originRunAsync_1;
        (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
      };
    }
  }, [throttleWait, throttleLeading, throttleTrailing]);
  if (!throttleWait) {
    return {};
  }
  return {
    onCancel: function onCancel() {
      var _a2;
      (_a2 = throttledRef.current) === null || _a2 === void 0 ? void 0 : _a2.cancel();
    }
  };
};
const useThrottlePlugin$1 = useThrottlePlugin;
var useMount = function useMount2(fn) {
  react.exports.useEffect(function() {
    fn === null || fn === void 0 ? void 0 : fn();
  }, []);
};
const useMount$1 = useMount;
var __read$6 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var useUpdate = function useUpdate2() {
  var _a = __read$6(react.exports.useState({}), 2), setState = _a[1];
  return react.exports.useCallback(function() {
    return setState({});
  }, []);
};
const useUpdate$1 = useUpdate;
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s) {
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
      }
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
var __awaiter = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  }, f2, y2, t2, g2;
  return g2 = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_) {
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    }
    if (op[0] & 5)
      throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __rest$E = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var __read$5 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$2 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$5(arguments[i]));
  }
  return ar;
};
var Fetch = function() {
  function Fetch2(serviceRef, options, subscribe4, initState) {
    if (initState === void 0) {
      initState = {};
    }
    this.serviceRef = serviceRef;
    this.options = options;
    this.subscribe = subscribe4;
    this.initState = initState;
    this.count = 0;
    this.state = {
      loading: false,
      params: void 0,
      data: void 0,
      error: void 0
    };
    this.state = __assign$1(__assign$1(__assign$1({}, this.state), {
      loading: !options.manual
    }), initState);
  }
  Fetch2.prototype.setState = function(s) {
    if (s === void 0) {
      s = {};
    }
    this.state = __assign$1(__assign$1({}, this.state), s);
    this.subscribe();
  };
  Fetch2.prototype.runPluginHandler = function(event) {
    var rest = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      rest[_i - 1] = arguments[_i];
    }
    var r2 = this.pluginImpls.map(function(i) {
      var _a;
      return (_a = i[event]) === null || _a === void 0 ? void 0 : _a.call.apply(_a, __spread$2([i], rest));
    }).filter(Boolean);
    return Object.assign.apply(Object, __spread$2([{}], r2));
  };
  Fetch2.prototype.runAsync = function() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    return __awaiter(this, void 0, void 0, function() {
      var currentCount, _l, _m, stopNow, _o, returnNow, state, servicePromise, res, error_1;
      var _p;
      return __generator(this, function(_q) {
        switch (_q.label) {
          case 0:
            this.count += 1;
            currentCount = this.count;
            _l = this.runPluginHandler("onBefore", params), _m = _l.stopNow, stopNow = _m === void 0 ? false : _m, _o = _l.returnNow, returnNow = _o === void 0 ? false : _o, state = __rest$E(_l, ["stopNow", "returnNow"]);
            if (stopNow) {
              return [
                2,
                new Promise(function() {
                })
              ];
            }
            this.setState(__assign$1({
              loading: true,
              params
            }, state));
            if (returnNow) {
              return [
                2,
                Promise.resolve(state.data)
              ];
            }
            (_b = (_a = this.options).onBefore) === null || _b === void 0 ? void 0 : _b.call(_a, params);
            _q.label = 1;
          case 1:
            _q.trys.push([1, 3, , 4]);
            servicePromise = this.runPluginHandler("onRequest", this.serviceRef.current, params).servicePromise;
            if (!servicePromise) {
              servicePromise = (_p = this.serviceRef).current.apply(_p, __spread$2(params));
            }
            return [
              4,
              servicePromise
            ];
          case 2:
            res = _q.sent();
            if (currentCount !== this.count) {
              return [
                2,
                new Promise(function() {
                })
              ];
            }
            this.setState({
              data: res,
              error: void 0,
              loading: false
            });
            (_d = (_c = this.options).onSuccess) === null || _d === void 0 ? void 0 : _d.call(_c, res, params);
            this.runPluginHandler("onSuccess", res, params);
            (_f = (_e = this.options).onFinally) === null || _f === void 0 ? void 0 : _f.call(_e, params, res, void 0);
            if (currentCount === this.count) {
              this.runPluginHandler("onFinally", params, res, void 0);
            }
            return [
              2,
              res
            ];
          case 3:
            error_1 = _q.sent();
            if (currentCount !== this.count) {
              return [
                2,
                new Promise(function() {
                })
              ];
            }
            this.setState({
              error: error_1,
              loading: false
            });
            (_h = (_g = this.options).onError) === null || _h === void 0 ? void 0 : _h.call(_g, error_1, params);
            this.runPluginHandler("onError", error_1, params);
            (_k = (_j = this.options).onFinally) === null || _k === void 0 ? void 0 : _k.call(_j, params, void 0, error_1);
            if (currentCount === this.count) {
              this.runPluginHandler("onFinally", params, void 0, error_1);
            }
            throw error_1;
          case 4:
            return [
              2
            ];
        }
      });
    });
  };
  Fetch2.prototype.run = function() {
    var _this = this;
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    this.runAsync.apply(this, __spread$2(params))["catch"](function(error) {
      if (!_this.options.onError) {
        console.error(error);
      }
    });
  };
  Fetch2.prototype.cancel = function() {
    this.count += 1;
    this.setState({
      loading: false
    });
    this.runPluginHandler("onCancel");
  };
  Fetch2.prototype.refresh = function() {
    this.run.apply(this, __spread$2(this.state.params || []));
  };
  Fetch2.prototype.refreshAsync = function() {
    return this.runAsync.apply(this, __spread$2(this.state.params || []));
  };
  Fetch2.prototype.mutate = function(data2) {
    var targetData;
    if (isFunction$3(data2)) {
      targetData = data2(this.state.data);
    } else {
      targetData = data2;
    }
    this.runPluginHandler("onMutate", targetData);
    this.setState({
      data: targetData
    });
  };
  return Fetch2;
}();
const Fetch$1 = Fetch;
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s) {
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
      }
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __rest$D = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var __read$4 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread$1 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$4(arguments[i]));
  }
  return ar;
};
function useRequestImplement(service, options, plugins) {
  if (options === void 0) {
    options = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var _a = options.manual, manual = _a === void 0 ? false : _a, rest = __rest$D(options, ["manual"]);
  var fetchOptions = __assign({
    manual
  }, rest);
  var serviceRef = useLatest(service);
  var update = useUpdate$1();
  var fetchInstance = useCreation(function() {
    var initState = plugins.map(function(p2) {
      var _a2;
      return (_a2 = p2 === null || p2 === void 0 ? void 0 : p2.onInit) === null || _a2 === void 0 ? void 0 : _a2.call(p2, fetchOptions);
    }).filter(Boolean);
    return new Fetch$1(serviceRef, fetchOptions, update, Object.assign.apply(Object, __spread$1([{}], initState)));
  }, []);
  fetchInstance.options = fetchOptions;
  fetchInstance.pluginImpls = plugins.map(function(p2) {
    return p2(fetchInstance, fetchOptions);
  });
  useMount$1(function() {
    if (!manual) {
      var params = fetchInstance.state.params || options.defaultParams || [];
      fetchInstance.run.apply(fetchInstance, __spread$1(params));
    }
  });
  useUnmount$1(function() {
    fetchInstance.cancel();
  });
  return {
    loading: fetchInstance.state.loading,
    data: fetchInstance.state.data,
    error: fetchInstance.state.error,
    params: fetchInstance.state.params || [],
    cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)),
    refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)),
    refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)),
    run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)),
    runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)),
    mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance))
  };
}
var __read$3 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spread = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read$3(arguments[i]));
  }
  return ar;
};
function useRequest(service, options, plugins) {
  return useRequestImplement(service, options, __spread(plugins || [], [useDebouncePlugin$1, useLoadingDelayPlugin$1, usePollingPlugin$1, useRefreshOnWindowFocusPlugin$1, useThrottlePlugin$1, useAutoRunPlugin$1, useCachePlugin$1, useRetryPlugin$1]));
}
var __read$2 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
function useToggle(defaultValue, reverseValue) {
  if (defaultValue === void 0) {
    defaultValue = false;
  }
  var _a = __read$2(react.exports.useState(defaultValue), 2), state = _a[0], setState = _a[1];
  var actions = react.exports.useMemo(function() {
    var reverseValueOrigin = reverseValue === void 0 ? !defaultValue : reverseValue;
    var toggle = function toggle2() {
      return setState(function(s) {
        return s === defaultValue ? reverseValueOrigin : defaultValue;
      });
    };
    var set2 = function set3(value2) {
      return setState(value2);
    };
    var setLeft = function setLeft2() {
      return setState(defaultValue);
    };
    var setRight = function setRight2() {
      return setState(reverseValueOrigin);
    };
    return {
      toggle,
      set: set2,
      setLeft,
      setRight
    };
  }, []);
  return [state, actions];
}
var __read$1 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
function useBoolean(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = false;
  }
  var _a = __read$1(useToggle(defaultValue), 2), state = _a[0], _b = _a[1], toggle = _b.toggle, _set = _b.set;
  var actions = react.exports.useMemo(function() {
    var setTrue = function setTrue2() {
      return _set(true);
    };
    var setFalse = function setFalse2() {
      return _set(false);
    };
    return {
      toggle,
      set: function set2(v2) {
        return _set(!!v2);
      },
      setTrue,
      setFalse
    };
  }, []);
  return [state, actions];
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array4, key2) {
  var length = array4.length;
  while (length--) {
    if (eq$2(array4[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key2) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key2) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key2);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key2) {
  return assocIndexOf$1(this.__data__, key2) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key2, value2) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
  if (index2 < 0) {
    ++this.size;
    data2.push([key2, value2]);
  } else {
    data2[index2][1] = value2;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key2) {
  var data2 = this.__data__, result = data2["delete"](key2);
  this.size = data2.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key2) {
  return this.__data__.get(key2);
}
var _stackGet = stackGet$1;
function stackHas$1(key2) {
  return this.__data__.has(key2);
}
var _stackHas = stackHas$1;
var baseGetTag$3 = _baseGetTag, isObject$3 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value2) {
  if (!isObject$3(value2)) {
    return false;
  }
  var tag = baseGetTag$3(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$2 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$1(value2) {
  if (!isObject$2(value2) || isMasked(value2)) {
    return false;
  }
  var pattern4 = isFunction$1(value2) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value2));
}
var _baseIsNative = baseIsNative$1;
function getValue$4(object4, key2) {
  return object4 == null ? void 0 : object4[key2];
}
var _getValue = getValue$4;
var baseIsNative = _baseIsNative, getValue$3 = _getValue;
function getNative$7(object4, key2) {
  var value2 = getValue$3(object4, key2);
  return baseIsNative(value2) ? value2 : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative, root$5 = _root;
var Map$4 = getNative$6(root$5, "Map");
var _Map = Map$4;
var getNative$5 = _getNative;
var nativeCreate$4 = getNative$5(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet$1(key2) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data2, key2) ? data2[key2] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas$1(key2) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key2] !== void 0 : hasOwnProperty$6.call(data2, key2);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key2, value2) {
  var data2 = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data2[key2] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value2) {
  var type4 = typeof value2;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key2) {
  var data2 = map.__data__;
  return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key2) {
  var result = getMapData$3(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key2) {
  return getMapData$2(this, key2).get(key2);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key2) {
  return getMapData$1(this, key2).has(key2);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key2, value2) {
  var data2 = getMapData(this, key2), size = data2.size;
  data2.set(key2, value2);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$2 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key2, value2) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache$1) {
    var pairs = data2.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value2]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache$2(pairs);
  }
  data2.set(key2, value2);
  this.size = data2.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(entries) {
  var data2 = this.__data__ = new ListCache(entries);
  this.size = data2.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value2) {
  this.__data__.set(value2, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value2) {
  return this.__data__.has(value2);
}
var _setCacheHas = setCacheHas$1;
var MapCache$1 = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache$1();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length;
  while (++index2 < length) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache2, key2) {
  return cache2.has(key2);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$4 = _root;
var Uint8Array$1 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$1;
function mapToArray$1(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value2, key2) {
    result[++index2] = [key2, value2];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$2 = _Symbol, Uint8Array = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag$1(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array(object4), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq$1(+object4, +other);
    case errorTag$1:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object4 == other + "";
    case mapTag$2:
      var convert2 = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert2 || (convert2 = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object4, other);
      var result = equalArrays$1(convert2(object4), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object4) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array4, values) {
  var index2 = -1, length = values.length, offset3 = array4.length;
  while (++index2 < length) {
    array4[offset3 + index2] = values[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$1;
var isArray$6 = Array.isArray;
var isArray_1 = isArray$6;
var arrayPush = _arrayPush, isArray$5 = isArray_1;
function baseGetAllKeys$1(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray$5(object4) ? result : arrayPush(result, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array4[index2];
    if (predicate(value2, index2, array4)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$7 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value2) {
  return isObjectLike$3(value2) && baseGetTag$2(value2) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$2 = isObjectLike_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike$2(value2) && hasOwnProperty$5.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer3;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value2, length) {
  var type4 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type4 == "number" || type4 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var _isIndex = isIndex$2;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$1 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value2) {
  return isObjectLike$1(value2) && isLength$1(value2.length) && !!typedArrayTags[baseGetTag$1(value2)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value2) {
    return func(value2);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$4 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex$1 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$1(value2, inherited) {
  var isArr = isArray$4(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key2 in value2) {
    if ((inherited || hasOwnProperty$4.call(value2, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex$1(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$4 = Object.prototype;
function isPrototype$1(value2) {
  var Ctor = value2 && value2.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$4;
  return value2 === proto2;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys(object4);
  }
  var result = [];
  for (var key2 in Object(object4)) {
    if (hasOwnProperty$3.call(object4, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction2 = isFunction_1, isLength = isLength_1;
function isArrayLike$1(value2) {
  return value2 != null && isLength(value2.length) && !isFunction2(value2);
}
var isArrayLike_1 = isArrayLike$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$1(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
var keys_1 = keys$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys = keys_1;
function getAllKeys$1(object4) {
  return baseGetAllKeys(object4, keys, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function equalObjects$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object4), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$2.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object4[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object4, stack) : customizer(objValue, othValue, key2, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$3 = _root;
var DataView$1 = getNative$4(root$3, "DataView");
var _DataView = DataView$1;
var getNative$3 = _getNative, root$2 = _root;
var Promise$2 = getNative$3(root$2, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$1 = _root;
var Set$2 = getNative$2(root$1, "Set");
var _Set = Set$2;
var getNative$1 = _getNative, root = _root;
var WeakMap$2 = getNative$1(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value2) {
    var result = baseGetTag(value2), Ctor = result == objectTag$1 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$3 = isArray_1, isBuffer2 = isBuffer$2.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$3(object4), othIsArr = isArray$3(other), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer2(object4)) {
    if (!isBuffer2(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty$1.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$1(value2, other, bitmask, customizer, stack) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var baseIsEqual = _baseIsEqual;
function isEqual$1(value2, other) {
  return baseIsEqual(value2, other);
}
var isEqual_1 = isEqual$1;
var __values = globalThis && globalThis.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function next() {
        if (o && i >= o.length)
          o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var EventEmitter = function() {
  function EventEmitter2() {
    var _this = this;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.emit = function(val) {
      var e_1, _a;
      try {
        for (var _b = __values(_this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {
          var subscription = _c.value;
          subscription(val);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b["return"]))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    this.useSubscription = function(callback) {
      var callbackRef = react.exports.useRef();
      callbackRef.current = callback;
      react.exports.useEffect(function() {
        function subscription(val) {
          if (callbackRef.current) {
            callbackRef.current(val);
          }
        }
        _this.subscriptions.add(subscription);
        return function() {
          _this.subscriptions["delete"](subscription);
        };
      }, []);
    };
  }
  return EventEmitter2;
}();
function useEventEmitter() {
  var ref = react.exports.useRef();
  if (!ref.current) {
    ref.current = new EventEmitter();
  }
  return ref.current;
}
var __read = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) {
      ar.push(r2.value);
    }
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
function createUseStorageState(getStorage) {
  function useStorageState(key2, options) {
    var storage;
    try {
      storage = getStorage();
    } catch (err) {
      console.error(err);
    }
    var serializer = function serializer2(value2) {
      if (options === null || options === void 0 ? void 0 : options.serializer) {
        return options === null || options === void 0 ? void 0 : options.serializer(value2);
      }
      return JSON.stringify(value2);
    };
    var deserializer = function deserializer2(value2) {
      if (options === null || options === void 0 ? void 0 : options.deserializer) {
        return options === null || options === void 0 ? void 0 : options.deserializer(value2);
      }
      return JSON.parse(value2);
    };
    function getStoredValue() {
      try {
        var raw = storage === null || storage === void 0 ? void 0 : storage.getItem(key2);
        if (raw) {
          return deserializer(raw);
        }
      } catch (e2) {
        console.error(e2);
      }
      if (isFunction$3(options === null || options === void 0 ? void 0 : options.defaultValue)) {
        return options === null || options === void 0 ? void 0 : options.defaultValue();
      }
      return options === null || options === void 0 ? void 0 : options.defaultValue;
    }
    var _a = __read(react.exports.useState(function() {
      return getStoredValue();
    }), 2), state = _a[0], setState = _a[1];
    useUpdateEffect(function() {
      setState(getStoredValue());
    }, [key2]);
    var updateState = function updateState2(value2) {
      var currentState = isFunction$3(value2) ? value2(state) : value2;
      setState(currentState);
      if (isUndef(currentState)) {
        storage === null || storage === void 0 ? void 0 : storage.removeItem(key2);
      } else {
        try {
          storage === null || storage === void 0 ? void 0 : storage.setItem(key2, serializer(currentState));
        } catch (e2) {
          console.error(e2);
        }
      }
    };
    return [state, useMemoizedFn(updateState)];
  }
  return useStorageState;
}
var useLocalStorageState = createUseStorageState(function() {
  return isBrowser$2 ? localStorage : void 0;
});
const useLocalStorageState$1 = useLocalStorageState;
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key2) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key2) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key2) {
      var index2 = getIndex(this.__entries__, key2);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key2, value2) {
      var index2 = getIndex(this.__entries__, key2);
      if (~index2) {
        this.__entries__[index2][1] = value2;
      } else {
        this.__entries__.push([key2, value2]);
      }
    };
    class_1.prototype.delete = function(key2) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key2);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key2) {
      return !!~getIndex(this.__entries__, key2);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx2) {
      if (ctx2 === void 0) {
        ctx2 = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx2, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key2) {
      return !!~propertyName.indexOf(key2);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key2 = _a[_i];
    Object.defineProperty(target, key2, {
      value: props[key2],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position2) {
    var value2 = styles["border-" + position2 + "-width"];
    return size + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i];
    var value2 = styles["padding-" + position2];
    paddings[position2] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx2 = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx2, entries, ctx2);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$1 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$1.prototype[method4] = function() {
    var _a;
    return (_a = observers.get(this))[method4].apply(_a, arguments);
  };
});
var index$3 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$1;
}();
var CopyOutlined$7 = { exports: {} };
var CopyOutlined$6 = {};
var interopRequireWildcard = { exports: {} };
var _typeof$5 = { exports: {} };
(function(module) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$5);
(function(module) {
  var _typeof2 = _typeof$5.exports["default"];
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function")
      return null;
    var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
    var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
      return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }
  function _interopRequireWildcard2(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }
    var cache2 = _getRequireWildcardCache(nodeInterop);
    if (cache2 && cache2.has(obj)) {
      return cache2.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key2 in obj) {
      if (key2 !== "default" && Object.prototype.hasOwnProperty.call(obj, key2)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key2) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key2, desc);
        } else {
          newObj[key2] = obj[key2];
        }
      }
    }
    newObj["default"] = obj;
    if (cache2) {
      cache2.set(obj, newObj);
    }
    return newObj;
  }
  module.exports = _interopRequireWildcard2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireWildcard);
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var objectSpread2 = { exports: {} };
var hasRequiredObjectSpread2;
function requireObjectSpread2() {
  if (hasRequiredObjectSpread2)
    return objectSpread2.exports;
  hasRequiredObjectSpread2 = 1;
  (function(module) {
    var defineProperty2 = requireDefineProperty();
    function ownKeys2(object4, enumerableOnly) {
      var keys2 = Object.keys(object4);
      if (Object.getOwnPropertySymbols) {
        var symbols2 = Object.getOwnPropertySymbols(object4);
        enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
        })), keys2.push.apply(keys2, symbols2);
      }
      return keys2;
    }
    function _objectSpread22(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
          defineProperty2(target, key2, source[key2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
          Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
        });
      }
      return target;
    }
    module.exports = _objectSpread22, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectSpread2);
  return objectSpread2.exports;
}
var CopyOutlined$5 = {};
var hasRequiredCopyOutlined;
function requireCopyOutlined() {
  if (hasRequiredCopyOutlined)
    return CopyOutlined$5;
  hasRequiredCopyOutlined = 1;
  Object.defineProperty(CopyOutlined$5, "__esModule", { value: true });
  var CopyOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
  CopyOutlined$5.default = CopyOutlined4;
  return CopyOutlined$5;
}
var AntdIcon$1 = {};
var slicedToArray = { exports: {} };
var arrayWithHoles = { exports: {} };
var hasRequiredArrayWithHoles;
function requireArrayWithHoles() {
  if (hasRequiredArrayWithHoles)
    return arrayWithHoles.exports;
  hasRequiredArrayWithHoles = 1;
  (function(module) {
    function _arrayWithHoles2(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    module.exports = _arrayWithHoles2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayWithHoles);
  return arrayWithHoles.exports;
}
var iterableToArrayLimit = { exports: {} };
var hasRequiredIterableToArrayLimit;
function requireIterableToArrayLimit() {
  if (hasRequiredIterableToArrayLimit)
    return iterableToArrayLimit.exports;
  hasRequiredIterableToArrayLimit = 1;
  (function(module) {
    function _iterableToArrayLimit2(arr, i) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null)
        return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null)
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    module.exports = _iterableToArrayLimit2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(iterableToArrayLimit);
  return iterableToArrayLimit.exports;
}
var unsupportedIterableToArray = { exports: {} };
var arrayLikeToArray = { exports: {} };
var hasRequiredArrayLikeToArray;
function requireArrayLikeToArray() {
  if (hasRequiredArrayLikeToArray)
    return arrayLikeToArray.exports;
  hasRequiredArrayLikeToArray = 1;
  (function(module) {
    function _arrayLikeToArray2(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    }
    module.exports = _arrayLikeToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(arrayLikeToArray);
  return arrayLikeToArray.exports;
}
var hasRequiredUnsupportedIterableToArray;
function requireUnsupportedIterableToArray() {
  if (hasRequiredUnsupportedIterableToArray)
    return unsupportedIterableToArray.exports;
  hasRequiredUnsupportedIterableToArray = 1;
  (function(module) {
    var arrayLikeToArray2 = requireArrayLikeToArray();
    function _unsupportedIterableToArray2(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return arrayLikeToArray2(o, minLen);
      var n2 = Object.prototype.toString.call(o).slice(8, -1);
      if (n2 === "Object" && o.constructor)
        n2 = o.constructor.name;
      if (n2 === "Map" || n2 === "Set")
        return Array.from(o);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
        return arrayLikeToArray2(o, minLen);
    }
    module.exports = _unsupportedIterableToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(unsupportedIterableToArray);
  return unsupportedIterableToArray.exports;
}
var nonIterableRest = { exports: {} };
var hasRequiredNonIterableRest;
function requireNonIterableRest() {
  if (hasRequiredNonIterableRest)
    return nonIterableRest.exports;
  hasRequiredNonIterableRest = 1;
  (function(module) {
    function _nonIterableRest2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    module.exports = _nonIterableRest2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(nonIterableRest);
  return nonIterableRest.exports;
}
var hasRequiredSlicedToArray;
function requireSlicedToArray() {
  if (hasRequiredSlicedToArray)
    return slicedToArray.exports;
  hasRequiredSlicedToArray = 1;
  (function(module) {
    var arrayWithHoles2 = requireArrayWithHoles();
    var iterableToArrayLimit2 = requireIterableToArrayLimit();
    var unsupportedIterableToArray2 = requireUnsupportedIterableToArray();
    var nonIterableRest2 = requireNonIterableRest();
    function _slicedToArray2(arr, i) {
      return arrayWithHoles2(arr) || iterableToArrayLimit2(arr, i) || unsupportedIterableToArray2(arr, i) || nonIterableRest2();
    }
    module.exports = _slicedToArray2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(slicedToArray);
  return slicedToArray.exports;
}
var classnames$1 = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames)
    return classnames$1.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn2 = {}.hasOwnProperty;
      function classNames2() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString === Object.prototype.toString) {
              for (var key2 in arg) {
                if (hasOwn2.call(arg, key2) && arg[key2]) {
                  classes.push(key2);
                }
              }
            } else {
              classes.push(arg.toString());
            }
          }
        }
        return classes.join(" ");
      }
      if (module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames$1);
  return classnames$1.exports;
}
var Context$1 = {};
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext)
    return Context$1;
  hasRequiredContext = 1;
  Object.defineProperty(Context$1, "__esModule", {
    value: true
  });
  Context$1.default = void 0;
  var _react2 = react.exports;
  var IconContext2 = /* @__PURE__ */ (0, _react2.createContext)({});
  var _default2 = IconContext2;
  Context$1.default = _default2;
  return Context$1;
}
var IconBase$1 = {};
var utils$1 = {};
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var s = 0;
  var l2 = (max + min) / 2;
  if (max === min) {
    s = 0;
    h2 = 0;
  } else {
    var d2 = max - min;
    s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l: l2 };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s = bound01(s, 100);
  l2 = bound01(l2, 100);
  if (s === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, v: v2 };
}
function hsvToRgb(h2, s, v2) {
  h2 = bound01(h2, 360) * 6;
  s = bound01(s, 100);
  v2 = bound01(v2, 100);
  var i = Math.floor(h2);
  var f2 = h2 - i;
  var p2 = v2 * (1 - s);
  var q2 = v2 * (1 - f2 * s);
  var t2 = v2 * (1 - (1 - f2) * s);
  var mod = i % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g2, b2, a, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color2) {
  return {
    r: color2 >> 16,
    g: (color2 & 65280) >> 8,
    b: color2 & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color2) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v2 = null;
  var l2 = null;
  var ok2 = false;
  var format2 = false;
  if (typeof color2 === "string") {
    color2 = stringInputToObject(color2);
  }
  if (typeof color2 === "object") {
    if (isValidCSSUnit(color2.r) && isValidCSSUnit(color2.g) && isValidCSSUnit(color2.b)) {
      rgb = rgbToRgb(color2.r, color2.g, color2.b);
      ok2 = true;
      format2 = String(color2.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.v)) {
      s = convertToPercentage(color2.s);
      v2 = convertToPercentage(color2.v);
      rgb = hsvToRgb(color2.h, s, v2);
      ok2 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color2.h) && isValidCSSUnit(color2.s) && isValidCSSUnit(color2.l)) {
      s = convertToPercentage(color2.s);
      l2 = convertToPercentage(color2.l);
      rgb = hslToRgb(color2.h, s, l2);
      ok2 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color2, "a")) {
      a = color2.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok: ok2,
    format: color2.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color2) {
  color2 = color2.trim().toLowerCase();
  if (color2.length === 0) {
    return false;
  }
  var named = false;
  if (names[color2]) {
    color2 = names[color2];
    named = true;
  } else if (color2 === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color2);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color2);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color2);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color2) {
  return Boolean(matchers.CSS_UNIT.exec(String(color2)));
}
var TinyColor = function() {
  function TinyColor2(color2, opts) {
    if (color2 === void 0) {
      color2 = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a;
    if (color2 instanceof TinyColor2) {
      return color2;
    }
    if (typeof color2 === "number") {
      color2 = numberInputToObject(color2);
    }
    this.originalInput = color2;
    var rgb = inputToRGB(color2);
    this.originalInput = color2;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G2;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s = Math.round(hsl.s * 100);
    var l2 = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r2 = Math.round(this.r);
    var g2 = Math.round(this.g);
    var b2 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
      var _b = _a[_i], key2 = _b[0], value2 = _b[1];
      if (hex2 === value2) {
        return key2;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color2, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color2).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg2 = this.toRgb();
    var bg2 = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg2.r + (fg2.r - bg2.r) * fg2.a,
      g: bg2.g + (fg2.g - bg2.g) * fg2.a,
      b: bg2.b + (fg2.b - bg2.b) * fg2.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n2) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment2 = 360 / n2;
    for (var i = 1; i < n2; i++) {
      result.push(new TinyColor2({ h: (h2 + i * increment2) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color2) {
    return this.toRgbString() === new TinyColor2(color2).toRgbString();
  };
  return TinyColor2;
}();
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix$1(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i;
  } else if (i === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$2(hsv, i, light) {
  var value2;
  if (light) {
    value2 = hsv.v + brightnessStep1 * i;
  } else {
    value2 = hsv.v - brightnessStep2 * i;
  }
  if (value2 > 1) {
    value2 = 1;
  }
  return Number(value2.toFixed(2));
}
function generate$1(color2) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color2);
  for (var i = lightColorCount; i > 0; i -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i, true),
      s: getSaturation(hsv, i, true),
      v: getValue$2(hsv, i, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue$2(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix$1(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key2) {
  presetPalettes[key2] = generate$1(presetPrimaryColors[key2]);
  presetPalettes[key2].primary = presetPalettes[key2][5];
  presetDarkPalettes[key2] = generate$1(presetPrimaryColors[key2], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key2].primary = presetDarkPalettes[key2][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;
const index_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blue,
  cyan,
  geekblue,
  generate: generate$1,
  gold,
  green,
  grey,
  lime,
  magenta,
  orange,
  presetDarkPalettes,
  presetPalettes,
  presetPrimaryColors,
  purple,
  red,
  volcano,
  yellow
}, Symbol.toStringTag, { value: "Module" }));
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(index_esm);
var warning$3 = {};
var hasRequiredWarning;
function requireWarning() {
  if (hasRequiredWarning)
    return warning$3;
  hasRequiredWarning = 1;
  Object.defineProperty(warning$3, "__esModule", {
    value: true
  });
  warning$3.call = call2;
  warning$3.default = void 0;
  warning$3.note = note;
  warning$3.noteOnce = noteOnce;
  warning$3.resetWarned = resetWarned;
  warning$3.warning = warning3;
  warning$3.warningOnce = warningOnce2;
  var warned2 = {};
  function warning3(valid2, message2) {
  }
  function note(valid2, message2) {
  }
  function resetWarned() {
    warned2 = {};
  }
  function call2(method4, valid2, message2) {
    if (!valid2 && !warned2[message2]) {
      method4(false, message2);
      warned2[message2] = true;
    }
  }
  function warningOnce2(valid2, message2) {
    call2(warning3, valid2, message2);
  }
  function noteOnce(valid2, message2) {
    call2(note, valid2, message2);
  }
  var _default2 = warningOnce2;
  warning$3.default = _default2;
  return warning$3;
}
var dynamicCSS = {};
var canUseDom$1 = {};
var hasRequiredCanUseDom;
function requireCanUseDom() {
  if (hasRequiredCanUseDom)
    return canUseDom$1;
  hasRequiredCanUseDom = 1;
  Object.defineProperty(canUseDom$1, "__esModule", {
    value: true
  });
  canUseDom$1.default = canUseDom2;
  function canUseDom2() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  return canUseDom$1;
}
var hasRequiredDynamicCSS;
function requireDynamicCSS() {
  if (hasRequiredDynamicCSS)
    return dynamicCSS;
  hasRequiredDynamicCSS = 1;
  var _interopRequireDefault2 = interopRequireDefault.exports;
  Object.defineProperty(dynamicCSS, "__esModule", {
    value: true
  });
  dynamicCSS.injectCSS = injectCSS2;
  dynamicCSS.removeCSS = removeCSS;
  dynamicCSS.updateCSS = updateCSS2;
  var _canUseDom = _interopRequireDefault2(requireCanUseDom());
  var MARK_KEY2 = "rc-util-key";
  function getMark2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref.mark;
    if (mark2) {
      return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
    }
    return MARK_KEY2;
  }
  function getContainer2(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    var head = document.querySelector("head");
    return head || document.body;
  }
  function injectCSS2(css2) {
    var _option$csp;
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!(0, _canUseDom.default)()) {
      return null;
    }
    var styleNode = document.createElement("style");
    if ((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) {
      var _option$csp2;
      styleNode.nonce = (_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce;
    }
    styleNode.innerHTML = css2;
    var container = getContainer2(option);
    var firstChild = container.firstChild;
    if (option.prepend && container.prepend) {
      container.prepend(styleNode);
    } else if (option.prepend && firstChild) {
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  var containerCache2 = /* @__PURE__ */ new Map();
  function findExistNode2(key2) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var container = getContainer2(option);
    return Array.from(containerCache2.get(container).children).find(function(node) {
      return node.tagName === "STYLE" && node.getAttribute(getMark2(option)) === key2;
    });
  }
  function removeCSS(key2) {
    var _existNode$parentNode;
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var existNode = findExistNode2(key2, option);
    existNode === null || existNode === void 0 ? void 0 : (_existNode$parentNode = existNode.parentNode) === null || _existNode$parentNode === void 0 ? void 0 : _existNode$parentNode.removeChild(existNode);
  }
  function updateCSS2(css2, key2) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var container = getContainer2(option);
    if (!containerCache2.has(container)) {
      var placeholderStyle = injectCSS2("", option);
      var parentNode = placeholderStyle.parentNode;
      containerCache2.set(container, parentNode);
      parentNode.removeChild(placeholderStyle);
    }
    var existNode = findExistNode2(key2, option);
    if (existNode) {
      var _option$csp3, _option$csp4;
      if (((_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce) && existNode.nonce !== ((_option$csp4 = option.csp) === null || _option$csp4 === void 0 ? void 0 : _option$csp4.nonce)) {
        var _option$csp5;
        existNode.nonce = (_option$csp5 = option.csp) === null || _option$csp5 === void 0 ? void 0 : _option$csp5.nonce;
      }
      if (existNode.innerHTML !== css2) {
        existNode.innerHTML = css2;
      }
      return existNode;
    }
    var newNode = injectCSS2(css2, option);
    newNode.setAttribute(getMark2(option), key2);
    return newNode;
  }
  return dynamicCSS;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils$1;
  hasRequiredUtils = 1;
  var _interopRequireWildcard2 = interopRequireWildcard.exports;
  var _interopRequireDefault2 = interopRequireDefault.exports;
  Object.defineProperty(utils$1, "__esModule", {
    value: true
  });
  utils$1.warning = warning3;
  utils$1.isIconDefinition = isIconDefinition2;
  utils$1.normalizeAttrs = normalizeAttrs2;
  utils$1.generate = generate2;
  utils$1.getSecondaryColor = getSecondaryColor2;
  utils$1.normalizeTwoToneColors = normalizeTwoToneColors2;
  utils$1.useInsertStyles = utils$1.iconStyles = utils$1.svgBaseProps = void 0;
  var _objectSpread22 = _interopRequireDefault2(requireObjectSpread2());
  var _typeof2 = _interopRequireDefault2(_typeof$5.exports);
  var _colors = require$$4;
  var _react2 = _interopRequireWildcard2(react.exports);
  var _warning = _interopRequireDefault2(requireWarning());
  var _dynamicCSS = requireDynamicCSS();
  var _Context = _interopRequireDefault2(requireContext());
  function warning3(valid2, message2) {
    (0, _warning.default)(valid2, "[@ant-design/icons] ".concat(message2));
  }
  function isIconDefinition2(target) {
    return (0, _typeof2.default)(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && ((0, _typeof2.default)(target.icon) === "object" || typeof target.icon === "function");
  }
  function normalizeAttrs2() {
    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.keys(attrs).reduce(function(acc, key2) {
      var val = attrs[key2];
      switch (key2) {
        case "class":
          acc.className = val;
          delete acc.class;
          break;
        default:
          acc[key2] = val;
      }
      return acc;
    }, {});
  }
  function generate2(node, key2, rootProps) {
    if (!rootProps) {
      return /* @__PURE__ */ _react2.default.createElement(node.tag, (0, _objectSpread22.default)({
        key: key2
      }, normalizeAttrs2(node.attrs)), (node.children || []).map(function(child, index2) {
        return generate2(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
      }));
    }
    return /* @__PURE__ */ _react2.default.createElement(node.tag, (0, _objectSpread22.default)((0, _objectSpread22.default)({
      key: key2
    }, normalizeAttrs2(node.attrs)), rootProps), (node.children || []).map(function(child, index2) {
      return generate2(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
    }));
  }
  function getSecondaryColor2(primaryColor) {
    return (0, _colors.generate)(primaryColor)[0];
  }
  function normalizeTwoToneColors2(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  var svgBaseProps = {
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true",
    focusable: "false"
  };
  utils$1.svgBaseProps = svgBaseProps;
  var iconStyles2 = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
  utils$1.iconStyles = iconStyles2;
  var useInsertStyles3 = function useInsertStyles4() {
    var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles2;
    var _useContext = (0, _react2.useContext)(_Context.default), csp = _useContext.csp;
    (0, _react2.useEffect)(function() {
      (0, _dynamicCSS.updateCSS)(styleStr, "@ant-design-icons", {
        prepend: true,
        csp
      });
    }, []);
  };
  utils$1.useInsertStyles = useInsertStyles3;
  return utils$1;
}
var hasRequiredIconBase;
function requireIconBase() {
  if (hasRequiredIconBase)
    return IconBase$1;
  hasRequiredIconBase = 1;
  var _interopRequireDefault2 = interopRequireDefault.exports;
  Object.defineProperty(IconBase$1, "__esModule", {
    value: true
  });
  IconBase$1.default = void 0;
  var _objectWithoutProperties2 = _interopRequireDefault2(requireObjectWithoutProperties());
  var _objectSpread22 = _interopRequireDefault2(requireObjectSpread2());
  var _utils = requireUtils();
  var _excluded4 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
  var twoToneColorPalette2 = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  };
  function setTwoToneColors2(_ref) {
    var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
    twoToneColorPalette2.primaryColor = primaryColor;
    twoToneColorPalette2.secondaryColor = secondaryColor || (0, _utils.getSecondaryColor)(primaryColor);
    twoToneColorPalette2.calculated = !!secondaryColor;
  }
  function getTwoToneColors2() {
    return (0, _objectSpread22.default)({}, twoToneColorPalette2);
  }
  var IconBase3 = function IconBase4(props) {
    var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = (0, _objectWithoutProperties2.default)(props, _excluded4);
    var colors = twoToneColorPalette2;
    if (primaryColor) {
      colors = {
        primaryColor,
        secondaryColor: secondaryColor || (0, _utils.getSecondaryColor)(primaryColor)
      };
    }
    (0, _utils.useInsertStyles)();
    (0, _utils.warning)((0, _utils.isIconDefinition)(icon), "icon should be icon definiton, but got ".concat(icon));
    if (!(0, _utils.isIconDefinition)(icon)) {
      return null;
    }
    var target = icon;
    if (target && typeof target.icon === "function") {
      target = (0, _objectSpread22.default)((0, _objectSpread22.default)({}, target), {}, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }
    return (0, _utils.generate)(target.icon, "svg-".concat(target.name), (0, _objectSpread22.default)({
      className,
      onClick,
      style: style2,
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true"
    }, restProps));
  };
  IconBase3.displayName = "IconReact";
  IconBase3.getTwoToneColors = getTwoToneColors2;
  IconBase3.setTwoToneColors = setTwoToneColors2;
  var _default2 = IconBase3;
  IconBase$1.default = _default2;
  return IconBase$1;
}
var twoTonePrimaryColor = {};
var hasRequiredTwoTonePrimaryColor;
function requireTwoTonePrimaryColor() {
  if (hasRequiredTwoTonePrimaryColor)
    return twoTonePrimaryColor;
  hasRequiredTwoTonePrimaryColor = 1;
  var _interopRequireDefault2 = interopRequireDefault.exports;
  Object.defineProperty(twoTonePrimaryColor, "__esModule", {
    value: true
  });
  twoTonePrimaryColor.setTwoToneColor = setTwoToneColor2;
  twoTonePrimaryColor.getTwoToneColor = getTwoToneColor2;
  var _slicedToArray2 = _interopRequireDefault2(requireSlicedToArray());
  var _IconBase = _interopRequireDefault2(requireIconBase());
  var _utils = requireUtils();
  function setTwoToneColor2(twoToneColor) {
    var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return _IconBase.default.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor2() {
    var colors = _IconBase.default.getTwoToneColors();
    if (!colors.calculated) {
      return colors.primaryColor;
    }
    return [colors.primaryColor, colors.secondaryColor];
  }
  return twoTonePrimaryColor;
}
var hasRequiredAntdIcon;
function requireAntdIcon() {
  if (hasRequiredAntdIcon)
    return AntdIcon$1;
  hasRequiredAntdIcon = 1;
  var _interopRequireDefault2 = interopRequireDefault.exports;
  var _interopRequireWildcard2 = interopRequireWildcard.exports;
  Object.defineProperty(AntdIcon$1, "__esModule", {
    value: true
  });
  AntdIcon$1.default = void 0;
  var _objectSpread22 = _interopRequireDefault2(requireObjectSpread2());
  var _slicedToArray2 = _interopRequireDefault2(requireSlicedToArray());
  var _defineProperty2 = _interopRequireDefault2(requireDefineProperty());
  var _objectWithoutProperties2 = _interopRequireDefault2(requireObjectWithoutProperties());
  var React2 = _interopRequireWildcard2(react.exports);
  var _classnames = _interopRequireDefault2(requireClassnames());
  var _Context = _interopRequireDefault2(requireContext());
  var _IconBase = _interopRequireDefault2(requireIconBase());
  var _twoTonePrimaryColor = requireTwoTonePrimaryColor();
  var _utils = requireUtils();
  var _excluded4 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
  (0, _twoTonePrimaryColor.setTwoToneColor)("#1890ff");
  var Icon3 = /* @__PURE__ */ React2.forwardRef(function(props, ref) {
    var _classNames;
    var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = (0, _objectWithoutProperties2.default)(props, _excluded4);
    var _React$useContext = React2.useContext(_Context.default), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre;
    var classString = (0, _classnames.default)(prefixCls, (_classNames = {}, (0, _defineProperty2.default)(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), (0, _defineProperty2.default)(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
    var iconTabIndex = tabIndex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    var svgStyle = rotate ? {
      msTransform: "rotate(".concat(rotate, "deg)"),
      transform: "rotate(".concat(rotate, "deg)")
    } : void 0;
    var _normalizeTwoToneColo = (0, _utils.normalizeTwoToneColors)(twoToneColor), _normalizeTwoToneColo2 = (0, _slicedToArray2.default)(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return /* @__PURE__ */ React2.createElement("span", (0, _objectSpread22.default)((0, _objectSpread22.default)({
      role: "img",
      "aria-label": icon.name
    }, restProps), {}, {
      ref,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }), /* @__PURE__ */ React2.createElement(_IconBase.default, {
      icon,
      primaryColor,
      secondaryColor,
      style: svgStyle
    }));
  });
  Icon3.displayName = "AntdIcon";
  Icon3.getTwoToneColor = _twoTonePrimaryColor.getTwoToneColor;
  Icon3.setTwoToneColor = _twoTonePrimaryColor.setTwoToneColor;
  var _default2 = Icon3;
  AntdIcon$1.default = _default2;
  return AntdIcon$1;
}
var _interopRequireWildcard$7 = interopRequireWildcard.exports;
var _interopRequireDefault$7 = interopRequireDefault.exports;
Object.defineProperty(CopyOutlined$6, "__esModule", {
  value: true
});
CopyOutlined$6.default = void 0;
var _objectSpread2$9 = _interopRequireDefault$7(requireObjectSpread2());
var React$7 = _interopRequireWildcard$7(react.exports);
var _CopyOutlined = _interopRequireDefault$7(requireCopyOutlined());
var _AntdIcon$7 = _interopRequireDefault$7(requireAntdIcon());
var CopyOutlined$4 = function CopyOutlined(props, ref) {
  return /* @__PURE__ */ React$7.createElement(_AntdIcon$7.default, (0, _objectSpread2$9.default)((0, _objectSpread2$9.default)({}, props), {}, {
    ref,
    icon: _CopyOutlined.default
  }));
};
CopyOutlined$4.displayName = "CopyOutlined";
var _default$7 = /* @__PURE__ */ React$7.forwardRef(CopyOutlined$4);
CopyOutlined$6.default = _default$7;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _CopyOutlined2 = _interopRequireDefault2(CopyOutlined$6);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _CopyOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(CopyOutlined$7, CopyOutlined$7.exports);
const CopyOutlined$3 = /* @__PURE__ */ getDefaultExportFromCjs(CopyOutlined$7.exports);
var CodeOutlined$4 = { exports: {} };
var CodeOutlined$3 = {};
var CodeOutlined$2 = {};
var hasRequiredCodeOutlined;
function requireCodeOutlined() {
  if (hasRequiredCodeOutlined)
    return CodeOutlined$2;
  hasRequiredCodeOutlined = 1;
  Object.defineProperty(CodeOutlined$2, "__esModule", { value: true });
  var CodeOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M516 673c0 4.4 3.4 8 7.5 8h185c4.1 0 7.5-3.6 7.5-8v-48c0-4.4-3.4-8-7.5-8h-185c-4.1 0-7.5 3.6-7.5 8v48zm-194.9 6.1l192-161c3.8-3.2 3.8-9.1 0-12.3l-192-160.9A7.95 7.95 0 00308 351v62.7c0 2.4 1 4.6 2.9 6.1L420.7 512l-109.8 92.2a8.1 8.1 0 00-2.9 6.1V673c0 6.8 7.9 10.5 13.1 6.1zM880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "code", "theme": "outlined" };
  CodeOutlined$2.default = CodeOutlined3;
  return CodeOutlined$2;
}
var _interopRequireWildcard$6 = interopRequireWildcard.exports;
var _interopRequireDefault$6 = interopRequireDefault.exports;
Object.defineProperty(CodeOutlined$3, "__esModule", {
  value: true
});
CodeOutlined$3.default = void 0;
var _objectSpread2$8 = _interopRequireDefault$6(requireObjectSpread2());
var React$6 = _interopRequireWildcard$6(react.exports);
var _CodeOutlined = _interopRequireDefault$6(requireCodeOutlined());
var _AntdIcon$6 = _interopRequireDefault$6(requireAntdIcon());
var CodeOutlined$1 = function CodeOutlined(props, ref) {
  return /* @__PURE__ */ React$6.createElement(_AntdIcon$6.default, (0, _objectSpread2$8.default)((0, _objectSpread2$8.default)({}, props), {}, {
    ref,
    icon: _CodeOutlined.default
  }));
};
CodeOutlined$1.displayName = "CodeOutlined";
var _default$6 = /* @__PURE__ */ React$6.forwardRef(CodeOutlined$1);
CodeOutlined$3.default = _default$6;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _CodeOutlined2 = _interopRequireDefault2(CodeOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _CodeOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(CodeOutlined$4, CodeOutlined$4.exports);
const CodeOutlined2 = /* @__PURE__ */ getDefaultExportFromCjs(CodeOutlined$4.exports);
var CheckOutlined$7 = { exports: {} };
var CheckOutlined$6 = {};
var CheckOutlined$5 = {};
var hasRequiredCheckOutlined;
function requireCheckOutlined() {
  if (hasRequiredCheckOutlined)
    return CheckOutlined$5;
  hasRequiredCheckOutlined = 1;
  Object.defineProperty(CheckOutlined$5, "__esModule", { value: true });
  var CheckOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
  CheckOutlined$5.default = CheckOutlined4;
  return CheckOutlined$5;
}
var _interopRequireWildcard$5 = interopRequireWildcard.exports;
var _interopRequireDefault$5 = interopRequireDefault.exports;
Object.defineProperty(CheckOutlined$6, "__esModule", {
  value: true
});
CheckOutlined$6.default = void 0;
var _objectSpread2$7 = _interopRequireDefault$5(requireObjectSpread2());
var React$5 = _interopRequireWildcard$5(react.exports);
var _CheckOutlined = _interopRequireDefault$5(requireCheckOutlined());
var _AntdIcon$5 = _interopRequireDefault$5(requireAntdIcon());
var CheckOutlined$4 = function CheckOutlined(props, ref) {
  return /* @__PURE__ */ React$5.createElement(_AntdIcon$5.default, (0, _objectSpread2$7.default)((0, _objectSpread2$7.default)({}, props), {}, {
    ref,
    icon: _CheckOutlined.default
  }));
};
CheckOutlined$4.displayName = "CheckOutlined";
var _default$5 = /* @__PURE__ */ React$5.forwardRef(CheckOutlined$4);
CheckOutlined$6.default = _default$5;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _CheckOutlined2 = _interopRequireDefault2(CheckOutlined$6);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _CheckOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(CheckOutlined$7, CheckOutlined$7.exports);
const CheckOutlined$3 = /* @__PURE__ */ getDefaultExportFromCjs(CheckOutlined$7.exports);
var BugOutlined$4 = { exports: {} };
var BugOutlined$3 = {};
var BugOutlined$2 = {};
var hasRequiredBugOutlined;
function requireBugOutlined() {
  if (hasRequiredBugOutlined)
    return BugOutlined$2;
  hasRequiredBugOutlined = 1;
  Object.defineProperty(BugOutlined$2, "__esModule", { value: true });
  var BugOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M304 280h56c4.4 0 8-3.6 8-8 0-28.3 5.9-53.2 17.1-73.5 10.6-19.4 26-34.8 45.4-45.4C450.9 142 475.7 136 504 136h16c28.3 0 53.2 5.9 73.5 17.1 19.4 10.6 34.8 26 45.4 45.4C650 218.9 656 243.7 656 272c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8 0-40-8.8-76.7-25.9-108.1a184.31 184.31 0 00-74-74C596.7 72.8 560 64 520 64h-16c-40 0-76.7 8.8-108.1 25.9a184.31 184.31 0 00-74 74C304.8 195.3 296 232 296 272c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M940 512H792V412c76.8 0 139-62.2 139-139 0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8a63 63 0 01-63 63H232a63 63 0 01-63-63c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8 0 76.8 62.2 139 139 139v100H84c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h148v96c0 6.5.2 13 .7 19.3C164.1 728.6 116 796.7 116 876c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8 0-44.2 23.9-82.9 59.6-103.7a273 273 0 0022.7 49c24.3 41.5 59 76.2 100.5 100.5S460.5 960 512 960s99.8-13.9 141.3-38.2a281.38 281.38 0 00123.2-149.5A120 120 0 01836 876c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8 0-79.3-48.1-147.4-116.7-176.7.4-6.4.7-12.8.7-19.3v-96h148c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM716 680c0 36.8-9.7 72-27.8 102.9-17.7 30.3-43 55.6-73.3 73.3C584 874.3 548.8 884 512 884s-72-9.7-102.9-27.8c-30.3-17.7-55.6-43-73.3-73.3A202.75 202.75 0 01308 680V412h408v268z" } }] }, "name": "bug", "theme": "outlined" };
  BugOutlined$2.default = BugOutlined3;
  return BugOutlined$2;
}
var _interopRequireWildcard$4 = interopRequireWildcard.exports;
var _interopRequireDefault$4 = interopRequireDefault.exports;
Object.defineProperty(BugOutlined$3, "__esModule", {
  value: true
});
BugOutlined$3.default = void 0;
var _objectSpread2$6 = _interopRequireDefault$4(requireObjectSpread2());
var React$4 = _interopRequireWildcard$4(react.exports);
var _BugOutlined = _interopRequireDefault$4(requireBugOutlined());
var _AntdIcon$4 = _interopRequireDefault$4(requireAntdIcon());
var BugOutlined$1 = function BugOutlined(props, ref) {
  return /* @__PURE__ */ React$4.createElement(_AntdIcon$4.default, (0, _objectSpread2$6.default)((0, _objectSpread2$6.default)({}, props), {}, {
    ref,
    icon: _BugOutlined.default
  }));
};
BugOutlined$1.displayName = "BugOutlined";
var _default$4 = /* @__PURE__ */ React$4.forwardRef(BugOutlined$1);
BugOutlined$3.default = _default$4;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _BugOutlined2 = _interopRequireDefault2(BugOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _BugOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(BugOutlined$4, BugOutlined$4.exports);
const BugOutlined2 = /* @__PURE__ */ getDefaultExportFromCjs(BugOutlined$4.exports);
var classnames = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn2 = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString === Object.prototype.toString) {
            for (var key2 in arg) {
              if (hasOwn2.call(arg, key2) && arg[key2]) {
                classes.push(key2);
              }
            }
          } else {
            classes.push(arg.toString());
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
const classNames = classnames.exports;
var LinkOutlined$4 = { exports: {} };
var LinkOutlined$3 = {};
var LinkOutlined$2 = {};
var hasRequiredLinkOutlined;
function requireLinkOutlined() {
  if (hasRequiredLinkOutlined)
    return LinkOutlined$2;
  hasRequiredLinkOutlined = 1;
  Object.defineProperty(LinkOutlined$2, "__esModule", { value: true });
  var LinkOutlined3 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M574 665.4a8.03 8.03 0 00-11.3 0L446.5 781.6c-53.8 53.8-144.6 59.5-204 0-59.5-59.5-53.8-150.2 0-204l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3l-39.8-39.8a8.03 8.03 0 00-11.3 0L191.4 526.5c-84.6 84.6-84.6 221.5 0 306s221.5 84.6 306 0l116.2-116.2c3.1-3.1 3.1-8.2 0-11.3L574 665.4zm258.6-474c-84.6-84.6-221.5-84.6-306 0L410.3 307.6a8.03 8.03 0 000 11.3l39.7 39.7c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c53.8-53.8 144.6-59.5 204 0 59.5 59.5 53.8 150.2 0 204L665.3 562.6a8.03 8.03 0 000 11.3l39.8 39.8c3.1 3.1 8.2 3.1 11.3 0l116.2-116.2c84.5-84.6 84.5-221.5 0-306.1zM610.1 372.3a8.03 8.03 0 00-11.3 0L372.3 598.7a8.03 8.03 0 000 11.3l39.6 39.6c3.1 3.1 8.2 3.1 11.3 0l226.4-226.4c3.1-3.1 3.1-8.2 0-11.3l-39.5-39.6z" } }] }, "name": "link", "theme": "outlined" };
  LinkOutlined$2.default = LinkOutlined3;
  return LinkOutlined$2;
}
var _interopRequireWildcard$3 = interopRequireWildcard.exports;
var _interopRequireDefault$3 = interopRequireDefault.exports;
Object.defineProperty(LinkOutlined$3, "__esModule", {
  value: true
});
LinkOutlined$3.default = void 0;
var _objectSpread2$5 = _interopRequireDefault$3(requireObjectSpread2());
var React$3 = _interopRequireWildcard$3(react.exports);
var _LinkOutlined = _interopRequireDefault$3(requireLinkOutlined());
var _AntdIcon$3 = _interopRequireDefault$3(requireAntdIcon());
var LinkOutlined$1 = function LinkOutlined(props, ref) {
  return /* @__PURE__ */ React$3.createElement(_AntdIcon$3.default, (0, _objectSpread2$5.default)((0, _objectSpread2$5.default)({}, props), {}, {
    ref,
    icon: _LinkOutlined.default
  }));
};
LinkOutlined$1.displayName = "LinkOutlined";
var _default$3 = /* @__PURE__ */ React$3.forwardRef(LinkOutlined$1);
LinkOutlined$3.default = _default$3;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _LinkOutlined2 = _interopRequireDefault2(LinkOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _LinkOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(LinkOutlined$4, LinkOutlined$4.exports);
const LinkOutlined2 = /* @__PURE__ */ getDefaultExportFromCjs(LinkOutlined$4.exports);
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range3) {
        selection.addRange(range3);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$2(message2) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message2.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text2, options) {
  var debug, message2, reselectPrevious, range3, selection, mark2, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range3 = document.createRange();
    selection = document.getSelection();
    mark2 = document.createElement("span");
    mark2.textContent = text2;
    mark2.ariaHidden = "true";
    mark2.style.all = "unset";
    mark2.style.position = "fixed";
    mark2.style.top = 0;
    mark2.style.clip = "rect(0, 0, 0, 0)";
    mark2.style.whiteSpace = "pre";
    mark2.style.webkitUserSelect = "text";
    mark2.style.MozUserSelect = "text";
    mark2.style.msUserSelect = "text";
    mark2.style.userSelect = "text";
    mark2.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text2);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text2);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark2);
    range3.selectNodeContents(mark2);
    selection.addRange(range3);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text2);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message2 = format$2("message" in options ? options.message : defaultMessage);
      window.prompt(message2, text2);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range3);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark2) {
      document.body.removeChild(mark2);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard$1 = copy;
function _defineProperty$5(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn$1(self2, call2) {
  if (call2 && (_typeof$4(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
var classnamesExports = requireClassnames();
function toArray$4(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React$a.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$4(child));
    } else if (reactIs$1.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$4(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
var warned = {};
function warning$2(valid2, message2) {
}
function call(method4, valid2, message2) {
  if (!valid2 && !warned[message2]) {
    method4(false, message2);
    warned[message2] = true;
  }
}
function warningOnce(valid2, message2) {
  call(warning$2, valid2, message2);
}
function ownKeys$3(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread2$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key2) {
      _defineProperty$5(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = react.exports.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (_typeof$4(ref) === "object" && ref && "current" in ref) {
    ref.current = node;
  }
}
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node) {
    refs.forEach(function(ref) {
      fillRef(ref, node);
    });
  };
}
function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo(function() {
    return composeRef.apply(void 0, refs);
  }, refs, function(prev, next) {
    return prev.length === next.length && prev.every(function(ref, i) {
      return ref === next[i];
    });
  });
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$1.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function findDOMNode(node) {
  if (node instanceof HTMLElement) {
    return node;
  }
  return ReactDOM.findDOMNode(node);
}
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
var resizeObserver = new index$3(onResize);
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    resizeObserver.observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(DomWrapper2, _React$Component);
  var _super = _createSuper$1(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$2(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$2(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(react.exports.Component);
var CollectionContext = /* @__PURE__ */ react.exports.createContext(null);
function Collection(_ref) {
  var children = _ref.children, onBatchResize = _ref.onBatchResize;
  var resizeIdRef = react.exports.useRef(0);
  var resizeInfosRef = react.exports.useRef([]);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var onResize2 = react.exports.useCallback(function(size, element, data2) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element,
      data: data2
    });
    Promise.resolve().then(function() {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data2);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ react.exports.createElement(CollectionContext.Provider, {
    value: onResize2
  }, children);
}
function SingleObserver(props) {
  var children = props.children, disabled = props.disabled;
  var elementRef = react.exports.useRef(null);
  var wrapperRef = react.exports.useRef(null);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var isRenderProps = typeof children === "function";
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  var sizeRef = react.exports.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  var canRef = !isRenderProps && /* @__PURE__ */ react.exports.isValidElement(mergedChildren) && supportRef(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = react.exports.useMemo(function() {
    return composeRef(originRef, elementRef);
  }, [originRef, elementRef]);
  var propsRef = react.exports.useRef(props);
  propsRef.current = props;
  var onInternalResize = react.exports.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data2 = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2$4(_objectSpread2$4({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data2);
      if (onResize2) {
        Promise.resolve().then(function() {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  react.exports.useEffect(function() {
    var currentElement = findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function() {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ react.exports.createElement(DomWrapper$1, {
    ref: wrapperRef
  }, canRef ? /* @__PURE__ */ react.exports.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver(props) {
  var children = props.children;
  var childNodes = typeof children === "function" ? [children] : toArray$4(children);
  return childNodes.map(function(child, index2) {
    var key2 = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
    return /* @__PURE__ */ react.exports.createElement(SingleObserver, _extends$2({}, props, {
      key: key2
    }), child);
  });
}
ResizeObserver.Collection = Collection;
function omit(obj, fields) {
  var clone2 = _objectSpread2$4({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key2) {
      delete clone2[key2];
    });
  }
  return clone2;
}
var IconContext = /* @__PURE__ */ react.exports.createContext({});
const IconContext$1 = IconContext;
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = function warningFunc2() {
  warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context = /* @__PURE__ */ react.exports.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: function getInternalHooks() {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc
    };
  }
});
function toArray$3(value2) {
  if (value2 === void 0 || value2 === null) {
    return [];
  }
  return Array.isArray(value2) ? value2 : [value2];
}
function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime2() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn2 = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key2, value2) {
    return Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key2];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define2(obj, key2, value2) {
      return obj[key2] = value2;
    };
  }
  function wrap2(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context2 = new Context2(tryLocsList || []);
    return generator._invoke = function(innerFn2, self3, context3) {
      var state = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context3.method = method4, context3.arg = arg; ; ) {
          var delegate = context3.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context3);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context3.method)
            context3.sent = context3._sent = context3.arg;
          else if ("throw" === context3.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context3.arg;
            context3.dispatchException(context3.arg);
          } else
            "return" === context3.method && context3.abrupt("return", context3.arg);
          state = "executing";
          var record = tryCatch(innerFn2, self3, context3);
          if ("normal" === record.type) {
            if (state = context3.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context3.done
            };
          }
          "throw" === record.type && (state = "completed", context3.method = "throw", context3.arg = record.arg);
        }
      };
    }(innerFn, self2, context2), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap2;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method4) {
      define(prototype, method4, function(arg) {
        return this._invoke(method4, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method4, arg, resolve, reject) {
      var record = tryCatch(generator[method4], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value2 = result.value;
        return value2 && "object" == _typeof$4(value2) && hasOwn2.call(value2, "__await") ? PromiseImpl.resolve(value2.__await).then(function(value3) {
          invoke("next", value3, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value2).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    this._invoke = function(method4, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method4, arg, resolve, reject);
        });
      }
      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }
  function maybeInvokeDelegate(delegate, context2) {
    var method4 = delegate.iterator[context2.method];
    if (void 0 === method4) {
      if (context2.delegate = null, "throw" === context2.method) {
        if (delegate.iterator["return"] && (context2.method = "return", context2.arg = void 0, maybeInvokeDelegate(delegate, context2), "throw" === context2.method))
          return ContinueSentinel;
        context2.method = "throw", context2.arg = new TypeError("The iterator does not provide a 'throw' method");
      }
      return ContinueSentinel;
    }
    var record = tryCatch(method4, delegate.iterator, context2.arg);
    if ("throw" === record.type)
      return context2.method = "throw", context2.arg = record.arg, context2.delegate = null, ContinueSentinel;
    var info2 = record.arg;
    return info2 ? info2.done ? (context2[delegate.resultName] = info2.value, context2.next = delegate.nextLoc, "return" !== context2.method && (context2.method = "next", context2.arg = void 0), context2.delegate = null, ContinueSentinel) : info2 : (context2.method = "throw", context2.arg = new TypeError("iterator result is not an object"), context2.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context2(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1, next = function next2() {
          for (; ++i < iterable.length; ) {
            if (hasOwn2.call(iterable, i))
              return next2.value = iterable[i], next2.done = false, next2;
          }
          return next2.value = void 0, next2.done = true, next2;
        };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(object4) {
    var keys2 = [];
    for (var key2 in object4) {
      keys2.push(key2);
    }
    return keys2.reverse(), function next() {
      for (; keys2.length; ) {
        var key3 = keys2.pop();
        if (key3 in object4)
          return next.value = key3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, exports.values = values, Context2.prototype = {
    constructor: Context2,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name2 in this) {
          "t" === name2.charAt(0) && hasOwn2.call(this, name2) && !isNaN(+name2.slice(1)) && (this[name2] = void 0);
        }
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context2 = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context2.next = loc, caught && (context2.method = "next", context2.arg = void 0), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn2.call(entry, "catchLoc"), hasFinally = hasOwn2.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type4, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key2, arg) {
  try {
    var info2 = gen[key2](arg);
    var value2 = info2.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info2.done) {
    resolve(value2);
  } else {
    Promise.resolve(value2).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value2) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value2);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$1()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$1(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf$1(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf$1(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning$1 = function warning() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning$1 = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e2) {
        return typeof e2 === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format$1(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value2, type4) {
  if (value2 === void 0 || value2 === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value2) && !value2.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value2 === "string" && !value2) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a) {
    func(a, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }
  next([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });
    _pending["catch"](function(e2) {
      return e2;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next = function next2(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key2) {
      var arr = objArr[key2];
      if (firstFields.indexOf(key2) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function(e2) {
    return e2;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$1(value2, path) {
  var v2 = value2;
  for (var i = 0; i < path.length; i++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path[i]];
  }
  return v2;
}
function complementError(rule, source) {
  return function(oe2) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$1(source, rule.fullFields);
    } else {
      fieldValue = source[oe2.field || rule.fullField];
    }
    if (isErrorObj(oe2)) {
      oe2.field = oe2.field || rule.fullField;
      oe2.fieldValue = fieldValue;
      return oe2;
    }
    return {
      message: typeof oe2 === "function" ? oe2() : oe2,
      fieldValue,
      field: oe2.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value2 = source[s];
        if (typeof value2 === "object" && typeof target[s] === "object") {
          target[s] = _extends$1({}, target[s], value2);
        } else {
          target[s] = value2;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value2, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value2, type4 || rule.type))) {
    errors.push(format$1(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value2, source, errors, options) {
  if (/^\s+$/.test(value2) || value2 === "") {
    errors.push(format$1(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b2 = function b3(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value2) {
    return types.number(value2) && parseInt(value2, 10) === value2;
  },
  "float": function float(value2) {
    return types.number(value2) && !types.integer(value2);
  },
  array: function array(value2) {
    return Array.isArray(value2);
  },
  regexp: function regexp(value2) {
    if (value2 instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value2);
    } catch (e2) {
      return false;
    }
  },
  date: function date(value2) {
    return typeof value2.getTime === "function" && typeof value2.getMonth === "function" && typeof value2.getYear === "function" && !isNaN(value2.getTime());
  },
  number: function number(value2) {
    if (isNaN(value2)) {
      return false;
    }
    return typeof value2 === "number";
  },
  object: function object(value2) {
    return typeof value2 === "object" && !types.array(value2);
  },
  method: function method(value2) {
    return typeof value2 === "function";
  },
  email: function email(value2) {
    return typeof value2 === "string" && value2.length <= 320 && !!value2.match(pattern$2.email);
  },
  url: function url(value2) {
    return typeof value2 === "string" && value2.length <= 2048 && !!value2.match(getUrlRegex());
  },
  hex: function hex(value2) {
    return typeof value2 === "string" && !!value2.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value2, source, errors, options) {
  if (rule.required && value2 === void 0) {
    required$1(rule, value2, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value2)) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value2 !== rule.type) {
    errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value2, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value2;
  var key2 = null;
  var num = typeof value2 === "number";
  var str = typeof value2 === "string";
  var arr = Array.isArray(value2);
  if (num) {
    key2 = "number";
  } else if (str) {
    key2 = "string";
  } else if (arr) {
    key2 = "array";
  }
  if (!key2) {
    return false;
  }
  if (arr) {
    val = value2.length;
  }
  if (str) {
    val = value2.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format$1(options.messages[key2].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format$1(options.messages[key2].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format$1(options.messages[key2].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options.messages[key2].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value2, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value2) === -1) {
    errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value2, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value2)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value2)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value2, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options, "string");
    if (!isEmptyValue(value2, "string")) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
      rules.pattern(rule, value2, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value2, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value2 === "") {
      value2 = void 0;
    }
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (!isEmptyValue(value2)) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value2 === void 0 || value2 === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options, "array");
    if (value2 !== void 0 && value2 !== null) {
      rules.type(rule, value2, source, errors, options);
      rules.range(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (value2 !== void 0) {
      rules[ENUM](rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (!isEmptyValue(value2, "string")) {
      rules.pattern(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
    if (!isEmptyValue(value2, "date")) {
      var dateObject;
      if (value2 instanceof Date) {
        dateObject = value2;
      } else {
        dateObject = new Date(value2);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value2, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value2) ? "array" : typeof value2;
  rules.required(rule, value2, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value2, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options, ruleType);
    if (!isEmptyValue(value2, ruleType)) {
      rules.type(rule, value2, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value2, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value2) && !rule.required) {
      return callback();
    }
    rules.required(rule, value2, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name2) {
      var item = rules2[name2];
      _this.rules[name2] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o, oc2) {
    var _this2 = this;
    if (o === void 0) {
      o = {};
    }
    if (oc2 === void 0) {
      oc2 = function oc3() {
      };
    }
    var source = source_;
    var options = o;
    var callback = oc2;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add(e2) {
        if (Array.isArray(e2)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e2);
        } else {
          errors.push(e2);
        }
      }
      for (var i = 0; i < results.length; i++) {
        add(results[i]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$12 = this.messages();
      if (messages$12 === messages) {
        messages$12 = newMessages();
      }
      deepMerge(messages$12, options.messages);
      options.messages = messages$12;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr = _this2.rules[z2];
      var value2 = source[z2];
      arr.forEach(function(r2) {
        var rule = r2;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends$1({}, source);
          }
          value2 = source[z2] = rule.transform(value2);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends$1({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value: value2,
          source,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data2, doIt) {
      var rule = data2.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data2.value);
      rule.field = data2.field;
      function addFullField(key2, schema2) {
        return _extends$1({}, schema2, {
          fullField: rule.fullField + "." + key2,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key2]) : [key2]
        });
      }
      function cb2(e2) {
        if (e2 === void 0) {
          e2 = [];
        }
        var errorList = Array.isArray(e2) ? e2 : [e2];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data2.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data2.value).map(function(key2) {
              fieldsSchema[key2] = rule.defaultField;
            });
          }
          fieldsSchema = _extends$1({}, fieldsSchema, data2.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema2 = new Schema2(paredFieldsSchema);
          schema2.messages(options.messages);
          if (data2.rule.options) {
            data2.rule.options.messages = options.messages;
            data2.rule.options.error = options.error;
          }
          schema2.validate(data2.value, data2.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data2.value, cb2, data2.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data2.value, cb2, data2.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb2(error.message);
        }
        if (res === true) {
          cb2();
        } else if (res === false) {
          cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb2(res);
        } else if (res instanceof Error) {
          cb2(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb2();
        }, function(e2) {
          return cb2(e2);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format$1("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register2(type4, validator) {
  if (typeof validator !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator;
};
Schema.warning = warning$1;
Schema.messages = messages;
Schema.validators = validators;
var typeTemplate$1 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate$1,
    method: typeTemplate$1,
    array: typeTemplate$1,
    object: typeTemplate$1,
    number: typeTemplate$1,
    date: typeTemplate$1,
    boolean: typeTemplate$1,
    integer: typeTemplate$1,
    float: typeTemplate$1,
    regexp: typeTemplate$1,
    email: typeTemplate$1,
    url: typeTemplate$1,
    hex: typeTemplate$1
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
function get$1(entity, path) {
  var current = entity;
  for (var i = 0; i < path.length; i += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path[i]];
  }
  return current;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toArray(arr) {
  return _arrayWithHoles$3(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableRest$3();
}
function internalSet(entity, paths, value2, removeIfUndefined) {
  if (!paths.length) {
    return value2;
  }
  var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);
  var clone2;
  if (!entity && typeof path === "number") {
    clone2 = [];
  } else if (Array.isArray(entity)) {
    clone2 = _toConsumableArray(entity);
  } else {
    clone2 = _objectSpread2$4({}, entity);
  }
  if (removeIfUndefined && value2 === void 0 && restPath.length === 1) {
    delete clone2[path][restPath[0]];
  } else {
    clone2[path] = internalSet(clone2[path], restPath, value2, removeIfUndefined);
  }
  return clone2;
}
function set$1(entity, paths, value2) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value2 === void 0 && !get$1(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value2, removeIfUndefined);
}
function cloneDeep(val) {
  if (Array.isArray(val)) {
    return cloneArrayDeep(val);
  } else if (_typeof$4(val) === "object" && val !== null) {
    return cloneObjectDeep(val);
  }
  return val;
}
function cloneObjectDeep(val) {
  if (Object.getPrototypeOf(val) === Object.prototype) {
    var res = {};
    for (var key2 in val) {
      res[key2] = cloneDeep(val[key2]);
    }
    return res;
  }
  return val;
}
function cloneArrayDeep(val) {
  return val.map(function(item) {
    return cloneDeep(item);
  });
}
function getNamePath(path) {
  return toArray$3(path);
}
function getValue(store, namePath) {
  var value2 = get$1(store, namePath);
  return value2;
}
function setValue(store, namePath, value2) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var newStore = set$1(store, namePath, value2, removeIfUndefined);
  return newStore;
}
function cloneByNamePathList(store, namePathList) {
  var newStore = {};
  namePathList.forEach(function(namePath) {
    var value2 = getValue(store, namePath);
    newStore = setValue(newStore, namePath, value2);
  });
  return newStore;
}
function containsNamePath(namePathList, namePath) {
  return namePathList && namePathList.some(function(path) {
    return matchNamePath(path, namePath);
  });
}
function isObject$1(obj) {
  return _typeof$4(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues(store, values) {
  var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2$4({}, store);
  if (!values) {
    return newStore;
  }
  Object.keys(values).forEach(function(key2) {
    var prevValue = newStore[key2];
    var value2 = values[key2];
    var recursive = isObject$1(prevValue) && isObject$1(value2);
    newStore[key2] = recursive ? internalSetValues(prevValue, value2 || {}) : cloneDeep(value2);
  });
  return newStore;
}
function setValues(store) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce(function(current, newStore) {
    return internalSetValues(current, newStore);
  }, store);
}
function matchNamePath(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every(function(nameUnit, i) {
    return changedNamePath[i] === nameUnit;
  });
}
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || _typeof$4(source) !== "object" || _typeof$4(target) !== "object") {
    return false;
  }
  var sourceKeys = Object.keys(source);
  var targetKeys = Object.keys(target);
  var keys2 = new Set([].concat(sourceKeys, targetKeys));
  return _toConsumableArray(keys2).every(function(key2) {
    var sourceValue = source[key2];
    var targetValue = target[key2];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent(valuePropName) {
  var event = arguments.length <= 1 ? void 0 : arguments[1];
  if (event && event.target && _typeof$4(event.target) === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move(array4, moveIndex, toIndex) {
  var length = array4.length;
  if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {
    return array4;
  }
  var item = array4[moveIndex];
  var diff = moveIndex - toIndex;
  if (diff > 0) {
    return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length)));
  }
  if (diff < 0) {
    return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length)));
  }
  return array4;
}
var AsyncValidator = Schema;
function replaceMessage(template, kv) {
  return template.replace(/\$\{\w+\}/g, function(str) {
    var key2 = str.slice(2, -1);
    return kv[key2];
  });
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
function validateRule(_x, _x2, _x3, _x4, _x5) {
  return _validateRule.apply(this, arguments);
}
function _validateRule() {
  _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name2, value2, rule, options, messageVariables) {
    var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cloneRule = _objectSpread2$4({}, rule);
            delete cloneRule.ruleIndex;
            if (cloneRule.validator) {
              originValidator = cloneRule.validator;
              cloneRule.validator = function() {
                try {
                  return originValidator.apply(void 0, arguments);
                } catch (error) {
                  console.error(error);
                  return Promise.reject(CODE_LOGIC_ERROR);
                }
              };
            }
            subRuleField = null;
            if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
              subRuleField = cloneRule.defaultField;
              delete cloneRule.defaultField;
            }
            validator = new AsyncValidator(_defineProperty$5({}, name2, [cloneRule]));
            messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
            validator.messages(messages2);
            result = [];
            _context2.prev = 9;
            _context2.next = 12;
            return Promise.resolve(validator.validate(_defineProperty$5({}, name2, value2), _objectSpread2$4({}, options)));
          case 12:
            _context2.next = 17;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](9);
            if (_context2.t0.errors) {
              result = _context2.t0.errors.map(function(_ref4, index2) {
                var message2 = _ref4.message;
                var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                return /* @__PURE__ */ react.exports.isValidElement(mergedMessage) ? /* @__PURE__ */ react.exports.cloneElement(mergedMessage, {
                  key: "error_".concat(index2)
                }) : mergedMessage;
              });
            }
          case 17:
            if (!(!result.length && subRuleField)) {
              _context2.next = 22;
              break;
            }
            _context2.next = 20;
            return Promise.all(value2.map(function(subValue, i) {
              return validateRule("".concat(name2, ".").concat(i), subValue, subRuleField, options, messageVariables);
            }));
          case 20:
            subResults = _context2.sent;
            return _context2.abrupt("return", subResults.reduce(function(prev, errors) {
              return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));
            }, []));
          case 22:
            kv = _objectSpread2$4(_objectSpread2$4({}, rule), {}, {
              name: name2,
              enum: (rule.enum || []).join(", ")
            }, messageVariables);
            fillVariableResult = result.map(function(error) {
              if (typeof error === "string") {
                return replaceMessage(error, kv);
              }
              return error;
            });
            return _context2.abrupt("return", fillVariableResult);
          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[9, 14]]);
  }));
  return _validateRule.apply(this, arguments);
}
function validateRules(namePath, value2, rules2, options, validateFirst, messageVariables) {
  var name2 = namePath.join(".");
  var filledRules = rules2.map(function(currentRule, ruleIndex) {
    var originValidatorFunc = currentRule.validator;
    var cloneRule = _objectSpread2$4(_objectSpread2$4({}, currentRule), {}, {
      ruleIndex
    });
    if (originValidatorFunc) {
      cloneRule.validator = function(rule, val, callback) {
        var hasPromise = false;
        var wrappedCallback = function wrappedCallback2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          Promise.resolve().then(function() {
            warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
            if (!hasPromise) {
              callback.apply(void 0, args);
            }
          });
        };
        var promise = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
        warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise.then(function() {
            callback();
          }).catch(function(err) {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(function(_ref, _ref2) {
    var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
    var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  var summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(/* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
        var i, rule, errors;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                i = 0;
              case 1:
                if (!(i < filledRules.length)) {
                  _context.next = 12;
                  break;
                }
                rule = filledRules[i];
                _context.next = 5;
                return validateRule(name2, value2, rule, options, messageVariables);
              case 5:
                errors = _context.sent;
                if (!errors.length) {
                  _context.next = 9;
                  break;
                }
                reject([{
                  errors,
                  rule
                }]);
                return _context.abrupt("return");
              case 9:
                i += 1;
                _context.next = 1;
                break;
              case 12:
                resolve([]);
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }());
  } else {
    var rulePromises = filledRules.map(function(rule) {
      return validateRule(name2, value2, rule, options, messageVariables).then(function(errors) {
        return {
          errors,
          rule
        };
      });
    });
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch(function(e2) {
    return e2;
  });
  return summaryPromise;
}
function finishOnAllFailed(_x8) {
  return _finishOnAllFailed.apply(this, arguments);
}
function _finishOnAllFailed() {
  _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
              var _ref5;
              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
              return errors;
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _finishOnAllFailed.apply(this, arguments);
}
function finishOnFirstFailed(_x9) {
  return _finishOnFirstFailed.apply(this, arguments);
}
function _finishOnFirstFailed() {
  _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
    var count;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            count = 0;
            return _context4.abrupt("return", new Promise(function(resolve) {
              rulePromises.forEach(function(promise) {
                promise.then(function(ruleError) {
                  if (ruleError.errors.length) {
                    resolve([ruleError]);
                  }
                  count += 1;
                  if (count === rulePromises.length) {
                    resolve([]);
                  }
                });
              });
            }));
          case 2:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _finishOnFirstFailed.apply(this, arguments);
}
var _excluded$B = ["name"];
var EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info2) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev, next, "source" in info2 ? {
      source: info2.source
    } : {});
  }
  return prevValue !== nextValue;
}
var Field = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Field2, _React$Component);
  var _super = _createSuper$1(Field2);
  function Field2(props) {
    var _this;
    _classCallCheck$2(this, Field2);
    _this = _super.call(this, props);
    _this.state = {
      resetCount: 0
    };
    _this.cancelRegisterFunc = null;
    _this.mounted = false;
    _this.touched = false;
    _this.dirty = false;
    _this.validatePromise = null;
    _this.prevValidating = void 0;
    _this.errors = EMPTY_ERRORS;
    _this.warnings = EMPTY_ERRORS;
    _this.cancelRegister = function() {
      var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name2 = _this$props.name;
      if (_this.cancelRegisterFunc) {
        _this.cancelRegisterFunc(isListField, preserve, getNamePath(name2));
      }
      _this.cancelRegisterFunc = null;
    };
    _this.getNamePath = function() {
      var _this$props2 = _this.props, name2 = _this$props2.name, fieldContext = _this$props2.fieldContext;
      var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
      return name2 !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name2)) : [];
    };
    _this.getRules = function() {
      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
      return rules2.map(function(rule) {
        if (typeof rule === "function") {
          return rule(fieldContext);
        }
        return rule;
      });
    };
    _this.refresh = function() {
      if (!_this.mounted)
        return;
      _this.setState(function(_ref) {
        var resetCount = _ref.resetCount;
        return {
          resetCount: resetCount + 1
        };
      });
    };
    _this.triggerMetaEvent = function(destroy3) {
      var onMetaChange = _this.props.onMetaChange;
      onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2$4(_objectSpread2$4({}, _this.getMeta()), {}, {
        destroy: destroy3
      }));
    };
    _this.onStoreChange = function(prevStore, namePathList, info2) {
      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
      var store = info2.store;
      var namePath = _this.getNamePath();
      var prevValue = _this.getValue(prevStore);
      var curValue = _this.getValue(store);
      var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
      if (info2.type === "valueUpdate" && info2.source === "external" && prevValue !== curValue) {
        _this.touched = true;
        _this.dirty = true;
        _this.validatePromise = null;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
      }
      switch (info2.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            _this.touched = false;
            _this.dirty = false;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
            onReset === null || onReset === void 0 ? void 0 : onReset();
            _this.refresh();
            return;
          }
          break;
        case "remove": {
          if (shouldUpdate) {
            _this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          if (namePathMatch) {
            var data2 = info2.data;
            if ("touched" in data2) {
              _this.touched = data2.touched;
            }
            if ("validating" in data2 && !("originRCField" in data2)) {
              _this.validatePromise = data2.validating ? Promise.resolve([]) : null;
            }
            if ("errors" in data2) {
              _this.errors = data2.errors || EMPTY_ERRORS;
            }
            if ("warnings" in data2) {
              _this.warnings = data2.warnings || EMPTY_ERRORS;
            }
            _this.dirty = true;
            _this.triggerMetaEvent();
            _this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info2)) {
            _this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var dependencyList = dependencies.map(getNamePath);
          if (dependencyList.some(function(dependency) {
            return containsNamePath(info2.relatedFields, dependency);
          })) {
            _this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info2)) {
            _this.reRender();
            return;
          }
          break;
      }
      if (shouldUpdate === true) {
        _this.reRender();
      }
    };
    _this.validateRules = function(options) {
      var namePath = _this.getNamePath();
      var currentValue = _this.getValue();
      var rootPromise = Promise.resolve().then(function() {
        if (!_this.mounted) {
          return [];
        }
        var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
        var _ref2 = options || {}, triggerName = _ref2.triggerName;
        var filteredRules = _this.getRules();
        if (triggerName) {
          filteredRules = filteredRules.filter(function(rule) {
            var validateTrigger = rule.validateTrigger;
            if (!validateTrigger) {
              return true;
            }
            var triggerList = toArray$3(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }
        var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
        promise.catch(function(e2) {
          return e2;
        }).then(function() {
          var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
          if (_this.validatePromise === rootPromise) {
            var _ruleErrors$forEach;
            _this.validatePromise = null;
            var nextErrors = [];
            var nextWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
              var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
              if (warningOnly) {
                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
              } else {
                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
              }
            });
            _this.errors = nextErrors;
            _this.warnings = nextWarnings;
            _this.triggerMetaEvent();
            _this.reRender();
          }
        });
        return promise;
      });
      _this.validatePromise = rootPromise;
      _this.dirty = true;
      _this.errors = EMPTY_ERRORS;
      _this.warnings = EMPTY_ERRORS;
      _this.triggerMetaEvent();
      _this.reRender();
      return rootPromise;
    };
    _this.isFieldValidating = function() {
      return !!_this.validatePromise;
    };
    _this.isFieldTouched = function() {
      return _this.touched;
    };
    _this.isFieldDirty = function() {
      if (_this.dirty || _this.props.initialValue !== void 0) {
        return true;
      }
      var fieldContext = _this.props.fieldContext;
      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
      if (getInitialValue(_this.getNamePath()) !== void 0) {
        return true;
      }
      return false;
    };
    _this.getErrors = function() {
      return _this.errors;
    };
    _this.getWarnings = function() {
      return _this.warnings;
    };
    _this.isListField = function() {
      return _this.props.isListField;
    };
    _this.isList = function() {
      return _this.props.isList;
    };
    _this.isPreserve = function() {
      return _this.props.preserve;
    };
    _this.getMeta = function() {
      _this.prevValidating = _this.isFieldValidating();
      var meta = {
        touched: _this.isFieldTouched(),
        validating: _this.prevValidating,
        errors: _this.errors,
        warnings: _this.warnings,
        name: _this.getNamePath()
      };
      return meta;
    };
    _this.getOnlyChild = function(children) {
      if (typeof children === "function") {
        var meta = _this.getMeta();
        return _objectSpread2$4(_objectSpread2$4({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
          isFunction: true
        });
      }
      var childList = toArray$4(children);
      if (childList.length !== 1 || !/* @__PURE__ */ react.exports.isValidElement(childList[0])) {
        return {
          child: childList,
          isFunction: false
        };
      }
      return {
        child: childList[0],
        isFunction: false
      };
    };
    _this.getValue = function(store) {
      var getFieldsValue = _this.props.fieldContext.getFieldsValue;
      var namePath = _this.getNamePath();
      return getValue(store || getFieldsValue(true), namePath);
    };
    _this.getControlled = function() {
      var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _this$props6 = _this.props, trigger3 = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
      var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
      var namePath = _this.getNamePath();
      var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
      var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch2 = _getInternalHooks.dispatch;
      var value2 = _this.getValue();
      var mergedGetValueProps = getValueProps || function(val) {
        return _defineProperty$5({}, valuePropName, val);
      };
      var originTriggerFunc = childProps[trigger3];
      var control = _objectSpread2$4(_objectSpread2$4({}, childProps), mergedGetValueProps(value2));
      control[trigger3] = function() {
        _this.touched = true;
        _this.dirty = true;
        _this.triggerMetaEvent();
        var newValue;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (getValueFromEvent) {
          newValue = getValueFromEvent.apply(void 0, args);
        } else {
          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
        }
        if (normalize2) {
          newValue = normalize2(newValue, value2, getFieldsValue(true));
        }
        dispatch2({
          type: "updateValue",
          namePath,
          value: newValue
        });
        if (originTriggerFunc) {
          originTriggerFunc.apply(void 0, args);
        }
      };
      var validateTriggerList = toArray$3(mergedValidateTrigger || []);
      validateTriggerList.forEach(function(triggerName) {
        var originTrigger = control[triggerName];
        control[triggerName] = function() {
          if (originTrigger) {
            originTrigger.apply(void 0, arguments);
          }
          var rules2 = _this.props.rules;
          if (rules2 && rules2.length) {
            dispatch2({
              type: "validateField",
              namePath,
              triggerName
            });
          }
        };
      });
      return control;
    };
    if (props.fieldContext) {
      var getInternalHooks2 = props.fieldContext.getInternalHooks;
      var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
      initEntityValue(_assertThisInitialized$1(_this));
    }
    return _this;
  }
  _createClass$2(Field2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
      this.mounted = true;
      if (fieldContext) {
        var getInternalHooks2 = fieldContext.getInternalHooks;
        var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
        this.cancelRegisterFunc = registerField(this);
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelRegister();
      this.triggerMetaEvent(true);
      this.mounted = false;
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (!this.mounted)
        return;
      this.forceUpdate();
    }
  }, {
    key: "render",
    value: function render2() {
      var resetCount = this.state.resetCount;
      var children = this.props.children;
      var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction3 = _this$getOnlyChild.isFunction;
      var returnChildNode;
      if (isFunction3) {
        returnChildNode = child;
      } else if (/* @__PURE__ */ react.exports.isValidElement(child)) {
        returnChildNode = /* @__PURE__ */ react.exports.cloneElement(child, this.getControlled(child.props));
      } else {
        warningOnce(!child, "`children` of Field is not validate ReactElement.");
        returnChildNode = child;
      }
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, {
        key: resetCount
      }, returnChildNode);
    }
  }]);
  return Field2;
}(react.exports.Component);
Field.contextType = Context;
Field.defaultProps = {
  trigger: "onChange",
  valuePropName: "value"
};
function WrapperField(_ref5) {
  var name2 = _ref5.name, restProps = _objectWithoutProperties$1(_ref5, _excluded$B);
  var fieldContext = react.exports.useContext(Context);
  var namePath = name2 !== void 0 ? getNamePath(name2) : void 0;
  var key2 = "keep";
  if (!restProps.isListField) {
    key2 = "_".concat((namePath || []).join("_"));
  }
  return /* @__PURE__ */ react.exports.createElement(Field, _extends$2({
    key: key2,
    name: namePath
  }, restProps, {
    fieldContext
  }));
}
var ListContext$1 = /* @__PURE__ */ react.exports.createContext(null);
var List$3 = function List(_ref) {
  var name2 = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;
  var context2 = react.exports.useContext(Context);
  var keyRef = react.exports.useRef({
    keys: [],
    id: 0
  });
  var keyManager = keyRef.current;
  var prefixName = react.exports.useMemo(function() {
    var parentPrefixName = getNamePath(context2.prefixName) || [];
    return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name2)));
  }, [context2.prefixName, name2]);
  var fieldContext = react.exports.useMemo(function() {
    return _objectSpread2$4(_objectSpread2$4({}, context2), {}, {
      prefixName
    });
  }, [context2, prefixName]);
  var listContext = react.exports.useMemo(function() {
    return {
      getKey: function getKey2(namePath) {
        var len = prefixName.length;
        var pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }
    };
  }, [prefixName]);
  if (typeof children !== "function") {
    warningOnce(false, "Form.List only accepts function as children.");
    return null;
  }
  var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
    var source = _ref2.source;
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  };
  return /* @__PURE__ */ react.exports.createElement(ListContext$1.Provider, {
    value: listContext
  }, /* @__PURE__ */ react.exports.createElement(Context.Provider, {
    value: fieldContext
  }, /* @__PURE__ */ react.exports.createElement(WrapperField, {
    name: [],
    shouldUpdate,
    rules: rules2,
    validateTrigger,
    initialValue,
    isList: true
  }, function(_ref3, meta) {
    var _ref3$value = _ref3.value, value2 = _ref3$value === void 0 ? [] : _ref3$value, onChange2 = _ref3.onChange;
    var getFieldValue = context2.getFieldValue;
    var getNewValue = function getNewValue2() {
      var values = getFieldValue(prefixName || []);
      return values || [];
    };
    var operations = {
      add: function add(defaultValue, index2) {
        var newValue = getNewValue();
        if (index2 >= 0 && index2 <= newValue.length) {
          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
          onChange2([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
        } else {
          keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
          onChange2([].concat(_toConsumableArray(newValue), [defaultValue]));
        }
        keyManager.id += 1;
      },
      remove: function remove(index2) {
        var newValue = getNewValue();
        var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
        if (indexSet.size <= 0) {
          return;
        }
        keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
          return !indexSet.has(keysIndex);
        });
        onChange2(newValue.filter(function(_, valueIndex) {
          return !indexSet.has(valueIndex);
        }));
      },
      move: function move$1(from, to) {
        if (from === to) {
          return;
        }
        var newValue = getNewValue();
        if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {
          return;
        }
        keyManager.keys = move(keyManager.keys, from, to);
        onChange2(move(newValue, from, to));
      }
    };
    var listValue = value2 || [];
    if (!Array.isArray(listValue)) {
      listValue = [];
    }
    return children(listValue.map(function(__, index2) {
      var key2 = keyManager.keys[index2];
      if (key2 === void 0) {
        keyManager.keys[index2] = keyManager.id;
        key2 = keyManager.keys[index2];
        keyManager.id += 1;
      }
      return {
        name: index2,
        key: key2,
        isListField: true
      };
    }), operations, meta);
  })));
};
function _iterableToArrayLimit$3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$3();
}
function allPromiseFinish(promiseList) {
  var hasError = false;
  var count = promiseList.length;
  var results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise(function(resolve, reject) {
    promiseList.forEach(function(promise, index2) {
      promise.catch(function(e2) {
        hasError = true;
        return e2;
      }).then(function(result) {
        count -= 1;
        results[index2] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}
var SPLIT = "__@field_split__";
function normalize(namePath) {
  return namePath.map(function(cell) {
    return "".concat(_typeof$4(cell), ":").concat(cell);
  }).join(SPLIT);
}
var NameMap = /* @__PURE__ */ function() {
  function NameMap2() {
    _classCallCheck$2(this, NameMap2);
    this.kvs = /* @__PURE__ */ new Map();
  }
  _createClass$2(NameMap2, [{
    key: "set",
    value: function set2(key2, value2) {
      this.kvs.set(normalize(key2), value2);
    }
  }, {
    key: "get",
    value: function get2(key2) {
      return this.kvs.get(normalize(key2));
    }
  }, {
    key: "update",
    value: function update(key2, updater) {
      var origin = this.get(key2);
      var next = updater(origin);
      if (!next) {
        this.delete(key2);
      } else {
        this.set(key2, next);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key2) {
      this.kvs.delete(normalize(key2));
    }
  }, {
    key: "map",
    value: function map(callback) {
      return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
        var _ref2 = _slicedToArray$3(_ref, 2), key2 = _ref2[0], value2 = _ref2[1];
        var cells = key2.split(SPLIT);
        return callback({
          key: cells.map(function(cell) {
            var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray$3(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];
            return type4 === "number" ? Number(unit) : unit;
          }),
          value: value2
        });
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json2 = {};
      this.map(function(_ref3) {
        var key2 = _ref3.key, value2 = _ref3.value;
        json2[key2.join(".")] = value2;
        return null;
      });
      return json2;
    }
  }]);
  return NameMap2;
}();
var _excluded$A = ["name", "errors"];
var FormStore = /* @__PURE__ */ _createClass$2(function FormStore2(forceRootUpdate) {
  var _this = this;
  _classCallCheck$2(this, FormStore2);
  this.formHooked = false;
  this.forceRootUpdate = void 0;
  this.subscribable = true;
  this.store = {};
  this.fieldEntities = [];
  this.initialValues = {};
  this.callbacks = {};
  this.validateMessages = null;
  this.preserve = null;
  this.lastValidatePromise = null;
  this.getForm = function() {
    return {
      getFieldValue: _this.getFieldValue,
      getFieldsValue: _this.getFieldsValue,
      getFieldError: _this.getFieldError,
      getFieldWarning: _this.getFieldWarning,
      getFieldsError: _this.getFieldsError,
      isFieldsTouched: _this.isFieldsTouched,
      isFieldTouched: _this.isFieldTouched,
      isFieldValidating: _this.isFieldValidating,
      isFieldsValidating: _this.isFieldsValidating,
      resetFields: _this.resetFields,
      setFields: _this.setFields,
      setFieldValue: _this.setFieldValue,
      setFieldsValue: _this.setFieldsValue,
      validateFields: _this.validateFields,
      submit: _this.submit,
      _init: true,
      getInternalHooks: _this.getInternalHooks
    };
  };
  this.getInternalHooks = function(key2) {
    if (key2 === HOOK_MARK) {
      _this.formHooked = true;
      return {
        dispatch: _this.dispatch,
        initEntityValue: _this.initEntityValue,
        registerField: _this.registerField,
        useSubscribe: _this.useSubscribe,
        setInitialValues: _this.setInitialValues,
        destroyForm: _this.destroyForm,
        setCallbacks: _this.setCallbacks,
        setValidateMessages: _this.setValidateMessages,
        getFields: _this.getFields,
        setPreserve: _this.setPreserve,
        getInitialValue: _this.getInitialValue,
        registerWatch: _this.registerWatch
      };
    }
    warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
    return null;
  };
  this.useSubscribe = function(subscribable) {
    _this.subscribable = subscribable;
  };
  this.prevWithoutPreserves = null;
  this.setInitialValues = function(initialValues, init) {
    _this.initialValues = initialValues || {};
    if (init) {
      var _this$prevWithoutPres;
      var nextStore = setValues({}, initialValues, _this.store);
      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
        var namePath = _ref.key;
        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));
      });
      _this.prevWithoutPreserves = null;
      _this.updateStore(nextStore);
    }
  };
  this.destroyForm = function() {
    var prevWithoutPreserves = new NameMap();
    _this.getFieldEntities(true).forEach(function(entity) {
      if (!_this.isMergedPreserve(entity.isPreserve())) {
        prevWithoutPreserves.set(entity.getNamePath(), true);
      }
    });
    _this.prevWithoutPreserves = prevWithoutPreserves;
  };
  this.getInitialValue = function(namePath) {
    var initValue = getValue(_this.initialValues, namePath);
    return namePath.length ? cloneDeep(initValue) : initValue;
  };
  this.setCallbacks = function(callbacks) {
    _this.callbacks = callbacks;
  };
  this.setValidateMessages = function(validateMessages) {
    _this.validateMessages = validateMessages;
  };
  this.setPreserve = function(preserve) {
    _this.preserve = preserve;
  };
  this.watchList = [];
  this.registerWatch = function(callback) {
    _this.watchList.push(callback);
    return function() {
      _this.watchList = _this.watchList.filter(function(fn) {
        return fn !== callback;
      });
    };
  };
  this.notifyWatch = function() {
    var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (_this.watchList.length) {
      var values = _this.getFieldsValue();
      _this.watchList.forEach(function(callback) {
        callback(values, namePath);
      });
    }
  };
  this.timeoutId = null;
  this.warningUnhooked = function() {
  };
  this.updateStore = function(nextStore) {
    _this.store = nextStore;
  };
  this.getFieldEntities = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!pure) {
      return _this.fieldEntities;
    }
    return _this.fieldEntities.filter(function(field) {
      return field.getNamePath().length;
    });
  };
  this.getFieldsMap = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var cache2 = new NameMap();
    _this.getFieldEntities(pure).forEach(function(field) {
      var namePath = field.getNamePath();
      cache2.set(namePath, field);
    });
    return cache2;
  };
  this.getFieldEntitiesForNamePathList = function(nameList) {
    if (!nameList) {
      return _this.getFieldEntities(true);
    }
    var cache2 = _this.getFieldsMap(true);
    return nameList.map(function(name2) {
      var namePath = getNamePath(name2);
      return cache2.get(namePath) || {
        INVALIDATE_NAME_PATH: getNamePath(name2)
      };
    });
  };
  this.getFieldsValue = function(nameList, filterFunc) {
    _this.warningUnhooked();
    if (nameList === true && !filterFunc) {
      return _this.store;
    }
    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
    var filteredNameList = [];
    fieldEntities.forEach(function(entity) {
      var _entity$isListField;
      var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
        return;
      }
      if (!filterFunc) {
        filteredNameList.push(namePath);
      } else {
        var meta = "getMeta" in entity ? entity.getMeta() : null;
        if (filterFunc(meta)) {
          filteredNameList.push(namePath);
        }
      }
    });
    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
  };
  this.getFieldValue = function(name2) {
    _this.warningUnhooked();
    var namePath = getNamePath(name2);
    return getValue(_this.store, namePath);
  };
  this.getFieldsError = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map(function(entity, index2) {
      if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
        return {
          name: entity.getNamePath(),
          errors: entity.getErrors(),
          warnings: entity.getWarnings()
        };
      }
      return {
        name: getNamePath(nameList[index2]),
        errors: [],
        warnings: []
      };
    });
  };
  this.getFieldError = function(name2) {
    _this.warningUnhooked();
    var namePath = getNamePath(name2);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.errors;
  };
  this.getFieldWarning = function(name2) {
    _this.warningUnhooked();
    var namePath = getNamePath(name2);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  };
  this.isFieldsTouched = function() {
    _this.warningUnhooked();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var arg0 = args[0], arg1 = args[1];
    var namePathList;
    var isAllFieldsTouched = false;
    if (args.length === 0) {
      namePathList = null;
    } else if (args.length === 1) {
      if (Array.isArray(arg0)) {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = false;
      } else {
        namePathList = null;
        isAllFieldsTouched = arg0;
      }
    } else {
      namePathList = arg0.map(getNamePath);
      isAllFieldsTouched = arg1;
    }
    var fieldEntities = _this.getFieldEntities(true);
    var isFieldTouched = function isFieldTouched2(field) {
      return field.isFieldTouched();
    };
    if (!namePathList) {
      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
    }
    var map = new NameMap();
    namePathList.forEach(function(shortNamePath) {
      map.set(shortNamePath, []);
    });
    fieldEntities.forEach(function(field) {
      var fieldNamePath = field.getNamePath();
      namePathList.forEach(function(shortNamePath) {
        if (shortNamePath.every(function(nameUnit, i) {
          return fieldNamePath[i] === nameUnit;
        })) {
          map.update(shortNamePath, function(list2) {
            return [].concat(_toConsumableArray(list2), [field]);
          });
        }
      });
    });
    var isNamePathListTouched = function isNamePathListTouched2(entities) {
      return entities.some(isFieldTouched);
    };
    var namePathListEntities = map.map(function(_ref2) {
      var value2 = _ref2.value;
      return value2;
    });
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  };
  this.isFieldTouched = function(name2) {
    _this.warningUnhooked();
    return _this.isFieldsTouched([name2]);
  };
  this.isFieldsValidating = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntities();
    if (!nameList) {
      return fieldEntities.some(function(testField) {
        return testField.isFieldValidating();
      });
    }
    var namePathList = nameList.map(getNamePath);
    return fieldEntities.some(function(testField) {
      var fieldNamePath = testField.getNamePath();
      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  };
  this.isFieldValidating = function(name2) {
    _this.warningUnhooked();
    return _this.isFieldsValidating([name2]);
  };
  this.resetWithFieldInitialValue = function() {
    var info2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var cache2 = new NameMap();
    var fieldEntities = _this.getFieldEntities(true);
    fieldEntities.forEach(function(field) {
      var initialValue = field.props.initialValue;
      var namePath = field.getNamePath();
      if (initialValue !== void 0) {
        var records = cache2.get(namePath) || /* @__PURE__ */ new Set();
        records.add({
          entity: field,
          value: initialValue
        });
        cache2.set(namePath, records);
      }
    });
    var resetWithFields = function resetWithFields2(entities) {
      entities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = field.getNamePath();
          var formInitialValue = _this.getInitialValue(namePath);
          if (formInitialValue !== void 0) {
            warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
          } else {
            var records = cache2.get(namePath);
            if (records && records.size > 1) {
              warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            } else if (records) {
              var originValue = _this.getFieldValue(namePath);
              if (!info2.skipExist || originValue === void 0) {
                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));
              }
            }
          }
        }
      });
    };
    var requiredFieldEntities;
    if (info2.entities) {
      requiredFieldEntities = info2.entities;
    } else if (info2.namePathList) {
      requiredFieldEntities = [];
      info2.namePathList.forEach(function(namePath) {
        var records = cache2.get(namePath);
        if (records) {
          var _requiredFieldEntitie;
          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
            return r2.entity;
          })));
        }
      });
    } else {
      requiredFieldEntities = fieldEntities;
    }
    resetWithFields(requiredFieldEntities);
  };
  this.resetFields = function(nameList) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (!nameList) {
      _this.updateStore(setValues({}, _this.initialValues));
      _this.resetWithFieldInitialValue();
      _this.notifyObservers(prevStore, null, {
        type: "reset"
      });
      _this.notifyWatch();
      return;
    }
    var namePathList = nameList.map(getNamePath);
    namePathList.forEach(function(namePath) {
      var initialValue = _this.getInitialValue(namePath);
      _this.updateStore(setValue(_this.store, namePath, initialValue));
    });
    _this.resetWithFieldInitialValue({
      namePathList
    });
    _this.notifyObservers(prevStore, namePathList, {
      type: "reset"
    });
    _this.notifyWatch(namePathList);
  };
  this.setFields = function(fields) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    var namePathList = [];
    fields.forEach(function(fieldData) {
      var name2 = fieldData.name;
      fieldData.errors;
      var data2 = _objectWithoutProperties$1(fieldData, _excluded$A);
      var namePath = getNamePath(name2);
      namePathList.push(namePath);
      if ("value" in data2) {
        _this.updateStore(setValue(_this.store, namePath, data2.value));
      }
      _this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    });
    _this.notifyWatch(namePathList);
  };
  this.getFields = function() {
    var entities = _this.getFieldEntities(true);
    var fields = entities.map(function(field) {
      var namePath = field.getNamePath();
      var meta = field.getMeta();
      var fieldData = _objectSpread2$4(_objectSpread2$4({}, meta), {}, {
        name: namePath,
        value: _this.getFieldValue(namePath)
      });
      Object.defineProperty(fieldData, "originRCField", {
        value: true
      });
      return fieldData;
    });
    return fields;
  };
  this.initEntityValue = function(entity) {
    var initialValue = entity.props.initialValue;
    if (initialValue !== void 0) {
      var namePath = entity.getNamePath();
      var prevValue = getValue(_this.store, namePath);
      if (prevValue === void 0) {
        _this.updateStore(setValue(_this.store, namePath, initialValue));
      }
    }
  };
  this.isMergedPreserve = function(fieldPreserve) {
    var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
  };
  this.registerField = function(entity) {
    _this.fieldEntities.push(entity);
    var namePath = entity.getNamePath();
    _this.notifyWatch([namePath]);
    if (entity.props.initialValue !== void 0) {
      var prevStore = _this.store;
      _this.resetWithFieldInitialValue({
        entities: [entity],
        skipExist: true
      });
      _this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(isListField, preserve) {
      var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      _this.fieldEntities = _this.fieldEntities.filter(function(item) {
        return item !== entity;
      });
      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
        var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
          return !matchNamePath(field.getNamePath(), namePath);
        })) {
          var _prevStore = _this.store;
          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));
          _this.notifyObservers(_prevStore, [namePath], {
            type: "remove"
          });
          _this.triggerDependenciesUpdate(_prevStore, namePath);
        }
      }
      _this.notifyWatch([namePath]);
    };
  };
  this.dispatch = function(action) {
    switch (action.type) {
      case "updateValue": {
        var namePath = action.namePath, value2 = action.value;
        _this.updateValue(namePath, value2);
        break;
      }
      case "validateField": {
        var _namePath = action.namePath, triggerName = action.triggerName;
        _this.validateFields([_namePath], {
          triggerName
        });
        break;
      }
    }
  };
  this.notifyObservers = function(prevStore, namePathList, info2) {
    if (_this.subscribable) {
      var mergedInfo = _objectSpread2$4(_objectSpread2$4({}, info2), {}, {
        store: _this.getFieldsValue(true)
      });
      _this.getFieldEntities().forEach(function(_ref3) {
        var onStoreChange = _ref3.onStoreChange;
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else {
      _this.forceRootUpdate();
    }
  };
  this.triggerDependenciesUpdate = function(prevStore, namePath) {
    var childrenFields = _this.getDependencyChildrenFields(namePath);
    if (childrenFields.length) {
      _this.validateFields(childrenFields);
    }
    _this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
    });
    return childrenFields;
  };
  this.updateValue = function(name2, value2) {
    var namePath = getNamePath(name2);
    var prevStore = _this.store;
    _this.updateStore(setValue(_this.store, namePath, value2));
    _this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    });
    _this.notifyWatch([namePath]);
    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
    var onValuesChange = _this.callbacks.onValuesChange;
    if (onValuesChange) {
      var changedValues = cloneByNamePathList(_this.store, [namePath]);
      onValuesChange(changedValues, _this.getFieldsValue());
    }
    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
  };
  this.setFieldsValue = function(store) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (store) {
      var nextStore = setValues(_this.store, store);
      _this.updateStore(nextStore);
    }
    _this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    });
    _this.notifyWatch();
  };
  this.setFieldValue = function(name2, value2) {
    _this.setFields([{
      name: name2,
      value: value2
    }]);
  };
  this.getDependencyChildrenFields = function(rootNamePath) {
    var children = /* @__PURE__ */ new Set();
    var childrenFields = [];
    var dependencies2fields = new NameMap();
    _this.getFieldEntities().forEach(function(field) {
      var dependencies = field.props.dependencies;
      (dependencies || []).forEach(function(dependency) {
        var dependencyNamePath = getNamePath(dependency);
        dependencies2fields.update(dependencyNamePath, function() {
          var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          fields.add(field);
          return fields;
        });
      });
    });
    var fillChildren = function fillChildren2(namePath) {
      var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach(function(field) {
        if (!children.has(field)) {
          children.add(field);
          var fieldNamePath = field.getNamePath();
          if (field.isFieldDirty() && fieldNamePath.length) {
            childrenFields.push(fieldNamePath);
            fillChildren2(fieldNamePath);
          }
        }
      });
    };
    fillChildren(rootNamePath);
    return childrenFields;
  };
  this.triggerOnFieldsChange = function(namePathList, filedErrors) {
    var onFieldsChange = _this.callbacks.onFieldsChange;
    if (onFieldsChange) {
      var fields = _this.getFields();
      if (filedErrors) {
        var cache2 = new NameMap();
        filedErrors.forEach(function(_ref4) {
          var name2 = _ref4.name, errors = _ref4.errors;
          cache2.set(name2, errors);
        });
        fields.forEach(function(field) {
          field.errors = cache2.get(field.name) || field.errors;
        });
      }
      var changedFields = fields.filter(function(_ref5) {
        var fieldName = _ref5.name;
        return containsNamePath(namePathList, fieldName);
      });
      onFieldsChange(changedFields, fields);
    }
  };
  this.validateFields = function(nameList, options) {
    _this.warningUnhooked();
    var provideNameList = !!nameList;
    var namePathList = provideNameList ? nameList.map(getNamePath) : [];
    var promiseList = [];
    _this.getFieldEntities(true).forEach(function(field) {
      if (!provideNameList) {
        namePathList.push(field.getNamePath());
      }
      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
        var namePath = field.getNamePath();
        if (namePath.every(function(nameUnit, i) {
          return nameList[i] === nameUnit || nameList[i] === void 0;
        })) {
          namePathList.push(namePath);
        }
      }
      if (!field.props.rules || !field.props.rules.length) {
        return;
      }
      var fieldNamePath = field.getNamePath();
      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
        var promise = field.validateRules(_objectSpread2$4({
          validateMessages: _objectSpread2$4(_objectSpread2$4({}, defaultValidateMessages), _this.validateMessages)
        }, options));
        promiseList.push(promise.then(function() {
          return {
            name: fieldNamePath,
            errors: [],
            warnings: []
          };
        }).catch(function(ruleErrors) {
          var _ruleErrors$forEach;
          var mergedErrors = [];
          var mergedWarnings = [];
          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
            var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
            if (warningOnly) {
              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
            } else {
              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name: fieldNamePath,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    });
    var summaryPromise = allPromiseFinish(promiseList);
    _this.lastValidatePromise = summaryPromise;
    summaryPromise.catch(function(results) {
      return results;
    }).then(function(results) {
      var resultNamePathList = results.map(function(_ref7) {
        var name2 = _ref7.name;
        return name2;
      });
      _this.notifyObservers(_this.store, resultNamePathList, {
        type: "validateFinish"
      });
      _this.triggerOnFieldsChange(resultNamePathList, results);
    });
    var returnPromise = summaryPromise.then(function() {
      if (_this.lastValidatePromise === summaryPromise) {
        return Promise.resolve(_this.getFieldsValue(namePathList));
      }
      return Promise.reject([]);
    }).catch(function(results) {
      var errorList = results.filter(function(result) {
        return result && result.errors.length;
      });
      return Promise.reject({
        values: _this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: _this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch(function(e2) {
      return e2;
    });
    return returnPromise;
  };
  this.submit = function() {
    _this.warningUnhooked();
    _this.validateFields().then(function(values) {
      var onFinish = _this.callbacks.onFinish;
      if (onFinish) {
        try {
          onFinish(values);
        } catch (err) {
          console.error(err);
        }
      }
    }).catch(function(e2) {
      var onFinishFailed = _this.callbacks.onFinishFailed;
      if (onFinishFailed) {
        onFinishFailed(e2);
      }
    });
  };
  this.forceRootUpdate = forceRootUpdate;
});
function useForm$1(form2) {
  var formRef = react.exports.useRef();
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray$3(_React$useState, 2), forceUpdate = _React$useState2[1];
  if (!formRef.current) {
    if (form2) {
      formRef.current = form2;
    } else {
      var forceReRender = function forceReRender2() {
        forceUpdate({});
      };
      var formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
var FormContext$1 = /* @__PURE__ */ react.exports.createContext({
  triggerFormChange: function triggerFormChange() {
  },
  triggerFormFinish: function triggerFormFinish() {
  },
  registerForm: function registerForm() {
  },
  unregisterForm: function unregisterForm() {
  }
});
var FormProvider$1 = function FormProvider(_ref) {
  var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
  var formContext = react.exports.useContext(FormContext$1);
  var formsRef = react.exports.useRef({});
  return /* @__PURE__ */ react.exports.createElement(FormContext$1.Provider, {
    value: _objectSpread2$4(_objectSpread2$4({}, formContext), {}, {
      validateMessages: _objectSpread2$4(_objectSpread2$4({}, formContext.validateMessages), validateMessages),
      triggerFormChange: function triggerFormChange2(name2, changedFields) {
        if (onFormChange) {
          onFormChange(name2, {
            changedFields,
            forms: formsRef.current
          });
        }
        formContext.triggerFormChange(name2, changedFields);
      },
      triggerFormFinish: function triggerFormFinish2(name2, values) {
        if (onFormFinish) {
          onFormFinish(name2, {
            values,
            forms: formsRef.current
          });
        }
        formContext.triggerFormFinish(name2, values);
      },
      registerForm: function registerForm2(name2, form2) {
        if (name2) {
          formsRef.current = _objectSpread2$4(_objectSpread2$4({}, formsRef.current), {}, _defineProperty$5({}, name2, form2));
        }
        formContext.registerForm(name2, form2);
      },
      unregisterForm: function unregisterForm2(name2) {
        var newForms = _objectSpread2$4({}, formsRef.current);
        delete newForms[name2];
        formsRef.current = newForms;
        formContext.unregisterForm(name2);
      }
    })
  }, children);
};
var _excluded$z = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
var Form$3 = function Form(_ref, ref) {
  var name2 = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form2 = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties$1(_ref, _excluded$z);
  var formContext = react.exports.useContext(FormContext$1);
  var _useForm = useForm$1(form2), _useForm2 = _slicedToArray$3(_useForm, 1), formInstance = _useForm2[0];
  var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
  react.exports.useImperativeHandle(ref, function() {
    return formInstance;
  });
  react.exports.useEffect(function() {
    formContext.registerForm(name2, formInstance);
    return function() {
      formContext.unregisterForm(name2);
    };
  }, [formContext, formInstance, name2]);
  setValidateMessages(_objectSpread2$4(_objectSpread2$4({}, formContext.validateMessages), validateMessages));
  setCallbacks({
    onValuesChange,
    onFieldsChange: function onFieldsChange(changedFields) {
      formContext.triggerFormChange(name2, changedFields);
      if (_onFieldsChange) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        _onFieldsChange.apply(void 0, [changedFields].concat(rest));
      }
    },
    onFinish: function onFinish(values2) {
      formContext.triggerFormFinish(name2, values2);
      if (_onFinish) {
        _onFinish(values2);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve);
  var mountRef = react.exports.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  react.exports.useEffect(function() {
    return destroyForm;
  }, []);
  var childrenNode;
  var childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    var values = formInstance.getFieldsValue(true);
    childrenNode = children(values, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  var prevFieldsRef = react.exports.useRef();
  react.exports.useEffect(function() {
    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  var formContextValue = react.exports.useMemo(function() {
    return _objectSpread2$4(_objectSpread2$4({}, formInstance), {}, {
      validateTrigger
    });
  }, [formInstance, validateTrigger]);
  var wrapperNode = /* @__PURE__ */ react.exports.createElement(Context.Provider, {
    value: formContextValue
  }, childrenNode);
  if (Component2 === false) {
    return wrapperNode;
  }
  return /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({}, restProps, {
    onSubmit: function onSubmit(event) {
      event.preventDefault();
      event.stopPropagation();
      formInstance.submit();
    },
    onReset: function onReset(event) {
      var _restProps$onReset;
      event.preventDefault();
      formInstance.resetFields();
      (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
    }
  }), wrapperNode);
};
function stringify(value2) {
  try {
    return JSON.stringify(value2);
  } catch (err) {
    return Math.random();
  }
}
function useWatch() {
  var dependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var form2 = arguments.length > 1 ? arguments[1] : void 0;
  var _useState = react.exports.useState(), _useState2 = _slicedToArray$3(_useState, 2), value2 = _useState2[0], setValue2 = _useState2[1];
  var valueStr = react.exports.useMemo(function() {
    return stringify(value2);
  }, [value2]);
  var valueStrRef = react.exports.useRef(valueStr);
  valueStrRef.current = valueStr;
  var fieldContext = react.exports.useContext(Context);
  var formInstance = form2 || fieldContext;
  var isValidForm = formInstance && formInstance._init;
  var namePath = getNamePath(dependencies);
  var namePathRef = react.exports.useRef(namePath);
  namePathRef.current = namePath;
  react.exports.useEffect(function() {
    if (!isValidForm) {
      return;
    }
    var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
    var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
    var cancelRegister = registerWatch(function(store) {
      var newValue = getValue(store, namePathRef.current);
      var nextValueStr = stringify(newValue);
      if (valueStrRef.current !== nextValueStr) {
        valueStrRef.current = nextValueStr;
        setValue2(newValue);
      }
    });
    var initialValue = getValue(getFieldsValue(), namePathRef.current);
    setValue2(initialValue);
    return cancelRegister;
  }, []);
  return value2;
}
var InternalForm$2 = /* @__PURE__ */ react.exports.forwardRef(Form$3);
var RefForm = InternalForm$2;
RefForm.FormProvider = FormProvider$1;
RefForm.Field = WrapperField;
RefForm.List = List$3;
RefForm.useForm = useForm$1;
RefForm.useWatch = useWatch;
var safeIsNaN = Number.isNaN || function ponyfill(value2) {
  return typeof value2 === "number" && value2 !== value2;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache2 = null;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (cache2 && cache2.lastThis === this && isEqual2(newArgs, cache2.lastArgs)) {
      return cache2.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache2 = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache2 = null;
  };
  return memoized;
}
const enUS$1 = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var locale$2 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
var locale$1 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
const TimePicker = locale$1;
var locale = {
  lang: _extends$2({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, locale$2),
  timePickerLocale: _extends$2({}, TimePicker)
};
const enUS = locale;
var typeTemplate = "${label} is not a valid ${type}";
var localeValues = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No Data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      "default": "Field validation error for ${label}",
      required: "Please enter ${label}",
      "enum": "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        "boolean": typeTemplate,
        integer: typeTemplate,
        "float": typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  }
};
const defaultLocale = localeValues;
var runtimeLocale = _extends$2({}, defaultLocale.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    runtimeLocale = _extends$2(_extends$2({}, runtimeLocale), newLocale);
  } else {
    runtimeLocale = _extends$2({}, defaultLocale.Modal);
  }
}
var LocaleContext = /* @__PURE__ */ react.exports.createContext(void 0);
const LocaleContext$1 = LocaleContext;
var ANT_MARK = "internalMark";
var LocaleProvider = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(LocaleProvider2, _React$Component);
  var _super = _createSuper$1(LocaleProvider2);
  function LocaleProvider2(props) {
    var _this;
    _classCallCheck$2(this, LocaleProvider2);
    _this = _super.call(this, props);
    _this.getMemoizedContextValue = memoizeOne(function(localeValue) {
      return _extends$2(_extends$2({}, localeValue), {
        exist: true
      });
    });
    changeConfirmLocale(props.locale && props.locale.Modal);
    return _this;
  }
  _createClass$2(LocaleProvider2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      changeConfirmLocale(this.props.locale && this.props.locale.Modal);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var locale2 = this.props.locale;
      if (prevProps.locale !== locale2) {
        changeConfirmLocale(locale2 && locale2.Modal);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      changeConfirmLocale();
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, locale2 = _this$props.locale, children = _this$props.children;
      var contextValue = this.getMemoizedContextValue(locale2);
      return /* @__PURE__ */ react.exports.createElement(LocaleContext$1.Provider, {
        value: contextValue
      }, children);
    }
  }]);
  return LocaleProvider2;
}(react.exports.Component);
LocaleProvider.defaultProps = {
  locale: {}
};
var LocaleReceiver = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(LocaleReceiver2, _React$Component);
  var _super = _createSuper$1(LocaleReceiver2);
  function LocaleReceiver2() {
    _classCallCheck$2(this, LocaleReceiver2);
    return _super.apply(this, arguments);
  }
  _createClass$2(LocaleReceiver2, [{
    key: "getLocale",
    value: function getLocale() {
      var _this$props = this.props, componentName = _this$props.componentName, defaultLocale$1 = _this$props.defaultLocale;
      var locale2 = defaultLocale$1 || defaultLocale[componentName !== null && componentName !== void 0 ? componentName : "global"];
      var antLocale = this.context;
      var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
      return _extends$2(_extends$2({}, locale2 instanceof Function ? locale2() : locale2), localeFromContext || {});
    }
  }, {
    key: "getLocaleCode",
    value: function getLocaleCode() {
      var antLocale = this.context;
      var localeCode = antLocale && antLocale.locale;
      if (antLocale && antLocale.exist && !localeCode) {
        return defaultLocale.locale;
      }
      return localeCode;
    }
  }, {
    key: "render",
    value: function render2() {
      return this.props.children(this.getLocale(), this.getLocaleCode(), this.context);
    }
  }]);
  return LocaleReceiver2;
}(react.exports.Component);
LocaleReceiver.defaultProps = {
  componentName: "global"
};
LocaleReceiver.contextType = LocaleContext$1;
function useLocaleReceiver(componentName, defaultLocale$1) {
  var antLocale = react.exports.useContext(LocaleContext$1);
  var componentLocale = react.exports.useMemo(function() {
    var locale2 = defaultLocale$1 || defaultLocale[componentName || "global"];
    var localeFromContext = componentName && antLocale ? antLocale[componentName] : {};
    return _extends$2(_extends$2({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
  }, [componentName, defaultLocale$1, antLocale]);
  return [componentLocale];
}
var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
const CheckCircleFilledSvg = CheckCircleFilled$2;
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var MARK_KEY = "rc-util-key";
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark2 = _ref.mark;
  if (mark2) {
    return mark2.startsWith("data-") ? mark2 : "data-".concat(mark2);
  }
  return MARK_KEY;
}
function getContainer$1(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function injectCSS(css2) {
  var _option$csp;
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var styleNode = document.createElement("style");
  if ((_option$csp = option.csp) === null || _option$csp === void 0 ? void 0 : _option$csp.nonce) {
    var _option$csp2;
    styleNode.nonce = (_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer$1(option);
  var firstChild = container.firstChild;
  if (option.prepend && container.prepend) {
    container.prepend(styleNode);
  } else if (option.prepend && firstChild) {
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
var containerCache = /* @__PURE__ */ new Map();
function findExistNode(key2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer$1(option);
  return Array.from(containerCache.get(container).children).find(function(node) {
    return node.tagName === "STYLE" && node.getAttribute(getMark(option)) === key2;
  });
}
function updateCSS(css2, key2) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer$1(option);
  if (!containerCache.has(container)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    parentNode.removeChild(placeholderStyle);
  }
  var existNode = findExistNode(key2, option);
  if (existNode) {
    var _option$csp3, _option$csp4;
    if (((_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce) && existNode.nonce !== ((_option$csp4 = option.csp) === null || _option$csp4 === void 0 ? void 0 : _option$csp4.nonce)) {
      var _option$csp5;
      existNode.nonce = (_option$csp5 = option.csp) === null || _option$csp5 === void 0 ? void 0 : _option$csp5.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key2);
  return newNode;
}
function warning2(valid2, message2) {
  warningOnce(valid2, "[@ant-design/icons] ".concat(message2));
}
function isIconDefinition(target) {
  return _typeof$4(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$4(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key2) {
    var val = attrs[key2];
    switch (key2) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key2] = val;
    }
    return acc;
  }, {});
}
function generate(node, key2, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ React$a.createElement(node.tag, _objectSpread2$4({
      key: key2
    }, normalizeAttrs(node.attrs)), (node.children || []).map(function(child, index2) {
      return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ React$a.createElement(node.tag, _objectSpread2$4(_objectSpread2$4({
    key: key2
  }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function(child, index2) {
    return generate(child, "".concat(key2, "-").concat(node.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles = function useInsertStyles2() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  var _useContext = react.exports.useContext(IconContext$1), csp = _useContext.csp;
  react.exports.useEffect(function() {
    updateCSS(styleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
var _excluded$y = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread2$4({}, twoToneColorPalette);
}
var IconBase = function IconBase2(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties$1(props, _excluded$y);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles();
  warning2(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2$4(_objectSpread2$4({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread2$4({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase.displayName = "IconReact";
IconBase.getTwoToneColors = getTwoToneColors;
IconBase.setTwoToneColors = setTwoToneColors;
const ReactIcon = IconBase;
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$3(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors = ReactIcon.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}
var _excluded$x = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor("#1890ff");
var Icon$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties$1(props, _excluded$x);
  var _React$useContext = react.exports.useContext(IconContext$1), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre;
  var classString = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$5(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray$3(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ react.exports.createElement("span", _objectSpread2$4(_objectSpread2$4({
    role: "img",
    "aria-label": icon.name
  }, restProps), {}, {
    ref,
    tabIndex: iconTabIndex,
    onClick,
    className: classString
  }), /* @__PURE__ */ react.exports.createElement(ReactIcon, {
    icon,
    primaryColor,
    secondaryColor,
    style: svgStyle
  }));
});
Icon$2.displayName = "AntdIcon";
Icon$2.getTwoToneColor = getTwoToneColor;
Icon$2.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon$2;
var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CheckCircleFilledSvg
  }));
};
CheckCircleFilled.displayName = "CheckCircleFilled";
const CheckCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CheckCircleFilled);
var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
const CloseCircleFilledSvg = CloseCircleFilled$2;
var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CloseCircleFilledSvg
  }));
};
CloseCircleFilled.displayName = "CloseCircleFilled";
const CloseCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CloseCircleFilled);
var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: ExclamationCircleFilledSvg
  }));
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
const ExclamationCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(ExclamationCircleFilled);
var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
const InfoCircleFilledSvg = InfoCircleFilled$2;
var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: InfoCircleFilledSvg
  }));
};
InfoCircleFilled.displayName = "InfoCircleFilled";
const InfoCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(InfoCircleFilled);
var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;
var LoadingOutlined = function LoadingOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: LoadingOutlinedSvg
  }));
};
LoadingOutlined.displayName = "LoadingOutlined";
const LoadingOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LoadingOutlined);
var fullClone = _objectSpread2$4({}, ReactDOM$1);
var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  var mainVersion = Number((version || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e2) {
}
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$4(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node, container) {
  toggleWarning(true);
  var root2 = container[MARK] || createRoot(container);
  toggleWarning(false);
  root2.render(node);
  container[MARK] = root2;
}
function legacyRender(node, container) {
  reactRender(node, container);
}
function render(node, container) {
  if (createRoot) {
    modernRender(node, container);
    return;
  }
  legacyRender(node, container);
}
function modernUnmount(_x) {
  return _modernUnmount.apply(this, arguments);
}
function _modernUnmount() {
  _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve().then(function() {
              var _container$MARK;
              (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
              delete container[MARK];
            }));
          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _modernUnmount.apply(this, arguments);
}
function legacyUnmount(container) {
  unmountComponentAtNode(container);
}
function unmount(_x2) {
  return _unmount.apply(this, arguments);
}
function _unmount() {
  _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot !== void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount(container));
          case 2:
            legacyUnmount(container);
          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _unmount.apply(this, arguments);
}
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement("div");
  style = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$2(transitionName2, transitionType) {
  if (!transitionName2)
    return null;
  if (_typeof$4(transitionName2) === "object") {
    var type4 = transitionType.replace(/-\w/g, function(match2) {
      return match2[1].toUpperCase();
    });
    return transitionName2[type4];
  }
  return "".concat(transitionName2, "-").concat(transitionType);
}
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
function useSafeState(defaultValue) {
  var destroyRef = react.exports.useRef(false);
  var _React$useState = react.exports.useState(defaultValue), _React$useState2 = _slicedToArray$3(_React$useState, 2), value2 = _React$useState2[0], setValue2 = _React$useState2[1];
  react.exports.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value2, safeSetState];
}
var raf = function raf2(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = function raf3(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id2) {
  rafIds.delete(id2);
}
function wrapperRaf$1(callback) {
  var times2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id2 = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id2);
      callback();
    } else {
      var realId = raf(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id2, realId);
    }
  }
  callRef(times2);
  return id2;
}
wrapperRaf$1.cancel = function(id2) {
  var realId = rafIds.get(id2);
  cleanup(realId);
  return caf(realId);
};
const useNextFrame = function() {
  var nextFrameRef = react.exports.useRef(null);
  function cancelNextFrame() {
    wrapperRaf$1.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf$1(function() {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  react.exports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
};
var useIsomorphicLayoutEffect = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
const useStepQueue = function(status, callback) {
  var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray$3(_useState, 2), step = _useState2[0], setStep = _useState2[1];
  var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray$3(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  useIsomorphicLayoutEffect(function() {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index2 = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index2 + 1];
      var result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else {
        nextFrame(function(info2) {
          function doNext() {
            if (info2.isCanceled())
              return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  react.exports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
};
const useDomMotionEvents = function(callback) {
  var cacheElementRef = react.exports.useRef();
  var callbackRef = react.exports.useRef(callback);
  callbackRef.current = callback;
  var onInternalMotionEnd = react.exports.useCallback(function(event) {
    callbackRef.current(event);
  }, []);
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  react.exports.useEffect(function() {
    return function() {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
};
function useStatus(supportMotion, visible, getElement2, _ref) {
  var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
  var _useState = useSafeState(), _useState2 = _slicedToArray$3(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
  var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray$3(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
  var _useState5 = useSafeState(null), _useState6 = _slicedToArray$3(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
  var mountedRef = react.exports.useRef(false);
  var deadlineRef = react.exports.useRef(null);
  function getDomElement() {
    return getElement2();
  }
  var activeRef = react.exports.useRef(false);
  function onInternalMotionEnd(event) {
    var element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    }
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
  }
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray$3(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
  var eventHandlers = react.exports.useMemo(function() {
    var _ref2, _ref3, _ref4;
    switch (status) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty$5(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$5(_ref2, STEP_START, onAppearStart), _defineProperty$5(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$5(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$5(_ref3, STEP_START, onEnterStart), _defineProperty$5(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$5(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$5(_ref4, STEP_START, onLeaveStart), _defineProperty$5(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
      default:
        return {};
    }
  }, [status]);
  var _useStepQueue = useStepQueue(status, function(newStep) {
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      var _eventHandlers$step;
      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }
    if (step === STEP_ACTIVE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function() {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    return DoStep;
  }), _useStepQueue2 = _slicedToArray$3(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;
  useIsomorphicLayoutEffect(function() {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;
    if (!supportMotion) {
      return;
    }
    var nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    if (nextStatus) {
      setStatus(nextStatus);
      startStep();
    }
  }, [visible]);
  react.exports.useEffect(function() {
    if (status === STATUS_APPEAR && !motionAppear || status === STATUS_ENTER && !motionEnter || status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  react.exports.useEffect(function() {
    return function() {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);
  var firstMountChangeRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && status === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);
  var mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2$4({
      transition: "none"
    }, mergedStyle);
  }
  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(DomWrapper2, _React$Component);
  var _super = _createSuper$1(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck$2(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass$2(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(react.exports.Component);
function genCSSMotion(config) {
  var transitionSupport = config;
  if (_typeof$4(config) === "object") {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }
  var CSSMotion2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
    var supportMotion = isSupportTransition(props);
    var nodeRef = react.exports.useRef();
    var wrapperNodeRef = react.exports.useRef();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e2) {
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray$3(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
    var renderedRef = react.exports.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    var setNodeRef = react.exports.useCallback(function(node) {
      nodeRef.current = node;
      fillRef(ref, node);
    }, [ref]);
    var motionChildren;
    var mergedProps = _objectSpread2$4(_objectSpread2$4({}, eventProps), {}, {
      visible
    });
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE || !isSupportTransition(props)) {
      if (mergedVisible) {
        motionChildren = children(_objectSpread2$4({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current) {
        motionChildren = children(_objectSpread2$4(_objectSpread2$4({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender) {
        motionChildren = children(_objectSpread2$4(_objectSpread2$4({}, mergedProps), {}, {
          style: {
            display: "none"
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      motionChildren = children(_objectSpread2$4(_objectSpread2$4({}, mergedProps), {}, {
        className: classnamesExports(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$5(_classNames, getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty$5(_classNames, motionName, typeof motionName === "string"), _classNames)),
        style: statusStyle
      }), setNodeRef);
    }
    if (/* @__PURE__ */ react.exports.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var _motionChildren = motionChildren, originNodeRef = _motionChildren.ref;
      if (!originNodeRef) {
        motionChildren = /* @__PURE__ */ react.exports.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /* @__PURE__ */ react.exports.createElement(DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion2.displayName = "CSSMotion";
  return CSSMotion2;
}
const CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key2) {
  var keyObj;
  if (key2 && _typeof$4(key2) === "object" && "key" in key2) {
    keyObj = key2;
  } else {
    keyObj = {
      key: key2
    };
  }
  return _objectSpread2$4(_objectSpread2$4({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return keys2.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var list2 = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach(function(keyObj) {
    var hit = false;
    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i) {
          list2 = list2.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
            return _objectSpread2$4(_objectSpread2$4({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }
        list2.push(_objectSpread2$4(_objectSpread2$4({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list2.push(_objectSpread2$4(_objectSpread2$4({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });
  if (currentIndex < currentLen) {
    list2 = list2.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
      return _objectSpread2$4(_objectSpread2$4({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  var keys2 = {};
  list2.forEach(function(_ref) {
    var key2 = _ref.key;
    keys2[key2] = (keys2[key2] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys2).filter(function(key2) {
    return keys2[key2] > 1;
  });
  duplicatedKeys.forEach(function(matchKey) {
    list2 = list2.filter(function(_ref2) {
      var key2 = _ref2.key, status = _ref2.status;
      return key2 !== matchKey || status !== STATUS_REMOVE;
    });
    list2.forEach(function(node) {
      if (node.key === matchKey) {
        node.status = STATUS_KEEP;
      }
    });
  });
  return list2;
}
var _excluded$w = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$6 = ["status"];
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
  var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$1(CSSMotionList3, _React$Component);
    var _super = _createSuper$1(CSSMotionList3);
    function CSSMotionList3() {
      var _this;
      _classCallCheck$2(this, CSSMotionList3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        keyEntities: []
      };
      _this.removeKey = function(removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function(entity) {
          if (entity.key !== removeKey)
            return entity;
          return _objectSpread2$4(_objectSpread2$4({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function(_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      };
      return _this;
    }
    _createClass$2(CSSMotionList3, [{
      key: "render",
      value: function render2() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties$1(_this$props, _excluded$w);
        var Component2 = component || react.exports.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function(prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /* @__PURE__ */ react.exports.createElement(Component2, restProps, keyEntities.map(function(_ref2) {
          var status = _ref2.status, eventProps = _objectWithoutProperties$1(_ref2, _excluded2$6);
          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /* @__PURE__ */ react.exports.createElement(CSSMotion$1, _extends$2({}, motionProps, {
            key: eventProps.key,
            visible,
            eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });
              if (!changedVisible) {
                var restKeysCount = _this2.removeKey(eventProps.key);
                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          }), children);
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys2 = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys2);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function(entity) {
            var prevEntity = keyEntities.find(function(_ref5) {
              var key2 = _ref5.key;
              return entity.key === key2;
            });
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList3;
  }(react.exports.Component);
  CSSMotionList2.defaultProps = {
    component: "div"
  };
  return CSSMotionList2;
}
const CSSMotionList = genCSSMotionList(supportTransition);
var Notice = /* @__PURE__ */ function(_Component) {
  _inherits$1(Notice2, _Component);
  var _super = _createSuper$1(Notice2);
  function Notice2() {
    var _this;
    _classCallCheck$2(this, Notice2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.closeTimer = null;
    _this.close = function(e2) {
      if (e2) {
        e2.stopPropagation();
      }
      _this.clearCloseTimer();
      var _this$props = _this.props, onClose2 = _this$props.onClose, noticeKey = _this$props.noticeKey;
      if (onClose2) {
        onClose2(noticeKey);
      }
    };
    _this.startCloseTimer = function() {
      if (_this.props.duration) {
        _this.closeTimer = window.setTimeout(function() {
          _this.close();
        }, _this.props.duration * 1e3);
      }
    };
    _this.clearCloseTimer = function() {
      if (_this.closeTimer) {
        clearTimeout(_this.closeTimer);
        _this.closeTimer = null;
      }
    };
    return _this;
  }
  _createClass$2(Notice2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startCloseTimer();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.duration !== prevProps.duration || this.props.updateMark !== prevProps.updateMark || this.props.visible !== prevProps.visible && this.props.visible) {
        this.restartCloseTimer();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.clearCloseTimer();
    }
  }, {
    key: "restartCloseTimer",
    value: function restartCloseTimer() {
      this.clearCloseTimer();
      this.startCloseTimer();
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, closable = _this$props2.closable, closeIcon = _this$props2.closeIcon, style2 = _this$props2.style, onClick = _this$props2.onClick, children = _this$props2.children, holder = _this$props2.holder;
      var componentClass = "".concat(prefixCls, "-notice");
      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(acc, key2) {
        if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role") {
          acc[key2] = _this2.props[key2];
        }
        return acc;
      }, {});
      var node = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
        className: classnamesExports(componentClass, className, _defineProperty$5({}, "".concat(componentClass, "-closable"), closable)),
        style: style2,
        onMouseEnter: this.clearCloseTimer,
        onMouseLeave: this.startCloseTimer,
        onClick
      }, dataOrAriaAttributeProps), /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(componentClass, "-content")
      }, children), closable ? /* @__PURE__ */ react.exports.createElement("a", {
        tabIndex: 0,
        onClick: this.close,
        className: "".concat(componentClass, "-close")
      }, closeIcon || /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(componentClass, "-close-x")
      })) : null);
      if (holder) {
        return /* @__PURE__ */ ReactDOM.createPortal(node, holder);
      }
      return node;
    }
  }]);
  return Notice2;
}(react.exports.Component);
Notice.defaultProps = {
  onClose: function onClose() {
  },
  duration: 1.5
};
function useNotification(notificationInstance2) {
  var createdRef = react.exports.useRef({});
  var _React$useState = react.exports.useState([]), _React$useState2 = _slicedToArray$3(_React$useState, 2), elements = _React$useState2[0], setElements = _React$useState2[1];
  function notify(noticeProps) {
    var firstMount = true;
    notificationInstance2.add(noticeProps, function(div, props) {
      var key2 = props.key;
      if (div && (!createdRef.current[key2] || firstMount)) {
        var noticeEle = /* @__PURE__ */ react.exports.createElement(Notice, _extends$2({}, props, {
          holder: div
        }));
        createdRef.current[key2] = noticeEle;
        setElements(function(originElements) {
          var index2 = originElements.findIndex(function(ele) {
            return ele.key === props.key;
          });
          if (index2 === -1) {
            return [].concat(_toConsumableArray(originElements), [noticeEle]);
          }
          var cloneList = _toConsumableArray(originElements);
          cloneList[index2] = noticeEle;
          return cloneList;
        });
      }
      firstMount = false;
    });
  }
  return [notify, /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, elements)];
}
var _excluded$v = ["getContainer"];
var seed = 0;
var now = Date.now();
function getUuid() {
  var id2 = seed;
  seed += 1;
  return "rcNotification_".concat(now, "_").concat(id2);
}
var Notification = /* @__PURE__ */ function(_Component) {
  _inherits$1(Notification2, _Component);
  var _super = _createSuper$1(Notification2);
  function Notification2() {
    var _this;
    _classCallCheck$2(this, Notification2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      notices: []
    };
    _this.hookRefs = /* @__PURE__ */ new Map();
    _this.add = function(originNotice, holderCallback) {
      var key2 = originNotice.key || getUuid();
      var notice2 = _objectSpread2$4(_objectSpread2$4({}, originNotice), {}, {
        key: key2
      });
      var maxCount2 = _this.props.maxCount;
      _this.setState(function(previousState) {
        var notices = previousState.notices;
        var noticeIndex = notices.map(function(v2) {
          return v2.notice.key;
        }).indexOf(key2);
        var updatedNotices = notices.concat();
        if (noticeIndex !== -1) {
          updatedNotices.splice(noticeIndex, 1, {
            notice: notice2,
            holderCallback
          });
        } else {
          if (maxCount2 && notices.length >= maxCount2) {
            notice2.key = updatedNotices[0].notice.key;
            notice2.updateMark = getUuid();
            notice2.userPassKey = key2;
            updatedNotices.shift();
          }
          updatedNotices.push({
            notice: notice2,
            holderCallback
          });
        }
        return {
          notices: updatedNotices
        };
      });
    };
    _this.remove = function(removeKey) {
      _this.setState(function(_ref) {
        var notices = _ref.notices;
        return {
          notices: notices.filter(function(_ref2) {
            var _ref2$notice = _ref2.notice, key2 = _ref2$notice.key, userPassKey = _ref2$notice.userPassKey;
            var mergedKey = userPassKey || key2;
            return mergedKey !== removeKey;
          })
        };
      });
    };
    _this.noticePropsMap = {};
    return _this;
  }
  _createClass$2(Notification2, [{
    key: "getTransitionName",
    value: function getTransitionName3() {
      var _this$props = this.props, prefixCls = _this$props.prefixCls, animation = _this$props.animation;
      var transitionName2 = this.props.transitionName;
      if (!transitionName2 && animation) {
        transitionName2 = "".concat(prefixCls, "-").concat(animation);
      }
      return transitionName2;
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var notices = this.state.notices;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, closeIcon = _this$props2.closeIcon, style2 = _this$props2.style;
      var noticeKeys = [];
      notices.forEach(function(_ref3, index2) {
        var notice2 = _ref3.notice, holderCallback = _ref3.holderCallback;
        var updateMark = index2 === notices.length - 1 ? notice2.updateMark : void 0;
        var key2 = notice2.key, userPassKey = notice2.userPassKey;
        var noticeProps = _objectSpread2$4(_objectSpread2$4(_objectSpread2$4({
          prefixCls,
          closeIcon
        }, notice2), notice2.props), {}, {
          key: key2,
          noticeKey: userPassKey || key2,
          updateMark,
          onClose: function onClose2(noticeKey) {
            var _notice$onClose;
            _this2.remove(noticeKey);
            (_notice$onClose = notice2.onClose) === null || _notice$onClose === void 0 ? void 0 : _notice$onClose.call(notice2);
          },
          onClick: notice2.onClick,
          children: notice2.content
        });
        noticeKeys.push(key2);
        _this2.noticePropsMap[key2] = {
          props: noticeProps,
          holderCallback
        };
      });
      return /* @__PURE__ */ react.exports.createElement("div", {
        className: classnamesExports(prefixCls, className),
        style: style2
      }, /* @__PURE__ */ react.exports.createElement(CSSMotionList, {
        keys: noticeKeys,
        motionName: this.getTransitionName(),
        onVisibleChanged: function onVisibleChanged(changedVisible, _ref4) {
          var key2 = _ref4.key;
          if (!changedVisible) {
            delete _this2.noticePropsMap[key2];
          }
        }
      }, function(_ref5) {
        var key2 = _ref5.key, motionClassName = _ref5.className, motionStyle = _ref5.style, visible = _ref5.visible;
        var _this2$noticePropsMap = _this2.noticePropsMap[key2], noticeProps = _this2$noticePropsMap.props, holderCallback = _this2$noticePropsMap.holderCallback;
        if (holderCallback) {
          return /* @__PURE__ */ react.exports.createElement("div", {
            key: key2,
            className: classnamesExports(motionClassName, "".concat(prefixCls, "-hook-holder")),
            style: _objectSpread2$4({}, motionStyle),
            ref: function ref(div) {
              if (typeof key2 === "undefined") {
                return;
              }
              if (div) {
                _this2.hookRefs.set(key2, div);
                holderCallback(div, noticeProps);
              } else {
                _this2.hookRefs.delete(key2);
              }
            }
          });
        }
        return /* @__PURE__ */ react.exports.createElement(Notice, _extends$2({}, noticeProps, {
          className: classnamesExports(motionClassName, noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.className),
          style: _objectSpread2$4(_objectSpread2$4({}, motionStyle), noticeProps === null || noticeProps === void 0 ? void 0 : noticeProps.style),
          visible
        }));
      }));
    }
  }]);
  return Notification2;
}(react.exports.Component);
Notification.newInstance = void 0;
Notification.defaultProps = {
  prefixCls: "rc-notification",
  animation: "fade",
  style: {
    top: 65,
    left: "50%"
  }
};
Notification.newInstance = function newNotificationInstance(properties, callback) {
  var _ref6 = properties || {}, getContainer2 = _ref6.getContainer, props = _objectWithoutProperties$1(_ref6, _excluded$v);
  var div = document.createElement("div");
  if (getContainer2) {
    var root2 = getContainer2();
    root2.appendChild(div);
  } else {
    document.body.appendChild(div);
  }
  var called = false;
  function ref(notification2) {
    if (called) {
      return;
    }
    called = true;
    callback({
      notice: function notice2(noticeProps) {
        notification2.add(noticeProps);
      },
      removeNotice: function removeNotice(key2) {
        notification2.remove(key2);
      },
      component: notification2,
      destroy: function destroy3() {
        unmount(div);
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
      },
      useNotification: function useNotification$1() {
        return useNotification(notification2);
      }
    });
  }
  render(/* @__PURE__ */ react.exports.createElement(Notification, _extends$2({}, props, {
    ref
  })), div);
};
function createUseMessage(getRcNotificationInstance, getRCNoticeProps2) {
  var useMessage = function useMessage2() {
    var getPrefixCls;
    var getPopupContainer;
    var innerInstance = null;
    var proxy = {
      add: function add(noticeProps, holderCallback) {
        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);
      }
    };
    var _useRCNotification = useNotification(proxy), _useRCNotification2 = _slicedToArray$3(_useRCNotification, 2), hookNotify = _useRCNotification2[0], holder = _useRCNotification2[1];
    function notify(args) {
      var customizePrefixCls = args.prefixCls;
      var mergedPrefixCls = getPrefixCls("message", customizePrefixCls);
      var rootPrefixCls = getPrefixCls();
      var target = args.key || getKeyThenIncreaseKey();
      var closePromise = new Promise(function(resolve) {
        var callback = function callback2() {
          if (typeof args.onClose === "function") {
            args.onClose();
          }
          return resolve(true);
        };
        getRcNotificationInstance(_extends$2(_extends$2({}, args), {
          prefixCls: mergedPrefixCls,
          rootPrefixCls,
          getPopupContainer
        }), function(_ref) {
          var prefixCls = _ref.prefixCls, instance = _ref.instance;
          innerInstance = instance;
          hookNotify(getRCNoticeProps2(_extends$2(_extends$2({}, args), {
            key: target,
            onClose: callback
          }), prefixCls));
        });
      });
      var result = function result2() {
        if (innerInstance) {
          innerInstance.removeNotice(target);
        }
      };
      result.then = function(filled, rejected) {
        return closePromise.then(filled, rejected);
      };
      result.promise = closePromise;
      return result;
    }
    var hookApiRef = react.exports.useRef({});
    hookApiRef.current.open = notify;
    typeList.forEach(function(type4) {
      return attachTypeApi(hookApiRef.current, type4);
    });
    return [hookApiRef.current, /* @__PURE__ */ react.exports.createElement(ConfigConsumer, {
      key: "holder"
    }, function(context2) {
      getPrefixCls = context2.getPrefixCls;
      getPopupContainer = context2.getPopupContainer;
      return holder;
    })];
  };
  return useMessage;
}
var messageInstance;
var defaultDuration$1 = 3;
var defaultTop$1;
var key = 1;
var localPrefixCls = "";
var transitionName = "move-up";
var hasTransitionName = false;
var getContainer;
var maxCount$1;
var rtl$1 = false;
function getKeyThenIncreaseKey() {
  return key++;
}
function setMessageConfig(options) {
  if (options.top !== void 0) {
    defaultTop$1 = options.top;
    messageInstance = null;
  }
  if (options.duration !== void 0) {
    defaultDuration$1 = options.duration;
  }
  if (options.prefixCls !== void 0) {
    localPrefixCls = options.prefixCls;
  }
  if (options.getContainer !== void 0) {
    getContainer = options.getContainer;
    messageInstance = null;
  }
  if (options.transitionName !== void 0) {
    transitionName = options.transitionName;
    messageInstance = null;
    hasTransitionName = true;
  }
  if (options.maxCount !== void 0) {
    maxCount$1 = options.maxCount;
    messageInstance = null;
  }
  if (options.rtl !== void 0) {
    rtl$1 = options.rtl;
  }
}
function getRCNotificationInstance(args, callback) {
  var customizePrefixCls = args.prefixCls, getContextPopupContainer = args.getPopupContainer;
  var _globalConfig = globalConfig(), getPrefixCls = _globalConfig.getPrefixCls, getRootPrefixCls = _globalConfig.getRootPrefixCls, getIconPrefixCls = _globalConfig.getIconPrefixCls;
  var prefixCls = getPrefixCls("message", customizePrefixCls || localPrefixCls);
  var rootPrefixCls = getRootPrefixCls(args.rootPrefixCls, prefixCls);
  var iconPrefixCls = getIconPrefixCls();
  if (messageInstance) {
    callback({
      prefixCls,
      rootPrefixCls,
      iconPrefixCls,
      instance: messageInstance
    });
    return;
  }
  var instanceConfig = {
    prefixCls,
    transitionName: hasTransitionName ? transitionName : "".concat(rootPrefixCls, "-").concat(transitionName),
    style: {
      top: defaultTop$1
    },
    getContainer: getContainer || getContextPopupContainer,
    maxCount: maxCount$1
  };
  Notification.newInstance(instanceConfig, function(instance) {
    if (messageInstance) {
      callback({
        prefixCls,
        rootPrefixCls,
        iconPrefixCls,
        instance: messageInstance
      });
      return;
    }
    messageInstance = instance;
    callback({
      prefixCls,
      rootPrefixCls,
      iconPrefixCls,
      instance
    });
  });
}
var typeToIcon$1 = {
  info: InfoCircleFilled$1,
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  loading: LoadingOutlined$1
};
var typeList = Object.keys(typeToIcon$1);
function getRCNoticeProps$1(args, prefixCls, iconPrefixCls) {
  var _classNames;
  var duration = args.duration !== void 0 ? args.duration : defaultDuration$1;
  var IconComponent = typeToIcon$1[args.type];
  var messageClass = classnamesExports("".concat(prefixCls, "-custom-content"), (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(args.type), args.type), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), rtl$1 === true), _classNames));
  return {
    key: args.key,
    duration,
    style: args.style || {},
    className: args.className,
    content: /* @__PURE__ */ react.exports.createElement(ConfigProvider, {
      iconPrefixCls
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: messageClass
    }, args.icon || IconComponent && /* @__PURE__ */ react.exports.createElement(IconComponent, null), /* @__PURE__ */ react.exports.createElement("span", null, args.content))),
    onClose: args.onClose,
    onClick: args.onClick
  };
}
function notice$1(args) {
  var target = args.key || getKeyThenIncreaseKey();
  var closePromise = new Promise(function(resolve) {
    var callback = function callback2() {
      if (typeof args.onClose === "function") {
        args.onClose();
      }
      return resolve(true);
    };
    getRCNotificationInstance(args, function(_ref) {
      var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, instance = _ref.instance;
      instance.notice(getRCNoticeProps$1(_extends$2(_extends$2({}, args), {
        key: target,
        onClose: callback
      }), prefixCls, iconPrefixCls));
    });
  });
  var result = function result2() {
    if (messageInstance) {
      messageInstance.removeNotice(target);
    }
  };
  result.then = function(filled, rejected) {
    return closePromise.then(filled, rejected);
  };
  result.promise = closePromise;
  return result;
}
function isArgsProps(content2) {
  return Object.prototype.toString.call(content2) === "[object Object]" && !!content2.content;
}
var api$1 = {
  open: notice$1,
  config: setMessageConfig,
  destroy: function destroy(messageKey) {
    if (messageInstance) {
      if (messageKey) {
        var _messageInstance = messageInstance, removeNotice = _messageInstance.removeNotice;
        removeNotice(messageKey);
      } else {
        var _messageInstance2 = messageInstance, destroy3 = _messageInstance2.destroy;
        destroy3();
        messageInstance = null;
      }
    }
  }
};
function attachTypeApi(originalApi, type4) {
  originalApi[type4] = function(content2, duration, onClose2) {
    if (isArgsProps(content2)) {
      return originalApi.open(_extends$2(_extends$2({}, content2), {
        type: type4
      }));
    }
    if (typeof duration === "function") {
      onClose2 = duration;
      duration = void 0;
    }
    return originalApi.open({
      content: content2,
      duration,
      type: type4,
      onClose: onClose2
    });
  };
}
typeList.forEach(function(type4) {
  return attachTypeApi(api$1, type4);
});
api$1.warn = api$1.warning;
api$1.useMessage = createUseMessage(getRCNotificationInstance, getRCNoticeProps$1);
const message = api$1;
var CheckCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "check-circle", "theme": "outlined" };
const CheckCircleOutlinedSvg = CheckCircleOutlined$2;
var CheckCircleOutlined = function CheckCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CheckCircleOutlinedSvg
  }));
};
CheckCircleOutlined.displayName = "CheckCircleOutlined";
const CheckCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CheckCircleOutlined);
var CloseCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M685.4 354.8c0-4.4-3.6-8-8-8l-66 .3L512 465.6l-99.3-118.4-66.1-.3c-4.4 0-8 3.5-8 8 0 1.9.7 3.7 1.9 5.2l130.1 155L340.5 670a8.32 8.32 0 00-1.9 5.2c0 4.4 3.6 8 8 8l66.1-.3L512 564.4l99.3 118.4 66 .3c4.4 0 8-3.5 8-8 0-1.9-.7-3.7-1.9-5.2L553.5 515l130.1-155c1.2-1.4 1.8-3.3 1.8-5.2z" } }, { "tag": "path", "attrs": { "d": "M512 65C264.6 65 64 265.6 64 513s200.6 448 448 448 448-200.6 448-448S759.4 65 512 65zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, "name": "close-circle", "theme": "outlined" };
const CloseCircleOutlinedSvg = CloseCircleOutlined$2;
var CloseCircleOutlined = function CloseCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CloseCircleOutlinedSvg
  }));
};
CloseCircleOutlined.displayName = "CloseCircleOutlined";
const CloseCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CloseCircleOutlined);
var CloseOutlined$7 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
const CloseOutlinedSvg = CloseOutlined$7;
var CloseOutlined$5 = function CloseOutlined(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CloseOutlinedSvg
  }));
};
CloseOutlined$5.displayName = "CloseOutlined";
const CloseOutlined$6 = /* @__PURE__ */ react.exports.forwardRef(CloseOutlined$5);
var ExclamationCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, "name": "exclamation-circle", "theme": "outlined" };
const ExclamationCircleOutlinedSvg = ExclamationCircleOutlined$2;
var ExclamationCircleOutlined = function ExclamationCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: ExclamationCircleOutlinedSvg
  }));
};
ExclamationCircleOutlined.displayName = "ExclamationCircleOutlined";
const ExclamationCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(ExclamationCircleOutlined);
var InfoCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, "name": "info-circle", "theme": "outlined" };
const InfoCircleOutlinedSvg = InfoCircleOutlined$2;
var InfoCircleOutlined = function InfoCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: InfoCircleOutlinedSvg
  }));
};
InfoCircleOutlined.displayName = "InfoCircleOutlined";
const InfoCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(InfoCircleOutlined);
function createUseNotification(getNotificationInstance2, getRCNoticeProps2) {
  var useNotification$1 = function useNotification$12() {
    var getPrefixCls;
    var innerInstance = null;
    var proxy = {
      add: function add(noticeProps, holderCallback) {
        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);
      }
    };
    var _useRCNotification = useNotification(proxy), _useRCNotification2 = _slicedToArray$3(_useRCNotification, 2), hookNotify = _useRCNotification2[0], holder = _useRCNotification2[1];
    function notify(args) {
      var customizePrefixCls = args.prefixCls;
      var mergedPrefixCls = getPrefixCls("notification", customizePrefixCls);
      getNotificationInstance2(_extends$2(_extends$2({}, args), {
        prefixCls: mergedPrefixCls
      }), function(_ref) {
        var prefixCls = _ref.prefixCls, instance = _ref.instance;
        innerInstance = instance;
        hookNotify(getRCNoticeProps2(args, prefixCls));
      });
    }
    var hookApiRef = react.exports.useRef({});
    hookApiRef.current.open = notify;
    ["success", "info", "warning", "error"].forEach(function(type4) {
      hookApiRef.current[type4] = function(args) {
        return hookApiRef.current.open(_extends$2(_extends$2({}, args), {
          type: type4
        }));
      };
    });
    return [hookApiRef.current, /* @__PURE__ */ react.exports.createElement(ConfigConsumer, {
      key: "holder"
    }, function(context2) {
      getPrefixCls = context2.getPrefixCls;
      return holder;
    })];
  };
  return useNotification$1;
}
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve) {
      resolve(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var notificationInstance = {};
var defaultDuration = 4.5;
var defaultTop = 24;
var defaultBottom = 24;
var defaultPrefixCls$1 = "";
var defaultPlacement = "topRight";
var defaultGetContainer;
var defaultCloseIcon;
var rtl = false;
var maxCount;
function setNotificationConfig(options) {
  var duration = options.duration, placement = options.placement, bottom = options.bottom, top = options.top, getContainer2 = options.getContainer, closeIcon = options.closeIcon, prefixCls = options.prefixCls;
  if (prefixCls !== void 0) {
    defaultPrefixCls$1 = prefixCls;
  }
  if (duration !== void 0) {
    defaultDuration = duration;
  }
  if (placement !== void 0) {
    defaultPlacement = placement;
  } else if (options.rtl) {
    defaultPlacement = "topLeft";
  }
  if (bottom !== void 0) {
    defaultBottom = bottom;
  }
  if (top !== void 0) {
    defaultTop = top;
  }
  if (getContainer2 !== void 0) {
    defaultGetContainer = getContainer2;
  }
  if (closeIcon !== void 0) {
    defaultCloseIcon = closeIcon;
  }
  if (options.rtl !== void 0) {
    rtl = options.rtl;
  }
  if (options.maxCount !== void 0) {
    maxCount = options.maxCount;
  }
}
function getPlacementStyle(placement) {
  var top = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultTop;
  var bottom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultBottom;
  var style2;
  switch (placement) {
    case "top":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style2 = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style2 = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style2 = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style2 = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style2;
}
function getNotificationInstance(args, callback) {
  var _args$placement = args.placement, placement = _args$placement === void 0 ? defaultPlacement : _args$placement, top = args.top, bottom = args.bottom, _args$getContainer = args.getContainer, getContainer2 = _args$getContainer === void 0 ? defaultGetContainer : _args$getContainer, customizePrefixCls = args.prefixCls;
  var _globalConfig = globalConfig(), getPrefixCls = _globalConfig.getPrefixCls, getIconPrefixCls = _globalConfig.getIconPrefixCls;
  var prefixCls = getPrefixCls("notification", customizePrefixCls || defaultPrefixCls$1);
  var iconPrefixCls = getIconPrefixCls();
  var cacheKey = "".concat(prefixCls, "-").concat(placement);
  var cacheInstance = notificationInstance[cacheKey];
  if (cacheInstance) {
    Promise.resolve(cacheInstance).then(function(instance) {
      callback({
        prefixCls: "".concat(prefixCls, "-notice"),
        iconPrefixCls,
        instance
      });
    });
    return;
  }
  var notificationClass = classnamesExports("".concat(prefixCls, "-").concat(placement), _defineProperty$5({}, "".concat(prefixCls, "-rtl"), rtl === true));
  notificationInstance[cacheKey] = new Promise(function(resolve) {
    Notification.newInstance({
      prefixCls,
      className: notificationClass,
      style: getPlacementStyle(placement, top, bottom),
      getContainer: getContainer2,
      maxCount
    }, function(notification2) {
      resolve(notification2);
      callback({
        prefixCls: "".concat(prefixCls, "-notice"),
        iconPrefixCls,
        instance: notification2
      });
    });
  });
}
var typeToIcon = {
  success: CheckCircleOutlined$1,
  info: InfoCircleOutlined$1,
  error: CloseCircleOutlined$1,
  warning: ExclamationCircleOutlined$1
};
function getRCNoticeProps(args, prefixCls, iconPrefixCls) {
  var durationArg = args.duration, icon = args.icon, type4 = args.type, description = args.description, message2 = args.message, btn = args.btn, onClose2 = args.onClose, onClick = args.onClick, key2 = args.key, style2 = args.style, className = args.className, _args$closeIcon = args.closeIcon, closeIcon = _args$closeIcon === void 0 ? defaultCloseIcon : _args$closeIcon;
  var duration = durationArg === void 0 ? defaultDuration : durationArg;
  var iconNode = null;
  if (icon) {
    iconNode = /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-icon")
    }, args.icon);
  } else if (type4) {
    iconNode = /* @__PURE__ */ react.exports.createElement(typeToIcon[type4] || null, {
      className: "".concat(prefixCls, "-icon ").concat(prefixCls, "-icon-").concat(type4)
    });
  }
  var closeIconToRender = /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-close-x")
  }, closeIcon || /* @__PURE__ */ react.exports.createElement(CloseOutlined$6, {
    className: "".concat(prefixCls, "-close-icon")
  }));
  var autoMarginTag = !description && iconNode ? /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-message-single-line-auto-margin")
  }) : null;
  return {
    content: /* @__PURE__ */ react.exports.createElement(ConfigProvider, {
      iconPrefixCls
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: iconNode ? "".concat(prefixCls, "-with-icon") : "",
      role: "alert"
    }, iconNode, /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-message")
    }, autoMarginTag, message2), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-description")
    }, description), btn ? /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-btn")
    }, btn) : null)),
    duration,
    closable: true,
    closeIcon: closeIconToRender,
    onClose: onClose2,
    onClick,
    key: key2,
    style: style2 || {},
    className: classnamesExports(className, _defineProperty$5({}, "".concat(prefixCls, "-").concat(type4), !!type4))
  };
}
function notice(args) {
  getNotificationInstance(args, function(_ref) {
    var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, instance = _ref.instance;
    instance.notice(getRCNoticeProps(args, prefixCls, iconPrefixCls));
  });
}
var api = {
  open: notice,
  close: function close(key2) {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      return Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.removeNotice(key2);
      });
    });
  },
  config: setNotificationConfig,
  destroy: function destroy2() {
    Object.keys(notificationInstance).forEach(function(cacheKey) {
      Promise.resolve(notificationInstance[cacheKey]).then(function(instance) {
        instance.destroy();
      });
      delete notificationInstance[cacheKey];
    });
  }
};
["success", "info", "warning", "error"].forEach(function(type4) {
  api[type4] = function(args) {
    return api.open(_extends$2(_extends$2({}, args), {
      type: type4
    }));
  };
});
api.warn = api.warning;
api.useNotification = createUseNotification(getNotificationInstance, getRCNoticeProps);
const notification = api;
var defaultGetPrefixCls = function defaultGetPrefixCls2(suffixCls, customizePrefixCls) {
  if (customizePrefixCls)
    return customizePrefixCls;
  return suffixCls ? "ant-".concat(suffixCls) : "ant";
};
var ConfigContext = /* @__PURE__ */ react.exports.createContext({
  getPrefixCls: defaultGetPrefixCls
});
var ConfigConsumer = ConfigContext.Consumer;
var dynamicStyleMark = "-ant-".concat(Date.now(), "-").concat(Math.random());
function getStyle(globalPrefixCls2, theme) {
  var variables = {};
  var formatColor = function formatColor2(color2, updater) {
    var clone2 = color2.clone();
    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
    return clone2.toRgbString();
  };
  var fillColor = function fillColor2(colorVal, type4) {
    var baseColor = new TinyColor(colorVal);
    var colorPalettes = generate$1(baseColor.toRgbString());
    variables["".concat(type4, "-color")] = formatColor(baseColor);
    variables["".concat(type4, "-color-disabled")] = colorPalettes[1];
    variables["".concat(type4, "-color-hover")] = colorPalettes[4];
    variables["".concat(type4, "-color-active")] = colorPalettes[7];
    variables["".concat(type4, "-color-outline")] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables["".concat(type4, "-color-deprecated-bg")] = colorPalettes[1];
    variables["".concat(type4, "-color-deprecated-border")] = colorPalettes[3];
  };
  if (theme.primaryColor) {
    fillColor(theme.primaryColor, "primary");
    var primaryColor = new TinyColor(theme.primaryColor);
    var primaryColors = generate$1(primaryColor.toRgbString());
    primaryColors.forEach(function(color2, index2) {
      variables["primary-".concat(index2 + 1)] = color2;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(35);
    });
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, function(c2) {
      return c2.lighten(20);
    });
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, function(c2) {
      return c2.tint(20);
    });
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, function(c2) {
      return c2.tint(50);
    });
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.12);
    });
    var primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, function(c2) {
      return c2.setAlpha(c2.getAlpha() * 0.3);
    });
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, function(c2) {
      return c2.darken(2);
    });
  }
  if (theme.successColor) {
    fillColor(theme.successColor, "success");
  }
  if (theme.warningColor) {
    fillColor(theme.warningColor, "warning");
  }
  if (theme.errorColor) {
    fillColor(theme.errorColor, "error");
  }
  if (theme.infoColor) {
    fillColor(theme.infoColor, "info");
  }
  var cssList = Object.keys(variables).map(function(key2) {
    return "--".concat(globalPrefixCls2, "-").concat(key2, ": ").concat(variables[key2], ";");
  });
  return "\n  :root {\n    ".concat(cssList.join("\n"), "\n  }\n  ").trim();
}
function registerTheme(globalPrefixCls2, theme) {
  var style2 = getStyle(globalPrefixCls2, theme);
  if (canUseDom()) {
    updateCSS(style2, "".concat(dynamicStyleMark, "-dynamic-theme"));
  }
}
var DisabledContext = /* @__PURE__ */ react.exports.createContext(false);
var DisabledContextProvider = function DisabledContextProvider2(_ref) {
  var children = _ref.children, disabled = _ref.disabled;
  var originDisabled = react.exports.useContext(DisabledContext);
  return /* @__PURE__ */ react.exports.createElement(DisabledContext.Provider, {
    value: disabled || originDisabled
  }, children);
};
const DisabledContext$1 = DisabledContext;
var SizeContext = /* @__PURE__ */ react.exports.createContext(void 0);
var SizeContextProvider = function SizeContextProvider2(_ref) {
  var children = _ref.children, size = _ref.size;
  return /* @__PURE__ */ react.exports.createElement(SizeContext.Consumer, null, function(originSize) {
    return /* @__PURE__ */ react.exports.createElement(SizeContext.Provider, {
      value: size || originSize
    }, children);
  });
};
const SizeContext$1 = SizeContext;
var PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form"];
var defaultPrefixCls = "ant";
var defaultIconPrefixCls = "anticon";
var globalPrefixCls;
var globalIconPrefixCls;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
var setGlobalConfig = function setGlobalConfig2(_ref) {
  var prefixCls = _ref.prefixCls, iconPrefixCls = _ref.iconPrefixCls, theme = _ref.theme;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if (theme) {
    registerTheme(getGlobalPrefixCls(), theme);
  }
};
var globalConfig = function globalConfig2() {
  return {
    getPrefixCls: function getPrefixCls(suffixCls, customizePrefixCls) {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? "".concat(getGlobalPrefixCls(), "-").concat(suffixCls) : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: function getRootPrefixCls(rootPrefixCls, customizePrefixCls) {
      if (rootPrefixCls) {
        return rootPrefixCls;
      }
      if (globalPrefixCls) {
        return globalPrefixCls;
      }
      if (customizePrefixCls && customizePrefixCls.includes("-")) {
        return customizePrefixCls.replace(/^(.*)-[^-]*$/, "$1");
      }
      return getGlobalPrefixCls();
    }
  };
};
var ProviderChildren = function ProviderChildren2(props) {
  var _a, _b;
  var children = props.children, csp = props.csp, autoInsertSpaceInButton = props.autoInsertSpaceInButton, form2 = props.form, locale2 = props.locale, componentSize = props.componentSize, direction = props.direction, space2 = props.space, virtual2 = props.virtual, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, legacyLocale = props.legacyLocale, parentContext = props.parentContext, iconPrefixCls = props.iconPrefixCls, componentDisabled = props.componentDisabled;
  var getPrefixCls = react.exports.useCallback(function(suffixCls, customizePrefixCls) {
    var prefixCls = props.prefixCls;
    if (customizePrefixCls)
      return customizePrefixCls;
    var mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? "".concat(mergedPrefixCls, "-").concat(suffixCls) : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]);
  var config = _extends$2(_extends$2({}, parentContext), {
    csp,
    autoInsertSpaceInButton,
    locale: locale2 || legacyLocale,
    direction,
    space: space2,
    virtual: virtual2,
    dropdownMatchSelectWidth,
    getPrefixCls
  });
  PASSED_PROPS.forEach(function(propName) {
    var propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  var memoedConfig = useMemo(function() {
    return config;
  }, config, function(prevConfig, currentConfig) {
    var prevKeys = Object.keys(prevConfig);
    var currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some(function(key2) {
      return prevConfig[key2] !== currentConfig[key2];
    });
  });
  var memoIconContextValue = react.exports.useMemo(function() {
    return {
      prefixCls: iconPrefixCls,
      csp
    };
  }, [iconPrefixCls, csp]);
  var childNode = children;
  var validateMessages = {};
  if (locale2) {
    validateMessages = ((_a = locale2.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || ((_b = defaultLocale.Form) === null || _b === void 0 ? void 0 : _b.defaultValidateMessages) || {};
  }
  if (form2 && form2.validateMessages) {
    validateMessages = _extends$2(_extends$2({}, validateMessages), form2.validateMessages);
  }
  if (Object.keys(validateMessages).length > 0) {
    childNode = /* @__PURE__ */ react.exports.createElement(FormProvider$1, {
      validateMessages
    }, children);
  }
  if (locale2) {
    childNode = /* @__PURE__ */ react.exports.createElement(LocaleProvider, {
      locale: locale2,
      _ANT_MARK__: ANT_MARK
    }, childNode);
  }
  if (iconPrefixCls || csp) {
    childNode = /* @__PURE__ */ react.exports.createElement(IconContext$1.Provider, {
      value: memoIconContextValue
    }, childNode);
  }
  if (componentSize) {
    childNode = /* @__PURE__ */ react.exports.createElement(SizeContextProvider, {
      size: componentSize
    }, childNode);
  }
  if (componentDisabled !== void 0) {
    childNode = /* @__PURE__ */ react.exports.createElement(DisabledContextProvider, {
      disabled: componentDisabled
    }, childNode);
  }
  return /* @__PURE__ */ react.exports.createElement(ConfigContext.Provider, {
    value: memoedConfig
  }, childNode);
};
var ConfigProvider = function ConfigProvider2(props) {
  react.exports.useEffect(function() {
    if (props.direction) {
      message.config({
        rtl: props.direction === "rtl"
      });
      notification.config({
        rtl: props.direction === "rtl"
      });
    }
  }, [props.direction]);
  return /* @__PURE__ */ react.exports.createElement(LocaleReceiver, null, function(_, __, legacyLocale) {
    return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, function(context2) {
      return /* @__PURE__ */ react.exports.createElement(ProviderChildren, _extends$2({
        parentContext: context2,
        legacyLocale
      }, props));
    });
  });
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext$1;
ConfigProvider.config = setGlobalConfig;
function throttleByAnimationFrame(fn) {
  var requestId;
  var later = function later2(args) {
    return function() {
      requestId = null;
      fn.apply(void 0, _toConsumableArray(args));
    };
  };
  var throttled = function throttled2() {
    if (requestId == null) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      requestId = wrapperRaf$1(later(args));
    }
  };
  throttled.cancel = function() {
    wrapperRaf$1.cancel(requestId);
    requestId = null;
  };
  return throttled;
}
function throttleByAnimationFrameDecorator() {
  return function throttle2(target, key2, descriptor) {
    var fn = descriptor.value;
    var definingProperty = false;
    return {
      configurable: true,
      get: function get2() {
        if (definingProperty || this === target.prototype || this.hasOwnProperty(key2)) {
          return fn;
        }
        var boundFn = throttleByAnimationFrame(fn.bind(this));
        definingProperty = true;
        Object.defineProperty(this, key2, {
          value: boundFn,
          configurable: true,
          writable: true
        });
        definingProperty = false;
        return boundFn;
      }
    };
  };
}
function addEventListenerWrap(target, eventType, cb2, option) {
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e2) {
    ReactDOM.unstable_batchedUpdates(cb2, e2);
  } : cb2;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
function getTargetRect(target) {
  return target !== window ? target.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function getFixedTop(placeholderReact, targetRect, offsetTop) {
  if (offsetTop !== void 0 && targetRect.top > placeholderReact.top - offsetTop) {
    return offsetTop + targetRect.top;
  }
  return void 0;
}
function getFixedBottom(placeholderReact, targetRect, offsetBottom) {
  if (offsetBottom !== void 0 && targetRect.bottom < placeholderReact.bottom + offsetBottom) {
    var targetBottomOffset = window.innerHeight - targetRect.bottom;
    return offsetBottom + targetBottomOffset;
  }
  return void 0;
}
var TRIGGER_EVENTS = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
var observerEntities = [];
function addObserveTarget(target, affix) {
  if (!target)
    return;
  var entity = observerEntities.find(function(item) {
    return item.target === target;
  });
  if (entity) {
    entity.affixList.push(affix);
  } else {
    entity = {
      target,
      affixList: [affix],
      eventHandlers: {}
    };
    observerEntities.push(entity);
    TRIGGER_EVENTS.forEach(function(eventName) {
      entity.eventHandlers[eventName] = addEventListenerWrap(target, eventName, function() {
        entity.affixList.forEach(function(targetAffix) {
          targetAffix.lazyUpdatePosition();
        });
      });
    });
  }
}
function removeObserveTarget(affix) {
  var observerEntity = observerEntities.find(function(oriObserverEntity) {
    var hasAffix = oriObserverEntity.affixList.some(function(item) {
      return item === affix;
    });
    if (hasAffix) {
      oriObserverEntity.affixList = oriObserverEntity.affixList.filter(function(item) {
        return item !== affix;
      });
    }
    return hasAffix;
  });
  if (observerEntity && observerEntity.affixList.length === 0) {
    observerEntities = observerEntities.filter(function(item) {
      return item !== observerEntity;
    });
    TRIGGER_EVENTS.forEach(function(eventName) {
      var handler2 = observerEntity.eventHandlers[eventName];
      if (handler2 && handler2.remove) {
        handler2.remove();
      }
    });
  }
}
var __decorate = globalThis && globalThis.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if ((typeof Reflect === "undefined" ? "undefined" : _typeof$4(Reflect)) === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--) {
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
    }
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
function getDefaultTarget() {
  return typeof window !== "undefined" ? window : null;
}
var AffixStatus;
(function(AffixStatus2) {
  AffixStatus2[AffixStatus2["None"] = 0] = "None";
  AffixStatus2[AffixStatus2["Prepare"] = 1] = "Prepare";
})(AffixStatus || (AffixStatus = {}));
var Affix = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Affix2, _React$Component);
  var _super = _createSuper$1(Affix2);
  function Affix2() {
    var _this;
    _classCallCheck$2(this, Affix2);
    _this = _super.apply(this, arguments);
    _this.state = {
      status: AffixStatus.None,
      lastAffix: false,
      prevTarget: null
    };
    _this.getOffsetTop = function() {
      var _this$props = _this.props, offsetBottom = _this$props.offsetBottom, offsetTop = _this$props.offsetTop;
      return offsetBottom === void 0 && offsetTop === void 0 ? 0 : offsetTop;
    };
    _this.getOffsetBottom = function() {
      return _this.props.offsetBottom;
    };
    _this.savePlaceholderNode = function(node) {
      _this.placeholderNode = node;
    };
    _this.saveFixedNode = function(node) {
      _this.fixedNode = node;
    };
    _this.measure = function() {
      var _this$state = _this.state, status = _this$state.status, lastAffix = _this$state.lastAffix;
      var onChange2 = _this.props.onChange;
      var targetFunc = _this.getTargetFunc();
      if (status !== AffixStatus.Prepare || !_this.fixedNode || !_this.placeholderNode || !targetFunc) {
        return;
      }
      var offsetTop = _this.getOffsetTop();
      var offsetBottom = _this.getOffsetBottom();
      var targetNode = targetFunc();
      if (!targetNode) {
        return;
      }
      var newState = {
        status: AffixStatus.None
      };
      var targetRect = getTargetRect(targetNode);
      var placeholderReact = getTargetRect(_this.placeholderNode);
      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);
      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);
      if (fixedTop !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          top: fixedTop,
          width: placeholderReact.width,
          height: placeholderReact.height
        };
        newState.placeholderStyle = {
          width: placeholderReact.width,
          height: placeholderReact.height
        };
      } else if (fixedBottom !== void 0) {
        newState.affixStyle = {
          position: "fixed",
          bottom: fixedBottom,
          width: placeholderReact.width,
          height: placeholderReact.height
        };
        newState.placeholderStyle = {
          width: placeholderReact.width,
          height: placeholderReact.height
        };
      }
      newState.lastAffix = !!newState.affixStyle;
      if (onChange2 && lastAffix !== newState.lastAffix) {
        onChange2(newState.lastAffix);
      }
      _this.setState(newState);
    };
    _this.prepareMeasure = function() {
      _this.setState({
        status: AffixStatus.Prepare,
        affixStyle: void 0,
        placeholderStyle: void 0
      });
    };
    return _this;
  }
  _createClass$2(Affix2, [{
    key: "getTargetFunc",
    value: function getTargetFunc() {
      var getTargetContainer = this.context.getTargetContainer;
      var target = this.props.target;
      if (target !== void 0) {
        return target;
      }
      return getTargetContainer || getDefaultTarget;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      var targetFunc = this.getTargetFunc();
      if (targetFunc) {
        this.timeout = setTimeout(function() {
          addObserveTarget(targetFunc(), _this2);
          _this2.updatePosition();
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var prevTarget = this.state.prevTarget;
      var targetFunc = this.getTargetFunc();
      var newTarget = (targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc()) || null;
      if (prevTarget !== newTarget) {
        removeObserveTarget(this);
        if (newTarget) {
          addObserveTarget(newTarget, this);
          this.updatePosition();
        }
        this.setState({
          prevTarget: newTarget
        });
      }
      if (prevProps.offsetTop !== this.props.offsetTop || prevProps.offsetBottom !== this.props.offsetBottom) {
        this.updatePosition();
      }
      this.measure();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      clearTimeout(this.timeout);
      removeObserveTarget(this);
      this.updatePosition.cancel();
      this.lazyUpdatePosition.cancel();
    }
  }, {
    key: "updatePosition",
    value: function updatePosition() {
      this.prepareMeasure();
    }
  }, {
    key: "lazyUpdatePosition",
    value: function lazyUpdatePosition() {
      var targetFunc = this.getTargetFunc();
      var affixStyle = this.state.affixStyle;
      if (targetFunc && affixStyle) {
        var offsetTop = this.getOffsetTop();
        var offsetBottom = this.getOffsetBottom();
        var targetNode = targetFunc();
        if (targetNode && this.placeholderNode) {
          var targetRect = getTargetRect(targetNode);
          var placeholderReact = getTargetRect(this.placeholderNode);
          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop);
          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom);
          if (fixedTop !== void 0 && affixStyle.top === fixedTop || fixedBottom !== void 0 && affixStyle.bottom === fixedBottom) {
            return;
          }
        }
      }
      this.prepareMeasure();
    }
  }, {
    key: "render",
    value: function render2() {
      var _this3 = this;
      var _this$state2 = this.state, affixStyle = _this$state2.affixStyle, placeholderStyle = _this$state2.placeholderStyle;
      var _this$props2 = this.props, affixPrefixCls = _this$props2.affixPrefixCls, children = _this$props2.children;
      var className = classnamesExports(_defineProperty$5({}, affixPrefixCls, !!affixStyle));
      var props = omit(this.props, ["prefixCls", "offsetTop", "offsetBottom", "target", "onChange", "affixPrefixCls"]);
      return /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
        onResize: function onResize2() {
          _this3.updatePosition();
        }
      }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, props, {
        ref: this.savePlaceholderNode
      }), affixStyle && /* @__PURE__ */ react.exports.createElement("div", {
        style: placeholderStyle,
        "aria-hidden": "true"
      }), /* @__PURE__ */ react.exports.createElement("div", {
        className,
        ref: this.saveFixedNode,
        style: affixStyle
      }, /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
        onResize: function onResize2() {
          _this3.updatePosition();
        }
      }, children))));
    }
  }]);
  return Affix2;
}(react.exports.Component);
Affix.contextType = ConfigContext;
__decorate([throttleByAnimationFrameDecorator()], Affix.prototype, "updatePosition", null);
__decorate([throttleByAnimationFrameDecorator()], Affix.prototype, "lazyUpdatePosition", null);
var AffixFC = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var customizePrefixCls = props.prefixCls;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var affixPrefixCls = getPrefixCls("affix", customizePrefixCls);
  var affixProps = _extends$2(_extends$2({}, props), {
    affixPrefixCls
  });
  return /* @__PURE__ */ react.exports.createElement(Affix, _extends$2({}, affixProps, {
    ref
  }));
});
const Affix$1 = AffixFC;
function getDataOrAriaProps(props) {
  return Object.keys(props).reduce(function(prev, key2) {
    if ((key2.startsWith("data-") || key2.startsWith("aria-") || key2 === "role") && !key2.startsWith("data-__")) {
      prev[key2] = props[key2];
    }
    return prev;
  }, {});
}
var isValidElement = react.exports.isValidElement;
function replaceElement(element, replacement, props) {
  if (!isValidElement(element))
    return replacement;
  return /* @__PURE__ */ react.exports.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
}
function cloneElement(element, props) {
  return replaceElement(element, element, props);
}
function isWindow$1(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
function getScroll$1(target, top) {
  var _a, _b;
  if (typeof window === "undefined") {
    return 0;
  }
  var method4 = top ? "scrollTop" : "scrollLeft";
  var result = 0;
  if (isWindow$1(target)) {
    result = target[top ? "pageYOffset" : "pageXOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method4];
  } else if (target instanceof HTMLElement) {
    result = target[method4];
  } else if (target) {
    result = target[method4];
  }
  if (target && !isWindow$1(target) && typeof result !== "number") {
    result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method4];
  }
  return result;
}
function easeInOutCubic(t2, b2, c2, d2) {
  var cc2 = c2 - b2;
  t2 /= d2 / 2;
  if (t2 < 1) {
    return cc2 / 2 * t2 * t2 * t2 + b2;
  }
  return cc2 / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
}
function scrollTo(y2) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _options$getContainer = options.getContainer, getContainer2 = _options$getContainer === void 0 ? function() {
    return window;
  } : _options$getContainer, callback = options.callback, _options$duration = options.duration, duration = _options$duration === void 0 ? 450 : _options$duration;
  var container = getContainer2();
  var scrollTop = getScroll$1(container, true);
  var startTime = Date.now();
  var frameFunc = function frameFunc2() {
    var timestamp = Date.now();
    var time = timestamp - startTime;
    var nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
    if (isWindow$1(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof HTMLDocument || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      wrapperRaf$1(frameFunc2);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  wrapperRaf$1(frameFunc);
}
var AnchorContext = /* @__PURE__ */ react.exports.createContext(null);
const AnchorContext$1 = AnchorContext;
function getDefaultContainer() {
  return window;
}
function getOffsetTop(element, container) {
  if (!element.getClientRects().length) {
    return 0;
  }
  var rect = element.getBoundingClientRect();
  if (rect.width || rect.height) {
    if (container === window) {
      container = element.ownerDocument.documentElement;
      return rect.top - container.clientTop;
    }
    return rect.top - container.getBoundingClientRect().top;
  }
  return rect.top;
}
var sharpMatcherRegx = /#([\S ]+)$/;
var Anchor$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Anchor2, _React$Component);
  var _super = _createSuper$1(Anchor2);
  function Anchor2() {
    var _this;
    _classCallCheck$2(this, Anchor2);
    _this = _super.apply(this, arguments);
    _this.state = {
      activeLink: null
    };
    _this.wrapperRef = /* @__PURE__ */ react.exports.createRef();
    _this.links = [];
    _this.registerLink = function(link) {
      if (!_this.links.includes(link)) {
        _this.links.push(link);
      }
    };
    _this.unregisterLink = function(link) {
      var index2 = _this.links.indexOf(link);
      if (index2 !== -1) {
        _this.links.splice(index2, 1);
      }
    };
    _this.getContainer = function() {
      var getTargetContainer = _this.context.getTargetContainer;
      var getContainer2 = _this.props.getContainer;
      var getFunc = getContainer2 || getTargetContainer || getDefaultContainer;
      return getFunc();
    };
    _this.handleScrollTo = function(link) {
      var _this$props = _this.props, offsetTop = _this$props.offsetTop, targetOffset2 = _this$props.targetOffset;
      _this.setCurrentActiveLink(link);
      var container = _this.getContainer();
      var scrollTop = getScroll$1(container, true);
      var sharpLinkMatch = sharpMatcherRegx.exec(link);
      if (!sharpLinkMatch) {
        return;
      }
      var targetElement = document.getElementById(sharpLinkMatch[1]);
      if (!targetElement) {
        return;
      }
      var eleOffsetTop = getOffsetTop(targetElement, container);
      var y2 = scrollTop + eleOffsetTop;
      y2 -= targetOffset2 !== void 0 ? targetOffset2 : offsetTop || 0;
      _this.animating = true;
      scrollTo(y2, {
        callback: function callback() {
          _this.animating = false;
        },
        getContainer: _this.getContainer
      });
    };
    _this.saveInkNode = function(node) {
      _this.inkNode = node;
    };
    _this.setCurrentActiveLink = function(link) {
      var activeLink = _this.state.activeLink;
      var _this$props2 = _this.props, onChange2 = _this$props2.onChange, getCurrentAnchor = _this$props2.getCurrentAnchor;
      if (activeLink === link) {
        return;
      }
      _this.setState({
        activeLink: typeof getCurrentAnchor === "function" ? getCurrentAnchor(link) : link
      });
      onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(link);
    };
    _this.handleScroll = function() {
      if (_this.animating) {
        return;
      }
      var _this$props3 = _this.props, offsetTop = _this$props3.offsetTop, bounds = _this$props3.bounds, targetOffset2 = _this$props3.targetOffset;
      var currentActiveLink = _this.getCurrentAnchor(targetOffset2 !== void 0 ? targetOffset2 : offsetTop || 0, bounds);
      _this.setCurrentActiveLink(currentActiveLink);
    };
    _this.updateInk = function() {
      var _assertThisInitialize = _assertThisInitialized$1(_this), prefixCls = _assertThisInitialize.prefixCls, wrapperRef = _assertThisInitialize.wrapperRef;
      var anchorNode = wrapperRef.current;
      var linkNode = anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.getElementsByClassName("".concat(prefixCls, "-link-title-active"))[0];
      if (linkNode) {
        _this.inkNode.style.top = "".concat(linkNode.offsetTop + linkNode.clientHeight / 2 - 4.5, "px");
      }
    };
    _this.getMemoizedContextValue = memoizeOne(function(link, onClickFn) {
      return {
        registerLink: _this.registerLink,
        unregisterLink: _this.unregisterLink,
        scrollTo: _this.handleScrollTo,
        activeLink: link,
        onClick: onClickFn
      };
    });
    return _this;
  }
  _createClass$2(Anchor2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollContainer = this.getContainer();
      this.scrollEvent = addEventListenerWrap(this.scrollContainer, "scroll", this.handleScroll);
      this.handleScroll();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.scrollEvent) {
        var currentContainer = this.getContainer();
        if (this.scrollContainer !== currentContainer) {
          this.scrollContainer = currentContainer;
          this.scrollEvent.remove();
          this.scrollEvent = addEventListenerWrap(this.scrollContainer, "scroll", this.handleScroll);
          this.handleScroll();
        }
      }
      this.updateInk();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.scrollEvent) {
        this.scrollEvent.remove();
      }
    }
  }, {
    key: "getCurrentAnchor",
    value: function getCurrentAnchor() {
      var offsetTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var bounds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
      var linkSections = [];
      var container = this.getContainer();
      this.links.forEach(function(link) {
        var sharpLinkMatch = sharpMatcherRegx.exec(link.toString());
        if (!sharpLinkMatch) {
          return;
        }
        var target = document.getElementById(sharpLinkMatch[1]);
        if (target) {
          var top = getOffsetTop(target, container);
          if (top < offsetTop + bounds) {
            linkSections.push({
              link,
              top
            });
          }
        }
      });
      if (linkSections.length) {
        var maxSection = linkSections.reduce(function(prev, curr) {
          return curr.top > prev.top ? curr : prev;
        });
        return maxSection.link;
      }
      return "";
    }
  }, {
    key: "render",
    value: function render2() {
      var direction = this.context.direction;
      var _this$props4 = this.props, prefixCls = _this$props4.anchorPrefixCls, _this$props4$classNam = _this$props4.className, className = _this$props4$classNam === void 0 ? "" : _this$props4$classNam, style2 = _this$props4.style, offsetTop = _this$props4.offsetTop, affix = _this$props4.affix, showInkInFixed = _this$props4.showInkInFixed, children = _this$props4.children, onClick = _this$props4.onClick;
      var activeLink = this.state.activeLink;
      this.prefixCls = prefixCls;
      var inkClass = classnamesExports("".concat(prefixCls, "-ink-ball"), {
        visible: activeLink
      });
      var wrapperClass = classnamesExports("".concat(prefixCls, "-wrapper"), _defineProperty$5({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), className);
      var anchorClass = classnamesExports(prefixCls, _defineProperty$5({}, "".concat(prefixCls, "-fixed"), !affix && !showInkInFixed));
      var wrapperStyle = _extends$2({
        maxHeight: offsetTop ? "calc(100vh - ".concat(offsetTop, "px)") : "100vh"
      }, style2);
      var anchorContent = /* @__PURE__ */ react.exports.createElement("div", {
        ref: this.wrapperRef,
        className: wrapperClass,
        style: wrapperStyle
      }, /* @__PURE__ */ react.exports.createElement("div", {
        className: anchorClass
      }, /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(prefixCls, "-ink")
      }, /* @__PURE__ */ react.exports.createElement("span", {
        className: inkClass,
        ref: this.saveInkNode
      })), children));
      var contextValue = this.getMemoizedContextValue(activeLink, onClick);
      return /* @__PURE__ */ react.exports.createElement(AnchorContext$1.Provider, {
        value: contextValue
      }, !affix ? anchorContent : /* @__PURE__ */ react.exports.createElement(Affix$1, {
        offsetTop,
        target: this.getContainer
      }, anchorContent));
    }
  }]);
  return Anchor2;
}(react.exports.Component);
Anchor$2.defaultProps = {
  affix: true,
  showInkInFixed: false
};
Anchor$2.contextType = ConfigContext;
var AnchorFC = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var customizePrefixCls = props.prefixCls;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var anchorPrefixCls = getPrefixCls("anchor", customizePrefixCls);
  var anchorProps = _extends$2(_extends$2({}, props), {
    anchorPrefixCls
  });
  return /* @__PURE__ */ react.exports.createElement(Anchor$2, _extends$2({}, anchorProps, {
    ref
  }));
});
const InternalAnchor = AnchorFC;
var AnchorLink = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(AnchorLink2, _React$Component);
  var _super = _createSuper$1(AnchorLink2);
  function AnchorLink2() {
    var _this;
    _classCallCheck$2(this, AnchorLink2);
    _this = _super.apply(this, arguments);
    _this.handleClick = function(e2) {
      var _this$context = _this.context, scrollTo2 = _this$context.scrollTo, onClick = _this$context.onClick;
      var _this$props = _this.props, href = _this$props.href, title = _this$props.title;
      onClick === null || onClick === void 0 ? void 0 : onClick(e2, {
        title,
        href
      });
      scrollTo2(href);
    };
    _this.renderAnchorLink = function(_ref) {
      var getPrefixCls = _ref.getPrefixCls;
      var _this$props2 = _this.props, customizePrefixCls = _this$props2.prefixCls, href = _this$props2.href, title = _this$props2.title, children = _this$props2.children, className = _this$props2.className, target = _this$props2.target;
      var prefixCls = getPrefixCls("anchor", customizePrefixCls);
      var active = _this.context.activeLink === href;
      var wrapperClassName = classnamesExports("".concat(prefixCls, "-link"), _defineProperty$5({}, "".concat(prefixCls, "-link-active"), active), className);
      var titleClassName = classnamesExports("".concat(prefixCls, "-link-title"), _defineProperty$5({}, "".concat(prefixCls, "-link-title-active"), active));
      return /* @__PURE__ */ react.exports.createElement("div", {
        className: wrapperClassName
      }, /* @__PURE__ */ react.exports.createElement("a", {
        className: titleClassName,
        href,
        title: typeof title === "string" ? title : "",
        target,
        onClick: _this.handleClick
      }, title), children);
    };
    return _this;
  }
  _createClass$2(AnchorLink2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.context.registerLink(this.props.href);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(_ref2) {
      var prevHref = _ref2.href;
      var href = this.props.href;
      if (prevHref !== href) {
        this.context.unregisterLink(prevHref);
        this.context.registerLink(href);
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.context.unregisterLink(this.props.href);
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, this.renderAnchorLink);
    }
  }]);
  return AnchorLink2;
}(react.exports.Component);
AnchorLink.defaultProps = {
  href: "#"
};
AnchorLink.contextType = AnchorContext$1;
const AnchorLink$1 = AnchorLink;
var Anchor = InternalAnchor;
Anchor.Link = AnchorLink$1;
const Anchor$1 = Anchor;
function useEvent(callback) {
  var fnRef = react.exports.useRef();
  fnRef.current = callback;
  var memoFn = react.exports.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var useLayoutEffect$1 = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
  var firstMountRef = react.exports.useRef(true);
  useLayoutEffect$1(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect$1(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
var Source;
(function(Source2) {
  Source2[Source2["INNER"] = 0] = "INNER";
  Source2[Source2["PROP"] = 1] = "PROP";
})(Source || (Source = {}));
function hasValue(value2) {
  return value2 !== void 0;
}
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, value2 = _ref.value, onChange2 = _ref.onChange, postState = _ref.postState;
  var _useState = useSafeState(function() {
    var finalValue = void 0;
    var source;
    if (hasValue(value2)) {
      finalValue = value2;
      source = Source.PROP;
    } else if (hasValue(defaultValue)) {
      finalValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      source = Source.PROP;
    } else {
      finalValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      source = Source.INNER;
    }
    return [finalValue, source, finalValue];
  }), _useState2 = _slicedToArray$3(_useState, 2), mergedValue = _useState2[0], setMergedValue = _useState2[1];
  var chosenValue = hasValue(value2) ? value2 : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  useLayoutUpdateEffect(function() {
    setMergedValue(function(_ref2) {
      var _ref3 = _slicedToArray$3(_ref2, 1), prevValue = _ref3[0];
      return [value2, Source.PROP, prevValue];
    });
  }, [value2]);
  var changeEventPrevRef = react.exports.useRef();
  var triggerChange = useEvent(function(updater, ignoreDestroy) {
    setMergedValue(function(prev) {
      var _prev = _slicedToArray$3(prev, 3), prevValue = _prev[0], prevSource = _prev[1], prevPrevValue = _prev[2];
      var nextValue = typeof updater === "function" ? updater(prevValue) : updater;
      if (nextValue === prevValue) {
        return prev;
      }
      var overridePrevValue = prevSource === Source.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source.INNER, overridePrevValue];
    }, ignoreDestroy);
  });
  var onChangeFn = useEvent(onChange2);
  useLayoutEffect$1(function() {
    var _mergedValue = _slicedToArray$3(mergedValue, 3), current = _mergedValue[0], source = _mergedValue[1], prev = _mergedValue[2];
    if (current !== prev && source === Source.INNER) {
      onChangeFn(current, prev);
      changeEventPrevRef.current = prev;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}
var KeyCode = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
const isMobile = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4))) {
    return true;
  }
  return false;
};
function getKey$1(data2, index2) {
  var key2 = data2.key;
  var value2;
  if ("value" in data2) {
    value2 = data2.value;
  }
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  if (value2 !== void 0) {
    return value2;
  }
  return "rc-index-key-".concat(index2);
}
function fillFieldNames$1(fieldNames, childrenAsData) {
  var _ref = fieldNames || {}, label = _ref.label, value2 = _ref.value, options = _ref.options;
  return {
    label: label || (childrenAsData ? "children" : "label"),
    value: value2 || "value",
    options: options || "options"
  };
}
function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fieldNames = _ref2.fieldNames, childrenAsData = _ref2.childrenAsData;
  var flattenList = [];
  var _fillFieldNames = fillFieldNames$1(fieldNames, false), fieldLabel = _fillFieldNames.label, fieldValue = _fillFieldNames.value, fieldOptions = _fillFieldNames.options;
  function dig(list2, isGroupOption) {
    list2.forEach(function(data2) {
      var label = data2[fieldLabel];
      if (isGroupOption || !(fieldOptions in data2)) {
        var value2 = data2[fieldValue];
        flattenList.push({
          key: getKey$1(data2, flattenList.length),
          groupOption: isGroupOption,
          data: data2,
          label,
          value: value2
        });
      } else {
        var grpLabel = label;
        if (grpLabel === void 0 && childrenAsData) {
          grpLabel = data2.label;
        }
        flattenList.push({
          key: getKey$1(data2, flattenList.length),
          group: true,
          data: data2,
          label: grpLabel
        });
        dig(data2[fieldOptions], true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}
function injectPropsWithOption(option) {
  var newOption = _objectSpread2$4({}, option);
  if (!("props" in newOption)) {
    Object.defineProperty(newOption, "props", {
      get: function get2() {
        warningOnce(false, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`.");
        return newOption;
      }
    });
  }
  return newOption;
}
function getSeparatedContent(text2, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }
  var match2 = false;
  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3), token = _ref4[0], restTokens = _ref4.slice(1);
    if (!token) {
      return [str];
    }
    var list3 = str.split(token);
    match2 = match2 || list3.length > 1;
    return list3.reduce(function(prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function(unit) {
      return unit;
    });
  }
  var list2 = separate(text2, tokens);
  return match2 ? list2 : null;
}
function contains(root2, n2) {
  if (!root2) {
    return false;
  }
  return root2.contains(n2);
}
var Portal = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;
  var parentRef = react.exports.useRef();
  var containerRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {};
  });
  var initRef = react.exports.useRef(false);
  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer2();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  react.exports.useEffect(function() {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  react.exports.useEffect(function() {
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function() {
      var _containerRef$current, _containerRef$current2;
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /* @__PURE__ */ ReactDOM.createPortal(children, containerRef.current) : null;
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$4(_objectSpread2$4({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i = 0; i < placements2.length; i += 1) {
    var placement = placements2[i];
    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
function getMotion$1(_ref) {
  var prefixCls = _ref.prefixCls, motion = _ref.motion, animation = _ref.animation, transitionName2 = _ref.transitionName;
  if (motion) {
    return motion;
  }
  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName2) {
    return {
      motionName: transitionName2
    };
  }
  return null;
}
function Mask(props) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion = {};
  if (maskMotion || maskTransitionName || maskAnimation) {
    motion = _objectSpread2$4({
      motionAppear: true
    }, getMotion$1({
      motion: maskMotion,
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({}, motion, {
    visible,
    removeOnLeave: true
  }), function(_ref) {
    var className = _ref.className;
    return /* @__PURE__ */ react.exports.createElement("div", {
      style: {
        zIndex
      },
      className: classnamesExports("".concat(prefixCls, "-mask"), className)
    });
  });
}
const isVisible = function(element) {
  if (!element) {
    return false;
  }
  if (element.offsetParent) {
    return true;
  }
  if (element.getBBox) {
    var box = element.getBBox();
    if (box.width || box.height) {
      return true;
    }
  }
  if (element.getBoundingClientRect) {
    var _box = element.getBoundingClientRect();
    if (_box.width || _box.height) {
      return true;
    }
  }
  return false;
};
function ownKeys$2(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    if (enumerableOnly) {
      symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread2$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key2) {
        _defineProperty$4(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _defineProperty$4(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style2 = document.createElement("p").style;
  var testProp = "Transform";
  for (var key2 in jsCssMap) {
    if (key2 + testProp in style2) {
      vendorPrefix = key2;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node, value2) {
  var name2 = getTransitionName$1();
  if (name2) {
    node.style[name2] = value2;
    if (name2 !== "transitionProperty") {
      node.style.transitionProperty = value2;
    }
  }
}
function setTransform(node, value2) {
  var name2 = getTransformName();
  if (name2) {
    node.style[name2] = value2;
    if (name2 !== "transform") {
      node.style.transform = value2;
    }
  }
}
function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName$1()];
}
function getTransformXY(node) {
  var style2 = window.getComputedStyle(node, null);
  var transform = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style2 = window.getComputedStyle(node, null);
  var transform = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(","), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(","), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el2, name2, v2) {
  var value2 = v2;
  if (_typeof$3(name2) === "object") {
    for (var i in name2) {
      if (name2.hasOwnProperty(i)) {
        css(el2, i, name2[i]);
      }
    }
    return void 0;
  }
  if (typeof value2 !== "undefined") {
    if (typeof value2 === "number") {
      value2 = "".concat(value2, "px");
    }
    el2.style[name2] = value2;
    return void 0;
  }
  return getComputedStyleX(el2, name2);
}
function getClientPosition(elem) {
  var box;
  var x2;
  var y2;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  box = elem.getBoundingClientRect();
  x2 = Math.floor(box.left);
  y2 = Math.floor(box.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll(w2);
}
function getScrollTop(w2) {
  return getScroll(w2, true);
}
function getOffset$2(el2) {
  var pos = getClientPosition(el2);
  var doc = el2.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w2);
  pos.top += getScrollTop(w2);
  return pos;
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }
  if (node.nodeType === 9) {
    return node;
  }
  return node.ownerDocument;
}
function _getComputedStyle(elem, name2, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name2) || computedStyle[name2];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT$1 = "left";
var PX = "px";
function _getComputedStyleIE(elem, name2) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name2];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name2)) {
    var style2 = elem.style;
    var left = style2[LEFT$1];
    var rsLeft = elem[RUNTIME_STYLE][LEFT$1];
    elem[RUNTIME_STYLE][LEFT$1] = elem[CURRENT_STYLE][LEFT$1];
    style2[LEFT$1] = name2 === "fontSize" ? "1em" : ret || 0;
    ret = style2.pixelLeft + PX;
    style2[LEFT$1] = left;
    elem[RUNTIME_STYLE][LEFT$1] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset3, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$2(elem);
  if ("left" in offset3 || "top" in offset3) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset3) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset3) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$2(elem);
  var originalStyle = {};
  for (var key2 in offset3) {
    if (offset3.hasOwnProperty(key2)) {
      var dir = getOffsetDirection(key2, option);
      var preset = key2 === "left" ? presetH : presetV;
      var off = originalOffset[key2] - old[key2];
      if (dir === key2) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset3 || "top" in offset3) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset3) {
    if (offset3.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset3[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset3) {
  var originalOffset = getOffset$2(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset3) {
    resultXY.x = originalXY.x + offset3.left - originalOffset.left;
  }
  if ("top" in offset3) {
    resultXY.y = originalXY.y + offset3.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset3, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$2(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset3.left.toFixed(0);
    var tTop = offset3.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset3, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset3);
  } else {
    setLeftTop(elem, offset3, option);
  }
}
function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style2 = elem.style;
  var name2;
  for (name2 in options) {
    if (options.hasOwnProperty(name2)) {
      old[name2] = style2[name2];
      style2[name2] = options[name2];
    }
  }
  callback.call(elem);
  for (name2 in options) {
    if (options.hasOwnProperty(name2)) {
      style2[name2] = old[name2];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value2 = 0;
  var prop;
  var j;
  var i;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }
        value2 += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value2;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each(["Width", "Height"], function(name2) {
  domUtils["doc".concat(name2)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(d2.documentElement["scroll".concat(name2)], d2.body["scroll".concat(name2)], domUtils["viewport".concat(name2)](d2));
  };
  domUtils["viewport".concat(name2)] = function(win) {
    var prop = "client".concat(name2);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name2, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name2 === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name2 === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name2 === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name2);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name2] || 0;
    }
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args);
  } else {
    swap(elem, cssShow, function() {
      val = getWH.apply(void 0, args);
    });
  }
  return val;
}
each(["width", "height"], function(name2) {
  var first = name2.charAt(0).toUpperCase() + name2.slice(1);
  domUtils["outer".concat(first)] = function(el2, includeMargin) {
    return el2 && getWHIgnoreDisplay(el2, name2, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name2] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name2, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name2, CONTENT_INDEX);
  };
});
function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}
var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument,
  offset: function offset(el2, value2, option) {
    if (typeof value2 !== "undefined") {
      setOffset(el2, value2, option || {});
    } else {
      return getOffset$2(el2);
    }
  },
  isWindow,
  each,
  css,
  clone: function clone(obj) {
    var i;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },
  mix,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge2() {
    var ret = {};
    for (var i = 0; i < arguments.length; i++) {
      utils.mix(ret, i < 0 || arguments.length <= i ? void 0 : arguments[i]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix(utils, domUtils);
var getParent2 = utils.getParent;
function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === "html" ? null : getParent2(element);
  }
  for (parent = getParent2(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent2(parent)) {
    positionStyle = utils.css(parent, "position");
    if (positionStyle !== "static") {
      return parent;
    }
  }
  return null;
}
var getParent$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1(element); parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils.css(parent, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el2 = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;
  while (el2) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el2.clientWidth !== 0) && el2 !== body && el2 !== documentElement && utils.css(el2, "overflow") !== "visible") {
      var pos = utils.offset(el2);
      pos.left += el2.clientLeft;
      pos.top += el2.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right, pos.left + el2.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el2.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el2 === body || el2 === documentElement) {
      break;
    }
    el2 = getOffsetParent(el2);
  }
  var originalPosition = null;
  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position2 = utils.css(element, "position");
    if (position2 === "absolute") {
      element.style.position = "fixed";
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils.mix(pos, size);
}
function getRegion(node) {
  var offset3;
  var w2;
  var h2;
  if (!utils.isWindow(node) && node.nodeType !== 9) {
    offset3 = utils.offset(node);
    w2 = utils.outerWidth(node);
    h2 = utils.outerHeight(node);
  } else {
    var win = utils.getWindow(node);
    offset3 = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w2 = utils.viewportWidth(win);
    h2 = utils.viewportHeight(win);
  }
  offset3.width = w2;
  offset3.height = h2;
  return offset3;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H2 = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H2 === "c") {
    x2 += w2 / 2;
  } else if (H2 === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points, offset3, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset3[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff[1] + offset3[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg2, map) {
  var ret = [];
  utils.each(points, function(p2) {
    ret.push(p2.replace(reg2, function(m2) {
      return map[m2];
    }));
  });
  return ret;
}
function flipOffset(offset3, index2) {
  offset3[index2] = -offset3[index2];
  return offset3;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset3, el2) {
  offset3[0] = convertOffset(offset3[0], el2.width);
  offset3[1] = convertOffset(offset3[1], el2.height);
}
function doAlign(el2, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset3 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el2;
  offset3 = [].concat(offset3);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail2 = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  var elRegion = getRegion(source);
  normalizeOffset(offset3, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
  var newElRegion = utils.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset3, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail2 = 1;
          points = newPoints;
          offset3 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset3, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail2 = 1;
          points = _newPoints;
          offset3 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail2) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset3, targetOffset2);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points = _newPoints2;
      offset3 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
  }
  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points,
    offset: offset3,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el2, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el2, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el2, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el2);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points = [align.points[0], "cc"];
  return doAlign(el2, tgtRegion, _objectSpread2$3(_objectSpread2$3({}, align), {}, {
    points
  }), pointInView);
}
function isSamePoint(prev, next) {
  if (prev === next)
    return true;
  if (!prev || !next)
    return false;
  if ("pageX" in next && "pageY" in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }
  if ("clientX" in next && "clientY" in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;
  function onResize2(_ref) {
    var _ref2 = _slicedToArray$3(_ref, 1), target = _ref2[0].target;
    if (!document.documentElement.contains(target))
      return;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(function() {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  var resizeObserver2 = new index$3(onResize2);
  if (element) {
    resizeObserver2.observe(element);
  }
  return function() {
    resizeObserver2.disconnect();
  };
}
const useBuffer = function(callback, buffer2) {
  var calledRef = React$a.useRef(false);
  var timeoutRef = React$a.useRef(null);
  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }
  function trigger3(force) {
    cancelTrigger();
    if (!calledRef.current || force === true) {
      if (callback() === false) {
        return;
      }
      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
      }, buffer2);
    } else {
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
        trigger3();
      }, buffer2);
    }
  }
  return [trigger3, function() {
    calledRef.current = false;
    cancelTrigger();
  }];
};
function getElement(func) {
  if (typeof func !== "function")
    return null;
  return func();
}
function getPoint(point2) {
  if (_typeof$4(point2) !== "object" || !point2)
    return null;
  return point2;
}
var Align = function Align2(_ref, ref) {
  var children = _ref.children, disabled = _ref.disabled, target = _ref.target, align = _ref.align, onAlign = _ref.onAlign, monitorWindowResize = _ref.monitorWindowResize, _ref$monitorBufferTim = _ref.monitorBufferTime, monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = React$a.useRef({});
  var nodeRef = React$a.useRef();
  var childNode = React$a.Children.only(children);
  var forceAlignPropsRef = React$a.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;
  var _useBuffer = useBuffer(function() {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current, latestDisabled = _forceAlignPropsRef$c.disabled, latestTarget = _forceAlignPropsRef$c.target, latestAlign = _forceAlignPropsRef$c.align, latestOnAlign = _forceAlignPropsRef$c.onAlign;
    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element = getElement(latestTarget);
      var point2 = getPoint(latestTarget);
      cacheRef.current.element = element;
      cacheRef.current.point = point2;
      cacheRef.current.align = latestAlign;
      var _document = document, activeElement = _document.activeElement;
      if (element && isVisible(element)) {
        result = alignElement(source, element, latestAlign);
      } else if (point2) {
        result = alignPoint(source, point2, latestAlign);
      }
      restoreFocus(activeElement, source);
      if (latestOnAlign && result) {
        latestOnAlign(source, result);
      }
      return true;
    }
    return false;
  }, monitorBufferTime), _useBuffer2 = _slicedToArray$3(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
  var resizeMonitor = React$a.useRef({
    cancel: function cancel2() {
    }
  });
  var sourceResizeMonitor = React$a.useRef({
    cancel: function cancel2() {
    }
  });
  React$a.useEffect(function() {
    var element = getElement(target);
    var point2 = getPoint(target);
    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }
    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point2) || !isEqual_1(cacheRef.current.align, align)) {
      _forceAlign();
      if (resizeMonitor.current.element !== element) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element;
        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);
      }
    }
  });
  React$a.useEffect(function() {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]);
  var winResizeRef = React$a.useRef(null);
  React$a.useEffect(function() {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = addEventListenerWrap(window, "resize", _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]);
  React$a.useEffect(function() {
    return function() {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current)
        winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []);
  React$a.useImperativeHandle(ref, function() {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  });
  if (/* @__PURE__ */ React$a.isValidElement(childNode)) {
    childNode = /* @__PURE__ */ React$a.cloneElement(childNode, {
      ref: composeRef(childNode.ref, nodeRef)
    });
  }
  return childNode;
};
var RcAlign = /* @__PURE__ */ React$a.forwardRef(Align);
RcAlign.displayName = "Align";
var StatusQueue = ["measure", "alignPre", "align", null, "motion"];
const useVisibleStatus = function(visible, doMeasure) {
  var _useState = useSafeState(null), _useState2 = _slicedToArray$3(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];
  var rafRef = react.exports.useRef();
  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }
  function cancelRaf() {
    wrapperRaf$1.cancel(rafRef.current);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf$1(function() {
      setStatus(function(prev) {
        switch (status) {
          case "align":
            return "motion";
          case "motion":
            return "stable";
        }
        return prev;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  react.exports.useEffect(function() {
    setStatus("measure");
  }, [visible]);
  react.exports.useEffect(function() {
    switch (status) {
      case "measure":
        doMeasure();
        break;
    }
    if (status) {
      rafRef.current = wrapperRaf$1(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var index2, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index2 = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index2 + 1];
                if (nextStatus && index2 !== -1) {
                  setStatus(nextStatus);
                }
              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  react.exports.useEffect(function() {
    return function() {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
};
const useStretchStyle = function(stretch) {
  var _React$useState = react.exports.useState({
    width: 0,
    height: 0
  }), _React$useState2 = _slicedToArray$3(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];
  function measureStretch(element) {
    setTargetSize({
      width: element.offsetWidth,
      height: element.offsetHeight
    });
  }
  var style2 = react.exports.useMemo(function() {
    var sizeStyle = {};
    if (stretch) {
      var width = targetSize.width, height = targetSize.height;
      if (stretch.indexOf("height") !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = height;
      }
      if (stretch.indexOf("width") !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }
    return sizeStyle;
  }, [stretch, targetSize]);
  return [style2, measureStretch];
};
var PopupInner = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point2 = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart, onClick = props.onClick;
  var alignRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var _useState = react.exports.useState(), _useState2 = _slicedToArray$3(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];
  var _useStretchStyle = useStretchStyle(stretch), _useStretchStyle2 = _slicedToArray$3(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  }
  var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray$3(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
  var _useState3 = react.exports.useState(0), _useState4 = _slicedToArray$3(_useState3, 2), alignTimes = _useState4[0], setAlignTimes = _useState4[1];
  var prepareResolveRef = react.exports.useRef();
  useLayoutEffect$1(function() {
    if (status === "alignPre") {
      setAlignTimes(0);
    }
  }, [status]);
  function getAlignTarget() {
    if (point2) {
      return point2;
    }
    return getRootDomNode;
  }
  function forceAlign() {
    var _alignRef$current;
    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }
  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);
    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    }
    setAlignTimes(function(val) {
      return val + 1;
    });
    if (status === "align") {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  }
  useLayoutEffect$1(function() {
    if (status === "align") {
      if (alignTimes < 2) {
        forceAlign();
      } else {
        goNextStatus(function() {
          var _prepareResolveRef$cu;
          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]);
  var motion = _objectSpread2$4({}, getMotion$1(props));
  ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(eventName) {
    var originHandler = motion[eventName];
    motion[eventName] = function(element, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
    };
  });
  function onShowPrepare() {
    return new Promise(function(resolve) {
      prepareResolveRef.current = resolve;
    });
  }
  react.exports.useEffect(function() {
    if (!motion.motionName && status === "motion") {
      goNextStatus();
    }
  }, [motion.motionName, status]);
  react.exports.useImperativeHandle(ref, function() {
    return {
      forceAlign,
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$4(_objectSpread2$4({}, stretchStyle), {}, {
    zIndex,
    opacity: status === "motion" || status === "stable" || !visible ? void 0 : 0,
    pointerEvents: !visible && status !== "stable" ? "none" : void 0
  }, style2);
  var alignDisabled = true;
  if ((align === null || align === void 0 ? void 0 : align.points) && (status === "align" || status === "stable")) {
    alignDisabled = false;
  }
  var childNode = children;
  if (react.exports.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
    visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }, motion, {
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender
  }), function(_ref, motionRef) {
    var motionClassName = _ref.className, motionStyle = _ref.style;
    var mergedClassName = classnamesExports(prefixCls, className, alignedClassName, motionClassName);
    return /* @__PURE__ */ react.exports.createElement(RcAlign, {
      target: getAlignTarget(),
      key: "popup",
      ref: alignRef,
      monitorWindowResize: true,
      disabled: alignDisabled,
      align,
      onAlign: onInternalAlign
    }, /* @__PURE__ */ react.exports.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onMouseEnter,
      onMouseLeave,
      onMouseDownCapture: onMouseDown,
      onTouchStartCapture: onTouchStart,
      onClick,
      style: _objectSpread2$4(_objectSpread2$4({}, motionStyle), mergedStyle)
    }, childNode));
  });
});
PopupInner.displayName = "PopupInner";
var MobilePopupInner = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender, onClick = props.onClick;
  var elementRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$4({
    zIndex
  }, popupStyle);
  var childNode = children;
  if (react.exports.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }
  if (popupRender) {
    childNode = popupRender(childNode);
  }
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
    visible,
    ref: elementRef,
    removeOnLeave: true
  }, popupMotion), function(_ref, motionRef) {
    var motionClassName = _ref.className, motionStyle = _ref.style;
    var mergedClassName = classnamesExports(prefixCls, popupClassName, motionClassName);
    return /* @__PURE__ */ react.exports.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onClick,
      style: _objectSpread2$4(_objectSpread2$4({}, motionStyle), mergedStyle)
    }, childNode);
  });
});
MobilePopupInner.displayName = "MobilePopupInner";
var _excluded$u = ["visible", "mobile"];
var Popup$1 = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var visible = _ref.visible, mobile = _ref.mobile, props = _objectWithoutProperties$1(_ref, _excluded$u);
  var _useState = react.exports.useState(visible), _useState2 = _slicedToArray$3(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray$3(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];
  var cloneProps = _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    visible: innerVisible
  });
  react.exports.useEffect(function() {
    serInnerVisible(visible);
    if (visible && mobile) {
      setInMobile(isMobile());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /* @__PURE__ */ react.exports.createElement(MobilePopupInner, _extends$2({}, cloneProps, {
    mobile,
    ref
  })) : /* @__PURE__ */ react.exports.createElement(PopupInner, _extends$2({}, cloneProps, {
    ref
  }));
  return /* @__PURE__ */ react.exports.createElement("div", null, /* @__PURE__ */ react.exports.createElement(Mask, cloneProps), popupNode);
});
Popup$1.displayName = "Popup";
var TriggerContext = /* @__PURE__ */ react.exports.createContext(null);
function noop$2() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function generateTrigger(PortalComponent) {
  var Trigger2 = /* @__PURE__ */ function(_React$Component) {
    _inherits$1(Trigger3, _React$Component);
    var _super = _createSuper$1(Trigger3);
    function Trigger3(props) {
      var _this;
      _classCallCheck$2(this, Trigger3);
      _this = _super.call(this, props);
      _this.popupRef = /* @__PURE__ */ react.exports.createRef();
      _this.triggerRef = /* @__PURE__ */ react.exports.createRef();
      _this.portalContainer = void 0;
      _this.attachId = void 0;
      _this.clickOutsideHandler = void 0;
      _this.touchOutsideHandler = void 0;
      _this.contextMenuOutsideHandler1 = void 0;
      _this.contextMenuOutsideHandler2 = void 0;
      _this.mouseDownTimeout = void 0;
      _this.focusTime = void 0;
      _this.preClickTime = void 0;
      _this.preTouchTime = void 0;
      _this.delayTimer = void 0;
      _this.hasPopupMouseDown = void 0;
      _this.onMouseEnter = function(e2) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;
        _this.fireEvents("onMouseEnter", e2);
        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
      };
      _this.onMouseMove = function(e2) {
        _this.fireEvents("onMouseMove", e2);
        _this.setPoint(e2);
      };
      _this.onMouseLeave = function(e2) {
        _this.fireEvents("onMouseLeave", e2);
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onPopupMouseEnter = function() {
        _this.clearDelayTimer();
      };
      _this.onPopupMouseLeave = function(e2) {
        var _this$popupRef$curren;
        if (e2.relatedTarget && !e2.relatedTarget.setTimeout && contains((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e2.relatedTarget)) {
          return;
        }
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };
      _this.onFocus = function(e2) {
        _this.fireEvents("onFocus", e2);
        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      };
      _this.onMouseDown = function(e2) {
        _this.fireEvents("onMouseDown", e2);
        _this.preClickTime = Date.now();
      };
      _this.onTouchStart = function(e2) {
        _this.fireEvents("onTouchStart", e2);
        _this.preTouchTime = Date.now();
      };
      _this.onBlur = function(e2) {
        _this.fireEvents("onBlur", e2);
        _this.clearDelayTimer();
        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      };
      _this.onContextMenu = function(e2) {
        e2.preventDefault();
        _this.fireEvents("onContextMenu", e2);
        _this.setPopupVisible(true, e2);
      };
      _this.onContextMenuClose = function() {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      };
      _this.onClick = function(event) {
        _this.fireEvents("onClick", event);
        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0;
        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !_this.state.popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      };
      _this.onPopupMouseDown = function() {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function() {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _this$context;
          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      };
      _this.onDocumentClick = function(event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }
        var target = event.target;
        var root2 = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if ((!contains(root2, target) || _this.isContextMenuOnly()) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      };
      _this.getRootDomNode = function() {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;
        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }
        try {
          var domNode = findDOMNode(_this.triggerRef.current);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return ReactDOM.findDOMNode(_assertThisInitialized$1(_this));
      };
      _this.getPopupClassNameFromAlign = function(align) {
        var className = [];
        var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      };
      _this.getComponent = function() {
        var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender, onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state, popupVisible = _this$state.popupVisible, point2 = _this$state.point;
        var align = _this.getPopupAlign();
        var mouseProps = {};
        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }
        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /* @__PURE__ */ react.exports.createElement(Popup$1, _extends$2({
          prefixCls,
          destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint2 && point2,
          className: popupClassName,
          align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile,
          forceRender,
          onClick: onPopupClick
        }), typeof popup === "function" ? popup() : popup);
      };
      _this.attachParent = function(popupContainer) {
        wrapperRaf$1.cancel(_this.attachId);
        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          _this.attachId = wrapperRaf$1(function() {
            _this.attachParent(popupContainer);
          });
        }
      };
      _this.getContainer = function() {
        if (!_this.portalContainer) {
          var getDocument2 = _this.props.getDocument;
          var popupContainer = getDocument2(_this.getRootDomNode()).createElement("div");
          popupContainer.style.position = "absolute";
          popupContainer.style.top = "0";
          popupContainer.style.left = "0";
          popupContainer.style.width = "100%";
          _this.portalContainer = popupContainer;
        }
        _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      };
      _this.setPoint = function(point2) {
        var alignPoint2 = _this.props.alignPoint;
        if (!alignPoint2 || !point2)
          return;
        _this.setState({
          point: {
            pageX: point2.pageX,
            pageY: point2.pageY
          }
        });
      };
      _this.handlePortalUpdate = function() {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      };
      _this.triggerContextValue = {
        onPopupMouseDown: _this.onPopupMouseDown
      };
      var _popupVisible;
      if ("popupVisible" in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function(h2) {
        _this["fire".concat(h2)] = function(e2) {
          _this.fireEvents(h2, e2);
        };
      });
      return _this;
    }
    _createClass$2(Trigger3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state;
        if (state.popupVisible) {
          var currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick);
          }
          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextMenuClose);
          }
          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextMenuClose);
          }
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf$1.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value: function setPopupVisible(popupVisible, event) {
        var alignPoint2 = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();
        if (prevPopupVisible !== popupVisible) {
          if (!("popupVisible" in this.props)) {
            this.setState({
              popupVisible,
              prevPopupVisible
            });
          }
          this.props.onPopupVisibleChange(popupVisible);
        }
        if (alignPoint2 && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;
        var delay = delayS * 1e3;
        this.clearDelayTimer();
        if (delay) {
          var point2 = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function() {
            _this2.setPopupVisible(visible, point2);
            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }
        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;
        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }
        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === "contextMenu" || action.length === 1 && action[0] === "contextMenu";
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;
        return action.indexOf("contextMenu") !== -1 || showAction.indexOf("contextMenu") !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseEnter") !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseLeave") !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;
          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type4, e2) {
        var childCallback = this.props.children.props[type4];
        if (childCallback) {
          childCallback(e2);
        }
        var callback = this.props[type4];
        if (callback) {
          callback(e2);
        }
      }
    }, {
      key: "close",
      value: function close3() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render2() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;
        var child = react.exports.Children.only(children);
        var newChildProps = {
          key: "trigger"
        };
        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains("onContextMenu");
        }
        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains("onClick");
          newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
          newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
        }
        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter;
          if (alignPoint2) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains("onMouseEnter");
        }
        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains("onMouseLeave");
        }
        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains("onFocus");
          newChildProps.onBlur = this.createTwoChains("onBlur");
        }
        var childrenClassName = classnamesExports(child && child.props && child.props.className, className);
        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }
        var cloneProps = _objectSpread2$4({}, newChildProps);
        if (supportRef(child)) {
          cloneProps.ref = composeRef(this.triggerRef, child.ref);
        }
        var trigger3 = /* @__PURE__ */ react.exports.cloneElement(child, cloneProps);
        var portal;
        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /* @__PURE__ */ react.exports.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }
        if (!popupVisible && autoDestroy) {
          portal = null;
        }
        return /* @__PURE__ */ react.exports.createElement(TriggerContext.Provider, {
          value: this.triggerContextValue
        }, trigger3, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};
        if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }
        return newState;
      }
    }]);
    return Trigger3;
  }(react.exports.Component);
  Trigger2.contextType = TriggerContext;
  Trigger2.defaultProps = {
    prefixCls: "rc-trigger-popup",
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop$2,
    afterPopupVisibleChange: noop$2,
    onPopupAlign: noop$2,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  };
  return Trigger2;
}
const Trigger = generateTrigger(Portal);
var _excluded$t = ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];
var getBuiltInPlacements = function getBuiltInPlacements2(dropdownMatchSelectWidth) {
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX,
        adjustY: 1
      }
    }
  };
};
var SelectTrigger = function SelectTrigger2(props, ref) {
  var prefixCls = props.prefixCls;
  props.disabled;
  var visible = props.visible, children = props.children, popupElement = props.popupElement, containerWidth = props.containerWidth, animation = props.animation, transitionName2 = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction, placement = props.placement, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, getPopupContainer = props.getPopupContainer, empty2 = props.empty, getTriggerDOMNode = props.getTriggerDOMNode, onPopupVisibleChange = props.onPopupVisibleChange, onPopupMouseEnter = props.onPopupMouseEnter, restProps = _objectWithoutProperties$1(props, _excluded$t);
  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var popupNode = popupElement;
  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  }
  var builtInPlacements = react.exports.useMemo(function() {
    return getBuiltInPlacements(dropdownMatchSelectWidth);
  }, [dropdownMatchSelectWidth]);
  var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName2;
  var popupRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return {
      getPopupElement: function getPopupElement() {
        return popupRef.current;
      }
    };
  });
  var popupStyle = _objectSpread2$4({
    minWidth: containerWidth
  }, dropdownStyle);
  if (typeof dropdownMatchSelectWidth === "number") {
    popupStyle.width = dropdownMatchSelectWidth;
  } else if (dropdownMatchSelectWidth) {
    popupStyle.width = containerWidth;
  }
  return /* @__PURE__ */ react.exports.createElement(Trigger, _extends$2({}, restProps, {
    showAction: onPopupVisibleChange ? ["click"] : [],
    hideAction: onPopupVisibleChange ? ["click"] : [],
    popupPlacement: placement || (direction === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: builtInPlacements,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: mergedTransitionName,
    popup: /* @__PURE__ */ react.exports.createElement("div", {
      ref: popupRef,
      onMouseEnter: onPopupMouseEnter
    }, popupNode),
    popupAlign: dropdownAlign,
    popupVisible: visible,
    getPopupContainer,
    popupClassName: classnamesExports(dropdownClassName, _defineProperty$5({}, "".concat(dropdownPrefixCls, "-empty"), empty2)),
    popupStyle,
    getTriggerDOMNode,
    onPopupVisibleChange
  }), children);
};
var RefSelectTrigger = /* @__PURE__ */ react.exports.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = "SelectTrigger";
var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
var ariaPrefix = "aria-";
var dataPrefix = "data-";
function match(key2, prefix2) {
  return key2.indexOf(prefix2) === 0;
}
function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var mergedConfig;
  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2$4({}, ariaOnly);
  }
  var attrs = {};
  Object.keys(props).forEach(function(key2) {
    if (mergedConfig.aria && (key2 === "role" || match(key2, ariaPrefix)) || mergedConfig.data && match(key2, dataPrefix) || mergedConfig.attr && propList.includes(key2)) {
      attrs[key2] = props[key2];
    }
  });
  return attrs;
}
var _excluded$s = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED = void 0;
function InternalItem$1(props, ref) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey2 = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order2 = props.order, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties$1(props, _excluded$s);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey2, width);
  }
  react.exports.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order2 : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({
    className: classnamesExports(!invalidate && prefixCls, className),
    style: _objectSpread2$4(_objectSpread2$4({}, overflowStyle), style2)
  }, overflowProps, restProps, {
    ref
  }), childNode);
  if (responsive) {
    itemNode = /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
      onResize: function onResize2(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }
  return itemNode;
}
var Item$4 = /* @__PURE__ */ react.exports.forwardRef(InternalItem$1);
Item$4.displayName = "Item";
function useBatchFrameState() {
  var _useState = useSafeState({}), _useState2 = _slicedToArray$3(_useState, 2), forceUpdate = _useState2[1];
  var statesRef = react.exports.useRef([]);
  var walkingIndex = 0;
  var beforeFrameId = 0;
  function createState(defaultValue) {
    var myIndex = walkingIndex;
    walkingIndex += 1;
    if (statesRef.current.length < myIndex + 1) {
      statesRef.current[myIndex] = defaultValue;
    }
    var value2 = statesRef.current[myIndex];
    function setValue2(val) {
      statesRef.current[myIndex] = typeof val === "function" ? val(statesRef.current[myIndex]) : val;
      wrapperRaf$1.cancel(beforeFrameId);
      beforeFrameId = wrapperRaf$1(function() {
        forceUpdate({}, true);
      });
    }
    return [value2, setValue2];
  }
  return createState;
}
var _excluded$r = ["component"], _excluded2$5 = ["className"], _excluded3$1 = ["className"];
var InternalRawItem = function InternalRawItem2(props, ref) {
  var context2 = react.exports.useContext(OverflowContext);
  if (!context2) {
    var _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties$1(props, _excluded$r);
    return /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({}, _restProps, {
      ref
    }));
  }
  var contextClassName = context2.className, restContext = _objectWithoutProperties$1(context2, _excluded2$5);
  var className = props.className, restProps = _objectWithoutProperties$1(props, _excluded3$1);
  return /* @__PURE__ */ react.exports.createElement(OverflowContext.Provider, {
    value: null
  }, /* @__PURE__ */ react.exports.createElement(Item$4, _extends$2({
    ref,
    className: classnamesExports(contextClassName, className)
  }, restContext, restProps)));
};
var RawItem = /* @__PURE__ */ react.exports.forwardRef(InternalRawItem);
RawItem.displayName = "RawItem";
var _excluded$q = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext = /* @__PURE__ */ react.exports.createContext(null);
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data2 = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey2 = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount2 = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties$1(props, _excluded$q);
  var createUseState = useBatchFrameState();
  var fullySSR = ssr === "full";
  var _createUseState = createUseState(null), _createUseState2 = _slicedToArray$3(_createUseState, 2), containerWidth = _createUseState2[0], setContainerWidth = _createUseState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _createUseState3 = createUseState(/* @__PURE__ */ new Map()), _createUseState4 = _slicedToArray$3(_createUseState3, 2), itemWidths = _createUseState4[0], setItemWidths = _createUseState4[1];
  var _createUseState5 = createUseState(0), _createUseState6 = _slicedToArray$3(_createUseState5, 2), prevRestWidth = _createUseState6[0], setPrevRestWidth = _createUseState6[1];
  var _createUseState7 = createUseState(0), _createUseState8 = _slicedToArray$3(_createUseState7, 2), restWidth = _createUseState8[0], setRestWidth = _createUseState8[1];
  var _createUseState9 = createUseState(0), _createUseState10 = _slicedToArray$3(_createUseState9, 2), suffixWidth = _createUseState10[0], setSuffixWidth = _createUseState10[1];
  var _useState = react.exports.useState(null), _useState2 = _slicedToArray$3(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = react.exports.useState(null), _useState4 = _slicedToArray$3(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = react.exports.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = react.exports.useState(false), _useState6 = _slicedToArray$3(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount2 === RESPONSIVE;
  var shouldResponsive = data2.length && isResponsive;
  var invalidate = maxCount2 === INVALIDATE;
  var showRest = shouldResponsive || typeof maxCount2 === "number" && data2.length > maxCount2;
  var mergedData = react.exports.useMemo(function() {
    var items = data2;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data2;
      } else {
        items = data2.slice(0, Math.min(data2.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount2 === "number") {
      items = data2.slice(0, maxCount2);
    }
    return items;
  }, [data2, itemWidth, containerWidth, maxCount2, shouldResponsive]);
  var omittedItems = react.exports.useMemo(function() {
    if (shouldResponsive) {
      return data2.slice(mergedDisplayCount + 1);
    }
    return data2.slice(mergedData.length);
  }, [data2, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey2 = react.exports.useCallback(function(item, index2) {
    var _ref;
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return (_ref = itemKey2 && (item === null || item === void 0 ? void 0 : item[itemKey2])) !== null && _ref !== void 0 ? _ref : index2;
  }, [itemKey2]);
  var mergedRenderItem = react.exports.useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data2.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key2, width) {
    setItemWidths(function(origin) {
      var clone2 = new Map(origin);
      if (width === null) {
        clone2.delete(key2);
      } else {
        clone2.set(key2, width);
      }
      return clone2;
    });
  }
  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey2(mergedData[index2], index2));
  }
  useLayoutEffect$1(function() {
    if (mergedContainerWidth && mergedRestWidth && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey2, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key2 = getKey2(item, index2);
    return /* @__PURE__ */ react.exports.createElement(OverflowContext.Provider, {
      key: key2,
      value: _objectSpread2$4(_objectSpread2$4({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key2,
        registerSize,
        display: index2 <= mergedDisplayCount
      })
    }, renderRawItem(item, index2));
  } : function(item, index2) {
    var key2 = getKey2(item, index2);
    return /* @__PURE__ */ react.exports.createElement(Item$4, _extends$2({}, itemSharedProps, {
      order: index2,
      key: key2,
      item,
      renderItem: mergedRenderItem,
      itemKey: key2,
      registerSize,
      display: index2 <= mergedDisplayCount
    }));
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /* @__PURE__ */ react.exports.createElement(Item$4, _extends$2({}, itemSharedProps, restContextProps), typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ react.exports.createElement(OverflowContext.Provider, {
      value: _objectSpread2$4(_objectSpread2$4({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }
  var overflowNode = /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({
    className: classnamesExports(!invalidate && prefixCls, className),
    style: style2,
    ref
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ react.exports.createElement(Item$4, _extends$2({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }
  return overflowNode;
}
var ForwardOverflow = /* @__PURE__ */ react.exports.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var TransBtn = function TransBtn2(_ref) {
  var className = _ref.className, customizeIcon = _ref.customizeIcon, customizeIconProps = _ref.customizeIconProps, _onMouseDown = _ref.onMouseDown, onClick = _ref.onClick, children = _ref.children;
  var icon;
  if (typeof customizeIcon === "function") {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }
  return /* @__PURE__ */ react.exports.createElement("span", {
    className,
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();
      if (_onMouseDown) {
        _onMouseDown(event);
      }
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick,
    "aria-hidden": true
  }, icon !== void 0 ? icon : /* @__PURE__ */ react.exports.createElement("span", {
    className: classnamesExports(className.split(/\s+/).map(function(cls) {
      return "".concat(cls, "-icon");
    }))
  }, children));
};
var Input$4 = function Input(_ref, ref) {
  var _inputNode2, _inputNode2$props;
  var prefixCls = _ref.prefixCls, id2 = _ref.id, inputElement = _ref.inputElement, disabled = _ref.disabled, tabIndex = _ref.tabIndex, autoFocus = _ref.autoFocus, autoComplete = _ref.autoComplete, editable = _ref.editable, activeDescendantId = _ref.activeDescendantId, value2 = _ref.value, maxLength = _ref.maxLength, _onKeyDown = _ref.onKeyDown, _onMouseDown = _ref.onMouseDown, _onChange = _ref.onChange, onPaste = _ref.onPaste, _onCompositionStart = _ref.onCompositionStart, _onCompositionEnd = _ref.onCompositionEnd, open = _ref.open, attrs = _ref.attrs;
  var inputNode = inputElement || /* @__PURE__ */ react.exports.createElement("input", null);
  var _inputNode = inputNode, originRef = _inputNode.ref, originProps = _inputNode.props;
  var onOriginKeyDown = originProps.onKeyDown, onOriginChange = originProps.onChange, onOriginMouseDown = originProps.onMouseDown, onOriginCompositionStart = originProps.onCompositionStart, onOriginCompositionEnd = originProps.onCompositionEnd, style2 = originProps.style;
  warning$2(!("maxLength" in inputNode.props));
  inputNode = /* @__PURE__ */ react.exports.cloneElement(inputNode, _objectSpread2$4(_objectSpread2$4(_objectSpread2$4({
    type: "search"
  }, originProps), {}, {
    id: id2,
    ref: composeRef(ref, originRef),
    disabled,
    tabIndex,
    autoComplete: autoComplete || "off",
    autoFocus,
    className: classnamesExports("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
    role: "combobox",
    "aria-expanded": open,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(id2, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(id2, "_list"),
    "aria-activedescendant": activeDescendantId
  }, attrs), {}, {
    value: editable ? value2 : "",
    maxLength,
    readOnly: !editable,
    unselectable: !editable ? "on" : null,
    style: _objectSpread2$4(_objectSpread2$4({}, style2), {}, {
      opacity: editable ? null : 0
    }),
    onKeyDown: function onKeyDown2(event) {
      _onKeyDown(event);
      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      _onMouseDown(event);
      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: function onChange2(event) {
      _onChange(event);
      if (onOriginChange) {
        onOriginChange(event);
      }
    },
    onCompositionStart: function onCompositionStart(event) {
      _onCompositionStart(event);
      if (onOriginCompositionStart) {
        onOriginCompositionStart(event);
      }
    },
    onCompositionEnd: function onCompositionEnd(event) {
      _onCompositionEnd(event);
      if (onOriginCompositionEnd) {
        onOriginCompositionEnd(event);
      }
    },
    onPaste
  }));
  return inputNode;
};
var RefInput = /* @__PURE__ */ react.exports.forwardRef(Input$4);
RefInput.displayName = "Input";
function toArray$2(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  return value2 !== void 0 ? [value2] : [];
}
var isClient = typeof window !== "undefined" && window.document && window.document.documentElement;
var isBrowserClient$1 = isClient;
function useLayoutEffect(effect, deps) {
  if (isBrowserClient$1) {
    react.exports.useLayoutEffect(effect, deps);
  } else {
    react.exports.useEffect(effect, deps);
  }
}
function itemKey$1(value2) {
  var _value$key;
  return (_value$key = value2.key) !== null && _value$key !== void 0 ? _value$key : value2.value;
}
var onPreventMouseDown = function onPreventMouseDown2(event) {
  event.preventDefault();
  event.stopPropagation();
};
var SelectSelector = function SelectSelector2(props) {
  var id2 = props.id, prefixCls = props.prefixCls, values = props.values, open = props.open, searchValue = props.searchValue, inputRef = props.inputRef, placeholder = props.placeholder, disabled = props.disabled, mode = props.mode, showSearch = props.showSearch, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, tabIndex = props.tabIndex, removeIcon = props.removeIcon, maxTagCount = props.maxTagCount, maxTagTextLength = props.maxTagTextLength, _props$maxTagPlacehol = props.maxTagPlaceholder, maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function(omittedValues) {
    return "+ ".concat(omittedValues.length, " ...");
  } : _props$maxTagPlacehol, tagRender = props.tagRender, onToggleOpen = props.onToggleOpen, onRemove = props.onRemove, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
  var measureRef = react.exports.useRef(null);
  var _useState = react.exports.useState(0), _useState2 = _slicedToArray$3(_useState, 2), inputWidth = _useState2[0], setInputWidth = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray$3(_useState3, 2), focused = _useState4[0], setFocused = _useState4[1];
  var selectionPrefixCls = "".concat(prefixCls, "-selection");
  var inputValue = open || mode === "tags" ? searchValue : "";
  var inputEditable = mode === "tags" || showSearch && (open || focused);
  useLayoutEffect(function() {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]);
  function defaultRenderSelector(title, content2, itemDisabled, closable, onClose2) {
    return /* @__PURE__ */ react.exports.createElement("span", {
      className: classnamesExports("".concat(selectionPrefixCls, "-item"), _defineProperty$5({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
      title: typeof title === "string" || typeof title === "number" ? title.toString() : void 0
    }, /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(selectionPrefixCls, "-item-content")
    }, content2), closable && /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: "".concat(selectionPrefixCls, "-item-remove"),
      onMouseDown: onPreventMouseDown,
      onClick: onClose2,
      customizeIcon: removeIcon
    }, "\xD7"));
  }
  function customizeRenderSelector(value2, content2, itemDisabled, closable, onClose2) {
    var onMouseDown = function onMouseDown2(e2) {
      onPreventMouseDown(e2);
      onToggleOpen(!open);
    };
    return /* @__PURE__ */ react.exports.createElement("span", {
      onMouseDown
    }, tagRender({
      label: content2,
      value: value2,
      disabled: itemDisabled,
      closable,
      onClose: onClose2
    }));
  }
  function renderItem(valueItem) {
    var itemDisabled = valueItem.disabled, label = valueItem.label, value2 = valueItem.value;
    var closable = !disabled && !itemDisabled;
    var displayLabel = label;
    if (typeof maxTagTextLength === "number") {
      if (typeof label === "string" || typeof label === "number") {
        var strLabel = String(displayLabel);
        if (strLabel.length > maxTagTextLength) {
          displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
        }
      }
    }
    var onClose2 = function onClose3(event) {
      if (event)
        event.stopPropagation();
      onRemove(valueItem);
    };
    return typeof tagRender === "function" ? customizeRenderSelector(value2, displayLabel, itemDisabled, closable, onClose2) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose2);
  }
  function renderRest(omittedValues) {
    var content2 = typeof maxTagPlaceholder === "function" ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return defaultRenderSelector(content2, content2, false);
  }
  var inputNode = /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(selectionPrefixCls, "-search"),
    style: {
      width: inputWidth
    },
    onFocus: function onFocus2() {
      setFocused(true);
    },
    onBlur: function onBlur2() {
      setFocused(false);
    }
  }, /* @__PURE__ */ react.exports.createElement(RefInput, {
    ref: inputRef,
    open,
    prefixCls,
    id: id2,
    inputElement: null,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex,
    attrs: pickAttrs(props, true)
  }), /* @__PURE__ */ react.exports.createElement("span", {
    ref: measureRef,
    className: "".concat(selectionPrefixCls, "-search-mirror"),
    "aria-hidden": true
  }, inputValue, "\xA0"));
  var selectionNode = /* @__PURE__ */ react.exports.createElement(ForwardOverflow, {
    prefixCls: "".concat(selectionPrefixCls, "-overflow"),
    data: values,
    renderItem,
    renderRest,
    suffix: inputNode,
    itemKey: itemKey$1,
    maxCount: maxTagCount
  });
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, selectionNode, !values.length && !inputValue && /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(selectionPrefixCls, "-placeholder")
  }, placeholder));
};
var SingleSelector = function SingleSelector2(props) {
  var inputElement = props.inputElement, prefixCls = props.prefixCls, id2 = props.id, inputRef = props.inputRef, disabled = props.disabled, autoFocus = props.autoFocus, autoComplete = props.autoComplete, activeDescendantId = props.activeDescendantId, mode = props.mode, open = props.open, values = props.values, placeholder = props.placeholder, tabIndex = props.tabIndex, showSearch = props.showSearch, searchValue = props.searchValue, activeValue = props.activeValue, maxLength = props.maxLength, onInputKeyDown = props.onInputKeyDown, onInputMouseDown = props.onInputMouseDown, onInputChange = props.onInputChange, onInputPaste = props.onInputPaste, onInputCompositionStart = props.onInputCompositionStart, onInputCompositionEnd = props.onInputCompositionEnd;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), inputChanged = _React$useState2[0], setInputChanged = _React$useState2[1];
  var combobox = mode === "combobox";
  var inputEditable = combobox || showSearch;
  var item = values[0];
  var inputValue = searchValue || "";
  if (combobox && activeValue && !inputChanged) {
    inputValue = activeValue;
  }
  react.exports.useEffect(function() {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]);
  var hasTextInput = mode !== "combobox" && !open && !showSearch ? false : !!inputValue;
  var title = item && (typeof item.label === "string" || typeof item.label === "number") ? item.label.toString() : void 0;
  var renderPlaceholder = function renderPlaceholder2() {
    if (item) {
      return null;
    }
    var hiddenStyle = hasTextInput ? {
      visibility: "hidden"
    } : void 0;
    return /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-selection-placeholder"),
      style: hiddenStyle
    }, placeholder);
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-selection-search")
  }, /* @__PURE__ */ react.exports.createElement(RefInput, {
    ref: inputRef,
    prefixCls,
    id: id2,
    open,
    inputElement,
    disabled,
    autoFocus,
    autoComplete,
    editable: inputEditable,
    activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: function onChange2(e2) {
      setInputChanged(true);
      onInputChange(e2);
    },
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex,
    attrs: pickAttrs(props, true),
    maxLength: combobox ? maxLength : void 0
  })), !combobox && item && !hasTextInput && /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(prefixCls, "-selection-item"),
    title
  }, item.label), renderPlaceholder());
};
function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250;
  var lockRef = react.exports.useRef(null);
  var timeoutRef = react.exports.useRef(null);
  react.exports.useEffect(function() {
    return function() {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);
  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }
    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(function() {
      lockRef.current = null;
    }, duration);
  }
  return [function() {
    return lockRef.current;
  }, doLock];
}
function isValidateOpenKey(currentKeyCode) {
  return ![
    KeyCode.ESC,
    KeyCode.SHIFT,
    KeyCode.BACKSPACE,
    KeyCode.TAB,
    KeyCode.WIN_KEY,
    KeyCode.ALT,
    KeyCode.META,
    KeyCode.WIN_KEY_RIGHT,
    KeyCode.CTRL,
    KeyCode.SEMICOLON,
    KeyCode.EQUALS,
    KeyCode.CAPS_LOCK,
    KeyCode.CONTEXT_MENU,
    KeyCode.F1,
    KeyCode.F2,
    KeyCode.F3,
    KeyCode.F4,
    KeyCode.F5,
    KeyCode.F6,
    KeyCode.F7,
    KeyCode.F8,
    KeyCode.F9,
    KeyCode.F10,
    KeyCode.F11,
    KeyCode.F12
  ].includes(currentKeyCode);
}
var Selector = function Selector2(props, ref) {
  var inputRef = react.exports.useRef(null);
  var compositionStatusRef = react.exports.useRef(false);
  var prefixCls = props.prefixCls, open = props.open, mode = props.mode, showSearch = props.showSearch, tokenWithEnter = props.tokenWithEnter, onSearch = props.onSearch, onSearchSubmit = props.onSearchSubmit, onToggleOpen = props.onToggleOpen, onInputKeyDown = props.onInputKeyDown, domRef = props.domRef;
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  });
  var _useLock = useLock(0), _useLock2 = _slicedToArray$3(_useLock, 2), getInputMouseDown = _useLock2[0], setInputMouseDown = _useLock2[1];
  var onInternalInputKeyDown = function onInternalInputKeyDown2(event) {
    var which = event.which;
    if (which === KeyCode.UP || which === KeyCode.DOWN) {
      event.preventDefault();
    }
    if (onInputKeyDown) {
      onInputKeyDown(event);
    }
    if (which === KeyCode.ENTER && mode === "tags" && !compositionStatusRef.current && !open) {
      onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
    }
    if (isValidateOpenKey(which)) {
      onToggleOpen(true);
    }
  };
  var onInternalInputMouseDown = function onInternalInputMouseDown2() {
    setInputMouseDown(true);
  };
  var pastedTextRef = react.exports.useRef(null);
  var triggerOnSearch = function triggerOnSearch2(value2) {
    if (onSearch(value2, true, compositionStatusRef.current) !== false) {
      onToggleOpen(true);
    }
  };
  var onInputCompositionStart = function onInputCompositionStart2() {
    compositionStatusRef.current = true;
  };
  var onInputCompositionEnd = function onInputCompositionEnd2(e2) {
    compositionStatusRef.current = false;
    if (mode !== "combobox") {
      triggerOnSearch(e2.target.value);
    }
  };
  var onInputChange = function onInputChange2(event) {
    var value2 = event.target.value;
    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      value2 = value2.replace(replacedText, pastedTextRef.current);
    }
    pastedTextRef.current = null;
    triggerOnSearch(value2);
  };
  var onInputPaste = function onInputPaste2(e2) {
    var clipboardData = e2.clipboardData;
    var value2 = clipboardData.getData("text");
    pastedTextRef.current = value2;
  };
  var onClick = function onClick2(_ref) {
    var target = _ref.target;
    if (target !== inputRef.current) {
      var isIE = document.body.style.msTouchAction !== void 0;
      if (isIE) {
        setTimeout(function() {
          inputRef.current.focus();
        });
      } else {
        inputRef.current.focus();
      }
    }
  };
  var onMouseDown = function onMouseDown2(event) {
    var inputMouseDown = getInputMouseDown();
    if (event.target !== inputRef.current && !inputMouseDown) {
      event.preventDefault();
    }
    if (mode !== "combobox" && (!showSearch || !inputMouseDown) || !open) {
      if (open) {
        onSearch("", true, false);
      }
      onToggleOpen();
    }
  };
  var sharedProps = {
    inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange,
    onInputPaste,
    onInputCompositionStart,
    onInputCompositionEnd
  };
  var selectNode = mode === "multiple" || mode === "tags" ? /* @__PURE__ */ react.exports.createElement(SelectSelector, _extends$2({}, props, sharedProps)) : /* @__PURE__ */ react.exports.createElement(SingleSelector, _extends$2({}, props, sharedProps));
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref: domRef,
    className: "".concat(prefixCls, "-selector"),
    onClick,
    onMouseDown
  }, selectNode);
};
var ForwardSelector = /* @__PURE__ */ react.exports.forwardRef(Selector);
ForwardSelector.displayName = "Selector";
function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  var propsRef = react.exports.useRef(null);
  propsRef.current = {
    open,
    triggerOpen,
    customizedTrigger
  };
  react.exports.useEffect(function() {
    function onGlobalMouseDown(event) {
      var _propsRef$current;
      if ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current.customizedTrigger) {
        return;
      }
      var target = event.target;
      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }
      if (propsRef.current.open && elements().filter(function(element) {
        return element;
      }).every(function(element) {
        return !element.contains(target) && element !== target;
      })) {
        propsRef.current.triggerOpen(false);
      }
    }
    window.addEventListener("mousedown", onGlobalMouseDown);
    return function() {
      return window.removeEventListener("mousedown", onGlobalMouseDown);
    };
  }, []);
}
function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), bool = _React$useState2[0], setBool = _React$useState2[1];
  var delayRef = react.exports.useRef(null);
  var cancelLatest = function cancelLatest2() {
    window.clearTimeout(delayRef.current);
  };
  react.exports.useEffect(function() {
    return cancelLatest;
  }, []);
  var delaySetBool = function delaySetBool2(value2, callback) {
    cancelLatest();
    delayRef.current = window.setTimeout(function() {
      setBool(value2);
      if (callback) {
        callback();
      }
    }, timeout);
  };
  return [bool, delaySetBool, cancelLatest];
}
var BaseSelectContext = /* @__PURE__ */ react.exports.createContext(null);
function useBaseProps() {
  return react.exports.useContext(BaseSelectContext);
}
var _excluded$p = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "showArrow", "inputIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];
var DEFAULT_OMIT_PROPS = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"];
function isMultiple(mode) {
  return mode === "tags" || mode === "multiple";
}
var BaseSelect = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _customizeRawInputEle, _classNames2;
  var id2 = props.id, prefixCls = props.prefixCls, className = props.className, showSearch = props.showSearch, tagRender = props.tagRender, direction = props.direction, omitDomProps = props.omitDomProps, displayValues = props.displayValues, onDisplayValuesChange = props.onDisplayValuesChange, emptyOptions = props.emptyOptions, _props$notFoundConten = props.notFoundContent, notFoundContent = _props$notFoundConten === void 0 ? "Not Found" : _props$notFoundConten, onClear = props.onClear, mode = props.mode, disabled = props.disabled, loading = props.loading, getInputElement = props.getInputElement, getRawInputElement = props.getRawInputElement, open = props.open, defaultOpen = props.defaultOpen, onDropdownVisibleChange = props.onDropdownVisibleChange, activeValue = props.activeValue, onActiveValueChange = props.onActiveValueChange, activeDescendantId = props.activeDescendantId, searchValue = props.searchValue, onSearch = props.onSearch, onSearchSplit = props.onSearchSplit, tokenSeparators = props.tokenSeparators, allowClear = props.allowClear, showArrow = props.showArrow, inputIcon = props.inputIcon, clearIcon = props.clearIcon, OptionList3 = props.OptionList, animation = props.animation, transitionName2 = props.transitionName, dropdownStyle = props.dropdownStyle, dropdownClassName = props.dropdownClassName, dropdownMatchSelectWidth = props.dropdownMatchSelectWidth, dropdownRender = props.dropdownRender, dropdownAlign = props.dropdownAlign, placement = props.placement, getPopupContainer = props.getPopupContainer, _props$showAction = props.showAction, showAction = _props$showAction === void 0 ? [] : _props$showAction, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onKeyUp2 = props.onKeyUp, onKeyDown2 = props.onKeyDown, onMouseDown = props.onMouseDown, restProps = _objectWithoutProperties$1(props, _excluded$p);
  var multiple = isMultiple(mode);
  var mergedShowSearch = (showSearch !== void 0 ? showSearch : multiple) || mode === "combobox";
  var domProps = _objectSpread2$4({}, restProps);
  DEFAULT_OMIT_PROPS.forEach(function(propName) {
    delete domProps[propName];
  });
  omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function(propName) {
    delete domProps[propName];
  });
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
  react.exports.useEffect(function() {
    setMobile(isMobile());
  }, []);
  var containerRef = react.exports.useRef(null);
  var selectorDomRef = react.exports.useRef(null);
  var triggerRef = react.exports.useRef(null);
  var selectorRef = react.exports.useRef(null);
  var listRef = react.exports.useRef(null);
  var _useDelayReset = useDelayReset(), _useDelayReset2 = _slicedToArray$3(_useDelayReset, 3), mockFocused = _useDelayReset2[0], setMockFocused = _useDelayReset2[1], cancelSetMockFocused = _useDelayReset2[2];
  react.exports.useImperativeHandle(ref, function() {
    var _selectorRef$current, _selectorRef$current2;
    return {
      focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
      blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
      scrollTo: function scrollTo2(arg) {
        var _listRef$current;
        return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
      }
    };
  });
  var mergedSearchValue = react.exports.useMemo(function() {
    var _displayValues$;
    if (mode !== "combobox") {
      return searchValue;
    }
    var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
    return typeof val === "string" || typeof val === "number" ? String(val) : "";
  }, [searchValue, mode, displayValues]);
  var customizeInputElement = mode === "combobox" && typeof getInputElement === "function" && getInputElement() || null;
  var customizeRawInputElement = typeof getRawInputElement === "function" && getRawInputElement();
  var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref);
  var _useMergedState = useMergedState(void 0, {
    defaultValue: defaultOpen,
    value: open
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), innerOpen = _useMergedState2[0], setInnerOpen = _useMergedState2[1];
  var mergedOpen = innerOpen;
  var emptyListContent = !notFoundContent && emptyOptions;
  if (disabled || emptyListContent && mergedOpen && mode === "combobox") {
    mergedOpen = false;
  }
  var triggerOpen = emptyListContent ? false : mergedOpen;
  var onToggleOpen = react.exports.useCallback(function(newOpen) {
    var nextOpen = newOpen !== void 0 ? newOpen : !mergedOpen;
    if (mergedOpen !== nextOpen && !disabled) {
      setInnerOpen(nextOpen);
      onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
    }
  }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]);
  var tokenWithEnter = react.exports.useMemo(function() {
    return (tokenSeparators || []).some(function(tokenSeparator) {
      return ["\n", "\r\n"].includes(tokenSeparator);
    });
  }, [tokenSeparators]);
  var onInternalSearch = function onInternalSearch2(searchText, fromTyping, isCompositing) {
    var ret = true;
    var newSearchText = searchText;
    onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null);
    var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators);
    if (mode !== "combobox" && patchLabels) {
      newSearchText = "";
      onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels);
      onToggleOpen(false);
      ret = false;
    }
    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? "typing" : "effect"
      });
    }
    return ret;
  };
  var onInternalSearchSubmit = function onInternalSearchSubmit2(searchText) {
    if (!searchText || !searchText.trim()) {
      return;
    }
    onSearch(searchText, {
      source: "submit"
    });
  };
  react.exports.useEffect(function() {
    if (!mergedOpen && !multiple && mode !== "combobox") {
      onInternalSearch("", false, false);
    }
  }, [mergedOpen]);
  react.exports.useEffect(function() {
    if (innerOpen && disabled) {
      setInnerOpen(false);
    }
    if (disabled) {
      setMockFocused(false);
    }
  }, [disabled]);
  var _useLock = useLock(), _useLock2 = _slicedToArray$3(_useLock, 2), getClearLock = _useLock2[0], setClearLock = _useLock2[1];
  var onInternalKeyDown = function onInternalKeyDown2(event) {
    var clearLock = getClearLock();
    var which = event.which;
    if (which === KeyCode.ENTER) {
      if (mode !== "combobox") {
        event.preventDefault();
      }
      if (!mergedOpen) {
        onToggleOpen(true);
      }
    }
    setClearLock(!!mergedSearchValue);
    if (which === KeyCode.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      var cloneDisplayValues = _toConsumableArray(displayValues);
      var removedDisplayValue = null;
      for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        var current = cloneDisplayValues[i];
        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }
      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: "remove",
          values: [removedDisplayValue]
        });
      }
    }
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current2;
      (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2.apply(void 0, [event].concat(rest));
  };
  var onInternalKeyUp = function onInternalKeyUp2(event) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }
    if (mergedOpen && listRef.current) {
      var _listRef$current3;
      (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
    }
    onKeyUp2 === null || onKeyUp2 === void 0 ? void 0 : onKeyUp2.apply(void 0, [event].concat(rest));
  };
  var onSelectorRemove = function onSelectorRemove2(val) {
    var newValues = displayValues.filter(function(i) {
      return i !== val;
    });
    onDisplayValuesChange(newValues, {
      type: "remove",
      values: [val]
    });
  };
  var focusRef = react.exports.useRef(false);
  var onContainerFocus = function onContainerFocus2() {
    setMockFocused(true);
    if (!disabled) {
      if (onFocus2 && !focusRef.current) {
        onFocus2.apply(void 0, arguments);
      }
      if (showAction.includes("focus")) {
        onToggleOpen(true);
      }
    }
    focusRef.current = true;
  };
  var onContainerBlur = function onContainerBlur2() {
    setMockFocused(false, function() {
      focusRef.current = false;
      onToggleOpen(false);
    });
    if (disabled) {
      return;
    }
    if (mergedSearchValue) {
      if (mode === "tags") {
        onSearch(mergedSearchValue, {
          source: "submit"
        });
      } else if (mode === "multiple") {
        onSearch("", {
          source: "blur"
        });
      }
    }
    if (onBlur2) {
      onBlur2.apply(void 0, arguments);
    }
  };
  var activeTimeoutIds = [];
  react.exports.useEffect(function() {
    return function() {
      activeTimeoutIds.forEach(function(timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    };
  }, []);
  var onInternalMouseDown = function onInternalMouseDown2(event) {
    var _triggerRef$current;
    var target = event.target;
    var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement();
    if (popupElement && popupElement.contains(target)) {
      var timeoutId = setTimeout(function() {
        var index2 = activeTimeoutIds.indexOf(timeoutId);
        if (index2 !== -1) {
          activeTimeoutIds.splice(index2, 1);
        }
        cancelSetMockFocused();
        if (!mobile && !popupElement.contains(document.activeElement)) {
          var _selectorRef$current3;
          (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }
    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      restArgs[_key3 - 1] = arguments[_key3];
    }
    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
  };
  var _React$useState3 = react.exports.useState(null), _React$useState4 = _slicedToArray$3(_React$useState3, 2), containerWidth = _React$useState4[0], setContainerWidth = _React$useState4[1];
  var _React$useState5 = react.exports.useState({}), _React$useState6 = _slicedToArray$3(_React$useState5, 2), forceUpdate = _React$useState6[1];
  function onPopupMouseEnter() {
    forceUpdate({});
  }
  useLayoutEffect$1(function() {
    if (triggerOpen) {
      var _containerRef$current;
      var newWidth = Math.ceil((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);
      if (containerWidth !== newWidth && !Number.isNaN(newWidth)) {
        setContainerWidth(newWidth);
      }
    }
  }, [triggerOpen]);
  var onTriggerVisibleChange;
  if (customizeRawInputElement) {
    onTriggerVisibleChange = function onTriggerVisibleChange2(newOpen) {
      onToggleOpen(newOpen);
    };
  }
  useSelectTriggerControl(function() {
    var _triggerRef$current2;
    return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
  }, triggerOpen, onToggleOpen, !!customizeRawInputElement);
  var baseSelectContext = react.exports.useMemo(function() {
    return _objectSpread2$4(_objectSpread2$4({}, props), {}, {
      notFoundContent,
      open: mergedOpen,
      triggerOpen,
      id: id2,
      showSearch: mergedShowSearch,
      multiple,
      toggleOpen: onToggleOpen
    });
  }, [props, notFoundContent, triggerOpen, mergedOpen, id2, mergedShowSearch, multiple, onToggleOpen]);
  var mergedShowArrow = showArrow !== void 0 ? showArrow : loading || !multiple && mode !== "combobox";
  var arrowNode;
  if (mergedShowArrow) {
    arrowNode = /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: classnamesExports("".concat(prefixCls, "-arrow"), _defineProperty$5({}, "".concat(prefixCls, "-arrow-loading"), loading)),
      customizeIcon: inputIcon,
      customizeIconProps: {
        loading,
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused: mockFocused,
        showSearch: mergedShowSearch
      }
    });
  }
  var clearNode;
  var onClearMouseDown = function onClearMouseDown2() {
    onClear === null || onClear === void 0 ? void 0 : onClear();
    onDisplayValuesChange([], {
      type: "clear",
      values: displayValues
    });
    onInternalSearch("", false, false);
  };
  if (!disabled && allowClear && (displayValues.length || mergedSearchValue)) {
    clearNode = /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: "".concat(prefixCls, "-clear"),
      onMouseDown: onClearMouseDown,
      customizeIcon: clearIcon
    }, "\xD7");
  }
  var optionList = /* @__PURE__ */ react.exports.createElement(OptionList3, {
    ref: listRef
  });
  var mergedClassName = classnamesExports(prefixCls, className, (_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty$5(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty$5(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty$5(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty$5(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty$5(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$5(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty$5(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty$5(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty$5(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2));
  var selectorNode = /* @__PURE__ */ react.exports.createElement(RefSelectTrigger, {
    ref: triggerRef,
    disabled,
    prefixCls,
    visible: triggerOpen,
    popupElement: optionList,
    containerWidth,
    animation,
    transitionName: transitionName2,
    dropdownStyle,
    dropdownClassName,
    direction,
    dropdownMatchSelectWidth,
    dropdownRender,
    dropdownAlign,
    placement,
    getPopupContainer,
    empty: emptyOptions,
    getTriggerDOMNode: function getTriggerDOMNode() {
      return selectorDomRef.current;
    },
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter
  }, customizeRawInputElement ? /* @__PURE__ */ react.exports.cloneElement(customizeRawInputElement, {
    ref: customizeRawInputRef
  }) : /* @__PURE__ */ react.exports.createElement(ForwardSelector, _extends$2({}, props, {
    domRef: selectorDomRef,
    prefixCls,
    inputElement: customizeInputElement,
    ref: selectorRef,
    id: id2,
    showSearch: mergedShowSearch,
    mode,
    activeDescendantId,
    tagRender,
    values: displayValues,
    open: mergedOpen,
    onToggleOpen,
    activeValue,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onRemove: onSelectorRemove,
    tokenWithEnter
  })));
  var renderNode;
  if (customizeRawInputElement) {
    renderNode = selectorNode;
  } else {
    renderNode = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      className: mergedClassName
    }, domProps, {
      ref: containerRef,
      onMouseDown: onInternalMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onFocus: onContainerFocus,
      onBlur: onContainerBlur
    }), mockFocused && !mergedOpen && /* @__PURE__ */ react.exports.createElement("span", {
      style: {
        width: 0,
        height: 0,
        position: "absolute",
        overflow: "hidden",
        opacity: 0
      },
      "aria-live": "polite"
    }, "".concat(displayValues.map(function(_ref) {
      var label = _ref.label, value2 = _ref.value;
      return ["number", "string"].includes(_typeof$4(label)) ? label : value2;
    }).join(", "))), selectorNode, arrowNode, clearNode);
  }
  return /* @__PURE__ */ react.exports.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, renderNode);
});
const useCache = function(labeledValues, valueOptions) {
  var cacheRef = react.exports.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  var filledLabeledValues = react.exports.useMemo(function() {
    var _cacheRef$current = cacheRef.current, prevValueCache = _cacheRef$current.values, prevOptionCache = _cacheRef$current.options;
    var patchedValues = labeledValues.map(function(item) {
      if (item.label === void 0) {
        var _prevValueCache$get;
        return _objectSpread2$4(_objectSpread2$4({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }
      return item;
    });
    var valueCache = /* @__PURE__ */ new Map();
    var optionCache = /* @__PURE__ */ new Map();
    patchedValues.forEach(function(item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  var getOption = react.exports.useCallback(function(val) {
    return valueOptions.get(val) || cacheRef.current.options.get(val);
  }, [valueOptions]);
  return [filledLabeledValues, getOption];
};
function includes(test, search2) {
  return toArray$2(test).join("").toUpperCase().includes(search2);
}
const useFilterOptions = function(options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return react.exports.useMemo(function() {
    if (!searchValue || filterOption === false) {
      return options;
    }
    var fieldOptions = fieldNames.options, fieldLabel = fieldNames.label, fieldValue = fieldNames.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOption === "function";
    var upperSearch = searchValue.toUpperCase();
    var filterFunc = customizeFilter ? filterOption : function(_, option) {
      if (optionFilterProp) {
        return includes(option[optionFilterProp], upperSearch);
      }
      if (option[fieldOptions]) {
        return includes(option[fieldLabel !== "children" ? fieldLabel : "label"], upperSearch);
      }
      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function(opt) {
      return injectPropsWithOption(opt);
    } : function(opt) {
      return opt;
    };
    options.forEach(function(item) {
      if (item[fieldOptions]) {
        var matchGroup = filterFunc(searchValue, wrapOption(item));
        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          var subOptions = item[fieldOptions].filter(function(subItem) {
            return filterFunc(searchValue, wrapOption(subItem));
          });
          if (subOptions.length) {
            filteredOptions.push(_objectSpread2$4(_objectSpread2$4({}, item), {}, _defineProperty$5({}, fieldOptions, subOptions)));
          }
        }
        return;
      }
      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
};
var uuid = 0;
var isBrowserClient = canUseDom();
function getUUID() {
  var retId;
  if (isBrowserClient) {
    retId = uuid;
    uuid += 1;
  } else {
    retId = "TEST_OR_SSR";
  }
  return retId;
}
function useId(id2) {
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray$3(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
  react.exports.useEffect(function() {
    setInnerId("rc_select_".concat(getUUID()));
  }, []);
  return id2 || innerId;
}
var _excluded$o = ["children", "value"], _excluded2$4 = ["children"];
function convertNodeToOption(node) {
  var key2 = node.key, _node$props = node.props, children = _node$props.children, value2 = _node$props.value, restProps = _objectWithoutProperties$1(_node$props, _excluded$o);
  return _objectSpread2$4({
    key: key2,
    value: value2 !== void 0 ? value2 : key2,
    children
  }, restProps);
}
function convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return toArray$4(nodes).map(function(node, index2) {
    if (!/* @__PURE__ */ react.exports.isValidElement(node) || !node.type) {
      return null;
    }
    var isSelectOptGroup = node.type.isSelectOptGroup, key2 = node.key, _node$props2 = node.props, children = _node$props2.children, restProps = _objectWithoutProperties$1(_node$props2, _excluded2$4);
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }
    return _objectSpread2$4(_objectSpread2$4({
      key: "__RC_SELECT_GRP__".concat(key2 === null ? index2 : key2, "__"),
      label: key2
    }, restProps), {}, {
      options: convertChildrenToData(children)
    });
  }).filter(function(data2) {
    return data2;
  });
}
function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
  return react.exports.useMemo(function() {
    var mergedOptions = options;
    var childrenAsData = !options;
    if (childrenAsData) {
      mergedOptions = convertChildrenToData(children);
    }
    var valueOptions = /* @__PURE__ */ new Map();
    var labelOptions = /* @__PURE__ */ new Map();
    var setLabelOptions = function setLabelOptions2(labelOptionsMap, option, key2) {
      if (key2 && typeof key2 === "string") {
        labelOptionsMap.set(option[key2], option);
      }
    };
    function dig(optionList) {
      var isChildren2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      for (var i = 0; i < optionList.length; i += 1) {
        var option = optionList[i];
        if (!option[fieldNames.options] || isChildren2) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label);
          setLabelOptions(labelOptions, option, optionFilterProp);
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    }
    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions,
      labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}
function useRefFunc(callback) {
  var funcRef = react.exports.useRef();
  funcRef.current = callback;
  var cacheFn = react.exports.useCallback(function() {
    return funcRef.current.apply(funcRef, arguments);
  }, []);
  return cacheFn;
}
var OptGroup = function OptGroup2() {
  return null;
};
OptGroup.isSelectOptGroup = true;
var Option = function Option2() {
  return null;
};
Option.isSelectOption = true;
function ownKeys$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key2) {
      _defineProperty$3(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _defineProperty$3(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
var Filler = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var height = _ref.height, offset3 = _ref.offset, children = _ref.children, prefixCls = _ref.prefixCls, onInnerResize = _ref.onInnerResize;
  var outerStyle = {};
  var innerStyle = {
    display: "flex",
    flexDirection: "column"
  };
  if (offset3 !== void 0) {
    outerStyle = {
      height,
      position: "relative",
      overflow: "hidden"
    };
    innerStyle = _objectSpread$1(_objectSpread$1({}, innerStyle), {}, {
      transform: "translateY(".concat(offset3, "px)"),
      position: "absolute",
      left: 0,
      right: 0,
      top: 0
    });
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: outerStyle
  }, /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
    onResize: function onResize2(_ref2) {
      var offsetHeight = _ref2.offsetHeight;
      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    style: innerStyle,
    className: classnamesExports(_defineProperty$3({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref
  }, children)));
});
Filler.displayName = "Filler";
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _defineProperty$2(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof$2(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var MIN_SIZE = 20;
function getPageY(e2) {
  return "touches" in e2 ? e2.touches[0].pageY : e2.pageY;
}
var ScrollBar = /* @__PURE__ */ function(_React$Component) {
  _inherits(ScrollBar2, _React$Component);
  var _super = _createSuper(ScrollBar2);
  function ScrollBar2() {
    var _this;
    _classCallCheck$1(this, ScrollBar2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.moveRaf = null;
    _this.scrollbarRef = /* @__PURE__ */ react.exports.createRef();
    _this.thumbRef = /* @__PURE__ */ react.exports.createRef();
    _this.visibleTimeout = null;
    _this.state = {
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    };
    _this.delayHidden = function() {
      clearTimeout(_this.visibleTimeout);
      _this.setState({
        visible: true
      });
      _this.visibleTimeout = setTimeout(function() {
        _this.setState({
          visible: false
        });
      }, 2e3);
    };
    _this.onScrollbarTouchStart = function(e2) {
      e2.preventDefault();
    };
    _this.onContainerMouseDown = function(e2) {
      e2.stopPropagation();
      e2.preventDefault();
    };
    _this.patchEvents = function() {
      window.addEventListener("mousemove", _this.onMouseMove);
      window.addEventListener("mouseup", _this.onMouseUp);
      _this.thumbRef.current.addEventListener("touchmove", _this.onMouseMove);
      _this.thumbRef.current.addEventListener("touchend", _this.onMouseUp);
    };
    _this.removeEvents = function() {
      var _this$scrollbarRef$cu;
      window.removeEventListener("mousemove", _this.onMouseMove);
      window.removeEventListener("mouseup", _this.onMouseUp);
      (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener("touchstart", _this.onScrollbarTouchStart);
      if (_this.thumbRef.current) {
        _this.thumbRef.current.removeEventListener("touchstart", _this.onMouseDown);
        _this.thumbRef.current.removeEventListener("touchmove", _this.onMouseMove);
        _this.thumbRef.current.removeEventListener("touchend", _this.onMouseUp);
      }
      wrapperRaf$1.cancel(_this.moveRaf);
    };
    _this.onMouseDown = function(e2) {
      var onStartMove = _this.props.onStartMove;
      _this.setState({
        dragging: true,
        pageY: getPageY(e2),
        startTop: _this.getTop()
      });
      onStartMove();
      _this.patchEvents();
      e2.stopPropagation();
      e2.preventDefault();
    };
    _this.onMouseMove = function(e2) {
      var _this$state = _this.state, dragging = _this$state.dragging, pageY = _this$state.pageY, startTop = _this$state.startTop;
      var onScroll = _this.props.onScroll;
      wrapperRaf$1.cancel(_this.moveRaf);
      if (dragging) {
        var offsetY = getPageY(e2) - pageY;
        var newTop = startTop + offsetY;
        var enableScrollRange = _this.getEnableScrollRange();
        var enableHeightRange = _this.getEnableHeightRange();
        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        _this.moveRaf = wrapperRaf$1(function() {
          onScroll(newScrollTop);
        });
      }
    };
    _this.onMouseUp = function() {
      var onStopMove = _this.props.onStopMove;
      _this.setState({
        dragging: false
      });
      onStopMove();
      _this.removeEvents();
    };
    _this.getSpinHeight = function() {
      var _this$props = _this.props, height = _this$props.height, count = _this$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };
    _this.getEnableScrollRange = function() {
      var _this$props2 = _this.props, scrollHeight = _this$props2.scrollHeight, height = _this$props2.height;
      return scrollHeight - height || 0;
    };
    _this.getEnableHeightRange = function() {
      var height = _this.props.height;
      var spinHeight = _this.getSpinHeight();
      return height - spinHeight || 0;
    };
    _this.getTop = function() {
      var scrollTop = _this.props.scrollTop;
      var enableScrollRange = _this.getEnableScrollRange();
      var enableHeightRange = _this.getEnableHeightRange();
      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }
      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };
    _this.showScroll = function() {
      var _this$props3 = _this.props, height = _this$props3.height, scrollHeight = _this$props3.scrollHeight;
      return scrollHeight > height;
    };
    return _this;
  }
  _createClass$1(ScrollBar2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollbarRef.current.addEventListener("touchstart", this.onScrollbarTouchStart);
      this.thumbRef.current.addEventListener("touchstart", this.onMouseDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.scrollTop !== this.props.scrollTop) {
        this.delayHidden();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$state2 = this.state, dragging = _this$state2.dragging, visible = _this$state2.visible;
      var prefixCls = this.props.prefixCls;
      var spinHeight = this.getSpinHeight();
      var top = this.getTop();
      var canScroll = this.showScroll();
      var mergedVisible = canScroll && visible;
      return /* @__PURE__ */ react.exports.createElement("div", {
        ref: this.scrollbarRef,
        className: classnamesExports("".concat(prefixCls, "-scrollbar"), _defineProperty$2({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
        style: {
          width: 8,
          top: 0,
          bottom: 0,
          right: 0,
          position: "absolute",
          display: mergedVisible ? null : "none"
        },
        onMouseDown: this.onContainerMouseDown,
        onMouseMove: this.delayHidden
      }, /* @__PURE__ */ react.exports.createElement("div", {
        ref: this.thumbRef,
        className: classnamesExports("".concat(prefixCls, "-scrollbar-thumb"), _defineProperty$2({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
        style: {
          width: "100%",
          height: spinHeight,
          top,
          left: 0,
          position: "absolute",
          background: "rgba(0, 0, 0, 0.5)",
          borderRadius: 99,
          cursor: "pointer",
          userSelect: "none"
        },
        onMouseDown: this.onMouseDown
      }));
    }
  }]);
  return ScrollBar2;
}(react.exports.Component);
function Item$3(_ref) {
  var children = _ref.children, setRef = _ref.setRef;
  var refFunc = react.exports.useCallback(function(node) {
    setRef(node);
  }, []);
  return /* @__PURE__ */ react.exports.cloneElement(children, {
    ref: refFunc
  });
}
function useChildren(list2, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey2 = _ref.getKey;
  return list2.slice(startIndex, endIndex + 1).map(function(item, index2) {
    var eleIndex = startIndex + index2;
    var node = renderFunc(item, eleIndex, {});
    var key2 = getKey2(item);
    return /* @__PURE__ */ react.exports.createElement(Item$3, {
      key: key2,
      setRef: function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, node);
  });
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var CacheMap = /* @__PURE__ */ function() {
  function CacheMap2() {
    _classCallCheck(this, CacheMap2);
    this.maps = void 0;
    this.maps = /* @__PURE__ */ Object.create(null);
  }
  _createClass(CacheMap2, [{
    key: "set",
    value: function set2(key2, value2) {
      this.maps[key2] = value2;
    }
  }, {
    key: "get",
    value: function get2(key2) {
      return this.maps[key2];
    }
  }]);
  return CacheMap2;
}();
function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$2(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useHeights(getKey2, onItemAdd, onItemRemove) {
  var _React$useState = react.exports.useState(0), _React$useState2 = _slicedToArray$2(_React$useState, 2), updatedMark = _React$useState2[0], setUpdatedMark = _React$useState2[1];
  var instanceRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var heightsRef = react.exports.useRef(new CacheMap());
  var collectRafRef = react.exports.useRef();
  function cancelRaf() {
    wrapperRaf$1.cancel(collectRafRef.current);
  }
  function collectHeight() {
    cancelRaf();
    collectRafRef.current = wrapperRaf$1(function() {
      instanceRef.current.forEach(function(element, key2) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;
          if (heightsRef.current.get(key2) !== offsetHeight) {
            heightsRef.current.set(key2, htmlElement.offsetHeight);
          }
        }
      });
      setUpdatedMark(function(c2) {
        return c2 + 1;
      });
    });
  }
  function setInstanceRef(item, instance) {
    var key2 = getKey2(item);
    var origin = instanceRef.current.get(key2);
    if (instance) {
      instanceRef.current.set(key2, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key2);
    }
    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }
  react.exports.useEffect(function() {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function useScrollTo(containerRef, data2, heights, itemHeight, getKey2, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = react.exports.useRef();
  return function(arg) {
    if (arg === null || arg === void 0) {
      triggerFlash();
      return;
    }
    wrapperRaf$1.cancel(scrollRef.current);
    if (typeof arg === "number") {
      syncScrollTop(arg);
    } else if (arg && _typeof$1(arg) === "object") {
      var index2;
      var align = arg.align;
      if ("index" in arg) {
        index2 = arg.index;
      } else {
        index2 = data2.findIndex(function(item) {
          return getKey2(item) === arg.key;
        });
      }
      var _arg$offset = arg.offset, offset3 = _arg$offset === void 0 ? 0 : _arg$offset;
      var syncScroll = function syncScroll2(times2, targetAlign) {
        if (times2 < 0 || !containerRef.current)
          return;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign;
        if (height) {
          var mergedAlign = targetAlign || align;
          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data2.length, index2);
          for (var i = 0; i <= maxLen; i += 1) {
            var key2 = getKey2(data2[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key2);
            itemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
            stackTop = itemBottom;
            if (i === index2 && cacheHeight === void 0) {
              needCollectHeight = true;
            }
          }
          var targetTop = null;
          switch (mergedAlign) {
            case "top":
              targetTop = itemTop - offset3;
              break;
            case "bottom":
              targetTop = itemBottom - height + offset3;
              break;
            default: {
              var scrollTop = containerRef.current.scrollTop;
              var scrollBottom = scrollTop + height;
              if (itemTop < scrollTop) {
                newTargetAlign = "top";
              } else if (itemBottom > scrollBottom) {
                newTargetAlign = "bottom";
              }
            }
          }
          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
            syncScrollTop(targetTop);
          }
        }
        scrollRef.current = wrapperRaf$1(function() {
          if (needCollectHeight) {
            collectHeight();
          }
          syncScroll2(times2 - 1, newTargetAlign);
        });
      };
      syncScroll(3);
    }
  };
}
function findListDiffIndex(originList, targetList, getKey2) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;
  if (originLen === 0 && targetLen === 0) {
    return null;
  }
  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }
  var notExistKey = {
    __EMPTY_ITEM__: true
  };
  function getItemKey(item) {
    if (item !== void 0) {
      return getKey2(item);
    }
    return notExistKey;
  }
  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;
  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);
    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }
  return diffIndex === null ? null : {
    index: diffIndex,
    multiple
  };
}
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useDiffItem(data2, getKey2, onDiff) {
  var _React$useState = react.exports.useState(data2), _React$useState2 = _slicedToArray$1(_React$useState, 2), prevData = _React$useState2[0], setPrevData = _React$useState2[1];
  var _React$useState3 = react.exports.useState(null), _React$useState4 = _slicedToArray$1(_React$useState3, 2), diffItem = _React$useState4[0], setDiffItem = _React$useState4[1];
  react.exports.useEffect(function() {
    var diff = findListDiffIndex(prevData || [], data2 || [], getKey2);
    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== void 0) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
      setDiffItem(data2[diff.index]);
    }
    setPrevData(data2);
  }, [data2]);
  return [diffItem];
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var isFF = (typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const useOriginScroll = function(isScrollAtTop, isScrollAtBottom) {
  var lockRef = react.exports.useRef(false);
  var lockTimeoutRef = react.exports.useRef(null);
  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function() {
      lockRef.current = false;
    }, 50);
  }
  var scrollPingRef = react.exports.useRef({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function(deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var originScroll = deltaY < 0 && scrollPingRef.current.top || deltaY > 0 && scrollPingRef.current.bottom;
    if (smoothOffset && originScroll) {
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }
    return !lockRef.current && originScroll;
  };
};
function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = react.exports.useRef(0);
  var nextFrameRef = react.exports.useRef(null);
  var wheelValueRef = react.exports.useRef(null);
  var isMouseScrollRef = react.exports.useRef(false);
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onWheel(event) {
    if (!inVirtual)
      return;
    wrapperRaf$1.cancel(nextFrameRef.current);
    var deltaY = event.deltaY;
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY;
    if (originScroll(deltaY))
      return;
    if (!isFF) {
      event.preventDefault();
    }
    nextFrameRef.current = wrapperRaf$1(function() {
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  }
  function onFireFoxScroll(event) {
    if (!inVirtual)
      return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }
  return [onWheel, onFireFoxScroll];
}
var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = react.exports.useRef(false);
  var touchYRef = react.exports.useRef(0);
  var elementRef = react.exports.useRef(null);
  var intervalRef = react.exports.useRef(null);
  var cleanUpEvents;
  var onTouchMove = function onTouchMove2(e2) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e2.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;
      if (callback(offsetY)) {
        e2.preventDefault();
      }
      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function() {
        offsetY *= SMOOTH_PTG;
        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };
  var onTouchEnd = function onTouchEnd2() {
    touchedRef.current = false;
    cleanUpEvents();
  };
  var onTouchStart = function onTouchStart2(e2) {
    cleanUpEvents();
    if (e2.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e2.touches[0].pageY);
      elementRef.current = e2.target;
      elementRef.current.addEventListener("touchmove", onTouchMove);
      elementRef.current.addEventListener("touchend", onTouchEnd);
    }
  };
  cleanUpEvents = function cleanUpEvents2() {
    if (elementRef.current) {
      elementRef.current.removeEventListener("touchmove", onTouchMove);
      elementRef.current.removeEventListener("touchend", onTouchEnd);
    }
  };
  useLayoutEffect$1(function() {
    if (inVirtual) {
      listRef.current.addEventListener("touchstart", onTouchStart);
    }
    return function() {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener("touchstart", onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
var _excluded$n = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key2 in source) {
        if (Object.prototype.hasOwnProperty.call(source, key2)) {
          target[key2] = source[key2];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols2 = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols2);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
      _defineProperty$1(target, key2, source[key2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
      Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
    });
  }
  return target;
}
function _defineProperty$1(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key2, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key2 = sourceSymbolKeys[i];
      if (excluded.indexOf(key2) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key2))
        continue;
      target[key2] = source[key2];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key2, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key2 = sourceKeys[i];
    if (excluded.indexOf(key2) >= 0)
      continue;
    target[key2] = source[key2];
  }
  return target;
}
var EMPTY_DATA$1 = [];
var ScrollStyle = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-virtual-list" : _props$prefixCls, className = props.className, height = props.height, itemHeight = props.itemHeight, _props$fullHeight = props.fullHeight, fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight, style2 = props.style, data2 = props.data, children = props.children, itemKey2 = props.itemKey, virtual2 = props.virtual, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, onScroll = props.onScroll, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$n);
  var useVirtual = !!(virtual2 !== false && height && itemHeight);
  var inVirtual = useVirtual && data2 && itemHeight * data2.length > height;
  var _useState = react.exports.useState(0), _useState2 = _slicedToArray(_useState, 2), scrollTop = _useState2[0], setScrollTop = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray(_useState3, 2), scrollMoving = _useState4[0], setScrollMoving = _useState4[1];
  var mergedClassName = classnamesExports(prefixCls, className);
  var mergedData = data2 || EMPTY_DATA$1;
  var componentRef = react.exports.useRef();
  var fillerInnerRef = react.exports.useRef();
  var scrollBarRef = react.exports.useRef();
  var getKey2 = react.exports.useCallback(function(item) {
    if (typeof itemKey2 === "function") {
      return itemKey2(item);
    }
    return item === null || item === void 0 ? void 0 : item[itemKey2];
  }, [itemKey2]);
  var sharedConfig = {
    getKey: getKey2
  };
  function syncScrollTop(newTop) {
    setScrollTop(function(origin) {
      var value2;
      if (typeof newTop === "function") {
        value2 = newTop(origin);
      } else {
        value2 = newTop;
      }
      var alignedTop = keepInRange(value2);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  }
  var rangeRef = react.exports.useRef({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = react.exports.useRef();
  var _useDiffItem = useDiffItem(mergedData, getKey2), _useDiffItem2 = _slicedToArray(_useDiffItem, 1), diffItem = _useDiffItem2[0];
  diffItemRef.current = diffItem;
  var _useHeights = useHeights(getKey2, null, null), _useHeights2 = _slicedToArray(_useHeights, 4), setInstanceRef = _useHeights2[0], collectHeight = _useHeights2[1], heights = _useHeights2[2], heightUpdatedMark = _useHeights2[3];
  var _React$useMemo = react.exports.useMemo(function() {
    if (!useVirtual) {
      return {
        scrollHeight: void 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    if (!inVirtual) {
      var _fillerInnerRef$curre;
      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: void 0
      };
    }
    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;
    for (var i = 0; i < dataLen; i += 1) {
      var item = mergedData[i];
      var key2 = getKey2(item);
      var cacheHeight = heights.get(key2);
      var currentItemBottom = itemTop + (cacheHeight === void 0 ? itemHeight : cacheHeight);
      if (currentItemBottom >= scrollTop && startIndex === void 0) {
        startIndex = i;
        startOffset = itemTop;
      }
      if (currentItemBottom > scrollTop + height && endIndex === void 0) {
        endIndex = i;
      }
      itemTop = currentItemBottom;
    }
    if (startIndex === void 0) {
      startIndex = 0;
      startOffset = 0;
    }
    if (endIndex === void 0) {
      endIndex = mergedData.length - 1;
    }
    endIndex = Math.min(endIndex + 1, mergedData.length);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]), scrollHeight = _React$useMemo.scrollHeight, start = _React$useMemo.start, end = _React$useMemo.end, offset3 = _React$useMemo.offset;
  rangeRef.current.start = start;
  rangeRef.current.end = end;
  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = react.exports.useRef(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;
  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;
    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }
    newTop = Math.max(newTop, 0);
    return newTop;
  }
  var isScrollAtTop = scrollTop <= 0;
  var isScrollAtBottom = scrollTop >= maxScrollHeight;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);
  function onScrollBar(newScrollTop) {
    var newTop = newScrollTop;
    syncScrollTop(newTop);
  }
  function onFallbackScroll(e2) {
    var newScrollTop = e2.currentTarget.scrollTop;
    if (newScrollTop !== scrollTop) {
      syncScrollTop(newScrollTop);
    }
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e2);
  }
  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function(offsetY) {
    syncScrollTop(function(top) {
      var newTop = top + offsetY;
      return newTop;
    });
  }), _useFrameWheel2 = _slicedToArray(_useFrameWheel, 2), onRawWheel = _useFrameWheel2[0], onFireFoxScroll = _useFrameWheel2[1];
  useMobileTouchMove(useVirtual, componentRef, function(deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }
    onRawWheel({
      preventDefault: function preventDefault() {
      },
      deltaY
    });
    return true;
  });
  useLayoutEffect$1(function() {
    function onMozMousePixelScroll(e2) {
      if (useVirtual) {
        e2.preventDefault();
      }
    }
    componentRef.current.addEventListener("wheel", onRawWheel);
    componentRef.current.addEventListener("DOMMouseScroll", onFireFoxScroll);
    componentRef.current.addEventListener("MozMousePixelScroll", onMozMousePixelScroll);
    return function() {
      if (componentRef.current) {
        componentRef.current.removeEventListener("wheel", onRawWheel);
        componentRef.current.removeEventListener("DOMMouseScroll", onFireFoxScroll);
        componentRef.current.removeEventListener("MozMousePixelScroll", onMozMousePixelScroll);
      }
    };
  }, [useVirtual]);
  var scrollTo2 = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey2, collectHeight, syncScrollTop, function() {
    var _scrollBarRef$current;
    (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
  });
  react.exports.useImperativeHandle(ref, function() {
    return {
      scrollTo: scrollTo2
    };
  });
  useLayoutEffect$1(function() {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]);
  var listChildren = useChildren(mergedData, start, end, setInstanceRef, children, sharedConfig);
  var componentStyle = null;
  if (height) {
    componentStyle = _objectSpread(_defineProperty$1({}, fullHeight ? "height" : "maxHeight", height), ScrollStyle);
    if (useVirtual) {
      componentStyle.overflowY = "hidden";
      if (scrollMoving) {
        componentStyle.pointerEvents = "none";
      }
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", _extends({
    style: _objectSpread(_objectSpread({}, style2), {}, {
      position: "relative"
    }),
    className: mergedClassName
  }, restProps), /* @__PURE__ */ react.exports.createElement(Component2, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll
  }, /* @__PURE__ */ react.exports.createElement(Filler, {
    prefixCls,
    height: scrollHeight,
    offset: offset3,
    onInnerResize: collectHeight,
    ref: fillerInnerRef
  }, listChildren)), useVirtual && /* @__PURE__ */ react.exports.createElement(ScrollBar, {
    ref: scrollBarRef,
    prefixCls,
    scrollTop,
    height,
    scrollHeight,
    count: mergedData.length,
    onScroll: onScrollBar,
    onStartMove: function onStartMove() {
      setScrollMoving(true);
    },
    onStopMove: function onStopMove() {
      setScrollMoving(false);
    }
  }));
}
var List$2 = /* @__PURE__ */ react.exports.forwardRef(RawList);
List$2.displayName = "List";
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var SelectContext = /* @__PURE__ */ react.exports.createContext(null);
var _excluded$m = ["disabled", "title", "children", "style", "className"];
function isTitleType(content2) {
  return typeof content2 === "string" || typeof content2 === "number";
}
var OptionList = function OptionList2(_, ref) {
  var _useBaseProps = useBaseProps(), prefixCls = _useBaseProps.prefixCls, id2 = _useBaseProps.id, open = _useBaseProps.open, multiple = _useBaseProps.multiple, mode = _useBaseProps.mode, searchValue = _useBaseProps.searchValue, toggleOpen = _useBaseProps.toggleOpen, notFoundContent = _useBaseProps.notFoundContent, onPopupScroll = _useBaseProps.onPopupScroll;
  var _React$useContext = react.exports.useContext(SelectContext), flattenOptions2 = _React$useContext.flattenOptions, onActiveValue = _React$useContext.onActiveValue, defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption, onSelect = _React$useContext.onSelect, menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon, rawValues = _React$useContext.rawValues, fieldNames = _React$useContext.fieldNames, virtual2 = _React$useContext.virtual, listHeight = _React$useContext.listHeight, listItemHeight = _React$useContext.listItemHeight;
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var memoFlattenOptions = useMemo(function() {
    return flattenOptions2;
  }, [open, flattenOptions2], function(prev, next) {
    return next[0] && prev[1] !== next[1];
  });
  var listRef = react.exports.useRef(null);
  var onListMouseDown = function onListMouseDown2(event) {
    event.preventDefault();
  };
  var scrollIntoView2 = function scrollIntoView3(args) {
    if (listRef.current) {
      listRef.current.scrollTo(typeof args === "number" ? {
        index: args
      } : args);
    }
  };
  var getEnabledActiveIndex = function getEnabledActiveIndex2(index2) {
    var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var len = memoFlattenOptions.length;
    for (var i = 0; i < len; i += 1) {
      var current = (index2 + i * offset3 + len) % len;
      var _memoFlattenOptions$c = memoFlattenOptions[current], group = _memoFlattenOptions$c.group, data2 = _memoFlattenOptions$c.data;
      if (!group && !data2.disabled) {
        return current;
      }
    }
    return -1;
  };
  var _React$useState = react.exports.useState(function() {
    return getEnabledActiveIndex(0);
  }), _React$useState2 = _slicedToArray$3(_React$useState, 2), activeIndex = _React$useState2[0], setActiveIndex = _React$useState2[1];
  var setActive = function setActive2(index2) {
    var fromKeyboard = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    setActiveIndex(index2);
    var info2 = {
      source: fromKeyboard ? "keyboard" : "mouse"
    };
    var flattenItem = memoFlattenOptions[index2];
    if (!flattenItem) {
      onActiveValue(null, -1, info2);
      return;
    }
    onActiveValue(flattenItem.value, index2, info2);
  };
  react.exports.useEffect(function() {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]);
  var isSelected = react.exports.useCallback(function(value2) {
    return rawValues.has(value2) && mode !== "combobox";
  }, [mode, _toConsumableArray(rawValues).toString()]);
  react.exports.useEffect(function() {
    var timeoutId = setTimeout(function() {
      if (!multiple && open && rawValues.size === 1) {
        var value2 = Array.from(rawValues)[0];
        var index2 = memoFlattenOptions.findIndex(function(_ref) {
          var data2 = _ref.data;
          return data2.value === value2;
        });
        if (index2 !== -1) {
          setActive(index2);
          scrollIntoView2(index2);
        }
      }
    });
    if (open) {
      var _listRef$current;
      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(timeoutId);
    };
  }, [open, searchValue]);
  var onSelectValue = function onSelectValue2(value2) {
    if (value2 !== void 0) {
      onSelect(value2, {
        selected: !rawValues.has(value2)
      });
    }
    if (!multiple) {
      toggleOpen(false);
    }
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      onKeyDown: function onKeyDown2(event) {
        var which = event.which, ctrlKey = event.ctrlKey;
        switch (which) {
          case KeyCode.N:
          case KeyCode.P:
          case KeyCode.UP:
          case KeyCode.DOWN: {
            var offset3 = 0;
            if (which === KeyCode.UP) {
              offset3 = -1;
            } else if (which === KeyCode.DOWN) {
              offset3 = 1;
            } else if (isPlatformMac() && ctrlKey) {
              if (which === KeyCode.N) {
                offset3 = 1;
              } else if (which === KeyCode.P) {
                offset3 = -1;
              }
            }
            if (offset3 !== 0) {
              var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset3, offset3);
              scrollIntoView2(nextActiveIndex);
              setActive(nextActiveIndex, true);
            }
            break;
          }
          case KeyCode.ENTER: {
            var item = memoFlattenOptions[activeIndex];
            if (item && !item.data.disabled) {
              onSelectValue(item.value);
            } else {
              onSelectValue(void 0);
            }
            if (open) {
              event.preventDefault();
            }
            break;
          }
          case KeyCode.ESC: {
            toggleOpen(false);
            if (open) {
              event.stopPropagation();
            }
          }
        }
      },
      onKeyUp: function onKeyUp2() {
      },
      scrollTo: function scrollTo2(index2) {
        scrollIntoView2(index2);
      }
    };
  });
  if (memoFlattenOptions.length === 0) {
    return /* @__PURE__ */ react.exports.createElement("div", {
      role: "listbox",
      id: "".concat(id2, "_list"),
      className: "".concat(itemPrefixCls, "-empty"),
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }
  var omitFieldNameList = Object.keys(fieldNames).map(function(key2) {
    return fieldNames[key2];
  });
  var getLabel = function getLabel2(item) {
    return item.label;
  };
  var renderItem = function renderItem2(index2) {
    var item = memoFlattenOptions[index2];
    if (!item)
      return null;
    var itemData = item.data || {};
    var value2 = itemData.value;
    var group = item.group;
    var attrs = pickAttrs(itemData, true);
    var mergedLabel = getLabel(item);
    return item ? /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      "aria-label": typeof mergedLabel === "string" && !group ? mergedLabel : null
    }, attrs, {
      key: index2,
      role: group ? "presentation" : "option",
      id: "".concat(id2, "_list_").concat(index2),
      "aria-selected": isSelected(value2)
    }), value2) : null;
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("div", {
    role: "listbox",
    id: "".concat(id2, "_list"),
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }, renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /* @__PURE__ */ react.exports.createElement(List$2, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual: virtual2
  }, function(item, itemIndex) {
    var _classNames;
    var group = item.group, groupOption = item.groupOption, data2 = item.data, label = item.label, value2 = item.value;
    var key2 = data2.key;
    if (group) {
      var _data$title;
      var groupTitle = (_data$title = data2.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : void 0;
      return /* @__PURE__ */ react.exports.createElement("div", {
        className: classnamesExports(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
        title: groupTitle
      }, label !== void 0 ? label : key2);
    }
    var disabled = data2.disabled, title = data2.title;
    data2.children;
    var style2 = data2.style, className = data2.className, otherProps = _objectWithoutProperties$1(data2, _excluded$m);
    var passedProps = omit(otherProps, omitFieldNameList);
    var selected = isSelected(value2);
    var optionPrefixCls = "".concat(itemPrefixCls, "-option");
    var optionClassName = classnamesExports(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty$5(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty$5(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty$5(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
    var mergedLabel = getLabel(item);
    var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === "function" || selected;
    var content2 = typeof mergedLabel === "number" ? mergedLabel : mergedLabel || value2;
    var optionTitle = isTitleType(content2) ? content2.toString() : void 0;
    if (title !== void 0) {
      optionTitle = title;
    }
    return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, pickAttrs(passedProps), {
      "aria-selected": selected,
      className: optionClassName,
      title: optionTitle,
      onMouseMove: function onMouseMove() {
        if (activeIndex === itemIndex || disabled) {
          return;
        }
        setActive(itemIndex);
      },
      onClick: function onClick() {
        if (!disabled) {
          onSelectValue(value2);
        }
      },
      style: style2
    }), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(optionPrefixCls, "-content")
    }, content2), /* @__PURE__ */ react.exports.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /* @__PURE__ */ react.exports.createElement(TransBtn, {
      className: "".concat(itemPrefixCls, "-option-state"),
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        isSelected: selected
      }
    }, selected ? "\u2713" : null));
  }));
};
var RefOptionList = /* @__PURE__ */ react.exports.forwardRef(OptionList);
RefOptionList.displayName = "OptionList";
var _excluded$l = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];
var OMIT_DOM_PROPS = ["inputValue"];
function isRawValue(value2) {
  return !value2 || _typeof$4(value2) !== "object";
}
var Select$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var id2 = props.id, mode = props.mode, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-select" : _props$prefixCls, backfill = props.backfill, fieldNames = props.fieldNames, inputValue = props.inputValue, searchValue = props.searchValue, onSearch = props.onSearch, _props$autoClearSearc = props.autoClearSearchValue, autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$dropdownMatchS = props.dropdownMatchSelectWidth, dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS, filterOption = props.filterOption, filterSort = props.filterSort, optionFilterProp = props.optionFilterProp, optionLabelProp = props.optionLabelProp, options = props.options, children = props.children, defaultActiveFirstOption = props.defaultActiveFirstOption, menuItemSelectedIcon = props.menuItemSelectedIcon, virtual2 = props.virtual, _props$listHeight = props.listHeight, listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight, _props$listItemHeight = props.listItemHeight, listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight, value2 = props.value, defaultValue = props.defaultValue, labelInValue = props.labelInValue, onChange2 = props.onChange, restProps = _objectWithoutProperties$1(props, _excluded$l);
  var mergedId = useId(id2);
  var multiple = isMultiple(mode);
  var childrenAsData = !!(!options && children);
  var mergedFilterOption = react.exports.useMemo(function() {
    if (filterOption === void 0 && mode === "combobox") {
      return false;
    }
    return filterOption;
  }, [filterOption, mode]);
  var mergedFieldNames = react.exports.useMemo(function() {
    return fillFieldNames$1(fieldNames, childrenAsData);
  }, [
    JSON.stringify(fieldNames),
    childrenAsData
  ]);
  var _useMergedState = useMergedState("", {
    value: searchValue !== void 0 ? searchValue : inputValue,
    postState: function postState(search2) {
      return search2 || "";
    }
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), mergedSearchValue = _useMergedState2[0], setSearchValue = _useMergedState2[1];
  var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
  var valueOptions = parsedOptions.valueOptions, labelOptions = parsedOptions.labelOptions, mergedOptions = parsedOptions.options;
  var convert2LabelValues = react.exports.useCallback(function(draftValues) {
    var valueList = toArray$2(draftValues);
    return valueList.map(function(val) {
      var rawValue;
      var rawLabel;
      var rawKey;
      var rawDisabled;
      if (isRawValue(val)) {
        rawValue = val;
      } else {
        var _val$value;
        rawKey = val.key;
        rawLabel = val.label;
        rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
      }
      var option = valueOptions.get(rawValue);
      if (option) {
        var _option$key;
        if (rawLabel === void 0)
          rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
        if (rawKey === void 0)
          rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
        rawDisabled = option === null || option === void 0 ? void 0 : option.disabled;
      }
      return {
        label: rawLabel,
        value: rawValue,
        key: rawKey,
        disabled: rawDisabled
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]);
  var _useMergedState3 = useMergedState(defaultValue, {
    value: value2
  }), _useMergedState4 = _slicedToArray$3(_useMergedState3, 2), internalValue = _useMergedState4[0], setInternalValue = _useMergedState4[1];
  var rawLabeledValues = react.exports.useMemo(function() {
    var _values$;
    var values = convert2LabelValues(internalValue);
    if (mode === "combobox" && !((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
      return [];
    }
    return values;
  }, [internalValue, convert2LabelValues, mode]);
  var _useCache = useCache(rawLabeledValues, valueOptions), _useCache2 = _slicedToArray$3(_useCache, 2), mergedValues = _useCache2[0], getMixedOption = _useCache2[1];
  var displayValues = react.exports.useMemo(function() {
    if (!mode && mergedValues.length === 1) {
      var firstValue = mergedValues[0];
      if (firstValue.value === null && (firstValue.label === null || firstValue.label === void 0)) {
        return [];
      }
    }
    return mergedValues.map(function(item) {
      var _item$label;
      return _objectSpread2$4(_objectSpread2$4({}, item), {}, {
        label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
      });
    });
  }, [mode, mergedValues]);
  var rawValues = react.exports.useMemo(function() {
    return new Set(mergedValues.map(function(val) {
      return val.value;
    }));
  }, [mergedValues]);
  react.exports.useEffect(function() {
    if (mode === "combobox") {
      var _mergedValues$;
      var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;
      if (strValue !== void 0 && strValue !== null) {
        setSearchValue(String(strValue));
      }
    }
  }, [mergedValues]);
  var createTagOption = useRefFunc(function(val, label) {
    var _ref;
    var mergedLabel = label !== null && label !== void 0 ? label : val;
    return _ref = {}, _defineProperty$5(_ref, mergedFieldNames.value, val), _defineProperty$5(_ref, mergedFieldNames.label, mergedLabel), _ref;
  });
  var filledTagOptions = react.exports.useMemo(function() {
    if (mode !== "tags") {
      return mergedOptions;
    }
    var cloneOptions = _toConsumableArray(mergedOptions);
    var existOptions = function existOptions2(val) {
      return valueOptions.has(val);
    };
    _toConsumableArray(mergedValues).sort(function(a, b2) {
      return a.value < b2.value ? -1 : 1;
    }).forEach(function(item) {
      var val = item.value;
      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });
    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp);
  var filledSearchOptions = react.exports.useMemo(function() {
    if (mode !== "tags" || !mergedSearchValue || filteredOptions.some(function(item) {
      return item[optionFilterProp || "value"] === mergedSearchValue;
    })) {
      return filteredOptions;
    }
    return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
  }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue]);
  var orderedFilteredOptions = react.exports.useMemo(function() {
    if (!filterSort) {
      return filledSearchOptions;
    }
    return _toConsumableArray(filledSearchOptions).sort(function(a, b2) {
      return filterSort(a, b2);
    });
  }, [filledSearchOptions, filterSort]);
  var displayOptions = react.exports.useMemo(function() {
    return flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData
    });
  }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]);
  var triggerChange = function triggerChange2(values) {
    var labeledValues = convert2LabelValues(values);
    setInternalValue(labeledValues);
    if (onChange2 && (labeledValues.length !== mergedValues.length || labeledValues.some(function(newVal, index2) {
      var _mergedValues$index;
      return ((_mergedValues$index = mergedValues[index2]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
    }))) {
      var returnValues = labelInValue ? labeledValues : labeledValues.map(function(v2) {
        return v2.value;
      });
      var returnOptions = labeledValues.map(function(v2) {
        return injectPropsWithOption(getMixedOption(v2.value));
      });
      onChange2(multiple ? returnValues : returnValues[0], multiple ? returnOptions : returnOptions[0]);
    }
  };
  var _React$useState = react.exports.useState(null), _React$useState2 = _slicedToArray$3(_React$useState, 2), activeValue = _React$useState2[0], setActiveValue = _React$useState2[1];
  var _React$useState3 = react.exports.useState(0), _React$useState4 = _slicedToArray$3(_React$useState3, 2), accessibilityIndex = _React$useState4[0], setAccessibilityIndex = _React$useState4[1];
  var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== void 0 ? defaultActiveFirstOption : mode !== "combobox";
  var onActiveValue = react.exports.useCallback(function(active, index2) {
    var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$source = _ref2.source, source = _ref2$source === void 0 ? "keyboard" : _ref2$source;
    setAccessibilityIndex(index2);
    if (backfill && mode === "combobox" && active !== null && source === "keyboard") {
      setActiveValue(String(active));
    }
  }, [backfill, mode]);
  var triggerSelect = function triggerSelect2(val, selected) {
    var getSelectEnt = function getSelectEnt2() {
      var _option$key2;
      var option2 = getMixedOption(val);
      return [labelInValue ? {
        label: option2 === null || option2 === void 0 ? void 0 : option2[mergedFieldNames.label],
        value: val,
        key: (_option$key2 = option2 === null || option2 === void 0 ? void 0 : option2.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
      } : val, injectPropsWithOption(option2)];
    };
    if (selected && onSelect) {
      var _getSelectEnt = getSelectEnt(), _getSelectEnt2 = _slicedToArray$3(_getSelectEnt, 2), wrappedValue = _getSelectEnt2[0], option = _getSelectEnt2[1];
      onSelect(wrappedValue, option);
    } else if (!selected && onDeselect) {
      var _getSelectEnt3 = getSelectEnt(), _getSelectEnt4 = _slicedToArray$3(_getSelectEnt3, 2), _wrappedValue = _getSelectEnt4[0], _option = _getSelectEnt4[1];
      onDeselect(_wrappedValue, _option);
    }
  };
  var onInternalSelect = useRefFunc(function(val, info2) {
    var cloneValues;
    var mergedSelect = multiple ? info2.selected : true;
    if (mergedSelect) {
      cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
    } else {
      cloneValues = mergedValues.filter(function(v2) {
        return v2.value !== val;
      });
    }
    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect);
    if (mode === "combobox") {
      setActiveValue("");
    } else if (!isMultiple || autoClearSearchValue) {
      setSearchValue("");
      setActiveValue("");
    }
  });
  var onDisplayValuesChange = function onDisplayValuesChange2(nextValues, info2) {
    triggerChange(nextValues);
    if (info2.type === "remove" || info2.type === "clear") {
      info2.values.forEach(function(item) {
        triggerSelect(item.value, false);
      });
    }
  };
  var onInternalSearch = function onInternalSearch2(searchText, info2) {
    setSearchValue(searchText);
    setActiveValue(null);
    if (info2.source === "submit") {
      var formatted = (searchText || "").trim();
      if (formatted) {
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue("");
      }
      return;
    }
    if (info2.source !== "blur") {
      if (mode === "combobox") {
        triggerChange(searchText);
      }
      onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
    }
  };
  var onInternalSearchSplit = function onInternalSearchSplit2(words) {
    var patchValues = words;
    if (mode !== "tags") {
      patchValues = words.map(function(word) {
        var opt = labelOptions.get(word);
        return opt === null || opt === void 0 ? void 0 : opt.value;
      }).filter(function(val) {
        return val !== void 0;
      });
    }
    var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
    triggerChange(newRawValues);
    newRawValues.forEach(function(newRawValue) {
      triggerSelect(newRawValue, true);
    });
  };
  var selectContext = react.exports.useMemo(function() {
    var realVirtual = virtual2 !== false && dropdownMatchSelectWidth !== false;
    return _objectSpread2$4(_objectSpread2$4({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon,
      rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight,
      listItemHeight,
      childrenAsData
    });
  }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual2, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]);
  return /* @__PURE__ */ react.exports.createElement(SelectContext.Provider, {
    value: selectContext
  }, /* @__PURE__ */ react.exports.createElement(BaseSelect, _extends$2({}, restProps, {
    id: mergedId,
    prefixCls,
    ref,
    omitDomProps: OMIT_DOM_PROPS,
    mode,
    displayValues,
    onDisplayValuesChange,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSplit: onInternalSearchSplit,
    dropdownMatchSelectWidth,
    OptionList: RefOptionList,
    emptyOptions: !displayOptions.length,
    activeValue,
    activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
  })));
});
var TypedSelect = Select$2;
TypedSelect.Option = Option;
TypedSelect.OptGroup = OptGroup;
var Empty$2 = function Empty() {
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("empty-img-default");
  return /* @__PURE__ */ react.exports.createElement("svg", {
    className: prefixCls,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ react.exports.createElement("ellipse", {
    className: "".concat(prefixCls, "-ellipse"),
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-1"),
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-2"),
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-3"),
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-4"),
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z"
  })), /* @__PURE__ */ react.exports.createElement("path", {
    className: "".concat(prefixCls, "-path-5"),
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z"
  }), /* @__PURE__ */ react.exports.createElement("g", {
    className: "".concat(prefixCls, "-g"),
    transform: "translate(149.65 15.383)"
  }, /* @__PURE__ */ react.exports.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
const DefaultEmptyImg = Empty$2;
var Simple = function Simple2() {
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("empty-img-simple");
  return /* @__PURE__ */ react.exports.createElement("svg", {
    className: prefixCls,
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("ellipse", {
    className: "".concat(prefixCls, "-ellipse"),
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ react.exports.createElement("g", {
    className: "".concat(prefixCls, "-g"),
    fillRule: "nonzero"
  }, /* @__PURE__ */ react.exports.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    className: "".concat(prefixCls, "-path")
  }))));
};
const SimpleEmptyImg = Simple;
var __rest$C = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var defaultEmptyImg = /* @__PURE__ */ react.exports.createElement(DefaultEmptyImg, null);
var simpleEmptyImg = /* @__PURE__ */ react.exports.createElement(SimpleEmptyImg, null);
var Empty2 = function Empty3(_a) {
  var className = _a.className, customizePrefixCls = _a.prefixCls, _a$image = _a.image, image = _a$image === void 0 ? defaultEmptyImg : _a$image, description = _a.description, children = _a.children, imageStyle = _a.imageStyle, restProps = __rest$C(_a, ["className", "prefixCls", "image", "description", "children", "imageStyle"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  return /* @__PURE__ */ react.exports.createElement(LocaleReceiver, {
    componentName: "Empty"
  }, function(locale2) {
    var _classNames;
    var prefixCls = getPrefixCls("empty", customizePrefixCls);
    var des = typeof description !== "undefined" ? description : locale2.description;
    var alt = typeof des === "string" ? des : "empty";
    var imageNode = null;
    if (typeof image === "string") {
      imageNode = /* @__PURE__ */ react.exports.createElement("img", {
        alt,
        src: image
      });
    } else {
      imageNode = image;
    }
    return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
      className: classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-normal"), image === simpleEmptyImg), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className)
    }, restProps), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-image"),
      style: imageStyle
    }, imageNode), des && /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-description")
    }, des), children && /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-footer")
    }, children));
  });
};
Empty2.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
Empty2.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
const Empty$1 = Empty2;
var defaultRenderEmpty = function defaultRenderEmpty2(componentName) {
  return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, function(_ref) {
    var getPrefixCls = _ref.getPrefixCls;
    var prefix2 = getPrefixCls("empty");
    switch (componentName) {
      case "Table":
      case "List":
        return /* @__PURE__ */ react.exports.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE
        });
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return /* @__PURE__ */ react.exports.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE,
          className: "".concat(prefix2, "-small")
        });
      default:
        return /* @__PURE__ */ react.exports.createElement(Empty$1, null);
    }
  });
};
const defaultRenderEmpty$1 = defaultRenderEmpty;
var FormContext = /* @__PURE__ */ react.exports.createContext({
  labelAlign: "right",
  vertical: false,
  itemRef: function itemRef() {
  }
});
var NoStyleItemContext = /* @__PURE__ */ react.exports.createContext(null);
var FormProvider2 = function FormProvider3(props) {
  var providerProps = omit(props, ["prefixCls"]);
  return /* @__PURE__ */ react.exports.createElement(FormProvider$1, _extends$2({}, providerProps));
};
var FormItemPrefixContext = /* @__PURE__ */ react.exports.createContext({
  prefixCls: ""
});
var FormItemInputContext = /* @__PURE__ */ react.exports.createContext({});
var NoFormStyle = function NoFormStyle2(_ref) {
  var children = _ref.children, status = _ref.status, override = _ref.override;
  var formItemInputContext = react.exports.useContext(FormItemInputContext);
  var newFormItemInputContext = react.exports.useMemo(function() {
    var newContext = _extends$2({}, formItemInputContext);
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Provider, {
    value: newFormItemInputContext
  }, children);
};
var tuple = function tuple2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};
var tupleNum = function tupleNum2() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  return args;
};
var getCollapsedHeight = function getCollapsedHeight2() {
  return {
    height: 0,
    opacity: 0
  };
};
var getRealHeight = function getRealHeight2(node) {
  var scrollHeight = node.scrollHeight;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
var getCurrentHeight = function getCurrentHeight2(node) {
  return {
    height: node ? node.offsetHeight : 0
  };
};
var skipOpacityTransition = function skipOpacityTransition2(_, event) {
  return (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
};
var collapseMotion = {
  motionName: "ant-motion-collapse",
  onAppearStart: getCollapsedHeight,
  onEnterStart: getCollapsedHeight,
  onAppearActive: getRealHeight,
  onEnterActive: getRealHeight,
  onLeaveStart: getCurrentHeight,
  onLeaveActive: getCollapsedHeight,
  onAppearEnd: skipOpacityTransition,
  onEnterEnd: skipOpacityTransition,
  onLeaveEnd: skipOpacityTransition,
  motionDeadline: 500
};
tuple("bottomLeft", "bottomRight", "topLeft", "topRight");
var getTransitionDirection = function getTransitionDirection2(placement) {
  if (placement !== void 0 && (placement === "topLeft" || placement === "topRight")) {
    return "slide-down";
  }
  return "slide-up";
};
var getTransitionName = function getTransitionName2(rootPrefixCls, motion, transitionName2) {
  if (transitionName2 !== void 0) {
    return transitionName2;
  }
  return "".concat(rootPrefixCls, "-").concat(motion);
};
const collapseMotion$1 = collapseMotion;
tuple("warning", "error", "");
function getStatusClassNames(prefixCls, status, hasFeedback) {
  var _classNames;
  return classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-status-success"), status === "success"), _defineProperty$5(_classNames, "".concat(prefixCls, "-status-warning"), status === "warning"), _defineProperty$5(_classNames, "".concat(prefixCls, "-status-error"), status === "error"), _defineProperty$5(_classNames, "".concat(prefixCls, "-status-validating"), status === "validating"), _defineProperty$5(_classNames, "".concat(prefixCls, "-has-feedback"), hasFeedback), _classNames));
}
var getMergedStatus = function getMergedStatus2(contextStatus, customStatus) {
  return customStatus || contextStatus;
};
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
const CheckOutlinedSvg = CheckOutlined$2;
var CheckOutlined2 = function CheckOutlined3(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CheckOutlinedSvg
  }));
};
CheckOutlined2.displayName = "CheckOutlined";
const CheckOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CheckOutlined2);
var DownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, "name": "down", "theme": "outlined" };
const DownOutlinedSvg = DownOutlined$2;
var DownOutlined = function DownOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: DownOutlinedSvg
  }));
};
DownOutlined.displayName = "DownOutlined";
const DownOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(DownOutlined);
var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
const SearchOutlinedSvg = SearchOutlined$2;
var SearchOutlined = function SearchOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: SearchOutlinedSvg
  }));
};
SearchOutlined.displayName = "SearchOutlined";
const SearchOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(SearchOutlined);
function getIcons(_ref) {
  var suffixIcon = _ref.suffixIcon, clearIcon = _ref.clearIcon, menuItemSelectedIcon = _ref.menuItemSelectedIcon, removeIcon = _ref.removeIcon, loading = _ref.loading, multiple = _ref.multiple, hasFeedback = _ref.hasFeedback, prefixCls = _ref.prefixCls, showArrow = _ref.showArrow, feedbackIcon = _ref.feedbackIcon;
  var mergedClearIcon = clearIcon;
  if (!clearIcon) {
    mergedClearIcon = /* @__PURE__ */ react.exports.createElement(CloseCircleFilled$1, null);
  }
  var getSuffixIconNode = function getSuffixIconNode2(arrowIcon) {
    return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, showArrow !== false && arrowIcon, hasFeedback && feedbackIcon);
  };
  var mergedSuffixIcon = null;
  if (suffixIcon !== void 0) {
    mergedSuffixIcon = getSuffixIconNode(suffixIcon);
  } else if (loading) {
    mergedSuffixIcon = getSuffixIconNode(/* @__PURE__ */ react.exports.createElement(LoadingOutlined$1, {
      spin: true
    }));
  } else {
    var iconCls = "".concat(prefixCls, "-suffix");
    mergedSuffixIcon = function mergedSuffixIcon2(_ref2) {
      var open = _ref2.open, showSearch = _ref2.showSearch;
      if (open && showSearch) {
        return getSuffixIconNode(/* @__PURE__ */ react.exports.createElement(SearchOutlined$1, {
          className: iconCls
        }));
      }
      return getSuffixIconNode(/* @__PURE__ */ react.exports.createElement(DownOutlined$1, {
        className: iconCls
      }));
    };
  }
  var mergedItemIcon = null;
  if (menuItemSelectedIcon !== void 0) {
    mergedItemIcon = menuItemSelectedIcon;
  } else if (multiple) {
    mergedItemIcon = /* @__PURE__ */ react.exports.createElement(CheckOutlined$1, null);
  } else {
    mergedItemIcon = null;
  }
  var mergedRemoveIcon = null;
  if (removeIcon !== void 0) {
    mergedRemoveIcon = removeIcon;
  } else {
    mergedRemoveIcon = /* @__PURE__ */ react.exports.createElement(CloseOutlined$6, null);
  }
  return {
    clearIcon: mergedClearIcon,
    suffixIcon: mergedSuffixIcon,
    itemIcon: mergedItemIcon,
    removeIcon: mergedRemoveIcon
  };
}
var __rest$B = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var SECRET_COMBOBOX_MODE_DO_NOT_USE = "SECRET_COMBOBOX_MODE_DO_NOT_USE";
var InternalSelect = function InternalSelect2(_a, ref) {
  var _classNames2;
  var customizePrefixCls = _a.prefixCls, _a$bordered = _a.bordered, bordered = _a$bordered === void 0 ? true : _a$bordered, className = _a.className, getPopupContainer = _a.getPopupContainer, dropdownClassName = _a.dropdownClassName, _a$listHeight = _a.listHeight, listHeight = _a$listHeight === void 0 ? 256 : _a$listHeight, placement = _a.placement, _a$listItemHeight = _a.listItemHeight, listItemHeight = _a$listItemHeight === void 0 ? 24 : _a$listItemHeight, customizeSize = _a.size, customDisabled = _a.disabled, notFoundContent = _a.notFoundContent, customStatus = _a.status, showArrow = _a.showArrow, props = __rest$B(_a, ["prefixCls", "bordered", "className", "getPopupContainer", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "showArrow"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, renderEmpty = _React$useContext.renderEmpty, direction = _React$useContext.direction, virtual2 = _React$useContext.virtual, dropdownMatchSelectWidth = _React$useContext.dropdownMatchSelectWidth;
  var size = react.exports.useContext(SizeContext$1);
  var prefixCls = getPrefixCls("select", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var mode = react.exports.useMemo(function() {
    var m2 = props.mode;
    if (m2 === "combobox") {
      return void 0;
    }
    if (m2 === SECRET_COMBOBOX_MODE_DO_NOT_USE) {
      return "combobox";
    }
    return m2;
  }, [props.mode]);
  var isMultiple2 = mode === "multiple" || mode === "tags";
  var mergedShowArrow = showArrow !== void 0 ? showArrow : props.loading || !(isMultiple2 || mode === "combobox");
  var _useContext = react.exports.useContext(FormItemInputContext), contextStatus = _useContext.status, hasFeedback = _useContext.hasFeedback, isFormItemInput = _useContext.isFormItemInput, feedbackIcon = _useContext.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var mergedNotFound;
  if (notFoundContent !== void 0) {
    mergedNotFound = notFoundContent;
  } else if (mode === "combobox") {
    mergedNotFound = null;
  } else {
    mergedNotFound = (renderEmpty || defaultRenderEmpty$1)("Select");
  }
  var _getIcons = getIcons(_extends$2(_extends$2({}, props), {
    multiple: isMultiple2,
    hasFeedback,
    feedbackIcon,
    showArrow: mergedShowArrow,
    prefixCls
  })), suffixIcon = _getIcons.suffixIcon, itemIcon = _getIcons.itemIcon, removeIcon = _getIcons.removeIcon, clearIcon = _getIcons.clearIcon;
  var selectProps = omit(props, ["suffixIcon", "itemIcon"]);
  var rcSelectRtlDropdownClassName = classnamesExports(dropdownClassName, _defineProperty$5({}, "".concat(prefixCls, "-dropdown-").concat(direction), direction === "rtl"));
  var mergedSize = customizeSize || size;
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var mergedClassName = classnamesExports((_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-lg"), mergedSize === "large"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-sm"), mergedSize === "small"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-borderless"), !bordered), _defineProperty$5(_classNames2, "".concat(prefixCls, "-in-form-item"), isFormItemInput), _classNames2), getStatusClassNames(prefixCls, mergedStatus, hasFeedback), className);
  var getPlacement = function getPlacement2() {
    if (placement !== void 0) {
      return placement;
    }
    return direction === "rtl" ? "bottomRight" : "bottomLeft";
  };
  return /* @__PURE__ */ react.exports.createElement(TypedSelect, _extends$2({
    ref,
    virtual: virtual2,
    dropdownMatchSelectWidth
  }, selectProps, {
    transitionName: getTransitionName(rootPrefixCls, getTransitionDirection(placement), props.transitionName),
    listHeight,
    listItemHeight,
    mode,
    prefixCls,
    placement: getPlacement(),
    direction,
    inputIcon: suffixIcon,
    menuItemSelectedIcon: itemIcon,
    removeIcon,
    clearIcon,
    notFoundContent: mergedNotFound,
    className: mergedClassName,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    dropdownClassName: rcSelectRtlDropdownClassName,
    showArrow: hasFeedback || showArrow,
    disabled: mergedDisabled
  }));
};
var Select = /* @__PURE__ */ react.exports.forwardRef(InternalSelect);
Select.SECRET_COMBOBOX_MODE_DO_NOT_USE = SECRET_COMBOBOX_MODE_DO_NOT_USE;
Select.Option = Option;
Select.OptGroup = OptGroup;
const Select$1 = Select;
function useForceUpdate() {
  var _React$useReducer = react.exports.useReducer(function(x2) {
    return x2 + 1;
  }, 0), _React$useReducer2 = _slicedToArray$3(_React$useReducer, 2), forceUpdate = _React$useReducer2[1];
  return forceUpdate;
}
var responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
var responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
};
var subscribers = /* @__PURE__ */ new Map();
var subUid = -1;
var screens = {};
var responsiveObserve = {
  matchHandlers: {},
  dispatch: function dispatch(pointMap) {
    screens = pointMap;
    subscribers.forEach(function(func) {
      return func(screens);
    });
    return subscribers.size >= 1;
  },
  subscribe: function subscribe3(func) {
    if (!subscribers.size)
      this.register();
    subUid += 1;
    subscribers.set(subUid, func);
    func(screens);
    return subUid;
  },
  unsubscribe: function unsubscribe(token) {
    subscribers["delete"](token);
    if (!subscribers.size)
      this.unregister();
  },
  unregister: function unregister() {
    var _this = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var handler2 = _this.matchHandlers[matchMediaQuery];
      handler2 === null || handler2 === void 0 ? void 0 : handler2.mql.removeListener(handler2 === null || handler2 === void 0 ? void 0 : handler2.listener);
    });
    subscribers.clear();
  },
  register: function register3() {
    var _this2 = this;
    Object.keys(responsiveMap).forEach(function(screen) {
      var matchMediaQuery = responsiveMap[screen];
      var listener = function listener2(_ref) {
        var matches = _ref.matches;
        _this2.dispatch(_extends$2(_extends$2({}, screens), _defineProperty$5({}, screen, matches)));
      };
      var mql = window.matchMedia(matchMediaQuery);
      mql.addListener(listener);
      _this2.matchHandlers[matchMediaQuery] = {
        mql,
        listener
      };
      listener(mql);
    });
  }
};
function useBreakpoint() {
  var refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  var screensRef = react.exports.useRef({});
  var forceUpdate = useForceUpdate();
  react.exports.useEffect(function() {
    var token = responsiveObserve.subscribe(function(supportScreens) {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return function() {
      return responsiveObserve.unsubscribe(token);
    };
  }, []);
  return screensRef.current;
}
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$2 = [0, 0];
var placements$2 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};
function Popup(props) {
  var showArrow = props.showArrow, arrowContent = props.arrowContent, children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: classnamesExports("".concat(prefixCls, "-content"), className),
    style: style2
  }, showArrow !== false && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-arrow"),
    key: "arrow"
  }, arrowContent), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-inner"),
    id: id2,
    role: "tooltip",
    style: overlayInnerStyle
  }, typeof children === "function" ? children() : children));
}
var Tooltip$2 = function Tooltip(props, ref) {
  var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger3 = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName2 = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle, arrowContent = props.arrowContent, overlay = props.overlay, id2 = props.id, showArrow = props.showArrow, restProps = _objectWithoutProperties$1(props, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"]);
  var domRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return domRef.current;
  });
  var extraProps = _objectSpread2$4({}, restProps);
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  var getPopupElement = function getPopupElement2() {
    return /* @__PURE__ */ react.exports.createElement(Popup, {
      showArrow,
      arrowContent,
      key: "content",
      prefixCls,
      id: id2,
      overlayInnerStyle
    }, overlay);
  };
  var destroyTooltip = false;
  var autoDestroy = false;
  if (typeof destroyTooltipOnHide === "boolean") {
    destroyTooltip = destroyTooltipOnHide;
  } else if (destroyTooltipOnHide && _typeof$4(destroyTooltipOnHide) === "object") {
    var keepParent = destroyTooltipOnHide.keepParent;
    destroyTooltip = keepParent === true;
    autoDestroy = keepParent === false;
  }
  return /* @__PURE__ */ react.exports.createElement(Trigger, _extends$2({
    popupClassName: overlayClassName,
    prefixCls,
    popup: getPopupElement,
    action: trigger3,
    builtinPlacements: placements$2,
    popupPlacement: placement,
    ref: domRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName2,
    popupAnimation: animation,
    popupMotion: motion,
    defaultPopupVisible: defaultVisible,
    destroyPopupOnHide: destroyTooltip,
    autoDestroy,
    mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay
  }, extraProps), children);
};
const Tooltip$3 = /* @__PURE__ */ react.exports.forwardRef(Tooltip$2);
tuple("success", "processing", "error", "default", "warning");
var PresetColorTypes = tuple("pink", "red", "yellow", "orange", "cyan", "green", "blue", "purple", "geekblue", "magenta", "volcano", "gold", "lime");
var autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
var autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
var targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow2) {
  if (typeof autoAdjustOverflow2 === "boolean") {
    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return _extends$2(_extends$2({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
}
function getPlacements(config) {
  var _config$arrowWidth = config.arrowWidth, arrowWidth = _config$arrowWidth === void 0 ? 4 : _config$arrowWidth, _config$horizontalArr = config.horizontalArrowShift, horizontalArrowShift = _config$horizontalArr === void 0 ? 16 : _config$horizontalArr, _config$verticalArrow = config.verticalArrowShift, verticalArrowShift = _config$verticalArrow === void 0 ? 8 : _config$verticalArrow, autoAdjustOverflow2 = config.autoAdjustOverflow, arrowPointAtCenter = config.arrowPointAtCenter;
  var placementMap = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(horizontalArrowShift + arrowWidth), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(verticalArrowShift + arrowWidth)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [horizontalArrowShift + arrowWidth, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(verticalArrowShift + arrowWidth)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [horizontalArrowShift + arrowWidth, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, verticalArrowShift + arrowWidth]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(horizontalArrowShift + arrowWidth), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, verticalArrowShift + arrowWidth]
    }
  };
  Object.keys(placementMap).forEach(function(key2) {
    placementMap[key2] = arrowPointAtCenter ? _extends$2(_extends$2({}, placementMap[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2),
      targetOffset: targetOffset$1
    }) : _extends$2(_extends$2({}, placements$2[key2]), {
      overflow: getOverflowOptions(autoAdjustOverflow2)
    });
    placementMap[key2].ignoreShake = true;
  });
  return placementMap;
}
var __rest$A = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var splitObject = function splitObject2(obj, keys2) {
  var picked = {};
  var omitted = _extends$2({}, obj);
  keys2.forEach(function(key2) {
    if (obj && key2 in obj) {
      picked[key2] = obj[key2];
      delete omitted[key2];
    }
  });
  return {
    picked,
    omitted
  };
};
var PresetColorRegex = new RegExp("^(".concat(PresetColorTypes.join("|"), ")(-inverse)?$"));
function getDisabledCompatibleChildren(element, prefixCls) {
  var elementType = element.type;
  if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
    var _splitObject = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), picked = _splitObject.picked, omitted = _splitObject.omitted;
    var spanStyle = _extends$2(_extends$2({
      display: "inline-block"
    }, picked), {
      cursor: "not-allowed",
      width: element.props.block ? "100%" : null
    });
    var buttonStyle = _extends$2(_extends$2({}, omitted), {
      pointerEvents: "none"
    });
    var child = cloneElement(element, {
      style: buttonStyle,
      className: null
    });
    return /* @__PURE__ */ react.exports.createElement("span", {
      style: spanStyle,
      className: classnamesExports(element.props.className, "".concat(prefixCls, "-disabled-compatible-wrapper"))
    }, child);
  }
  return element;
}
var Tooltip2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames2;
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var _useMergedState = useMergedState(false, {
    value: props.visible,
    defaultValue: props.defaultVisible
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), visible = _useMergedState2[0], setVisible = _useMergedState2[1];
  var isNoTitle = function isNoTitle2() {
    var title = props.title, overlay = props.overlay;
    return !title && !overlay && title !== 0;
  };
  var onVisibleChange = function onVisibleChange2(vis) {
    var _a;
    setVisible(isNoTitle() ? false : vis);
    if (!isNoTitle()) {
      (_a = props.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(props, vis);
    }
  };
  var getTooltipPlacements = function getTooltipPlacements2() {
    var builtinPlacements = props.builtinPlacements, arrowPointAtCenter = props.arrowPointAtCenter, autoAdjustOverflow2 = props.autoAdjustOverflow;
    return builtinPlacements || getPlacements({
      arrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow2
    });
  };
  var onPopupAlign = function onPopupAlign2(domNode, align) {
    var placements2 = getTooltipPlacements();
    var placement = Object.keys(placements2).find(function(key2) {
      return placements2[key2].points[0] === align.points[0] && placements2[key2].points[1] === align.points[1];
    });
    if (!placement) {
      return;
    }
    var rect = domNode.getBoundingClientRect();
    var transformOrigin = {
      top: "50%",
      left: "50%"
    };
    if (placement.indexOf("top") >= 0 || placement.indexOf("Bottom") >= 0) {
      transformOrigin.top = "".concat(rect.height - align.offset[1], "px");
    } else if (placement.indexOf("Top") >= 0 || placement.indexOf("bottom") >= 0) {
      transformOrigin.top = "".concat(-align.offset[1], "px");
    }
    if (placement.indexOf("left") >= 0 || placement.indexOf("Right") >= 0) {
      transformOrigin.left = "".concat(rect.width - align.offset[0], "px");
    } else if (placement.indexOf("right") >= 0 || placement.indexOf("Left") >= 0) {
      transformOrigin.left = "".concat(-align.offset[0], "px");
    }
    domNode.style.transformOrigin = "".concat(transformOrigin.left, " ").concat(transformOrigin.top);
  };
  var getOverlay = function getOverlay2() {
    var title = props.title, overlay = props.overlay;
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  };
  var getPopupContainer = props.getPopupContainer, otherProps = __rest$A(props, ["getPopupContainer"]);
  var customizePrefixCls = props.prefixCls, openClassName = props.openClassName, getTooltipContainer = props.getTooltipContainer, overlayClassName = props.overlayClassName, color2 = props.color, overlayInnerStyle = props.overlayInnerStyle, children = props.children;
  var prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  var rootPrefixCls = getPrefixCls();
  var tempVisible = visible;
  if (!("visible" in props) && isNoTitle()) {
    tempVisible = false;
  }
  var child = getDisabledCompatibleChildren(isValidElement(children) ? children : /* @__PURE__ */ react.exports.createElement("span", null, children), prefixCls);
  var childProps = child.props;
  var childCls = classnamesExports(childProps.className, _defineProperty$5({}, openClassName || "".concat(prefixCls, "-open"), true));
  var customOverlayClassName = classnamesExports(overlayClassName, (_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-").concat(color2), color2 && PresetColorRegex.test(color2)), _classNames2));
  var formattedOverlayInnerStyle = overlayInnerStyle;
  var arrowContentStyle;
  if (color2 && !PresetColorRegex.test(color2)) {
    formattedOverlayInnerStyle = _extends$2(_extends$2({}, overlayInnerStyle), {
      background: color2
    });
    arrowContentStyle = {
      "--antd-arrow-background-color": color2
    };
  }
  return /* @__PURE__ */ react.exports.createElement(Tooltip$3, _extends$2({}, otherProps, {
    prefixCls,
    overlayClassName: customOverlayClassName,
    getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
    ref,
    builtinPlacements: getTooltipPlacements(),
    overlay: getOverlay(),
    visible: tempVisible,
    onVisibleChange,
    onPopupAlign,
    overlayInnerStyle: formattedOverlayInnerStyle,
    arrowContent: /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-arrow-content"),
      style: arrowContentStyle
    }),
    motion: {
      motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
      motionDeadline: 1e3
    }
  }), tempVisible ? cloneElement(child, {
    className: childCls
  }) : child);
});
Tooltip2.defaultProps = {
  placement: "top",
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: false,
  autoAdjustOverflow: true
};
const Tooltip$1 = Tooltip2;
var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
const EllipsisOutlinedSvg = EllipsisOutlined$2;
var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: EllipsisOutlinedSvg
  }));
};
EllipsisOutlined.displayName = "EllipsisOutlined";
const EllipsisOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EllipsisOutlined);
var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key2 = keysA[idx];
    if (!bHasOwnProperty(key2)) {
      return false;
    }
    var valueA = objA[key2];
    var valueB = objB[key2];
    ret = compare ? compare.call(compareContext, valueA, valueB, key2) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
};
var _excluded$k = ["children", "locked"];
var MenuContext$2 = /* @__PURE__ */ react.exports.createContext(null);
function mergeProps(origin, target) {
  var clone2 = _objectSpread2$4({}, origin);
  Object.keys(target).forEach(function(key2) {
    var value2 = target[key2];
    if (value2 !== void 0) {
      clone2[key2] = value2;
    }
  });
  return clone2;
}
function InheritableContextProvider(_ref) {
  var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties$1(_ref, _excluded$k);
  var context2 = react.exports.useContext(MenuContext$2);
  var inheritableContext = useMemo(function() {
    return mergeProps(context2, restProps);
  }, [context2, restProps], function(prev, next) {
    return !locked && (prev[0] !== next[0] || !shallowequal(prev[1], next[1]));
  });
  return /* @__PURE__ */ react.exports.createElement(MenuContext$2.Provider, {
    value: inheritableContext
  }, children);
}
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = react.exports.useContext(MenuContext$2), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = function(domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function(domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
var _excluded$j = ["item"];
function warnItemProp(_ref) {
  var item = _ref.item, restInfo = _objectWithoutProperties$1(_ref, _excluded$j);
  Object.defineProperty(restInfo, "item", {
    get: function get2() {
      warningOnce(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}
function Icon$1(_ref) {
  var icon = _ref.icon, props = _ref.props, children = _ref.children;
  var iconNode;
  if (typeof icon === "function") {
    iconNode = /* @__PURE__ */ react.exports.createElement(icon, _objectSpread2$4({}, props));
  } else {
    iconNode = icon;
  }
  return iconNode || children || null;
}
function useDirectionStyle(level) {
  var _React$useContext = react.exports.useContext(MenuContext$2), mode = _React$useContext.mode, rtl2 = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
  if (mode !== "inline") {
    return null;
  }
  var len = level;
  return rtl2 ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
var EmptyList = [];
var PathRegisterContext = /* @__PURE__ */ react.exports.createContext(null);
function useMeasure() {
  return react.exports.useContext(PathRegisterContext);
}
var PathTrackerContext = /* @__PURE__ */ react.exports.createContext(EmptyList);
function useFullPath$1(eventKey) {
  var parentKeyPath = react.exports.useContext(PathTrackerContext);
  return react.exports.useMemo(function() {
    return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}
var PathUserContext = /* @__PURE__ */ react.exports.createContext(null);
var IdContext = /* @__PURE__ */ react.exports.createContext(null);
function getMenuId(uuid2, eventKey) {
  if (uuid2 === void 0) {
    return null;
  }
  return "".concat(uuid2, "-").concat(eventKey);
}
function useMenuId(eventKey) {
  var id2 = react.exports.useContext(IdContext);
  return getMenuId(id2, eventKey);
}
var PrivateContext = /* @__PURE__ */ react.exports.createContext({});
var _excluded$i = ["title", "attribute", "elementRef"], _excluded2$3 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(LegacyMenuItem2, _React$Component);
  var _super = _createSuper$1(LegacyMenuItem2);
  function LegacyMenuItem2() {
    _classCallCheck$2(this, LegacyMenuItem2);
    return _super.apply(this, arguments);
  }
  _createClass$2(LegacyMenuItem2, [{
    key: "render",
    value: function render2() {
      var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties$1(_this$props, _excluded$i);
      var passedProps = omit(restProps, ["eventKey"]);
      warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
      return /* @__PURE__ */ react.exports.createElement(ForwardOverflow.Item, _extends$2({}, attribute, {
        title: typeof title === "string" ? title : void 0
      }, passedProps, {
        ref: elementRef
      }));
    }
  }]);
  return LegacyMenuItem2;
}(react.exports.Component);
var InternalMenuItem = function InternalMenuItem2(props) {
  var _classNames;
  var style2 = props.style, className = props.className, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus2 = props.onFocus, restProps = _objectWithoutProperties$1(props, _excluded2$3);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var connectedKeys = useFullPath$1(eventKey);
  var getEventInfo = function getEventInfo2(e2) {
    return {
      key: eventKey,
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e2
    };
  };
  var mergedItemIcon = itemIcon || contextItemIcon;
  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded3);
  var selected = selectedKeys.includes(eventKey);
  var directionStyle = useDirectionStyle(connectedKeys.length);
  var onInternalClick = function onInternalClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    var info2 = getEventInfo(e2);
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
    onItemClick(info2);
  };
  var onInternalKeyDown = function onInternalKeyDown2(e2) {
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
    if (e2.which === KeyCode.ENTER) {
      var info2 = getEventInfo(e2);
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
      onItemClick(info2);
    }
  };
  var onInternalFocus = function onInternalFocus2(e2) {
    onActive(eventKey);
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e2);
  };
  var optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  var renderNode = /* @__PURE__ */ react.exports.createElement(LegacyMenuItem, _extends$2({
    ref: legacyMenuItemRef,
    elementRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId
  }, restProps, activeProps, optionRoleProps, {
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$4(_objectSpread2$4({}, directionStyle), style2),
    className: classnamesExports(itemCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$5(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$5(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus
  }), children, /* @__PURE__ */ react.exports.createElement(Icon$1, {
    props: _objectSpread2$4(_objectSpread2$4({}, props), {}, {
      isSelected: selected
    }),
    icon: mergedItemIcon
  }));
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
};
function MenuItem$1(props) {
  var eventKey = props.eventKey;
  var measure = useMeasure();
  var connectedKeyPath = useFullPath$1(eventKey);
  react.exports.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(InternalMenuItem, props);
}
var _excluded$h = ["label", "children", "key", "type"];
function parseChildren(children, keyPath) {
  return toArray$4(children).map(function(child, index2) {
    if (/* @__PURE__ */ react.exports.isValidElement(child)) {
      var _child$props$eventKey, _child$props;
      var key2 = child.key;
      var eventKey = (_child$props$eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _child$props$eventKey !== void 0 ? _child$props$eventKey : key2;
      var emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
      }
      var cloneProps = {
        key: eventKey,
        eventKey
      };
      return /* @__PURE__ */ react.exports.cloneElement(child, cloneProps);
    }
    return child;
  });
}
function convertItemsToNodes$1(list2) {
  return (list2 || []).map(function(opt, index2) {
    if (opt && _typeof$4(opt) === "object") {
      var label = opt.label, children = opt.children, key2 = opt.key, type4 = opt.type, restProps = _objectWithoutProperties$1(opt, _excluded$h);
      var mergedKey = key2 !== null && key2 !== void 0 ? key2 : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ react.exports.createElement(MenuItemGroup, _extends$2({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes$1(children));
        }
        return /* @__PURE__ */ react.exports.createElement(SubMenu$2, _extends$2({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes$1(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ react.exports.createElement(Divider, _extends$2({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ react.exports.createElement(MenuItem$1, _extends$2({
        key: mergedKey
      }, restProps), label);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes$1(items);
  }
  return parseChildren(childNodes, keyPath);
}
function useMemoCallback(func) {
  var funRef = react.exports.useRef(func);
  funRef.current = func;
  var callback = react.exports.useCallback(function() {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : void 0;
}
var _excluded$g = ["className", "children"];
var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
  var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties$1(_ref, _excluded$g);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl2 = _React$useContext.rtl;
  return /* @__PURE__ */ react.exports.createElement("ul", _extends$2({
    className: classnamesExports(prefixCls, rtl2 && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className)
  }, restProps, {
    "data-menu-list": true,
    ref
  }), children);
};
var SubMenuList = /* @__PURE__ */ react.exports.forwardRef(InternalSubMenuList);
SubMenuList.displayName = "SubMenuList";
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
function getMotion(mode, motion, defaultMotions) {
  if (motion) {
    return motion;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
  var _React$useContext = react.exports.useContext(MenuContext$2), getPopupContainer = _React$useContext.getPopupContainer, rtl2 = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
  var placement = rtl2 ? _objectSpread2$4(_objectSpread2$4({}, placementsRtl), builtinPlacements) : _objectSpread2$4(_objectSpread2$4({}, placements$1), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion(mode, motion, defaultMotions);
  var mergedMotion = _objectSpread2$4(_objectSpread2$4({}, targetMotion), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });
  var visibleRef = react.exports.useRef();
  react.exports.useEffect(function() {
    visibleRef.current = wrapperRaf$1(function() {
      setInnerVisible(visible);
    });
    return function() {
      wrapperRaf$1.cancel(visibleRef.current);
    };
  }, [visible]);
  return /* @__PURE__ */ react.exports.createElement(Trigger, {
    prefixCls,
    popupClassName: classnamesExports("".concat(prefixCls, "-popup"), _defineProperty$5({}, "".concat(prefixCls, "-rtl"), rtl2), popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion
  }, children);
}
function InlineSubMenuList(_ref) {
  var id2 = _ref.id, open = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
  var fixedMode = "inline";
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
  var sameModeRef = react.exports.useRef(false);
  sameModeRef.current = mode === fixedMode;
  var _React$useState = react.exports.useState(!sameModeRef.current), _React$useState2 = _slicedToArray$3(_React$useState, 2), destroy3 = _React$useState2[0], setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open : false;
  react.exports.useEffect(function() {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  var mergedMotion = _objectSpread2$4({}, getMotion(fixedMode, motion, defaultMotions));
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function(newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy3) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current
  }, /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
    visible: mergedOpen
  }, mergedMotion, {
    forceRender: forceSubMenuRender,
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }), function(_ref2) {
    var motionClassName = _ref2.className, motionStyle = _ref2.style;
    return /* @__PURE__ */ react.exports.createElement(SubMenuList, {
      id: id2,
      className: motionClassName,
      style: motionStyle
    }, children);
  }));
}
var _excluded$f = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$2 = ["active"];
var InternalSubMenu = function InternalSubMenu2(props) {
  var _classNames;
  var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties$1(props, _excluded$f);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = react.exports.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath$1();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = react.exports.useRef();
  var popupRef = react.exports.useRef();
  var mergedItemIcon = itemIcon || contextItemIcon;
  var mergedExpandIcon = expandIcon || contextExpandIcon;
  var originOpen = openKeys.includes(eventKey);
  var open = !overflowDisabled && originOpen;
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);
  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties$1(_useActive, _excluded2$2);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive2(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent
    });
  };
  var mergedActive = react.exports.useMemo(function() {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  var directionStyle = useDirectionStyle(connectedPath.length);
  var onInternalTitleClick = function onInternalTitleClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e2
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  var onMergedItemClick = useMemoCallback(function(info2) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
    onItemClick(info2);
  });
  var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  var onInternalFocus = function onInternalFocus2() {
    onActive(eventKey);
  };
  var popupId = domDataId && "".concat(domDataId, "-popup");
  var titleNode = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus
  }, activeProps), title, /* @__PURE__ */ react.exports.createElement(Icon$1, {
    icon: mode !== "horizontal" ? mergedExpandIcon : null,
    props: _objectSpread2$4(_objectSpread2$4({}, props), {}, {
      isOpen: open,
      isSubMenu: true
    })
  }, /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(subMenuPrefixCls, "-arrow")
  })));
  var triggerModeRef = react.exports.useRef(mode);
  if (mode !== "inline") {
    triggerModeRef.current = connectedPath.length > 1 ? "vertical" : mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;
    titleNode = /* @__PURE__ */ react.exports.createElement(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open && mode !== "inline",
      popupClassName,
      popupOffset,
      popup: /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
        mode: triggerMode === "horizontal" ? "vertical" : triggerMode
      }, /* @__PURE__ */ react.exports.createElement(SubMenuList, {
        id: popupId,
        ref: popupRef
      }, children)),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange
    }, titleNode);
  }
  var listNode = /* @__PURE__ */ react.exports.createElement(ForwardOverflow.Item, _extends$2({
    role: "none"
  }, restProps, {
    component: "li",
    style: style2,
    className: classnamesExports(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(subMenuPrefixCls, "-open"), open), _defineProperty$5(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$5(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$5(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave
  }), titleNode, !overflowDisabled && /* @__PURE__ */ react.exports.createElement(InlineSubMenuList, {
    id: popupId,
    open,
    keyPath: connectedPath
  }, children));
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open,
      disabled: mergedDisabled
    });
  }
  return /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon
  }, listNode);
};
function SubMenu$2(props) {
  var eventKey = props.eventKey, children = props.children;
  var connectedKeyPath = useFullPath$1(eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  react.exports.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /* @__PURE__ */ react.exports.createElement(InternalSubMenu, props, childList);
  }
  return /* @__PURE__ */ react.exports.createElement(PathTrackerContext.Provider, {
    value: connectedKeyPath
  }, renderNode);
}
function focusable(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isVisible(node)) {
    var nodeName = node.nodeName.toLowerCase();
    var isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node.isContentEditable || nodeName === "a" && !!node.getAttribute("href");
    var tabIndexAttr = node.getAttribute("tabindex");
    var tabIndexNum = Number(tabIndexAttr);
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var res = _toConsumableArray(node.querySelectorAll("*")).filter(function(child) {
    return focusable(child, includePositive);
  });
  if (focusable(node, includePositive)) {
    res.unshift(node);
  }
  return res;
}
var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC$1 = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset$1(mode, isRootLevel, isRtl, which) {
  var _inline, _horizontal, _vertical, _offsets;
  var prev = "prev";
  var next = "next";
  var children = "children";
  var parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  var inline = (_inline = {}, _defineProperty$5(_inline, UP, prev), _defineProperty$5(_inline, DOWN, next), _inline);
  var horizontal = (_horizontal = {}, _defineProperty$5(_horizontal, LEFT, isRtl ? next : prev), _defineProperty$5(_horizontal, RIGHT, isRtl ? prev : next), _defineProperty$5(_horizontal, DOWN, children), _defineProperty$5(_horizontal, ENTER, children), _horizontal);
  var vertical = (_vertical = {}, _defineProperty$5(_vertical, UP, prev), _defineProperty$5(_vertical, DOWN, next), _defineProperty$5(_vertical, ENTER, children), _defineProperty$5(_vertical, ESC$1, parent), _defineProperty$5(_vertical, LEFT, isRtl ? children : parent), _defineProperty$5(_vertical, RIGHT, isRtl ? parent : children), _vertical);
  var offsets = {
    inline,
    horizontal,
    vertical,
    inlineSub: inline,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type4) {
    case prev:
      return {
        offset: -1,
        sibling: true
      };
    case next:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  var current = element;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements(container, elements) {
  var list2 = getFocusNodeList(container, true);
  return list2.filter(function(ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!parentQueryContainer) {
    return null;
  }
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
    return focusMenuElement === ele;
  });
  if (offset3 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset3 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
function useAccessibility$1(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = react.exports.useRef();
  var activeRef = react.exports.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf2() {
    wrapperRaf$1.cancel(rafRef.current);
  };
  react.exports.useEffect(function() {
    return function() {
      cleanRaf();
    };
  }, []);
  return function(e2) {
    var which = e2.which;
    if ([].concat(ArrowKeys, [ENTER, ESC$1, HOME, END]).includes(which)) {
      var elements;
      var key2element;
      var element2key;
      var refreshElements = function refreshElements2() {
        elements = /* @__PURE__ */ new Set();
        key2element = /* @__PURE__ */ new Map();
        element2key = /* @__PURE__ */ new Map();
        var keys2 = getKeys();
        keys2.forEach(function(key2) {
          var element = document.querySelector("[data-menu-id='".concat(getMenuId(id2, key2), "']"));
          if (element) {
            elements.add(element);
            element2key.set(element, key2);
            key2element.set(key2, element);
          }
        });
        return elements;
      };
      refreshElements();
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset$1(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e2.preventDefault();
      }
      var tryFocus = function tryFocus2(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;
          var link = menuElement.querySelector("a");
          if (link === null || link === void 0 ? void 0 : link.getAttribute("href")) {
            focusTargetElement = link;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = wrapperRaf$1(function() {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        var parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = wrapperRaf$1(function() {
          refreshElements();
          var controlId = focusMenuElement.getAttribute("aria-controls");
          var subQueryContainer = document.getElementById(controlId);
          var targetElement2 = getNextFocusElement(subQueryContainer, elements);
          tryFocus(targetElement2);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e2);
  };
}
var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id2) {
  var _useMergedState = useMergedState(id2, {
    value: id2
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
  react.exports.useEffect(function() {
    internalId += 1;
    var newId = "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid2;
}
function nextSlice(callback) {
  Promise.resolve().then(callback);
}
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = function getPathStr2(keyPath) {
  return keyPath.join(PATH_SPLIT);
};
var getPathKeys = function getPathKeys2(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray$3(_React$useState, 2), internalForceUpdate = _React$useState2[1];
  var key2pathRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var path2keyRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray$3(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
  var updateRef = react.exports.useRef(0);
  var destroyRef = react.exports.useRef(false);
  var forceUpdate = function forceUpdate2() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = react.exports.useCallback(function(key2, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key2);
    key2pathRef.current.set(key2, connectedPath);
    updateRef.current += 1;
    var id2 = updateRef.current;
    nextSlice(function() {
      if (id2 === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = react.exports.useCallback(function(key2, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key2);
  }, []);
  var refreshOverflowKeys = react.exports.useCallback(function(keys2) {
    setOverflowKeys(keys2);
  }, []);
  var getKeyPath = react.exports.useCallback(function(eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || "";
    var keys2 = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys2[0])) {
      keys2.unshift(OVERFLOW_KEY);
    }
    return keys2;
  }, [overflowKeys]);
  var isSubPathKey = react.exports.useCallback(function(pathKeys, eventKey) {
    return pathKeys.some(function(pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys2() {
    var keys2 = _toConsumableArray(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY);
    }
    return keys2;
  };
  var getSubPathKeys = react.exports.useCallback(function(key2) {
    var connectedPath = "".concat(key2pathRef.current.get(key2)).concat(PATH_SPLIT);
    var pathKeys = /* @__PURE__ */ new Set();
    _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  react.exports.useEffect(function() {
    return function() {
      destroyRef.current = true;
    };
  }, []);
  return {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
var _excluded$e = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
var EMPTY_LIST$3 = [];
var Menu$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _childList$, _classNames;
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-menu" : _props$prefixCls, rootClassName = props.rootClassName, style2 = props.style, className = props.className, _props$tabIndex = props.tabIndex, tabIndex = _props$tabIndex === void 0 ? 0 : _props$tabIndex, items = props.items, children = props.children, direction = props.direction, id2 = props.id, _props$mode = props.mode, mode = _props$mode === void 0 ? "vertical" : _props$mode, inlineCollapsed = props.inlineCollapsed, disabled = props.disabled, disabledOverflow = props.disabledOverflow, _props$subMenuOpenDel = props.subMenuOpenDelay, subMenuOpenDelay = _props$subMenuOpenDel === void 0 ? 0.1 : _props$subMenuOpenDel, _props$subMenuCloseDe = props.subMenuCloseDelay, subMenuCloseDelay = _props$subMenuCloseDe === void 0 ? 0.1 : _props$subMenuCloseDe, forceSubMenuRender = props.forceSubMenuRender, defaultOpenKeys = props.defaultOpenKeys, openKeys = props.openKeys, activeKey = props.activeKey, defaultActiveFirst = props.defaultActiveFirst, _props$selectable = props.selectable, selectable = _props$selectable === void 0 ? true : _props$selectable, _props$multiple = props.multiple, multiple = _props$multiple === void 0 ? false : _props$multiple, defaultSelectedKeys = props.defaultSelectedKeys, selectedKeys = props.selectedKeys, onSelect = props.onSelect, onDeselect = props.onDeselect, _props$inlineIndent = props.inlineIndent, inlineIndent = _props$inlineIndent === void 0 ? 24 : _props$inlineIndent, motion = props.motion, defaultMotions = props.defaultMotions, _props$triggerSubMenu = props.triggerSubMenuAction, triggerSubMenuAction = _props$triggerSubMenu === void 0 ? "hover" : _props$triggerSubMenu, builtinPlacements = props.builtinPlacements, itemIcon = props.itemIcon, expandIcon = props.expandIcon, _props$overflowedIndi = props.overflowedIndicator, overflowedIndicator = _props$overflowedIndi === void 0 ? "..." : _props$overflowedIndi, overflowedIndicatorPopupClassName = props.overflowedIndicatorPopupClassName, getPopupContainer = props.getPopupContainer, onClick = props.onClick, onOpenChange = props.onOpenChange, onKeyDown2 = props.onKeyDown;
  props.openAnimation;
  props.openTransitionName;
  var _internalRenderMenuItem = props._internalRenderMenuItem, _internalRenderSubMenuItem = props._internalRenderSubMenuItem, restProps = _objectWithoutProperties$1(props, _excluded$e);
  var childList = react.exports.useMemo(function() {
    return parseItems(children, items, EMPTY_LIST$3);
  }, [children, items]);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
  var containerRef = react.exports.useRef();
  var uuid2 = useUUID(id2);
  var isRtl = direction === "rtl";
  var _React$useMemo = react.exports.useMemo(function() {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray$3(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
  var _React$useState3 = react.exports.useState(0), _React$useState4 = _slicedToArray$3(_React$useState3, 2), lastVisibleIndex = _React$useState4[0], setLastVisibleIndex = _React$useState4[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || mergedMode !== "horizontal" || disabledOverflow;
  var _useMergedState = useMergedState(defaultOpenKeys, {
    value: openKeys,
    postState: function postState(keys2) {
      return keys2 || EMPTY_LIST$3;
    }
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
  var triggerOpenKeys = function triggerOpenKeys2(keys2) {
    setMergedOpenKeys(keys2);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
  };
  var _React$useState5 = react.exports.useState(mergedOpenKeys), _React$useState6 = _slicedToArray$3(_React$useState5, 2), inlineCacheOpenKeys = _React$useState6[0], setInlineCacheOpenKeys = _React$useState6[1];
  var isInlineMode = mergedMode === "inline";
  var mountRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  react.exports.useEffect(function() {
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST$3);
    }
  }, [isInlineMode]);
  react.exports.useEffect(function() {
    mountRef.current = true;
    return function() {
      mountRef.current = false;
    };
  }, []);
  var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = react.exports.useMemo(function() {
    return {
      registerPath,
      unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = react.exports.useMemo(function() {
    return {
      isSubPathKey
    };
  }, [isSubPathKey]);
  react.exports.useEffect(function() {
    refreshOverflowKeys(allVisible ? EMPTY_LIST$3 : childList.slice(lastVisibleIndex + 1).map(function(child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);
  var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
    value: activeKey
  }), _useMergedState4 = _slicedToArray$3(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function(key2) {
    setMergedActiveKey(key2);
  });
  var onInactive = useMemoCallback(function() {
    setMergedActiveKey(void 0);
  });
  react.exports.useImperativeHandle(ref, function() {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node) {
          return !node.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        if (shouldFocusKey) {
          var _containerRef$current, _containerRef$current2, _containerRef$current3;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
        }
      }
    };
  });
  var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
    value: selectedKeys,
    postState: function postState(keys2) {
      if (Array.isArray(keys2)) {
        return keys2;
      }
      if (keys2 === null || keys2 === void 0) {
        return EMPTY_LIST$3;
      }
      return [keys2];
    }
  }), _useMergedState6 = _slicedToArray$3(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
  var triggerSelection = function triggerSelection2(info2) {
    if (selectable) {
      var targetKey = info2.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function(key2) {
            return key2 !== targetKey;
          });
        } else {
          newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      var selectInfo = _objectSpread2$4(_objectSpread2$4({}, info2), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && mergedMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST$3);
    }
  };
  var onInternalClick = useMemoCallback(function(info2) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info2));
    triggerSelection(info2);
  });
  var onInternalOpenChange = useMemoCallback(function(key2, open) {
    var newOpenKeys = mergedOpenKeys.filter(function(k2) {
      return k2 !== key2;
    });
    if (open) {
      newOpenKeys.push(key2);
    } else if (mergedMode !== "inline") {
      var subPathKeys = getSubPathKeys(key2);
      newOpenKeys = newOpenKeys.filter(function(k2) {
        return !subPathKeys.has(k2);
      });
    }
    if (!shallowequal(mergedOpenKeys, newOpenKeys)) {
      triggerOpenKeys(newOpenKeys);
    }
  });
  var getInternalPopupContainer = useMemoCallback(getPopupContainer);
  var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key2, open) {
    var nextOpen = open !== null && open !== void 0 ? open : !mergedOpenKeys.includes(key2);
    onInternalOpenChange(key2, nextOpen);
  };
  var onInternalKeyDown = useAccessibility$1(mergedMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
  react.exports.useEffect(function() {
    setMounted(true);
  }, []);
  var privateContext = react.exports.useMemo(function() {
    return {
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  var wrappedChildList = mergedMode !== "horizontal" || disabledOverflow ? childList : childList.map(function(child, index2) {
    return /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
      key: child.key,
      overflowDisabled: index2 > lastVisibleIndex
    }, child);
  });
  var container = /* @__PURE__ */ react.exports.createElement(ForwardOverflow, _extends$2({
    id: id2,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: MenuItem$1,
    className: classnamesExports(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(mergedMode), className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-inline-collapsed"), mergedInlineCollapsed), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
    dir: direction,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node) {
      return node;
    },
    renderRawRest: function renderRawRest(omitItems) {
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /* @__PURE__ */ react.exports.createElement(SubMenu$2, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName
      }, originOmitItems);
    },
    maxCount: mergedMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown
  }, restProps));
  return /* @__PURE__ */ react.exports.createElement(PrivateContext.Provider, {
    value: privateContext
  }, /* @__PURE__ */ react.exports.createElement(IdContext.Provider, {
    value: uuid2
  }, /* @__PURE__ */ react.exports.createElement(InheritableContextProvider, {
    prefixCls,
    rootClassName,
    mode: mergedMode,
    openKeys: mergedOpenKeys,
    rtl: isRtl,
    disabled,
    motion: mounted ? motion : null,
    defaultMotions: mounted ? defaultMotions : null,
    activeKey: mergedActiveKey,
    onActive,
    onInactive,
    selectedKeys: mergedSelectKeys,
    inlineIndent,
    subMenuOpenDelay,
    subMenuCloseDelay,
    forceSubMenuRender,
    builtinPlacements,
    triggerSubMenuAction,
    getPopupContainer: getInternalPopupContainer,
    itemIcon,
    expandIcon,
    onItemClick: onInternalClick,
    onOpenChange: onInternalOpenChange
  }, /* @__PURE__ */ react.exports.createElement(PathUserContext.Provider, {
    value: pathUserContext
  }, container), /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": true
  }, /* @__PURE__ */ react.exports.createElement(PathRegisterContext.Provider, {
    value: registerPathContext
  }, childList)))));
});
var _excluded$d = ["className", "title", "eventKey", "children"], _excluded2$1 = ["children"];
var InternalMenuItemGroup = function InternalMenuItemGroup2(_ref) {
  var className = _ref.className, title = _ref.title;
  _ref.eventKey;
  var children = _ref.children, restProps = _objectWithoutProperties$1(_ref, _excluded$d);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /* @__PURE__ */ react.exports.createElement("li", _extends$2({}, restProps, {
    onClick: function onClick(e2) {
      return e2.stopPropagation();
    },
    className: classnamesExports(groupPrefixCls, className)
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(groupPrefixCls, "-title"),
    title: typeof title === "string" ? title : void 0
  }, title), /* @__PURE__ */ react.exports.createElement("ul", {
    className: "".concat(groupPrefixCls, "-list")
  }, children));
};
function MenuItemGroup(_ref2) {
  var children = _ref2.children, props = _objectWithoutProperties$1(_ref2, _excluded2$1);
  var connectedKeyPath = useFullPath$1(props.eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return /* @__PURE__ */ react.exports.createElement(InternalMenuItemGroup, omit(props, ["warnKey"]), childList);
}
function Divider(_ref) {
  var className = _ref.className, style2 = _ref.style;
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("li", {
    className: classnamesExports("".concat(prefixCls, "-item-divider"), className),
    style: style2
  });
}
var useFullPath = useFullPath$1;
var ExportMenu = Menu$2;
ExportMenu.Item = MenuItem$1;
ExportMenu.SubMenu = SubMenu$2;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider;
var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
const LeftOutlinedSvg = LeftOutlined$2;
var LeftOutlined = function LeftOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: LeftOutlinedSvg
  }));
};
LeftOutlined.displayName = "LeftOutlined";
const LeftOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LeftOutlined);
var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
const RightOutlinedSvg = RightOutlined$2;
var RightOutlined = function RightOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: RightOutlinedSvg
  }));
};
RightOutlined.displayName = "RightOutlined";
const RightOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(RightOutlined);
globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var SiderContext = /* @__PURE__ */ react.exports.createContext({});
var __rest$z = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var MenuDivider = function MenuDivider2(_a) {
  var customizePrefixCls = _a.prefixCls, className = _a.className, dashed = _a.dashed, restProps = __rest$z(_a, ["prefixCls", "className", "dashed"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("menu", customizePrefixCls);
  var classString = classnamesExports(_defineProperty$5({}, "".concat(prefixCls, "-item-divider-dashed"), !!dashed), className);
  return /* @__PURE__ */ react.exports.createElement(Divider, _extends$2({
    className: classString
  }, restProps));
};
const MenuDivider$1 = MenuDivider;
var MenuContext = /* @__PURE__ */ react.exports.createContext({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false
});
const MenuContext$1 = MenuContext;
var __rest$y = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var MenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(MenuItem2, _React$Component);
  var _super = _createSuper$1(MenuItem2);
  function MenuItem2() {
    var _this;
    _classCallCheck$2(this, MenuItem2);
    _this = _super.apply(this, arguments);
    _this.renderItem = function(_ref) {
      var _classNames;
      var siderCollapsed = _ref.siderCollapsed;
      var _a;
      var _this$context = _this.context, prefixCls = _this$context.prefixCls, firstLevel = _this$context.firstLevel, inlineCollapsed = _this$context.inlineCollapsed, direction = _this$context.direction, disableMenuItemTitleTooltip = _this$context.disableMenuItemTitleTooltip;
      var _this$props = _this.props, className = _this$props.className, children = _this$props.children;
      var _b = _this.props, title = _b.title, icon = _b.icon, danger = _b.danger, rest = __rest$y(_b, ["title", "icon", "danger"]);
      var tooltipTitle = title;
      if (typeof title === "undefined") {
        tooltipTitle = firstLevel ? children : "";
      } else if (title === false) {
        tooltipTitle = "";
      }
      var tooltipProps = {
        title: tooltipTitle
      };
      if (!siderCollapsed && !inlineCollapsed) {
        tooltipProps.title = null;
        tooltipProps.visible = false;
      }
      var childrenLength = toArray$4(children).length;
      var returnNode = /* @__PURE__ */ react.exports.createElement(MenuItem$1, _extends$2({}, rest, {
        className: classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-item-danger"), danger), _defineProperty$5(_classNames, "".concat(prefixCls, "-item-only-child"), (icon ? childrenLength + 1 : childrenLength) === 1), _classNames), className),
        title: typeof title === "string" ? title : void 0
      }), cloneElement(icon, {
        className: classnamesExports(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", "".concat(prefixCls, "-item-icon"))
      }), _this.renderItemChildren(inlineCollapsed));
      if (!disableMenuItemTitleTooltip) {
        returnNode = /* @__PURE__ */ react.exports.createElement(Tooltip$1, _extends$2({}, tooltipProps, {
          placement: direction === "rtl" ? "left" : "right",
          overlayClassName: "".concat(prefixCls, "-inline-collapsed-tooltip")
        }), returnNode);
      }
      return returnNode;
    };
    return _this;
  }
  _createClass$2(MenuItem2, [{
    key: "renderItemChildren",
    value: function renderItemChildren(inlineCollapsed) {
      var _this$context2 = this.context, prefixCls = _this$context2.prefixCls, firstLevel = _this$context2.firstLevel;
      var _this$props2 = this.props, icon = _this$props2.icon, children = _this$props2.children;
      var wrapNode = /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-title-content")
      }, children);
      if (!icon || isValidElement(children) && children.type === "span") {
        if (children && inlineCollapsed && firstLevel && typeof children === "string") {
          return /* @__PURE__ */ react.exports.createElement("div", {
            className: "".concat(prefixCls, "-inline-collapsed-noicon")
          }, children.charAt(0));
        }
      }
      return wrapNode;
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(SiderContext.Consumer, null, this.renderItem);
    }
  }]);
  return MenuItem2;
}(react.exports.Component);
MenuItem.contextType = MenuContext$1;
function SubMenu$1(props) {
  var _a;
  var popupClassName = props.popupClassName, icon = props.icon, title = props.title, theme = props.theme;
  var context2 = react.exports.useContext(MenuContext$1);
  var prefixCls = context2.prefixCls, inlineCollapsed = context2.inlineCollapsed, antdMenuTheme = context2.antdMenuTheme;
  var parentPath = useFullPath();
  var titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-inline-collapsed-noicon")
    }, title.charAt(0)) : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-title-content")
    }, title);
  } else {
    var titleIsSpan = isValidElement(title) && title.type === "span";
    titleNode = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, cloneElement(icon, {
      className: classnamesExports(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", "".concat(prefixCls, "-item-icon"))
    }), titleIsSpan ? title : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-title-content")
    }, title));
  }
  var contextValue = react.exports.useMemo(function() {
    return _extends$2(_extends$2({}, context2), {
      firstLevel: false
    });
  }, [context2]);
  return /* @__PURE__ */ react.exports.createElement(MenuContext$1.Provider, {
    value: contextValue
  }, /* @__PURE__ */ react.exports.createElement(SubMenu$2, _extends$2({}, omit(props, ["icon"]), {
    title: titleNode,
    popupClassName: classnamesExports(prefixCls, "".concat(prefixCls, "-").concat(theme || antdMenuTheme), popupClassName)
  })));
}
var __rest$x = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function convertItemsToNodes(list2) {
  return (list2 || []).map(function(opt, index2) {
    if (opt && _typeof$4(opt) === "object") {
      var _a = opt, label = _a.label, children = _a.children, key2 = _a.key, type4 = _a.type, restProps = __rest$x(_a, ["label", "children", "key", "type"]);
      var mergedKey = key2 !== null && key2 !== void 0 ? key2 : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ react.exports.createElement(MenuItemGroup, _extends$2({
            key: mergedKey
          }, restProps, {
            title: label
          }), convertItemsToNodes(children));
        }
        return /* @__PURE__ */ react.exports.createElement(SubMenu$1, _extends$2({
          key: mergedKey
        }, restProps, {
          title: label
        }), convertItemsToNodes(children));
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ react.exports.createElement(MenuDivider$1, _extends$2({
          key: mergedKey
        }, restProps));
      }
      return /* @__PURE__ */ react.exports.createElement(MenuItem, _extends$2({
        key: mergedKey
      }, restProps), label);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function useItems(items) {
  return react.exports.useMemo(function() {
    if (!items) {
      return items;
    }
    return convertItemsToNodes(items);
  }, [items]);
}
var __rest$w = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var OverrideContext = /* @__PURE__ */ react.exports.createContext(null);
var OverrideProvider = function OverrideProvider2(_a) {
  var children = _a.children, restProps = __rest$w(_a, ["children"]);
  var override = react.exports.useContext(OverrideContext);
  var context2 = react.exports.useMemo(function() {
    return _extends$2(_extends$2({}, override), restProps);
  }, [
    override,
    restProps.prefixCls,
    restProps.mode,
    restProps.selectable
  ]);
  return /* @__PURE__ */ react.exports.createElement(OverrideContext.Provider, {
    value: context2
  }, children);
};
const OverrideContext$1 = OverrideContext;
var __rest$v = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var InternalMenu = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _a;
  var override = react.exports.useContext(OverrideContext$1) || {};
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, getPopupContainer = _React$useContext.getPopupContainer, direction = _React$useContext.direction;
  var rootPrefixCls = getPrefixCls();
  var customizePrefixCls = props.prefixCls, className = props.className, _props$theme = props.theme, theme = _props$theme === void 0 ? "light" : _props$theme, expandIcon = props.expandIcon, _internalDisableMenuItemTitleTooltip = props._internalDisableMenuItemTitleTooltip, inlineCollapsed = props.inlineCollapsed, siderCollapsed = props.siderCollapsed, items = props.items, children = props.children, mode = props.mode, selectable = props.selectable, onClick = props.onClick, restProps = __rest$v(props, ["prefixCls", "className", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "mode", "selectable", "onClick"]);
  var passedProps = omit(restProps, ["collapsedWidth"]);
  var mergedChildren = useItems(items) || children;
  (_a = override.validator) === null || _a === void 0 ? void 0 : _a.call(override, {
    mode
  });
  var onItemClick = useEvent(function() {
    var _a2;
    onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
    (_a2 = override === null || override === void 0 ? void 0 : override.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(override);
  });
  var mergedMode = override.mode || mode;
  var mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : override.selectable;
  var mergedInlineCollapsed = react.exports.useMemo(function() {
    if (siderCollapsed !== void 0) {
      return siderCollapsed;
    }
    return inlineCollapsed;
  }, [inlineCollapsed, siderCollapsed]);
  var defaultMotions = {
    horizontal: {
      motionName: "".concat(rootPrefixCls, "-slide-up")
    },
    inline: collapseMotion$1,
    other: {
      motionName: "".concat(rootPrefixCls, "-zoom-big")
    }
  };
  var prefixCls = getPrefixCls("menu", customizePrefixCls || override.prefixCls);
  var menuClassName = classnamesExports("".concat(prefixCls, "-").concat(theme), className);
  var mergedExpandIcon;
  if (typeof expandIcon === "function") {
    mergedExpandIcon = expandIcon;
  } else {
    mergedExpandIcon = cloneElement(expandIcon || override.expandIcon, {
      className: "".concat(prefixCls, "-submenu-expand-icon")
    });
  }
  var contextValue = react.exports.useMemo(function() {
    return {
      prefixCls,
      inlineCollapsed: mergedInlineCollapsed || false,
      antdMenuTheme: theme,
      direction,
      firstLevel: true,
      disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
    };
  }, [prefixCls, mergedInlineCollapsed, theme, direction, _internalDisableMenuItemTitleTooltip]);
  return /* @__PURE__ */ react.exports.createElement(OverrideContext$1.Provider, {
    value: null
  }, /* @__PURE__ */ react.exports.createElement(MenuContext$1.Provider, {
    value: contextValue
  }, /* @__PURE__ */ react.exports.createElement(ExportMenu, _extends$2({
    getPopupContainer,
    overflowedIndicator: /* @__PURE__ */ react.exports.createElement(EllipsisOutlined$1, null),
    overflowedIndicatorPopupClassName: "".concat(prefixCls, "-").concat(theme),
    mode: mergedMode,
    selectable: mergedSelectable,
    onClick: onItemClick
  }, passedProps, {
    inlineCollapsed: mergedInlineCollapsed,
    className: menuClassName,
    prefixCls,
    direction,
    defaultMotions,
    expandIcon: mergedExpandIcon,
    ref
  }), mergedChildren)));
});
var Menu = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Menu2, _React$Component);
  var _super = _createSuper$1(Menu2);
  function Menu2() {
    var _this;
    _classCallCheck$2(this, Menu2);
    _this = _super.apply(this, arguments);
    _this.focus = function(options) {
      var _a;
      (_a = _this.menu) === null || _a === void 0 ? void 0 : _a.focus(options);
    };
    return _this;
  }
  _createClass$2(Menu2, [{
    key: "render",
    value: function render2() {
      var _this2 = this;
      return /* @__PURE__ */ react.exports.createElement(SiderContext.Consumer, null, function(context2) {
        return /* @__PURE__ */ react.exports.createElement(InternalMenu, _extends$2({
          ref: function ref(node) {
            _this2.menu = node;
          }
        }, _this2.props, context2));
      });
    }
  }]);
  return Menu2;
}(react.exports.Component);
Menu.Divider = MenuDivider$1;
Menu.Item = MenuItem;
Menu.SubMenu = SubMenu$1;
Menu.ItemGroup = MenuItemGroup;
const Menu$1 = Menu;
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  }
};
var ESC = KeyCode.ESC, TAB = KeyCode.TAB;
function useAccessibility(_ref) {
  var visible = _ref.visible, setTriggerVisible = _ref.setTriggerVisible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus;
  var focusMenuRef = react.exports.useRef(false);
  var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
    if (visible && triggerRef.current) {
      var _triggerRef$current, _triggerRef$current$t, _triggerRef$current$t2, _triggerRef$current$t3;
      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$t = _triggerRef$current.triggerRef) === null || _triggerRef$current$t === void 0 ? void 0 : (_triggerRef$current$t2 = _triggerRef$current$t.current) === null || _triggerRef$current$t2 === void 0 ? void 0 : (_triggerRef$current$t3 = _triggerRef$current$t2.focus) === null || _triggerRef$current$t3 === void 0 ? void 0 : _triggerRef$current$t3.call(_triggerRef$current$t2);
      setTriggerVisible(false);
      if (typeof onVisibleChange === "function") {
        onVisibleChange(false);
      }
    }
  };
  var focusMenu = function focusMenu2() {
    var _triggerRef$current2, _triggerRef$current2$, _triggerRef$current2$2, _triggerRef$current2$3;
    var elements = getFocusNodeList((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.popupRef) === null || _triggerRef$current2$ === void 0 ? void 0 : (_triggerRef$current2$2 = _triggerRef$current2$.current) === null || _triggerRef$current2$2 === void 0 ? void 0 : (_triggerRef$current2$3 = _triggerRef$current2$2.getElement) === null || _triggerRef$current2$3 === void 0 ? void 0 : _triggerRef$current2$3.call(_triggerRef$current2$2));
    var firstElement = elements[0];
    if (firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus) {
      firstElement.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  var handleKeyDown = function handleKeyDown2(event) {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        var focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  };
  react.exports.useEffect(function() {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        wrapperRaf$1(focusMenu, 3);
      }
      return function() {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return function() {
      focusMenuRef.current = false;
    };
  }, [visible]);
}
var _excluded$c = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus"];
function Dropdown$2(props, ref) {
  var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName2 = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements$12 = _props$placements === void 0 ? placements : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger3 = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, otherProps = _objectWithoutProperties$1(props, _excluded$c);
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray$3(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
  var mergedVisible = "visible" in props ? visible : triggerVisible;
  var triggerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return triggerRef.current;
  });
  useAccessibility({
    visible: mergedVisible,
    setTriggerVisible,
    triggerRef,
    onVisibleChange: props.onVisibleChange,
    autoFocus
  });
  var getOverlayElement = function getOverlayElement2() {
    var overlay = props.overlay;
    var overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  };
  var onClick = function onClick2(e2) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e2);
    }
  };
  var onVisibleChange = function onVisibleChange2(newVisible) {
    var onVisibleChangeProp = props.onVisibleChange;
    setTriggerVisible(newVisible);
    if (typeof onVisibleChangeProp === "function") {
      onVisibleChangeProp(newVisible);
    }
  };
  var getMenuElement = function getMenuElement2() {
    var overlayElement = getOverlayElement();
    return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, arrow && /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-arrow")
    }), overlayElement);
  };
  var getMenuElementOrLambda = function getMenuElementOrLambda2() {
    var overlay = props.overlay;
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  };
  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint2 = props.alignPoint;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint2;
  };
  var getOpenClassName = function getOpenClassName2() {
    var openClassName = props.openClassName;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return "".concat(prefixCls, "-open");
  };
  var renderChildren = function renderChildren2() {
    var children = props.children;
    var childrenProps = children.props ? children.props : {};
    var childClassName = classnamesExports(childrenProps.className, getOpenClassName());
    return mergedVisible && children ? /* @__PURE__ */ react.exports.cloneElement(children, {
      className: childClassName
    }) : children;
  };
  var triggerHideAction = hideAction;
  if (!triggerHideAction && trigger3.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return /* @__PURE__ */ react.exports.createElement(Trigger, _objectSpread2$4(_objectSpread2$4({
    builtinPlacements: placements$12
  }, otherProps), {}, {
    prefixCls,
    ref: triggerRef,
    popupClassName: classnamesExports(overlayClassName, _defineProperty$5({}, "".concat(prefixCls, "-show-arrow"), arrow)),
    popupStyle: overlayStyle,
    action: trigger3,
    showAction,
    hideAction: triggerHideAction || [],
    popupPlacement: placement,
    popupAlign: align,
    popupTransitionName: transitionName2,
    popupAnimation: animation,
    popupVisible: mergedVisible,
    stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
    popup: getMenuElementOrLambda(),
    onPopupVisibleChange: onVisibleChange,
    onPopupClick: onClick,
    getPopupContainer
  }), renderChildren());
}
const Dropdown$3 = /* @__PURE__ */ react.exports.forwardRef(Dropdown$2);
var id = 0;
var ids = {};
function wrapperRaf(callback) {
  var delayFrames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var myId = id++;
  var restFrames = delayFrames;
  function internalCallback() {
    restFrames -= 1;
    if (restFrames <= 0) {
      callback();
      delete ids[myId];
    } else {
      ids[myId] = wrapperRaf$1(internalCallback);
    }
  }
  ids[myId] = wrapperRaf$1(internalCallback);
  return myId;
}
wrapperRaf.cancel = function cancel(pid) {
  if (pid === void 0)
    return;
  wrapperRaf$1.cancel(ids[pid]);
  delete ids[pid];
};
wrapperRaf.ids = ids;
var styleForPseudo;
function isHidden(element) {
  return !element || element.offsetParent === null || element.hidden;
}
function isNotGrey(color2) {
  var match2 = (color2 || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match2 && match2[1] && match2[2] && match2[3]) {
    return !(match2[1] === match2[2] && match2[2] === match2[3]);
  }
  return true;
}
var InternalWave = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(InternalWave2, _React$Component);
  var _super = _createSuper$1(InternalWave2);
  function InternalWave2() {
    var _this;
    _classCallCheck$2(this, InternalWave2);
    _this = _super.apply(this, arguments);
    _this.containerRef = /* @__PURE__ */ react.exports.createRef();
    _this.animationStart = false;
    _this.destroyed = false;
    _this.onClick = function(node, waveColor) {
      var _a, _b;
      var _this$props = _this.props, insertExtraNode = _this$props.insertExtraNode, disabled = _this$props.disabled;
      if (disabled || !node || isHidden(node) || node.className.indexOf("-leave") >= 0) {
        return;
      }
      _this.extraNode = document.createElement("div");
      var _assertThisInitialize = _assertThisInitialized$1(_this), extraNode = _assertThisInitialize.extraNode;
      var getPrefixCls = _this.context.getPrefixCls;
      extraNode.className = "".concat(getPrefixCls(""), "-click-animating-node");
      var attributeName = _this.getAttributeName();
      node.setAttribute(attributeName, "true");
      if (waveColor && waveColor !== "#ffffff" && waveColor !== "rgb(255, 255, 255)" && isNotGrey(waveColor) && !/rgba\((?:\d*, ){3}0\)/.test(waveColor) && waveColor !== "transparent") {
        extraNode.style.borderColor = waveColor;
        var nodeRoot = ((_a = node.getRootNode) === null || _a === void 0 ? void 0 : _a.call(node)) || node.ownerDocument;
        var nodeBody = nodeRoot instanceof Document ? nodeRoot.body : (_b = nodeRoot.firstChild) !== null && _b !== void 0 ? _b : nodeRoot;
        styleForPseudo = updateCSS("\n      [".concat(getPrefixCls(""), "-click-animating-without-extra-node='true']::after, .").concat(getPrefixCls(""), "-click-animating-node {\n        --antd-wave-shadow-color: ").concat(waveColor, ";\n      }"), "antd-wave", {
          csp: _this.csp,
          attachTo: nodeBody
        });
      }
      if (insertExtraNode) {
        node.appendChild(extraNode);
      }
      ["transition", "animation"].forEach(function(name2) {
        node.addEventListener("".concat(name2, "start"), _this.onTransitionStart);
        node.addEventListener("".concat(name2, "end"), _this.onTransitionEnd);
      });
    };
    _this.onTransitionStart = function(e2) {
      if (_this.destroyed) {
        return;
      }
      var node = _this.containerRef.current;
      if (!e2 || e2.target !== node || _this.animationStart) {
        return;
      }
      _this.resetEffect(node);
    };
    _this.onTransitionEnd = function(e2) {
      if (!e2 || e2.animationName !== "fadeEffect") {
        return;
      }
      _this.resetEffect(e2.target);
    };
    _this.bindAnimationEvent = function(node) {
      if (!node || !node.getAttribute || node.getAttribute("disabled") || node.className.indexOf("disabled") >= 0) {
        return;
      }
      var onClick = function onClick2(e2) {
        if (e2.target.tagName === "INPUT" || isHidden(e2.target)) {
          return;
        }
        _this.resetEffect(node);
        var waveColor = getComputedStyle(node).getPropertyValue("border-top-color") || getComputedStyle(node).getPropertyValue("border-color") || getComputedStyle(node).getPropertyValue("background-color");
        _this.clickWaveTimeoutId = window.setTimeout(function() {
          return _this.onClick(node, waveColor);
        }, 0);
        wrapperRaf.cancel(_this.animationStartId);
        _this.animationStart = true;
        _this.animationStartId = wrapperRaf(function() {
          _this.animationStart = false;
        }, 10);
      };
      node.addEventListener("click", onClick, true);
      return {
        cancel: function cancel2() {
          node.removeEventListener("click", onClick, true);
        }
      };
    };
    _this.renderWave = function(_ref) {
      var csp = _ref.csp;
      var children = _this.props.children;
      _this.csp = csp;
      if (!/* @__PURE__ */ react.exports.isValidElement(children))
        return children;
      var ref = _this.containerRef;
      if (supportRef(children)) {
        ref = composeRef(children.ref, _this.containerRef);
      }
      return cloneElement(children, {
        ref
      });
    };
    return _this;
  }
  _createClass$2(InternalWave2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      var node = this.containerRef.current;
      if (!node || node.nodeType !== 1) {
        return;
      }
      this.instance = this.bindAnimationEvent(node);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.instance) {
        this.instance.cancel();
      }
      if (this.clickWaveTimeoutId) {
        clearTimeout(this.clickWaveTimeoutId);
      }
      this.destroyed = true;
    }
  }, {
    key: "getAttributeName",
    value: function getAttributeName() {
      var getPrefixCls = this.context.getPrefixCls;
      var insertExtraNode = this.props.insertExtraNode;
      return insertExtraNode ? "".concat(getPrefixCls(""), "-click-animating") : "".concat(getPrefixCls(""), "-click-animating-without-extra-node");
    }
  }, {
    key: "resetEffect",
    value: function resetEffect(node) {
      var _this2 = this;
      if (!node || node === this.extraNode || !(node instanceof Element)) {
        return;
      }
      var insertExtraNode = this.props.insertExtraNode;
      var attributeName = this.getAttributeName();
      node.setAttribute(attributeName, "false");
      if (styleForPseudo) {
        styleForPseudo.innerHTML = "";
      }
      if (insertExtraNode && this.extraNode && node.contains(this.extraNode)) {
        node.removeChild(this.extraNode);
      }
      ["transition", "animation"].forEach(function(name2) {
        node.removeEventListener("".concat(name2, "start"), _this2.onTransitionStart);
        node.removeEventListener("".concat(name2, "end"), _this2.onTransitionEnd);
      });
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, this.renderWave);
    }
  }]);
  return InternalWave2;
}(react.exports.Component);
InternalWave.contextType = ConfigContext;
var Wave = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(InternalWave, _extends$2({
    ref
  }, props));
});
const Wave$1 = Wave;
var __rest$u = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var GroupSizeContext = /* @__PURE__ */ react.exports.createContext(void 0);
var ButtonGroup$1 = function ButtonGroup(props) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls, size = props.size, className = props.className, others = __rest$u(props, ["prefixCls", "size", "className"]);
  var prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  var sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  var classes = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement(GroupSizeContext.Provider, {
    value: size
  }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, others, {
    className: classes
  })));
};
const Group$4 = ButtonGroup$1;
var getCollapsedWidth = function getCollapsedWidth2() {
  return {
    width: 0,
    opacity: 0,
    transform: "scale(0)"
  };
};
var getRealWidth = function getRealWidth2(node) {
  return {
    width: node.scrollWidth,
    opacity: 1,
    transform: "scale(1)"
  };
};
var LoadingIcon = function LoadingIcon2(_ref) {
  var prefixCls = _ref.prefixCls, loading = _ref.loading, existIcon = _ref.existIcon;
  var visible = !!loading;
  if (existIcon) {
    return /* @__PURE__ */ React$a.createElement("span", {
      className: "".concat(prefixCls, "-loading-icon")
    }, /* @__PURE__ */ React$a.createElement(LoadingOutlined$1, null));
  }
  return /* @__PURE__ */ React$a.createElement(CSSMotion, {
    visible,
    motionName: "".concat(prefixCls, "-loading-icon-motion"),
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth
  }, function(_ref2, ref) {
    var className = _ref2.className, style2 = _ref2.style;
    return /* @__PURE__ */ React$a.createElement("span", {
      className: "".concat(prefixCls, "-loading-icon"),
      style: style2,
      ref
    }, /* @__PURE__ */ React$a.createElement(LoadingOutlined$1, {
      className
    }));
  });
};
const LoadingIcon$1 = LoadingIcon;
var __rest$t = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
var isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isString(str) {
  return typeof str === "string";
}
function isUnBorderedButtonType(type4) {
  return type4 === "text" || type4 === "link";
}
function isReactFragment(node) {
  return /* @__PURE__ */ react.exports.isValidElement(node) && node.type === react.exports.Fragment;
}
function insertSpace(child, needInserted) {
  if (child === null || child === void 0) {
    return;
  }
  var SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement(child, {
      children: child.props.children.split("").join(SPACE)
    });
  }
  if (typeof child === "string") {
    return isTwoCNChar(child) ? /* @__PURE__ */ react.exports.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ react.exports.createElement("span", null, child);
  }
  if (isReactFragment(child)) {
    return /* @__PURE__ */ react.exports.createElement("span", null, child);
  }
  return child;
}
function spaceChildren(children, needInserted) {
  var isPrevChildPure = false;
  var childList = [];
  react.exports.Children.forEach(children, function(child) {
    var type4 = _typeof$4(child);
    var isCurrentChildPure = type4 === "string" || type4 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      var lastIndex = childList.length - 1;
      var lastChild = childList[lastIndex];
      childList[lastIndex] = "".concat(lastChild).concat(child);
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return react.exports.Children.map(childList, function(child) {
    return insertSpace(child, needInserted);
  });
}
tuple("default", "primary", "ghost", "dashed", "link", "text");
tuple("default", "circle", "round");
tuple("submit", "button", "reset");
var InternalButton = function InternalButton2(props, ref) {
  var _classNames;
  var _props$loading = props.loading, loading = _props$loading === void 0 ? false : _props$loading, customizePrefixCls = props.prefixCls, _props$type = props.type, type4 = _props$type === void 0 ? "default" : _props$type, danger = props.danger, _props$shape = props.shape, shape = _props$shape === void 0 ? "default" : _props$shape, customizeSize = props.size, customDisabled = props.disabled, className = props.className, children = props.children, icon = props.icon, _props$ghost = props.ghost, ghost = _props$ghost === void 0 ? false : _props$ghost, _props$block = props.block, block = _props$block === void 0 ? false : _props$block, _props$htmlType = props.htmlType, htmlType = _props$htmlType === void 0 ? "button" : _props$htmlType, rest = __rest$t(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "children", "icon", "ghost", "block", "htmlType"]);
  var size = react.exports.useContext(SizeContext$1);
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var groupSize = react.exports.useContext(GroupSizeContext);
  var _React$useState = react.exports.useState(!!loading), _React$useState2 = _slicedToArray$3(_React$useState, 2), innerLoading = _React$useState2[0], setLoading = _React$useState2[1];
  var _React$useState3 = react.exports.useState(false), _React$useState4 = _slicedToArray$3(_React$useState3, 2), hasTwoCNChar = _React$useState4[0], setHasTwoCNChar = _React$useState4[1];
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, autoInsertSpaceInButton = _React$useContext.autoInsertSpaceInButton, direction = _React$useContext.direction;
  var buttonRef = ref || /* @__PURE__ */ react.exports.createRef();
  var isNeedInserted = function isNeedInserted2() {
    return react.exports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type4);
  };
  var fixTwoCNChar = function fixTwoCNChar2() {
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    var buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  var loadingOrDelay = typeof loading === "boolean" ? loading : (loading === null || loading === void 0 ? void 0 : loading.delay) || true;
  react.exports.useEffect(function() {
    var delayTimer = null;
    if (typeof loadingOrDelay === "number") {
      delayTimer = window.setTimeout(function() {
        delayTimer = null;
        setLoading(loadingOrDelay);
      }, loadingOrDelay);
    } else {
      setLoading(loadingOrDelay);
    }
    return function() {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    };
  }, [loadingOrDelay]);
  react.exports.useEffect(fixTwoCNChar, [buttonRef]);
  var handleClick = function handleClick2(e2) {
    var onClick = props.onClick;
    if (innerLoading || mergedDisabled) {
      e2.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  };
  var prefixCls = getPrefixCls("btn", customizePrefixCls);
  var autoInsertSpace = autoInsertSpaceInButton !== false;
  var sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  var sizeFullname = groupSize || customizeSize || size;
  var sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
  var iconType = innerLoading ? "loading" : icon;
  var linkButtonRestProps = omit(rest, ["navigate"]);
  var classes = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(shape), shape !== "default" && shape), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(type4), type4), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$5(_classNames, "".concat(prefixCls, "-icon-only"), !children && children !== 0 && !!iconType), _defineProperty$5(_classNames, "".concat(prefixCls, "-background-ghost"), ghost && !isUnBorderedButtonType(type4)), _defineProperty$5(_classNames, "".concat(prefixCls, "-loading"), innerLoading), _defineProperty$5(_classNames, "".concat(prefixCls, "-two-chinese-chars"), hasTwoCNChar && autoInsertSpace && !innerLoading), _defineProperty$5(_classNames, "".concat(prefixCls, "-block"), block), _defineProperty$5(_classNames, "".concat(prefixCls, "-dangerous"), !!danger), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-disabled"), linkButtonRestProps.href !== void 0 && mergedDisabled), _classNames), className);
  var iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ react.exports.createElement(LoadingIcon$1, {
    existIcon: !!icon,
    prefixCls,
    loading: !!innerLoading
  });
  var kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0) {
    return /* @__PURE__ */ react.exports.createElement("a", _extends$2({}, linkButtonRestProps, {
      className: classes,
      onClick: handleClick,
      ref: buttonRef
    }), iconNode, kids);
  }
  var buttonNode = /* @__PURE__ */ react.exports.createElement("button", _extends$2({}, rest, {
    type: htmlType,
    className: classes,
    onClick: handleClick,
    disabled: mergedDisabled,
    ref: buttonRef
  }), iconNode, kids);
  if (isUnBorderedButtonType(type4)) {
    return buttonNode;
  }
  return /* @__PURE__ */ react.exports.createElement(Wave$1, {
    disabled: !!innerLoading
  }, buttonNode);
};
var Button$1 = /* @__PURE__ */ react.exports.forwardRef(InternalButton);
Button$1.Group = Group$4;
Button$1.__ANT_BUTTON = true;
const Button$2 = Button$1;
var __rest$s = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var ButtonGroup2 = Button$2.Group;
var DropdownButton = function DropdownButton2(props) {
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls, _props$type = props.type, type4 = _props$type === void 0 ? "default" : _props$type, disabled = props.disabled, loading = props.loading, onClick = props.onClick, htmlType = props.htmlType, children = props.children, className = props.className, overlay = props.overlay, trigger3 = props.trigger, align = props.align, visible = props.visible, onVisibleChange = props.onVisibleChange, placement = props.placement, getPopupContainer = props.getPopupContainer, href = props.href, _props$icon = props.icon, icon = _props$icon === void 0 ? /* @__PURE__ */ react.exports.createElement(EllipsisOutlined$1, null) : _props$icon, title = props.title, _props$buttonsRender = props.buttonsRender, buttonsRender = _props$buttonsRender === void 0 ? function(buttons) {
    return buttons;
  } : _props$buttonsRender, mouseEnterDelay = props.mouseEnterDelay, mouseLeaveDelay = props.mouseLeaveDelay, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, destroyPopupOnHide = props.destroyPopupOnHide, restProps = __rest$s(props, ["prefixCls", "type", "disabled", "loading", "onClick", "htmlType", "children", "className", "overlay", "trigger", "align", "visible", "onVisibleChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide"]);
  var prefixCls = getPrefixCls("dropdown-button", customizePrefixCls);
  var dropdownProps = {
    align,
    overlay,
    disabled,
    trigger: disabled ? [] : trigger3,
    onVisibleChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide
  };
  if ("visible" in props) {
    dropdownProps.visible = visible;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  }
  var leftButton = /* @__PURE__ */ react.exports.createElement(Button$2, {
    type: type4,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title
  }, children);
  var rightButton = /* @__PURE__ */ react.exports.createElement(Button$2, {
    type: type4,
    icon
  });
  var _buttonsRender = buttonsRender([leftButton, rightButton]), _buttonsRender2 = _slicedToArray$3(_buttonsRender, 2), leftButtonToRender = _buttonsRender2[0], rightButtonToRender = _buttonsRender2[1];
  return /* @__PURE__ */ react.exports.createElement(ButtonGroup2, _extends$2({}, restProps, {
    className: classnamesExports(prefixCls, className)
  }), leftButtonToRender, /* @__PURE__ */ react.exports.createElement(Dropdown$1, _extends$2({}, dropdownProps), rightButtonToRender));
};
DropdownButton.__ANT_BUTTON = true;
const DropdownButton$1 = DropdownButton;
tuple("topLeft", "topCenter", "topRight", "bottomLeft", "bottomCenter", "bottomRight", "top", "bottom");
var Dropdown = function Dropdown2(props) {
  var _React$useContext = react.exports.useContext(ConfigContext), getContextPopupContainer = _React$useContext.getPopupContainer, getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var getTransitionName3 = function getTransitionName4() {
    var rootPrefixCls = getPrefixCls();
    var _props$placement = props.placement, placement = _props$placement === void 0 ? "" : _props$placement, transitionName2 = props.transitionName;
    if (transitionName2 !== void 0) {
      return transitionName2;
    }
    if (placement.indexOf("top") >= 0) {
      return "".concat(rootPrefixCls, "-slide-down");
    }
    return "".concat(rootPrefixCls, "-slide-up");
  };
  var getPlacement = function getPlacement2() {
    var placement = props.placement;
    if (!placement) {
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      var newPlacement = placement.slice(0, placement.indexOf("Center"));
      return newPlacement;
    }
    return placement;
  };
  var arrow = props.arrow, customizePrefixCls = props.prefixCls, children = props.children, trigger3 = props.trigger, disabled = props.disabled, getPopupContainer = props.getPopupContainer, overlayClassName = props.overlayClassName, visible = props.visible, onVisibleChange = props.onVisibleChange;
  var prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  var child = react.exports.Children.only(children);
  var dropdownTrigger = cloneElement(child, {
    className: classnamesExports("".concat(prefixCls, "-trigger"), _defineProperty$5({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), child.props.className),
    disabled
  });
  var triggerActions = disabled ? [] : trigger3;
  var alignPoint2;
  if (triggerActions && triggerActions.indexOf("contextMenu") !== -1) {
    alignPoint2 = true;
  }
  var _useMergedState = useMergedState(false, {
    value: visible
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), mergedVisible = _useMergedState2[0], setVisible = _useMergedState2[1];
  var onInnerVisibleChange = useEvent(function(nextVisible) {
    onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextVisible);
    setVisible(nextVisible);
  });
  var overlayClassNameCustomized = classnamesExports(overlayClassName, _defineProperty$5({}, "".concat(prefixCls, "-rtl"), direction === "rtl"));
  var builtinPlacements = getPlacements({
    arrowPointAtCenter: _typeof$4(arrow) === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: true
  });
  var onMenuClick = react.exports.useCallback(function() {
    setVisible(false);
  }, []);
  var renderOverlay = function renderOverlay2() {
    var overlay = props.overlay;
    var overlayNode;
    if (typeof overlay === "function") {
      overlayNode = overlay();
    } else {
      overlayNode = overlay;
    }
    overlayNode = react.exports.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ react.exports.createElement("span", null, overlayNode) : overlayNode);
    return /* @__PURE__ */ react.exports.createElement(OverrideProvider, {
      prefixCls: "".concat(prefixCls, "-menu"),
      expandIcon: /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-menu-submenu-arrow")
      }, /* @__PURE__ */ react.exports.createElement(RightOutlined$1, {
        className: "".concat(prefixCls, "-menu-submenu-arrow-icon")
      })),
      mode: "vertical",
      selectable: false,
      onClick: onMenuClick,
      validator: function validator(_ref) {
        _ref.mode;
      }
    }, overlayNode);
  };
  return /* @__PURE__ */ react.exports.createElement(Dropdown$3, _extends$2({
    alignPoint: alignPoint2
  }, props, {
    visible: mergedVisible,
    builtinPlacements,
    arrow: !!arrow,
    overlayClassName: overlayClassNameCustomized,
    prefixCls,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    transitionName: getTransitionName3(),
    trigger: triggerActions,
    overlay: renderOverlay,
    placement: getPlacement(),
    onVisibleChange: onInnerVisibleChange
  }), dropdownTrigger);
};
Dropdown.Button = DropdownButton$1;
Dropdown.defaultProps = {
  mouseEnterDelay: 0.15,
  mouseLeaveDelay: 0.1
};
const Dropdown$1 = Dropdown;
function arrayMap$1(array4, iteratee) {
  var index2 = -1, length = array4 == null ? 0 : array4.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array4[index2], index2, array4);
  }
  return result;
}
var _arrayMap = arrayMap$1;
var Symbol$1 = _Symbol, arrayMap = _arrayMap, isArray$2 = isArray_1, isSymbol$2 = isSymbol_1;
var INFINITY$2 = 1 / 0;
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString$1(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray$2(value2)) {
    return arrayMap(value2, baseToString$1) + "";
  }
  if (isSymbol$2(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$2 ? "-0" : result;
}
var _baseToString = baseToString$1;
function baseSlice$1(array4, start, end) {
  var index2 = -1, length = array4.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array4[index2 + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var toNumber = toNumber_1;
var INFINITY$1 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$1(value2) {
  if (!value2) {
    return value2 === 0 ? value2 : 0;
  }
  value2 = toNumber(value2);
  if (value2 === INFINITY$1 || value2 === -INFINITY$1) {
    var sign = value2 < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value2 === value2 ? value2 : 0;
}
var toFinite_1 = toFinite$1;
var toFinite = toFinite_1;
function toInteger$1(value2) {
  var result = toFinite(value2), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseToString = _baseToString;
function toString$1(value2) {
  return value2 == null ? "" : baseToString(value2);
}
var toString_1 = toString$1;
var RadioGroupContext = /* @__PURE__ */ react.exports.createContext(null);
var RadioGroupContextProvider = RadioGroupContext.Provider;
var RadioOptionTypeContext = /* @__PURE__ */ react.exports.createContext(null);
var RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
var Checkbox$3 = /* @__PURE__ */ function(_Component) {
  _inherits$1(Checkbox2, _Component);
  var _super = _createSuper$1(Checkbox2);
  function Checkbox2(props) {
    var _this;
    _classCallCheck$2(this, Checkbox2);
    _this = _super.call(this, props);
    _this.handleChange = function(e2) {
      var _this$props = _this.props, disabled = _this$props.disabled, onChange2 = _this$props.onChange;
      if (disabled) {
        return;
      }
      if (!("checked" in _this.props)) {
        _this.setState({
          checked: e2.target.checked
        });
      }
      if (onChange2) {
        onChange2({
          target: _objectSpread2$4(_objectSpread2$4({}, _this.props), {}, {
            checked: e2.target.checked
          }),
          stopPropagation: function stopPropagation() {
            e2.stopPropagation();
          },
          preventDefault: function preventDefault() {
            e2.preventDefault();
          },
          nativeEvent: e2.nativeEvent
        });
      }
    };
    _this.saveInput = function(node) {
      _this.input = node;
    };
    var checked = "checked" in props ? props.checked : props.defaultChecked;
    _this.state = {
      checked
    };
    return _this;
  }
  _createClass$2(Checkbox2, [{
    key: "focus",
    value: function focus() {
      this.input.focus();
    }
  }, {
    key: "blur",
    value: function blur() {
      this.input.blur();
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, style2 = _this$props2.style, name2 = _this$props2.name, id2 = _this$props2.id, type4 = _this$props2.type, disabled = _this$props2.disabled, readOnly = _this$props2.readOnly, tabIndex = _this$props2.tabIndex, onClick = _this$props2.onClick, onFocus2 = _this$props2.onFocus, onBlur2 = _this$props2.onBlur, onKeyDown2 = _this$props2.onKeyDown, onKeyPress2 = _this$props2.onKeyPress, onKeyUp2 = _this$props2.onKeyUp, autoFocus = _this$props2.autoFocus, value2 = _this$props2.value, required4 = _this$props2.required, others = _objectWithoutProperties$1(_this$props2, ["prefixCls", "className", "style", "name", "id", "type", "disabled", "readOnly", "tabIndex", "onClick", "onFocus", "onBlur", "onKeyDown", "onKeyPress", "onKeyUp", "autoFocus", "value", "required"]);
      var globalProps = Object.keys(others).reduce(function(prev, key2) {
        if (key2.substr(0, 5) === "aria-" || key2.substr(0, 5) === "data-" || key2 === "role") {
          prev[key2] = others[key2];
        }
        return prev;
      }, {});
      var checked = this.state.checked;
      var classString = classnamesExports(prefixCls, className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-checked"), checked), _defineProperty$5(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return /* @__PURE__ */ React$a.createElement("span", {
        className: classString,
        style: style2
      }, /* @__PURE__ */ React$a.createElement("input", _extends$2({
        name: name2,
        id: id2,
        type: type4,
        required: required4,
        readOnly,
        disabled,
        tabIndex,
        className: "".concat(prefixCls, "-input"),
        checked: !!checked,
        onClick,
        onFocus: onFocus2,
        onBlur: onBlur2,
        onKeyUp: onKeyUp2,
        onKeyDown: onKeyDown2,
        onKeyPress: onKeyPress2,
        onChange: this.handleChange,
        autoFocus,
        ref: this.saveInput,
        value: value2
      }, globalProps)), /* @__PURE__ */ React$a.createElement("span", {
        className: "".concat(prefixCls, "-inner")
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ("checked" in props) {
        return _objectSpread2$4(_objectSpread2$4({}, state), {}, {
          checked: props.checked
        });
      }
      return null;
    }
  }]);
  return Checkbox2;
}(react.exports.Component);
Checkbox$3.defaultProps = {
  prefixCls: "rc-checkbox",
  className: "",
  style: {},
  type: "checkbox",
  defaultChecked: false,
  onFocus: function onFocus() {
  },
  onBlur: function onBlur() {
  },
  onChange: function onChange() {
  },
  onKeyDown: function onKeyDown() {
  },
  onKeyPress: function onKeyPress() {
  },
  onKeyUp: function onKeyUp() {
  }
};
var __rest$r = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var InternalRadio = function InternalRadio2(props, ref) {
  var _classNames;
  var groupContext = react.exports.useContext(RadioGroupContext);
  var radioOptionTypeContext = react.exports.useContext(RadioOptionTypeContext);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var innerRef = react.exports.useRef();
  var mergedRef = composeRef(ref, innerRef);
  var _useContext = react.exports.useContext(FormItemInputContext), isFormItemInput = _useContext.isFormItemInput;
  var onChange2 = function onChange3(e2) {
    var _a, _b;
    (_a = props.onChange) === null || _a === void 0 ? void 0 : _a.call(props, e2);
    (_b = groupContext === null || groupContext === void 0 ? void 0 : groupContext.onChange) === null || _b === void 0 ? void 0 : _b.call(groupContext, e2);
  };
  var customizePrefixCls = props.prefixCls, className = props.className, children = props.children, style2 = props.style, customDisabled = props.disabled, restProps = __rest$r(props, ["prefixCls", "className", "children", "style", "disabled"]);
  var radioPrefixCls = getPrefixCls("radio", customizePrefixCls);
  var prefixCls = ((groupContext === null || groupContext === void 0 ? void 0 : groupContext.optionType) || radioOptionTypeContext) === "button" ? "".concat(radioPrefixCls, "-button") : radioPrefixCls;
  var radioProps = _extends$2({}, restProps);
  var disabled = react.exports.useContext(DisabledContext$1);
  radioProps.disabled = customDisabled || disabled;
  if (groupContext) {
    radioProps.name = groupContext.name;
    radioProps.onChange = onChange2;
    radioProps.checked = props.value === groupContext.value;
    radioProps.disabled = radioProps.disabled || groupContext.disabled;
  }
  var wrapperClassString = classnamesExports("".concat(prefixCls, "-wrapper"), (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-checked"), radioProps.checked), _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-disabled"), radioProps.disabled), _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-in-form-item"), isFormItemInput), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement("label", {
    className: wrapperClassString,
    style: style2,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave
  }, /* @__PURE__ */ react.exports.createElement(Checkbox$3, _extends$2({}, radioProps, {
    type: "radio",
    prefixCls,
    ref: mergedRef
  })), children !== void 0 ? /* @__PURE__ */ react.exports.createElement("span", null, children) : null);
};
var Radio$2 = /* @__PURE__ */ react.exports.forwardRef(InternalRadio);
const InternalRadio$1 = Radio$2;
var RadioGroup = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext$1);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), value2 = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var onRadioChange = function onRadioChange2(ev) {
    var lastValue = value2;
    var val = ev.target.value;
    if (!("value" in props)) {
      setValue2(val);
    }
    var onChange2 = props.onChange;
    if (onChange2 && val !== lastValue) {
      onChange2(ev);
    }
  };
  var customizePrefixCls = props.prefixCls, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, options = props.options, _props$buttonStyle = props.buttonStyle, buttonStyle = _props$buttonStyle === void 0 ? "outline" : _props$buttonStyle, disabled = props.disabled, children = props.children, customizeSize = props.size, style2 = props.style, id2 = props.id, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onFocus2 = props.onFocus, onBlur2 = props.onBlur;
  var prefixCls = getPrefixCls("radio", customizePrefixCls);
  var groupPrefixCls = "".concat(prefixCls, "-group");
  var childrenToRender = children;
  if (options && options.length > 0) {
    childrenToRender = options.map(function(option) {
      if (typeof option === "string" || typeof option === "number") {
        return /* @__PURE__ */ react.exports.createElement(InternalRadio$1, {
          key: option.toString(),
          prefixCls,
          disabled,
          value: option,
          checked: value2 === option
        }, option);
      }
      return /* @__PURE__ */ react.exports.createElement(InternalRadio$1, {
        key: "radio-group-value-options-".concat(option.value),
        prefixCls,
        disabled: option.disabled || disabled,
        value: option.value,
        checked: value2 === option.value,
        style: option.style
      }, option.label);
    });
  }
  var mergedSize = customizeSize || size;
  var classString = classnamesExports(groupPrefixCls, "".concat(groupPrefixCls, "-").concat(buttonStyle), (_classNames = {}, _defineProperty$5(_classNames, "".concat(groupPrefixCls, "-").concat(mergedSize), mergedSize), _defineProperty$5(_classNames, "".concat(groupPrefixCls, "-rtl"), direction === "rtl"), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, getDataOrAriaProps(props), {
    className: classString,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onFocus: onFocus2,
    onBlur: onBlur2,
    id: id2,
    ref
  }), /* @__PURE__ */ react.exports.createElement(RadioGroupContextProvider, {
    value: {
      onChange: onRadioChange,
      value: value2,
      disabled: props.disabled,
      name: props.name,
      optionType: props.optionType
    }
  }, childrenToRender));
});
const Group$3 = /* @__PURE__ */ react.exports.memo(RadioGroup);
var __rest$q = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var RadioButton = function RadioButton2(props, ref) {
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var customizePrefixCls = props.prefixCls, radioProps = __rest$q(props, ["prefixCls"]);
  var prefixCls = getPrefixCls("radio", customizePrefixCls);
  return /* @__PURE__ */ react.exports.createElement(RadioOptionTypeContextProvider, {
    value: "button"
  }, /* @__PURE__ */ react.exports.createElement(InternalRadio$1, _extends$2({
    prefixCls
  }, radioProps, {
    type: "radio",
    ref
  })));
};
const Button = /* @__PURE__ */ react.exports.forwardRef(RadioButton);
var Radio = InternalRadio$1;
Radio.Button = Button;
Radio.Group = Group$3;
Radio.__ANT_RADIO = true;
const Radio$1 = Radio;
function removeFromCheckedKeys(halfCheckedKeys, checkedKeys) {
  var filteredKeys = /* @__PURE__ */ new Set();
  halfCheckedKeys.forEach(function(key2) {
    if (!checkedKeys.has(key2)) {
      filteredKeys.add(key2);
    }
  });
  return filteredKeys;
}
function isCheckDisabled(node) {
  var _ref = node || {}, disabled = _ref.disabled, disableCheckbox = _ref.disableCheckbox, checkable = _ref.checkable;
  return !!(disabled || disableCheckbox) || checkable === false;
}
function fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = /* @__PURE__ */ new Set();
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children = entity.children, children = _entity$children === void 0 ? [] : _entity$children;
      if (checkedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.add(childEntity.key);
        });
      }
    });
  }
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level = maxLevel; _level >= 0; _level -= 1) {
    var _entities = levelEntities.get(_level) || /* @__PURE__ */ new Set();
    _entities.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref2) {
        var key2 = _ref2.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (allChecked) {
        checkedKeys.add(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function cleanConductCheck(keys2, halfKeys, levelEntities, maxLevel, syntheticGetCheckDisabled) {
  var checkedKeys = new Set(keys2);
  var halfCheckedKeys = new Set(halfKeys);
  for (var level = 0; level <= maxLevel; level += 1) {
    var entities = levelEntities.get(level) || /* @__PURE__ */ new Set();
    entities.forEach(function(entity) {
      var key2 = entity.key, node = entity.node, _entity$children2 = entity.children, children = _entity$children2 === void 0 ? [] : _entity$children2;
      if (!checkedKeys.has(key2) && !halfCheckedKeys.has(key2) && !syntheticGetCheckDisabled(node)) {
        children.filter(function(childEntity) {
          return !syntheticGetCheckDisabled(childEntity.node);
        }).forEach(function(childEntity) {
          checkedKeys.delete(childEntity.key);
        });
      }
    });
  }
  halfCheckedKeys = /* @__PURE__ */ new Set();
  var visitedKeys = /* @__PURE__ */ new Set();
  for (var _level2 = maxLevel; _level2 >= 0; _level2 -= 1) {
    var _entities2 = levelEntities.get(_level2) || /* @__PURE__ */ new Set();
    _entities2.forEach(function(entity) {
      var parent = entity.parent, node = entity.node;
      if (syntheticGetCheckDisabled(node) || !entity.parent || visitedKeys.has(entity.parent.key)) {
        return;
      }
      if (syntheticGetCheckDisabled(entity.parent.node)) {
        visitedKeys.add(parent.key);
        return;
      }
      var allChecked = true;
      var partialChecked = false;
      (parent.children || []).filter(function(childEntity) {
        return !syntheticGetCheckDisabled(childEntity.node);
      }).forEach(function(_ref3) {
        var key2 = _ref3.key;
        var checked = checkedKeys.has(key2);
        if (allChecked && !checked) {
          allChecked = false;
        }
        if (!partialChecked && (checked || halfCheckedKeys.has(key2))) {
          partialChecked = true;
        }
      });
      if (!allChecked) {
        checkedKeys.delete(parent.key);
      }
      if (partialChecked) {
        halfCheckedKeys.add(parent.key);
      }
      visitedKeys.add(parent.key);
    });
  }
  return {
    checkedKeys: Array.from(checkedKeys),
    halfCheckedKeys: Array.from(removeFromCheckedKeys(halfCheckedKeys, checkedKeys))
  };
}
function conductCheck(keyList, checked, keyEntities, getCheckDisabled) {
  var warningMissKeys = [];
  var syntheticGetCheckDisabled;
  if (getCheckDisabled) {
    syntheticGetCheckDisabled = getCheckDisabled;
  } else {
    syntheticGetCheckDisabled = isCheckDisabled;
  }
  var keys2 = new Set(keyList.filter(function(key2) {
    var hasEntity = !!keyEntities[key2];
    if (!hasEntity) {
      warningMissKeys.push(key2);
    }
    return hasEntity;
  }));
  var levelEntities = /* @__PURE__ */ new Map();
  var maxLevel = 0;
  Object.keys(keyEntities).forEach(function(key2) {
    var entity = keyEntities[key2];
    var level = entity.level;
    var levelSet = levelEntities.get(level);
    if (!levelSet) {
      levelSet = /* @__PURE__ */ new Set();
      levelEntities.set(level, levelSet);
    }
    levelSet.add(entity);
    maxLevel = Math.max(maxLevel, level);
  });
  warningOnce(!warningMissKeys.length, "Tree missing follow keys: ".concat(warningMissKeys.slice(0, 100).map(function(key2) {
    return "'".concat(key2, "'");
  }).join(", ")));
  var result;
  if (checked === true) {
    result = fillConductCheck(keys2, levelEntities, maxLevel, syntheticGetCheckDisabled);
  } else {
    result = cleanConductCheck(keys2, checked.halfCheckedKeys, levelEntities, maxLevel, syntheticGetCheckDisabled);
  }
  return result;
}
var TreeContext = /* @__PURE__ */ react.exports.createContext(null);
var Indent = function Indent2(_ref) {
  var prefixCls = _ref.prefixCls, level = _ref.level, isStart = _ref.isStart, isEnd = _ref.isEnd;
  var baseClassName = "".concat(prefixCls, "-indent-unit");
  var list2 = [];
  for (var i = 0; i < level; i += 1) {
    var _classNames;
    list2.push(/* @__PURE__ */ react.exports.createElement("span", {
      key: i,
      className: classnamesExports(baseClassName, (_classNames = {}, _defineProperty$5(_classNames, "".concat(baseClassName, "-start"), isStart[i]), _defineProperty$5(_classNames, "".concat(baseClassName, "-end"), isEnd[i]), _classNames))
    }));
  }
  return /* @__PURE__ */ react.exports.createElement("span", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-indent")
  }, list2);
};
const Indent$1 = /* @__PURE__ */ react.exports.memo(Indent);
var _excluded$b = ["eventKey", "className", "style", "dragOver", "dragOverGapTop", "dragOverGapBottom", "isLeaf", "isStart", "isEnd", "expanded", "selected", "checked", "halfChecked", "loading", "domRef", "active", "data", "onMouseMove", "selectable"];
var ICON_OPEN = "open";
var ICON_CLOSE = "close";
var defaultTitle = "---";
var InternalTreeNode = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(InternalTreeNode2, _React$Component);
  var _super = _createSuper$1(InternalTreeNode2);
  function InternalTreeNode2() {
    var _this;
    _classCallCheck$2(this, InternalTreeNode2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      dragNodeHighlight: false
    };
    _this.selectHandle = void 0;
    _this.onSelectorClick = function(e2) {
      var onNodeClick = _this.props.context.onNodeClick;
      onNodeClick(e2, convertNodePropsToEventData(_this.props));
      if (_this.isSelectable()) {
        _this.onSelect(e2);
      } else {
        _this.onCheck(e2);
      }
    };
    _this.onSelectorDoubleClick = function(e2) {
      var onNodeDoubleClick = _this.props.context.onNodeDoubleClick;
      onNodeDoubleClick(e2, convertNodePropsToEventData(_this.props));
    };
    _this.onSelect = function(e2) {
      if (_this.isDisabled())
        return;
      var onNodeSelect = _this.props.context.onNodeSelect;
      e2.preventDefault();
      onNodeSelect(e2, convertNodePropsToEventData(_this.props));
    };
    _this.onCheck = function(e2) {
      if (_this.isDisabled())
        return;
      var _this$props = _this.props, disableCheckbox = _this$props.disableCheckbox, checked = _this$props.checked;
      var onNodeCheck = _this.props.context.onNodeCheck;
      if (!_this.isCheckable() || disableCheckbox)
        return;
      e2.preventDefault();
      var targetChecked = !checked;
      onNodeCheck(e2, convertNodePropsToEventData(_this.props), targetChecked);
    };
    _this.onMouseEnter = function(e2) {
      var onNodeMouseEnter = _this.props.context.onNodeMouseEnter;
      onNodeMouseEnter(e2, convertNodePropsToEventData(_this.props));
    };
    _this.onMouseLeave = function(e2) {
      var onNodeMouseLeave = _this.props.context.onNodeMouseLeave;
      onNodeMouseLeave(e2, convertNodePropsToEventData(_this.props));
    };
    _this.onContextMenu = function(e2) {
      var onNodeContextMenu = _this.props.context.onNodeContextMenu;
      onNodeContextMenu(e2, convertNodePropsToEventData(_this.props));
    };
    _this.onDragStart = function(e2) {
      var onNodeDragStart = _this.props.context.onNodeDragStart;
      e2.stopPropagation();
      _this.setState({
        dragNodeHighlight: true
      });
      onNodeDragStart(e2, _assertThisInitialized$1(_this));
      try {
        e2.dataTransfer.setData("text/plain", "");
      } catch (error) {
      }
    };
    _this.onDragEnter = function(e2) {
      var onNodeDragEnter = _this.props.context.onNodeDragEnter;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragEnter(e2, _assertThisInitialized$1(_this));
    };
    _this.onDragOver = function(e2) {
      var onNodeDragOver = _this.props.context.onNodeDragOver;
      e2.preventDefault();
      e2.stopPropagation();
      onNodeDragOver(e2, _assertThisInitialized$1(_this));
    };
    _this.onDragLeave = function(e2) {
      var onNodeDragLeave = _this.props.context.onNodeDragLeave;
      e2.stopPropagation();
      onNodeDragLeave(e2, _assertThisInitialized$1(_this));
    };
    _this.onDragEnd = function(e2) {
      var onNodeDragEnd = _this.props.context.onNodeDragEnd;
      e2.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDragEnd(e2, _assertThisInitialized$1(_this));
    };
    _this.onDrop = function(e2) {
      var onNodeDrop = _this.props.context.onNodeDrop;
      e2.preventDefault();
      e2.stopPropagation();
      _this.setState({
        dragNodeHighlight: false
      });
      onNodeDrop(e2, _assertThisInitialized$1(_this));
    };
    _this.onExpand = function(e2) {
      var _this$props2 = _this.props, loading = _this$props2.loading, onNodeExpand = _this$props2.context.onNodeExpand;
      if (loading)
        return;
      onNodeExpand(e2, convertNodePropsToEventData(_this.props));
    };
    _this.setSelectHandle = function(node) {
      _this.selectHandle = node;
    };
    _this.getNodeState = function() {
      var expanded = _this.props.expanded;
      if (_this.isLeaf()) {
        return null;
      }
      return expanded ? ICON_OPEN : ICON_CLOSE;
    };
    _this.hasChildren = function() {
      var eventKey = _this.props.eventKey;
      var keyEntities = _this.props.context.keyEntities;
      var _ref = keyEntities[eventKey] || {}, children = _ref.children;
      return !!(children || []).length;
    };
    _this.isLeaf = function() {
      var _this$props3 = _this.props, isLeaf = _this$props3.isLeaf, loaded = _this$props3.loaded;
      var loadData = _this.props.context.loadData;
      var hasChildren = _this.hasChildren();
      if (isLeaf === false) {
        return false;
      }
      return isLeaf || !loadData && !hasChildren || loadData && loaded && !hasChildren;
    };
    _this.isDisabled = function() {
      var disabled = _this.props.disabled;
      var treeDisabled = _this.props.context.disabled;
      return !!(treeDisabled || disabled);
    };
    _this.isCheckable = function() {
      var checkable = _this.props.checkable;
      var treeCheckable = _this.props.context.checkable;
      if (!treeCheckable || checkable === false)
        return false;
      return treeCheckable;
    };
    _this.syncLoadData = function(props) {
      var expanded = props.expanded, loading = props.loading, loaded = props.loaded;
      var _this$props$context = _this.props.context, loadData = _this$props$context.loadData, onNodeLoad = _this$props$context.onNodeLoad;
      if (loading) {
        return;
      }
      if (loadData && expanded && !_this.isLeaf()) {
        if (!_this.hasChildren() && !loaded) {
          onNodeLoad(convertNodePropsToEventData(_this.props));
        }
      }
    };
    _this.isDraggable = function() {
      var _this$props4 = _this.props, data2 = _this$props4.data, draggable = _this$props4.context.draggable;
      return !!(draggable && (!draggable.nodeDraggable || draggable.nodeDraggable(data2)));
    };
    _this.renderDragHandler = function() {
      var _this$props$context2 = _this.props.context, draggable = _this$props$context2.draggable, prefixCls = _this$props$context2.prefixCls;
      return (draggable === null || draggable === void 0 ? void 0 : draggable.icon) ? /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-draggable-icon")
      }, draggable.icon) : null;
    };
    _this.renderSwitcherIconDom = function(isLeaf) {
      var switcherIconFromProps = _this.props.switcherIcon;
      var switcherIconFromCtx = _this.props.context.switcherIcon;
      var switcherIcon = switcherIconFromProps || switcherIconFromCtx;
      if (typeof switcherIcon === "function") {
        return switcherIcon(_objectSpread2$4(_objectSpread2$4({}, _this.props), {}, {
          isLeaf
        }));
      }
      return switcherIcon;
    };
    _this.renderSwitcher = function() {
      var expanded = _this.props.expanded;
      var prefixCls = _this.props.context.prefixCls;
      if (_this.isLeaf()) {
        var _switcherIconDom = _this.renderSwitcherIconDom(true);
        return _switcherIconDom !== false ? /* @__PURE__ */ react.exports.createElement("span", {
          className: classnamesExports("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher-noop"))
        }, _switcherIconDom) : null;
      }
      var switcherCls = classnamesExports("".concat(prefixCls, "-switcher"), "".concat(prefixCls, "-switcher_").concat(expanded ? ICON_OPEN : ICON_CLOSE));
      var switcherIconDom = _this.renderSwitcherIconDom(false);
      return switcherIconDom !== false ? /* @__PURE__ */ react.exports.createElement("span", {
        onClick: _this.onExpand,
        className: switcherCls
      }, switcherIconDom) : null;
    };
    _this.renderCheckbox = function() {
      var _this$props5 = _this.props, checked = _this$props5.checked, halfChecked = _this$props5.halfChecked, disableCheckbox = _this$props5.disableCheckbox;
      var prefixCls = _this.props.context.prefixCls;
      var disabled = _this.isDisabled();
      var checkable = _this.isCheckable();
      if (!checkable)
        return null;
      var $custom = typeof checkable !== "boolean" ? checkable : null;
      return /* @__PURE__ */ react.exports.createElement("span", {
        className: classnamesExports("".concat(prefixCls, "-checkbox"), checked && "".concat(prefixCls, "-checkbox-checked"), !checked && halfChecked && "".concat(prefixCls, "-checkbox-indeterminate"), (disabled || disableCheckbox) && "".concat(prefixCls, "-checkbox-disabled")),
        onClick: _this.onCheck
      }, $custom);
    };
    _this.renderIcon = function() {
      var loading = _this.props.loading;
      var prefixCls = _this.props.context.prefixCls;
      return /* @__PURE__ */ react.exports.createElement("span", {
        className: classnamesExports("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__").concat(_this.getNodeState() || "docu"), loading && "".concat(prefixCls, "-icon_loading"))
      });
    };
    _this.renderSelector = function() {
      var dragNodeHighlight = _this.state.dragNodeHighlight;
      var _this$props6 = _this.props, title = _this$props6.title, selected = _this$props6.selected, icon = _this$props6.icon, loading = _this$props6.loading, data2 = _this$props6.data;
      var _this$props$context3 = _this.props.context, prefixCls = _this$props$context3.prefixCls, showIcon = _this$props$context3.showIcon, treeIcon = _this$props$context3.icon, loadData = _this$props$context3.loadData, titleRender = _this$props$context3.titleRender;
      var disabled = _this.isDisabled();
      var wrapClass = "".concat(prefixCls, "-node-content-wrapper");
      var $icon;
      if (showIcon) {
        var currentIcon = icon || treeIcon;
        $icon = currentIcon ? /* @__PURE__ */ react.exports.createElement("span", {
          className: classnamesExports("".concat(prefixCls, "-iconEle"), "".concat(prefixCls, "-icon__customize"))
        }, typeof currentIcon === "function" ? currentIcon(_this.props) : currentIcon) : _this.renderIcon();
      } else if (loadData && loading) {
        $icon = _this.renderIcon();
      }
      var titleNode;
      if (typeof title === "function") {
        titleNode = title(data2);
      } else if (titleRender) {
        titleNode = titleRender(data2);
      } else {
        titleNode = title;
      }
      var $title = /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-title")
      }, titleNode);
      return /* @__PURE__ */ react.exports.createElement("span", {
        ref: _this.setSelectHandle,
        title: typeof title === "string" ? title : "",
        className: classnamesExports("".concat(wrapClass), "".concat(wrapClass, "-").concat(_this.getNodeState() || "normal"), !disabled && (selected || dragNodeHighlight) && "".concat(prefixCls, "-node-selected")),
        onMouseEnter: _this.onMouseEnter,
        onMouseLeave: _this.onMouseLeave,
        onContextMenu: _this.onContextMenu,
        onClick: _this.onSelectorClick,
        onDoubleClick: _this.onSelectorDoubleClick
      }, $icon, $title, _this.renderDropIndicator());
    };
    _this.renderDropIndicator = function() {
      var _this$props7 = _this.props, disabled = _this$props7.disabled, eventKey = _this$props7.eventKey;
      var _this$props$context4 = _this.props.context, draggable = _this$props$context4.draggable, dropLevelOffset = _this$props$context4.dropLevelOffset, dropPosition = _this$props$context4.dropPosition, prefixCls = _this$props$context4.prefixCls, indent = _this$props$context4.indent, dropIndicatorRender2 = _this$props$context4.dropIndicatorRender, dragOverNodeKey = _this$props$context4.dragOverNodeKey, direction = _this$props$context4.direction;
      var rootDraggable = draggable !== false;
      var showIndicator = !disabled && rootDraggable && dragOverNodeKey === eventKey;
      return showIndicator ? dropIndicatorRender2({
        dropPosition,
        dropLevelOffset,
        indent,
        prefixCls,
        direction
      }) : null;
    };
    return _this;
  }
  _createClass$2(InternalTreeNode2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.syncLoadData(this.props);
    }
  }, {
    key: "isSelectable",
    value: function isSelectable() {
      var selectable = this.props.selectable;
      var treeSelectable = this.props.context.selectable;
      if (typeof selectable === "boolean") {
        return selectable;
      }
      return treeSelectable;
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$props8 = this.props, eventKey = _this$props8.eventKey, className = _this$props8.className, style2 = _this$props8.style, dragOver = _this$props8.dragOver, dragOverGapTop = _this$props8.dragOverGapTop, dragOverGapBottom = _this$props8.dragOverGapBottom, isLeaf = _this$props8.isLeaf, isStart = _this$props8.isStart, isEnd = _this$props8.isEnd, expanded = _this$props8.expanded, selected = _this$props8.selected, checked = _this$props8.checked, halfChecked = _this$props8.halfChecked, loading = _this$props8.loading, domRef = _this$props8.domRef, active = _this$props8.active;
      _this$props8.data;
      var onMouseMove = _this$props8.onMouseMove, selectable = _this$props8.selectable, otherProps = _objectWithoutProperties$1(_this$props8, _excluded$b);
      var _this$props$context5 = this.props.context, prefixCls = _this$props$context5.prefixCls, filterTreeNode = _this$props$context5.filterTreeNode, keyEntities = _this$props$context5.keyEntities, dropContainerKey = _this$props$context5.dropContainerKey, dropTargetKey = _this$props$context5.dropTargetKey, draggingNodeKey = _this$props$context5.draggingNodeKey;
      var disabled = this.isDisabled();
      var dataOrAriaAttributeProps = pickAttrs(otherProps, {
        aria: true,
        data: true
      });
      var _ref2 = keyEntities[eventKey] || {}, level = _ref2.level;
      var isEndNode = isEnd[isEnd.length - 1];
      var mergedDraggable = this.isDraggable();
      var draggableWithoutDisabled = !disabled && mergedDraggable;
      var dragging = draggingNodeKey === eventKey;
      var ariaSelected = selectable !== void 0 ? {
        "aria-selected": !!selectable
      } : void 0;
      return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
        ref: domRef,
        className: classnamesExports(className, "".concat(prefixCls, "-treenode"), (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-disabled"), disabled), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-switcher-").concat(expanded ? "open" : "close"), !isLeaf), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-checkbox-checked"), checked), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-checkbox-indeterminate"), halfChecked), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-selected"), selected), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-loading"), loading), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-active"), active), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-leaf-last"), isEndNode), _defineProperty$5(_classNames, "".concat(prefixCls, "-treenode-draggable"), draggableWithoutDisabled), _defineProperty$5(_classNames, "dragging", dragging), _defineProperty$5(_classNames, "drop-target", dropTargetKey === eventKey), _defineProperty$5(_classNames, "drop-container", dropContainerKey === eventKey), _defineProperty$5(_classNames, "drag-over", !disabled && dragOver), _defineProperty$5(_classNames, "drag-over-gap-top", !disabled && dragOverGapTop), _defineProperty$5(_classNames, "drag-over-gap-bottom", !disabled && dragOverGapBottom), _defineProperty$5(_classNames, "filter-node", filterTreeNode && filterTreeNode(convertNodePropsToEventData(this.props))), _classNames)),
        style: style2,
        draggable: draggableWithoutDisabled,
        "aria-grabbed": dragging,
        onDragStart: draggableWithoutDisabled ? this.onDragStart : void 0,
        onDragEnter: mergedDraggable ? this.onDragEnter : void 0,
        onDragOver: mergedDraggable ? this.onDragOver : void 0,
        onDragLeave: mergedDraggable ? this.onDragLeave : void 0,
        onDrop: mergedDraggable ? this.onDrop : void 0,
        onDragEnd: mergedDraggable ? this.onDragEnd : void 0,
        onMouseMove
      }, ariaSelected, dataOrAriaAttributeProps), /* @__PURE__ */ react.exports.createElement(Indent$1, {
        prefixCls,
        level,
        isStart,
        isEnd
      }), this.renderDragHandler(), this.renderSwitcher(), this.renderCheckbox(), this.renderSelector());
    }
  }]);
  return InternalTreeNode2;
}(react.exports.Component);
var ContextTreeNode = function ContextTreeNode2(props) {
  return /* @__PURE__ */ react.exports.createElement(TreeContext.Consumer, null, function(context2) {
    return /* @__PURE__ */ react.exports.createElement(InternalTreeNode, _extends$2({}, props, {
      context: context2
    }));
  });
};
ContextTreeNode.displayName = "TreeNode";
ContextTreeNode.defaultProps = {
  title: defaultTitle
};
ContextTreeNode.isTreeNode = 1;
function arrDel(list2, value2) {
  if (!list2)
    return [];
  var clone2 = list2.slice();
  var index2 = clone2.indexOf(value2);
  if (index2 >= 0) {
    clone2.splice(index2, 1);
  }
  return clone2;
}
function arrAdd(list2, value2) {
  var clone2 = (list2 || []).slice();
  if (clone2.indexOf(value2) === -1) {
    clone2.push(value2);
  }
  return clone2;
}
function posToArr(pos) {
  return pos.split("-");
}
function getPosition(level, index2) {
  return "".concat(level, "-").concat(index2);
}
function isTreeNode(node) {
  return node && node.type && node.type.isTreeNode;
}
function getDragChildrenKeys(dragNodeKey, keyEntities) {
  var dragChildrenKeys = [];
  var entity = keyEntities[dragNodeKey];
  function dig() {
    var list2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    list2.forEach(function(_ref) {
      var key2 = _ref.key, children = _ref.children;
      dragChildrenKeys.push(key2);
      dig(children);
    });
  }
  dig(entity.children);
  return dragChildrenKeys;
}
function isLastChild(treeNodeEntity) {
  if (treeNodeEntity.parent) {
    var posArr = posToArr(treeNodeEntity.pos);
    return Number(posArr[posArr.length - 1]) === treeNodeEntity.parent.children.length - 1;
  }
  return false;
}
function isFirstChild(treeNodeEntity) {
  var posArr = posToArr(treeNodeEntity.pos);
  return Number(posArr[posArr.length - 1]) === 0;
}
function calcDropPosition(event, dragNode, targetNode, indent, startMousePosition, allowDrop2, flattenedNodes, keyEntities, expandKeys, direction) {
  var _abstractDropNodeEnti;
  var clientX = event.clientX, clientY = event.clientY;
  var _event$target$getBoun = event.target.getBoundingClientRect(), top = _event$target$getBoun.top, height = _event$target$getBoun.height;
  var horizontalMouseOffset = (direction === "rtl" ? -1 : 1) * (((startMousePosition === null || startMousePosition === void 0 ? void 0 : startMousePosition.x) || 0) - clientX);
  var rawDropLevelOffset = (horizontalMouseOffset - 12) / indent;
  var abstractDropNodeEntity = keyEntities[targetNode.props.eventKey];
  if (clientY < top + height / 2) {
    var nodeIndex = flattenedNodes.findIndex(function(flattenedNode) {
      return flattenedNode.key === abstractDropNodeEntity.key;
    });
    var prevNodeIndex = nodeIndex <= 0 ? 0 : nodeIndex - 1;
    var prevNodeKey = flattenedNodes[prevNodeIndex].key;
    abstractDropNodeEntity = keyEntities[prevNodeKey];
  }
  var initialAbstractDropNodeKey = abstractDropNodeEntity.key;
  var abstractDragOverEntity = abstractDropNodeEntity;
  var dragOverNodeKey = abstractDropNodeEntity.key;
  var dropPosition = 0;
  var dropLevelOffset = 0;
  if (!expandKeys.includes(initialAbstractDropNodeKey)) {
    for (var i = 0; i < rawDropLevelOffset; i += 1) {
      if (isLastChild(abstractDropNodeEntity)) {
        abstractDropNodeEntity = abstractDropNodeEntity.parent;
        dropLevelOffset += 1;
      } else {
        break;
      }
    }
  }
  var abstractDragDataNode = dragNode.props.data;
  var abstractDropDataNode = abstractDropNodeEntity.node;
  var dropAllowed = true;
  if (isFirstChild(abstractDropNodeEntity) && abstractDropNodeEntity.level === 0 && clientY < top + height / 2 && allowDrop2({
    dragNode: abstractDragDataNode,
    dropNode: abstractDropDataNode,
    dropPosition: -1
  }) && abstractDropNodeEntity.key === targetNode.props.eventKey) {
    dropPosition = -1;
  } else if ((abstractDragOverEntity.children || []).length && expandKeys.includes(dragOverNodeKey)) {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 0
    })) {
      dropPosition = 0;
    } else {
      dropAllowed = false;
    }
  } else if (dropLevelOffset === 0) {
    if (rawDropLevelOffset > -1.5) {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    } else {
      if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 0
      })) {
        dropPosition = 0;
      } else if (allowDrop2({
        dragNode: abstractDragDataNode,
        dropNode: abstractDropDataNode,
        dropPosition: 1
      })) {
        dropPosition = 1;
      } else {
        dropAllowed = false;
      }
    }
  } else {
    if (allowDrop2({
      dragNode: abstractDragDataNode,
      dropNode: abstractDropDataNode,
      dropPosition: 1
    })) {
      dropPosition = 1;
    } else {
      dropAllowed = false;
    }
  }
  return {
    dropPosition,
    dropLevelOffset,
    dropTargetKey: abstractDropNodeEntity.key,
    dropTargetPos: abstractDropNodeEntity.pos,
    dragOverNodeKey,
    dropContainerKey: dropPosition === 0 ? null : ((_abstractDropNodeEnti = abstractDropNodeEntity.parent) === null || _abstractDropNodeEnti === void 0 ? void 0 : _abstractDropNodeEnti.key) || null,
    dropAllowed
  };
}
function calcSelectedKeys(selectedKeys, props) {
  if (!selectedKeys)
    return void 0;
  var multiple = props.multiple;
  if (multiple) {
    return selectedKeys.slice();
  }
  if (selectedKeys.length) {
    return [selectedKeys[0]];
  }
  return selectedKeys;
}
function parseCheckedKeys(keys2) {
  if (!keys2) {
    return null;
  }
  var keyProps;
  if (Array.isArray(keys2)) {
    keyProps = {
      checkedKeys: keys2,
      halfCheckedKeys: void 0
    };
  } else if (_typeof$4(keys2) === "object") {
    keyProps = {
      checkedKeys: keys2.checked || void 0,
      halfCheckedKeys: keys2.halfChecked || void 0
    };
  } else {
    warningOnce(false, "`checkedKeys` is not an array or an object");
    return null;
  }
  return keyProps;
}
function conductExpandParent(keyList, keyEntities) {
  var expandedKeys = /* @__PURE__ */ new Set();
  function conductUp(key2) {
    if (expandedKeys.has(key2))
      return;
    var entity = keyEntities[key2];
    if (!entity)
      return;
    expandedKeys.add(key2);
    var parent = entity.parent, node = entity.node;
    if (node.disabled)
      return;
    if (parent) {
      conductUp(parent.key);
    }
  }
  (keyList || []).forEach(function(key2) {
    conductUp(key2);
  });
  return _toConsumableArray(expandedKeys);
}
var _excluded$a = ["children"];
function getKey(key2, pos) {
  if (key2 !== null && key2 !== void 0) {
    return key2;
  }
  return pos;
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, title = _ref.title, _title = _ref._title, key2 = _ref.key, children = _ref.children;
  var mergedTitle = title || "title";
  return {
    title: mergedTitle,
    _title: _title || [mergedTitle],
    key: key2 || "key",
    children: children || "children"
  };
}
function convertTreeToData(rootNodes) {
  function dig(node) {
    var treeNodes = toArray$4(node);
    return treeNodes.map(function(treeNode) {
      if (!isTreeNode(treeNode)) {
        warningOnce(!treeNode, "Tree/TreeNode can only accept TreeNode as children.");
        return null;
      }
      var key2 = treeNode.key;
      var _treeNode$props = treeNode.props, children = _treeNode$props.children, rest = _objectWithoutProperties$1(_treeNode$props, _excluded$a);
      var dataNode = _objectSpread2$4({
        key: key2
      }, rest);
      var parsedChildren = dig(children);
      if (parsedChildren.length) {
        dataNode.children = parsedChildren;
      }
      return dataNode;
    }).filter(function(dataNode) {
      return dataNode;
    });
  }
  return dig(rootNodes);
}
function flattenTreeData(treeNodeList, expandedKeys, fieldNames) {
  var _fillFieldNames = fillFieldNames(fieldNames), fieldTitles = _fillFieldNames._title, fieldKey = _fillFieldNames.key, fieldChildren = _fillFieldNames.children;
  var expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);
  var flattenList = [];
  function dig(list2) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return list2.map(function(treeNode, index2) {
      var pos = getPosition(parent ? parent.pos : "0", index2);
      var mergedKey = getKey(treeNode[fieldKey], pos);
      var mergedTitle;
      for (var i = 0; i < fieldTitles.length; i += 1) {
        var fieldTitle = fieldTitles[i];
        if (treeNode[fieldTitle] !== void 0) {
          mergedTitle = treeNode[fieldTitle];
          break;
        }
      }
      var flattenNode = _objectSpread2$4(_objectSpread2$4({}, omit(treeNode, [].concat(_toConsumableArray(fieldTitles), [fieldKey, fieldChildren]))), {}, {
        title: mergedTitle,
        key: mergedKey,
        parent,
        pos,
        children: null,
        data: treeNode,
        isStart: [].concat(_toConsumableArray(parent ? parent.isStart : []), [index2 === 0]),
        isEnd: [].concat(_toConsumableArray(parent ? parent.isEnd : []), [index2 === list2.length - 1])
      });
      flattenList.push(flattenNode);
      if (expandedKeys === true || expandedKeySet.has(mergedKey)) {
        flattenNode.children = dig(treeNode[fieldChildren] || [], flattenNode);
      } else {
        flattenNode.children = [];
      }
      return flattenNode;
    });
  }
  dig(treeNodeList);
  return flattenList;
}
function traverseDataNodes(dataNodes, callback, config) {
  var mergedConfig = {};
  if (_typeof$4(config) === "object") {
    mergedConfig = config;
  } else {
    mergedConfig = {
      externalGetKey: config
    };
  }
  mergedConfig = mergedConfig || {};
  var _mergedConfig = mergedConfig, childrenPropName = _mergedConfig.childrenPropName, externalGetKey = _mergedConfig.externalGetKey, fieldNames = _mergedConfig.fieldNames;
  var _fillFieldNames2 = fillFieldNames(fieldNames), fieldKey = _fillFieldNames2.key, fieldChildren = _fillFieldNames2.children;
  var mergeChildrenPropName = childrenPropName || fieldChildren;
  var syntheticGetKey;
  if (externalGetKey) {
    if (typeof externalGetKey === "string") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return node[externalGetKey];
      };
    } else if (typeof externalGetKey === "function") {
      syntheticGetKey = function syntheticGetKey2(node) {
        return externalGetKey(node);
      };
    }
  } else {
    syntheticGetKey = function syntheticGetKey2(node, pos) {
      return getKey(node[fieldKey], pos);
    };
  }
  function processNode(node, index2, parent, pathNodes) {
    var children = node ? node[mergeChildrenPropName] : dataNodes;
    var pos = node ? getPosition(parent.pos, index2) : "0";
    var connectNodes = node ? [].concat(_toConsumableArray(pathNodes), [node]) : [];
    if (node) {
      var key2 = syntheticGetKey(node, pos);
      var data2 = {
        node,
        index: index2,
        pos,
        key: key2,
        parentPos: parent.node ? parent.pos : null,
        level: parent.level + 1,
        nodes: connectNodes
      };
      callback(data2);
    }
    if (children) {
      children.forEach(function(subNode, subIndex) {
        processNode(subNode, subIndex, {
          node,
          pos,
          level: parent ? parent.level + 1 : -1
        }, connectNodes);
      });
    }
  }
  processNode(null);
}
function convertDataToEntities(dataNodes) {
  var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, initWrapper = _ref2.initWrapper, processEntity = _ref2.processEntity, onProcessFinished = _ref2.onProcessFinished, externalGetKey = _ref2.externalGetKey, childrenPropName = _ref2.childrenPropName, fieldNames = _ref2.fieldNames;
  var legacyExternalGetKey = arguments.length > 2 ? arguments[2] : void 0;
  var mergedExternalGetKey = externalGetKey || legacyExternalGetKey;
  var posEntities = {};
  var keyEntities = {};
  var wrapper = {
    posEntities,
    keyEntities
  };
  if (initWrapper) {
    wrapper = initWrapper(wrapper) || wrapper;
  }
  traverseDataNodes(dataNodes, function(item) {
    var node = item.node, index2 = item.index, pos = item.pos, key2 = item.key, parentPos = item.parentPos, level = item.level, nodes = item.nodes;
    var entity = {
      node,
      nodes,
      index: index2,
      key: key2,
      pos,
      level
    };
    var mergedKey = getKey(key2, pos);
    posEntities[pos] = entity;
    keyEntities[mergedKey] = entity;
    entity.parent = posEntities[parentPos];
    if (entity.parent) {
      entity.parent.children = entity.parent.children || [];
      entity.parent.children.push(entity);
    }
    if (processEntity) {
      processEntity(entity, wrapper);
    }
  }, {
    externalGetKey: mergedExternalGetKey,
    childrenPropName,
    fieldNames
  });
  if (onProcessFinished) {
    onProcessFinished(wrapper);
  }
  return wrapper;
}
function getTreeNodeProps(key2, _ref3) {
  var expandedKeys = _ref3.expandedKeys, selectedKeys = _ref3.selectedKeys, loadedKeys = _ref3.loadedKeys, loadingKeys = _ref3.loadingKeys, checkedKeys = _ref3.checkedKeys, halfCheckedKeys = _ref3.halfCheckedKeys, dragOverNodeKey = _ref3.dragOverNodeKey, dropPosition = _ref3.dropPosition, keyEntities = _ref3.keyEntities;
  var entity = keyEntities[key2];
  var treeNodeProps = {
    eventKey: key2,
    expanded: expandedKeys.indexOf(key2) !== -1,
    selected: selectedKeys.indexOf(key2) !== -1,
    loaded: loadedKeys.indexOf(key2) !== -1,
    loading: loadingKeys.indexOf(key2) !== -1,
    checked: checkedKeys.indexOf(key2) !== -1,
    halfChecked: halfCheckedKeys.indexOf(key2) !== -1,
    pos: String(entity ? entity.pos : ""),
    dragOver: dragOverNodeKey === key2 && dropPosition === 0,
    dragOverGapTop: dragOverNodeKey === key2 && dropPosition === -1,
    dragOverGapBottom: dragOverNodeKey === key2 && dropPosition === 1
  };
  return treeNodeProps;
}
function convertNodePropsToEventData(props) {
  var data2 = props.data, expanded = props.expanded, selected = props.selected, checked = props.checked, loaded = props.loaded, loading = props.loading, halfChecked = props.halfChecked, dragOver = props.dragOver, dragOverGapTop = props.dragOverGapTop, dragOverGapBottom = props.dragOverGapBottom, pos = props.pos, active = props.active, eventKey = props.eventKey;
  var eventData = _objectSpread2$4(_objectSpread2$4({}, data2), {}, {
    expanded,
    selected,
    checked,
    loaded,
    loading,
    halfChecked,
    dragOver,
    dragOverGapTop,
    dragOverGapBottom,
    pos,
    active,
    key: eventKey
  });
  if (!("props" in eventData)) {
    Object.defineProperty(eventData, "props", {
      get: function get2() {
        warningOnce(false, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`.");
        return props;
      }
    });
  }
  return eventData;
}
var __rest$p = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var GroupContext = /* @__PURE__ */ react.exports.createContext(null);
var InternalCheckboxGroup = function InternalCheckboxGroup2(_a, ref) {
  var defaultValue = _a.defaultValue, children = _a.children, _a$options = _a.options, options = _a$options === void 0 ? [] : _a$options, customizePrefixCls = _a.prefixCls, className = _a.className, style2 = _a.style, onChange2 = _a.onChange, restProps = __rest$p(_a, ["defaultValue", "children", "options", "prefixCls", "className", "style", "onChange"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var _React$useState = react.exports.useState(restProps.value || defaultValue || []), _React$useState2 = _slicedToArray$3(_React$useState, 2), value2 = _React$useState2[0], setValue2 = _React$useState2[1];
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray$3(_React$useState3, 2), registeredValues = _React$useState4[0], setRegisteredValues = _React$useState4[1];
  react.exports.useEffect(function() {
    if ("value" in restProps) {
      setValue2(restProps.value || []);
    }
  }, [restProps.value]);
  var getOptions2 = function getOptions3() {
    return options.map(function(option) {
      if (typeof option === "string" || typeof option === "number") {
        return {
          label: option,
          value: option
        };
      }
      return option;
    });
  };
  var cancelValue = function cancelValue2(val) {
    setRegisteredValues(function(prevValues) {
      return prevValues.filter(function(v2) {
        return v2 !== val;
      });
    });
  };
  var registerValue = function registerValue2(val) {
    setRegisteredValues(function(prevValues) {
      return [].concat(_toConsumableArray(prevValues), [val]);
    });
  };
  var toggleOption = function toggleOption2(option) {
    var optionIndex = value2.indexOf(option.value);
    var newValue = _toConsumableArray(value2);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!("value" in restProps)) {
      setValue2(newValue);
    }
    var opts = getOptions2();
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(newValue.filter(function(val) {
      return registeredValues.indexOf(val) !== -1;
    }).sort(function(a, b2) {
      var indexA = opts.findIndex(function(opt) {
        return opt.value === a;
      });
      var indexB = opts.findIndex(function(opt) {
        return opt.value === b2;
      });
      return indexA - indexB;
    }));
  };
  var prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  var groupPrefixCls = "".concat(prefixCls, "-group");
  var domProps = omit(restProps, ["value", "disabled"]);
  if (options && options.length > 0) {
    children = getOptions2().map(function(option) {
      return /* @__PURE__ */ react.exports.createElement(InternalCheckbox$1, {
        prefixCls,
        key: option.value.toString(),
        disabled: "disabled" in option ? option.disabled : restProps.disabled,
        value: option.value,
        checked: value2.indexOf(option.value) !== -1,
        onChange: option.onChange,
        className: "".concat(groupPrefixCls, "-item"),
        style: option.style
      }, option.label);
    });
  }
  var context2 = {
    toggleOption,
    value: value2,
    disabled: restProps.disabled,
    name: restProps.name,
    registerValue,
    cancelValue
  };
  var classString = classnamesExports(groupPrefixCls, _defineProperty$5({}, "".concat(groupPrefixCls, "-rtl"), direction === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classString,
    style: style2
  }, domProps, {
    ref
  }), /* @__PURE__ */ react.exports.createElement(GroupContext.Provider, {
    value: context2
  }, children));
};
var CheckboxGroup = /* @__PURE__ */ react.exports.forwardRef(InternalCheckboxGroup);
const Group$2 = /* @__PURE__ */ react.exports.memo(CheckboxGroup);
var __rest$o = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var InternalCheckbox = function InternalCheckbox2(_a, ref) {
  var _classNames;
  var customizePrefixCls = _a.prefixCls, className = _a.className, children = _a.children, _a$indeterminate = _a.indeterminate, indeterminate = _a$indeterminate === void 0 ? false : _a$indeterminate, style2 = _a.style, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, _a$skipGroup = _a.skipGroup, skipGroup = _a$skipGroup === void 0 ? false : _a$skipGroup, disabled = _a.disabled, restProps = __rest$o(_a, ["prefixCls", "className", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var checkboxGroup = react.exports.useContext(GroupContext);
  var _useContext = react.exports.useContext(FormItemInputContext), isFormItemInput = _useContext.isFormItemInput;
  var contextDisabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = disabled || (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || contextDisabled;
  var prevValue = react.exports.useRef(restProps.value);
  react.exports.useEffect(function() {
    checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
  }, []);
  react.exports.useEffect(function() {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return function() {
      return checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
    };
  }, [restProps.value]);
  var prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  var checkboxProps = _extends$2({}, restProps);
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = function() {
      if (restProps.onChange) {
        restProps.onChange.apply(restProps, arguments);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value: restProps.value
        });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.indexOf(restProps.value) !== -1;
  }
  var classString = classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper"), true), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-checked"), checkboxProps.checked), _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-disabled"), mergedDisabled), _defineProperty$5(_classNames, "".concat(prefixCls, "-wrapper-in-form-item"), isFormItemInput), _classNames), className);
  var checkboxClass = classnamesExports(_defineProperty$5({}, "".concat(prefixCls, "-indeterminate"), indeterminate));
  var ariaChecked = indeterminate ? "mixed" : void 0;
  return /* @__PURE__ */ react.exports.createElement("label", {
    className: classString,
    style: style2,
    onMouseEnter,
    onMouseLeave
  }, /* @__PURE__ */ react.exports.createElement(Checkbox$3, _extends$2({
    "aria-checked": ariaChecked
  }, checkboxProps, {
    prefixCls,
    className: checkboxClass,
    disabled: mergedDisabled,
    ref
  })), children !== void 0 && /* @__PURE__ */ react.exports.createElement("span", null, children));
};
var Checkbox$2 = /* @__PURE__ */ react.exports.forwardRef(InternalCheckbox);
const InternalCheckbox$1 = Checkbox$2;
var Checkbox = InternalCheckbox$1;
Checkbox.Group = Group$2;
Checkbox.__ANT_CHECKBOX = true;
const Checkbox$1 = Checkbox;
var RowContext = /* @__PURE__ */ react.exports.createContext({});
const RowContext$1 = RowContext;
var __rest$n = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function parseFlex(flex) {
  if (typeof flex === "number") {
    return "".concat(flex, " ").concat(flex, " auto");
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return "0 0 ".concat(flex);
  }
  return flex;
}
var sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
var Col = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var _React$useContext2 = react.exports.useContext(RowContext$1), gutter = _React$useContext2.gutter, wrap2 = _React$useContext2.wrap, supportFlexGap = _React$useContext2.supportFlexGap;
  var customizePrefixCls = props.prefixCls, span = props.span, order2 = props.order, offset3 = props.offset, push = props.push, pull = props.pull, className = props.className, children = props.children, flex = props.flex, style2 = props.style, others = __rest$n(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
  var prefixCls = getPrefixCls("col", customizePrefixCls);
  var sizeClassObj = {};
  sizes.forEach(function(size) {
    var _extends2;
    var sizeProps = {};
    var propSize = props[size];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (_typeof$4(propSize) === "object") {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = _extends$2(_extends$2({}, sizeClassObj), (_extends2 = {}, _defineProperty$5(_extends2, "".concat(prefixCls, "-").concat(size, "-").concat(sizeProps.span), sizeProps.span !== void 0), _defineProperty$5(_extends2, "".concat(prefixCls, "-").concat(size, "-order-").concat(sizeProps.order), sizeProps.order || sizeProps.order === 0), _defineProperty$5(_extends2, "".concat(prefixCls, "-").concat(size, "-offset-").concat(sizeProps.offset), sizeProps.offset || sizeProps.offset === 0), _defineProperty$5(_extends2, "".concat(prefixCls, "-").concat(size, "-push-").concat(sizeProps.push), sizeProps.push || sizeProps.push === 0), _defineProperty$5(_extends2, "".concat(prefixCls, "-").concat(size, "-pull-").concat(sizeProps.pull), sizeProps.pull || sizeProps.pull === 0), _defineProperty$5(_extends2, "".concat(prefixCls, "-rtl"), direction === "rtl"), _extends2));
  });
  var classes = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(span), span !== void 0), _defineProperty$5(_classNames, "".concat(prefixCls, "-order-").concat(order2), order2), _defineProperty$5(_classNames, "".concat(prefixCls, "-offset-").concat(offset3), offset3), _defineProperty$5(_classNames, "".concat(prefixCls, "-push-").concat(push), push), _defineProperty$5(_classNames, "".concat(prefixCls, "-pull-").concat(pull), pull), _classNames), className, sizeClassObj);
  var mergedStyle = {};
  if (gutter && gutter[0] > 0) {
    var horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter;
    mergedStyle.paddingRight = horizontalGutter;
  }
  if (gutter && gutter[1] > 0 && !supportFlexGap) {
    var verticalGutter = gutter[1] / 2;
    mergedStyle.paddingTop = verticalGutter;
    mergedStyle.paddingBottom = verticalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap2 === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, others, {
    style: _extends$2(_extends$2({}, mergedStyle), style2),
    className: classes,
    ref
  }), children);
});
const Col$1 = Col;
var isStyleNameSupport = function isStyleNameSupport2(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function(name2) {
      return name2 in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport = function isStyleValueSupport2(styleName, value2) {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  var ele = document.createElement("div");
  var origin = ele.style[styleName];
  ele.style[styleName] = value2;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
var canUseDocElement = function canUseDocElement2() {
  return canUseDom() && window.document.documentElement;
};
var flexGapSupported;
var detectFlexGapSupported = function detectFlexGapSupported2() {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  var flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
const useFlexGapSupport = function() {
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), flexible = _React$useState2[0], setFlexible = _React$useState2[1];
  react.exports.useEffect(function() {
    setFlexible(detectFlexGapSupported());
  }, []);
  return flexible;
};
var __rest$m = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
tuple("top", "middle", "bottom", "stretch");
tuple("start", "end", "center", "space-around", "space-between", "space-evenly");
var Row = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls, justify = props.justify, align = props.align, className = props.className, style2 = props.style, children = props.children, _props$gutter = props.gutter, gutter = _props$gutter === void 0 ? 0 : _props$gutter, wrap2 = props.wrap, others = __rest$m(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var _React$useState = react.exports.useState({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  }), _React$useState2 = _slicedToArray$3(_React$useState, 2), screens2 = _React$useState2[0], setScreens = _React$useState2[1];
  var supportFlexGap = useFlexGapSupport();
  var gutterRef = react.exports.useRef(gutter);
  react.exports.useEffect(function() {
    var token = responsiveObserve.subscribe(function(screen) {
      var currentGutter = gutterRef.current || 0;
      if (!Array.isArray(currentGutter) && _typeof$4(currentGutter) === "object" || Array.isArray(currentGutter) && (_typeof$4(currentGutter[0]) === "object" || _typeof$4(currentGutter[1]) === "object")) {
        setScreens(screen);
      }
    });
    return function() {
      return responsiveObserve.unsubscribe(token);
    };
  }, []);
  var getGutter = function getGutter2() {
    var results = [void 0, void 0];
    var normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
    normalizedGutter.forEach(function(g2, index2) {
      if (_typeof$4(g2) === "object") {
        for (var i = 0; i < responsiveArray.length; i++) {
          var breakpoint = responsiveArray[i];
          if (screens2[breakpoint] && g2[breakpoint] !== void 0) {
            results[index2] = g2[breakpoint];
            break;
          }
        }
      } else {
        results[index2] = g2;
      }
    });
    return results;
  };
  var prefixCls = getPrefixCls("row", customizePrefixCls);
  var gutters = getGutter();
  var classes = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-no-wrap"), wrap2 === false), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(justify), justify), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(align), align), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
  var rowStyle = {};
  var horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
  var verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : void 0;
  if (horizontalGutter) {
    rowStyle.marginLeft = horizontalGutter;
    rowStyle.marginRight = horizontalGutter;
  }
  if (supportFlexGap) {
    var _gutters = _slicedToArray$3(gutters, 2);
    rowStyle.rowGap = _gutters[1];
  } else if (verticalGutter) {
    rowStyle.marginTop = verticalGutter;
    rowStyle.marginBottom = verticalGutter;
  }
  var _gutters2 = _slicedToArray$3(gutters, 2), gutterH = _gutters2[0], gutterV = _gutters2[1];
  var rowContext = react.exports.useMemo(function() {
    return {
      gutter: [gutterH, gutterV],
      wrap: wrap2,
      supportFlexGap
    };
  }, [gutterH, gutterV, wrap2, supportFlexGap]);
  return /* @__PURE__ */ react.exports.createElement(RowContext$1.Provider, {
    value: rowContext
  }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, others, {
    className: classes,
    style: _extends$2(_extends$2({}, rowStyle), style2),
    ref
  }), children));
});
const Row$1 = Row;
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    var inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    var outer = document.createElement("div");
    var outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function ensureSize(str) {
  var match2 = str.match(/^(.*)px$/);
  var value2 = Number(match2 === null || match2 === void 0 ? void 0 : match2[1]);
  return Number.isNaN(value2) ? getScrollBarSize() : value2;
}
function getTargetScrollBarSize(target) {
  if (typeof document === "undefined" || !target || !(target instanceof Element)) {
    return {
      width: 0,
      height: 0
    };
  }
  var _getComputedStyle2 = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle2.width, height = _getComputedStyle2.height;
  return {
    width: ensureSize(width),
    height: ensureSize(height)
  };
}
function useDebounce(value2) {
  var _React$useState = react.exports.useState(value2), _React$useState2 = _slicedToArray$3(_React$useState, 2), cacheValue = _React$useState2[0], setCacheValue = _React$useState2[1];
  react.exports.useEffect(function() {
    var timeout = setTimeout(function() {
      setCacheValue(value2);
    }, value2.length ? 0 : 10);
    return function() {
      clearTimeout(timeout);
    };
  }, [value2]);
  return cacheValue;
}
var EMPTY_LIST$2 = [];
function toErrorEntity(error, errorStatus, prefix2) {
  var index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  return {
    key: typeof error === "string" ? error : "".concat(prefix2, "-").concat(index2),
    error,
    errorStatus
  };
}
function ErrorList(_ref) {
  var help = _ref.help, helpStatus = _ref.helpStatus, _ref$errors = _ref.errors, errors = _ref$errors === void 0 ? EMPTY_LIST$2 : _ref$errors, _ref$warnings = _ref.warnings, warnings = _ref$warnings === void 0 ? EMPTY_LIST$2 : _ref$warnings, rootClassName = _ref.className, onVisibleChanged = _ref.onVisibleChanged;
  var _React$useContext = react.exports.useContext(FormItemPrefixContext), prefixCls = _React$useContext.prefixCls;
  var _React$useContext2 = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext2.getPrefixCls;
  var baseClassName = "".concat(prefixCls, "-item-explain");
  var rootPrefixCls = getPrefixCls();
  var debounceErrors = useDebounce(errors);
  var debounceWarnings = useDebounce(warnings);
  var fullKeyList = react.exports.useMemo(function() {
    if (help !== void 0 && help !== null) {
      return [toErrorEntity(help, helpStatus, "help")];
    }
    return [].concat(_toConsumableArray(debounceErrors.map(function(error, index2) {
      return toErrorEntity(error, "error", "error", index2);
    })), _toConsumableArray(debounceWarnings.map(function(warning3, index2) {
      return toErrorEntity(warning3, "warning", "warning", index2);
    })));
  }, [help, helpStatus, debounceErrors, debounceWarnings]);
  return /* @__PURE__ */ react.exports.createElement(CSSMotion, {
    motionDeadline: collapseMotion$1.motionDeadline,
    motionName: "".concat(rootPrefixCls, "-show-help"),
    visible: !!fullKeyList.length,
    onVisibleChanged
  }, function(holderProps) {
    var holderClassName = holderProps.className, holderStyle = holderProps.style;
    return /* @__PURE__ */ react.exports.createElement("div", {
      className: classnamesExports(baseClassName, holderClassName, rootClassName),
      style: holderStyle
    }, /* @__PURE__ */ react.exports.createElement(CSSMotionList, _extends$2({
      keys: fullKeyList
    }, collapseMotion$1, {
      motionName: "".concat(rootPrefixCls, "-show-help-item"),
      component: false
    }), function(itemProps) {
      var key2 = itemProps.key, error = itemProps.error, errorStatus = itemProps.errorStatus, itemClassName = itemProps.className, itemStyle = itemProps.style;
      return /* @__PURE__ */ react.exports.createElement("div", {
        key: key2,
        role: "alert",
        className: classnamesExports(itemClassName, _defineProperty$5({}, "".concat(baseClassName, "-").concat(errorStatus), errorStatus)),
        style: itemStyle
      }, error);
    }));
  });
}
function t(t2) {
  return "object" == typeof t2 && null != t2 && 1 === t2.nodeType;
}
function e(t2, e2) {
  return (!e2 || "hidden" !== t2) && "visible" !== t2 && "clip" !== t2;
}
function n(t2, n2) {
  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {
    var r2 = getComputedStyle(t2, null);
    return e(r2.overflowY, n2) || e(r2.overflowX, n2) || function(t3) {
      var e2 = function(t4) {
        if (!t4.ownerDocument || !t4.ownerDocument.defaultView)
          return null;
        try {
          return t4.ownerDocument.defaultView.frameElement;
        } catch (t5) {
          return null;
        }
      }(t3);
      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);
    }(t2);
  }
  return false;
}
function r(t2, e2, n2, r2, i, o, l2, d2) {
  return o < t2 && l2 > e2 || o > t2 && l2 < e2 ? 0 : o <= t2 && d2 <= n2 || l2 >= e2 && d2 >= n2 ? o - t2 - r2 : l2 > e2 && d2 < n2 || o < t2 && d2 > n2 ? l2 - e2 + i : 0;
}
function compute(e2, i) {
  var o = window, l2 = i.scrollMode, d2 = i.block, u2 = i.inline, h2 = i.boundary, a = i.skipOverflowHiddenElements, c2 = "function" == typeof h2 ? h2 : function(t2) {
    return t2 !== h2;
  };
  if (!t(e2))
    throw new TypeError("Invalid target");
  for (var f2 = document.scrollingElement || document.documentElement, s = [], p2 = e2; t(p2) && c2(p2); ) {
    if ((p2 = p2.parentElement) === f2) {
      s.push(p2);
      break;
    }
    null != p2 && p2 === document.body && n(p2) && !n(document.documentElement) || null != p2 && n(p2, a) && s.push(p2);
  }
  for (var m2 = o.visualViewport ? o.visualViewport.width : innerWidth, g2 = o.visualViewport ? o.visualViewport.height : innerHeight, w2 = window.scrollX || pageXOffset, v2 = window.scrollY || pageYOffset, W2 = e2.getBoundingClientRect(), b2 = W2.height, H2 = W2.width, y2 = W2.top, E2 = W2.right, M2 = W2.bottom, V2 = W2.left, x2 = "start" === d2 || "nearest" === d2 ? y2 : "end" === d2 ? M2 : y2 + b2 / 2, I2 = "center" === u2 ? V2 + H2 / 2 : "end" === u2 ? E2 : V2, C2 = [], T2 = 0; T2 < s.length; T2++) {
    var k2 = s[T2], B2 = k2.getBoundingClientRect(), D2 = B2.height, O2 = B2.width, R2 = B2.top, X2 = B2.right, Y2 = B2.bottom, L2 = B2.left;
    if ("if-needed" === l2 && y2 >= 0 && V2 >= 0 && M2 <= g2 && E2 <= m2 && y2 >= R2 && M2 <= Y2 && V2 >= L2 && E2 <= X2)
      return C2;
    var S2 = getComputedStyle(k2), j = parseInt(S2.borderLeftWidth, 10), q2 = parseInt(S2.borderTopWidth, 10), z2 = parseInt(S2.borderRightWidth, 10), A2 = parseInt(S2.borderBottomWidth, 10), F2 = 0, G2 = 0, J2 = "offsetWidth" in k2 ? k2.offsetWidth - k2.clientWidth - j - z2 : 0, K2 = "offsetHeight" in k2 ? k2.offsetHeight - k2.clientHeight - q2 - A2 : 0;
    if (f2 === k2)
      F2 = "start" === d2 ? x2 : "end" === d2 ? x2 - g2 : "nearest" === d2 ? r(v2, v2 + g2, g2, q2, A2, v2 + x2, v2 + x2 + b2, b2) : x2 - g2 / 2, G2 = "start" === u2 ? I2 : "center" === u2 ? I2 - m2 / 2 : "end" === u2 ? I2 - m2 : r(w2, w2 + m2, m2, j, z2, w2 + I2, w2 + I2 + H2, H2), F2 = Math.max(0, F2 + v2), G2 = Math.max(0, G2 + w2);
    else {
      F2 = "start" === d2 ? x2 - R2 - q2 : "end" === d2 ? x2 - Y2 + A2 + K2 : "nearest" === d2 ? r(R2, Y2, D2, q2, A2 + K2, x2, x2 + b2, b2) : x2 - (R2 + D2 / 2) + K2 / 2, G2 = "start" === u2 ? I2 - L2 - j : "center" === u2 ? I2 - (L2 + O2 / 2) + J2 / 2 : "end" === u2 ? I2 - X2 + z2 + J2 : r(L2, X2, O2, j, z2 + J2, I2, I2 + H2, H2);
      var N2 = k2.scrollLeft, P2 = k2.scrollTop;
      x2 += P2 - (F2 = Math.max(0, Math.min(P2 + F2, k2.scrollHeight - D2 + K2))), I2 += N2 - (G2 = Math.max(0, Math.min(N2 + G2, k2.scrollWidth - O2 + J2)));
    }
    C2.push({ el: k2, top: F2, left: G2 });
  }
  return C2;
}
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el2 = _ref.el, top = _ref.top, left = _ref.left;
    if (el2.scroll && canSmoothScroll) {
      el2.scroll({
        top,
        left,
        behavior
      });
    } else {
      el2.scrollTop = top;
      el2.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? compute(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);
}
var formItemNameBlackList = ["parentNode"];
var defaultItemNamePrefixCls = "form_item";
function toArray$1(candidate) {
  if (candidate === void 0 || candidate === false)
    return [];
  return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
  if (!namePath.length)
    return void 0;
  var mergedId = namePath.join("_");
  if (formName) {
    return "".concat(formName, "_").concat(mergedId);
  }
  var isIllegalName = formItemNameBlackList.indexOf(mergedId) >= 0;
  return isIllegalName ? "".concat(defaultItemNamePrefixCls, "_").concat(mergedId) : mergedId;
}
function toNamePathStr(name2) {
  var namePath = toArray$1(name2);
  return namePath.join("_");
}
function useForm(form2) {
  var _useRcForm = useForm$1(), _useRcForm2 = _slicedToArray$3(_useRcForm, 1), rcForm = _useRcForm2[0];
  var itemsRef = react.exports.useRef({});
  var wrapForm = react.exports.useMemo(function() {
    return form2 !== null && form2 !== void 0 ? form2 : _extends$2(_extends$2({}, rcForm), {
      __INTERNAL__: {
        itemRef: function itemRef2(name2) {
          return function(node) {
            var namePathStr = toNamePathStr(name2);
            if (node) {
              itemsRef.current[namePathStr] = node;
            } else {
              delete itemsRef.current[namePathStr];
            }
          };
        }
      },
      scrollToField: function scrollToField(name2) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var namePath = toArray$1(name2);
        var fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
        var node = fieldId ? document.getElementById(fieldId) : null;
        if (node) {
          scrollIntoView(node, _extends$2({
            scrollMode: "if-needed",
            block: "nearest"
          }, options));
        }
      },
      getFieldInstance: function getFieldInstance(name2) {
        var namePathStr = toNamePathStr(name2);
        return itemsRef.current[namePathStr];
      }
    });
  }, [form2, rcForm]);
  return [wrapForm];
}
var __rest$l = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var InternalForm = function InternalForm2(props, ref) {
  var _classNames;
  var contextSize = react.exports.useContext(SizeContext$1);
  var contextDisabled = react.exports.useContext(DisabledContext$1);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction, contextForm = _React$useContext.form;
  var customizePrefixCls = props.prefixCls, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, _props$size = props.size, size = _props$size === void 0 ? contextSize : _props$size, _props$disabled = props.disabled, disabled = _props$disabled === void 0 ? contextDisabled : _props$disabled, form2 = props.form, colon = props.colon, labelAlign = props.labelAlign, labelWrap = props.labelWrap, labelCol = props.labelCol, wrapperCol = props.wrapperCol, hideRequiredMark = props.hideRequiredMark, _props$layout = props.layout, layout = _props$layout === void 0 ? "horizontal" : _props$layout, scrollToFirstError = props.scrollToFirstError, requiredMark = props.requiredMark, onFinishFailed = props.onFinishFailed, name2 = props.name, restFormProps = __rest$l(props, ["prefixCls", "className", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name"]);
  var mergedRequiredMark = react.exports.useMemo(function() {
    if (requiredMark !== void 0) {
      return requiredMark;
    }
    if (contextForm && contextForm.requiredMark !== void 0) {
      return contextForm.requiredMark;
    }
    if (hideRequiredMark) {
      return false;
    }
    return true;
  }, [hideRequiredMark, requiredMark, contextForm]);
  var mergedColon = colon !== null && colon !== void 0 ? colon : contextForm === null || contextForm === void 0 ? void 0 : contextForm.colon;
  var prefixCls = getPrefixCls("form", customizePrefixCls);
  var formClassName = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(layout), true), _defineProperty$5(_classNames, "".concat(prefixCls, "-hide-required-mark"), mergedRequiredMark === false), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(size), size), _classNames), className);
  var _useForm = useForm(form2), _useForm2 = _slicedToArray$3(_useForm, 1), wrapForm = _useForm2[0];
  var __INTERNAL__ = wrapForm.__INTERNAL__;
  __INTERNAL__.name = name2;
  var formContextValue = react.exports.useMemo(function() {
    return {
      name: name2,
      labelAlign,
      labelCol,
      labelWrap,
      wrapperCol,
      vertical: layout === "vertical",
      colon: mergedColon,
      requiredMark: mergedRequiredMark,
      itemRef: __INTERNAL__.itemRef,
      form: wrapForm
    };
  }, [name2, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm]);
  react.exports.useImperativeHandle(ref, function() {
    return wrapForm;
  });
  var onInternalFinishFailed = function onInternalFinishFailed2(errorInfo) {
    onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
    var defaultScrollToFirstError = {
      block: "nearest"
    };
    if (scrollToFirstError && errorInfo.errorFields.length) {
      if (_typeof$4(scrollToFirstError) === "object") {
        defaultScrollToFirstError = scrollToFirstError;
      }
      wrapForm.scrollToField(errorInfo.errorFields[0].name, defaultScrollToFirstError);
    }
  };
  return /* @__PURE__ */ react.exports.createElement(DisabledContextProvider, {
    disabled
  }, /* @__PURE__ */ react.exports.createElement(SizeContextProvider, {
    size
  }, /* @__PURE__ */ react.exports.createElement(FormContext.Provider, {
    value: formContextValue
  }, /* @__PURE__ */ react.exports.createElement(RefForm, _extends$2({
    id: name2
  }, restFormProps, {
    name: name2,
    onFinishFailed: onInternalFinishFailed,
    form: wrapForm,
    className: formClassName
  })))));
};
var Form$2 = /* @__PURE__ */ react.exports.forwardRef(InternalForm);
const InternalForm$1 = Form$2;
var useFormItemStatus = function useFormItemStatus2() {
  var _useContext = react.exports.useContext(FormItemInputContext), status = _useContext.status;
  return {
    status
  };
};
const useFormItemStatus$1 = useFormItemStatus;
function useFrameState(defaultValue) {
  var _React$useState = react.exports.useState(defaultValue), _React$useState2 = _slicedToArray$3(_React$useState, 2), value2 = _React$useState2[0], setValue2 = _React$useState2[1];
  var frameRef = react.exports.useRef(null);
  var batchRef = react.exports.useRef([]);
  var destroyRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
      wrapperRaf$1.cancel(frameRef.current);
      frameRef.current = null;
    };
  }, []);
  function setFrameValue(updater) {
    if (destroyRef.current) {
      return;
    }
    if (frameRef.current === null) {
      batchRef.current = [];
      frameRef.current = wrapperRaf$1(function() {
        frameRef.current = null;
        setValue2(function(prevValue) {
          var current = prevValue;
          batchRef.current.forEach(function(func) {
            current = func(current);
          });
          return current;
        });
      });
    }
    batchRef.current.push(updater);
  }
  return [value2, setFrameValue];
}
function useItemRef() {
  var _React$useContext = react.exports.useContext(FormContext), itemRef2 = _React$useContext.itemRef;
  var cacheRef = react.exports.useRef({});
  function getRef(name2, children) {
    var childrenRef = children && _typeof$4(children) === "object" && children.ref;
    var nameStr = name2.join("_");
    if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
      cacheRef.current.name = nameStr;
      cacheRef.current.originRef = childrenRef;
      cacheRef.current.ref = composeRef(itemRef2(name2), childrenRef);
    }
    return cacheRef.current.ref;
  }
  return getRef;
}
var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;
var QuestionCircleOutlined = function QuestionCircleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: QuestionCircleOutlinedSvg
  }));
};
QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
const QuestionCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(QuestionCircleOutlined);
var __rest$k = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function toTooltipProps(tooltip) {
  if (!tooltip) {
    return null;
  }
  if (_typeof$4(tooltip) === "object" && !/* @__PURE__ */ react.exports.isValidElement(tooltip)) {
    return tooltip;
  }
  return {
    title: tooltip
  };
}
var FormItemLabel = function FormItemLabel2(_ref) {
  var prefixCls = _ref.prefixCls, label = _ref.label, htmlFor = _ref.htmlFor, labelCol = _ref.labelCol, labelAlign = _ref.labelAlign, colon = _ref.colon, required4 = _ref.required, requiredMark = _ref.requiredMark, tooltip = _ref.tooltip;
  var _useLocaleReceiver = useLocaleReceiver("Form"), _useLocaleReceiver2 = _slicedToArray$3(_useLocaleReceiver, 1), formLocale = _useLocaleReceiver2[0];
  if (!label)
    return null;
  return /* @__PURE__ */ react.exports.createElement(FormContext.Consumer, {
    key: "label"
  }, function(_ref2) {
    var _classNames2;
    var vertical = _ref2.vertical, contextLabelAlign = _ref2.labelAlign, contextLabelCol = _ref2.labelCol, labelWrap = _ref2.labelWrap, contextColon = _ref2.colon;
    var _a;
    var mergedLabelCol = labelCol || contextLabelCol || {};
    var mergedLabelAlign = labelAlign || contextLabelAlign;
    var labelClsBasic = "".concat(prefixCls, "-item-label");
    var labelColClassName = classnamesExports(labelClsBasic, mergedLabelAlign === "left" && "".concat(labelClsBasic, "-left"), mergedLabelCol.className, _defineProperty$5({}, "".concat(labelClsBasic, "-wrap"), !!labelWrap));
    var labelChildren = label;
    var computedColon = colon === true || contextColon !== false && colon !== false;
    var haveColon = computedColon && !vertical;
    if (haveColon && typeof label === "string" && label.trim() !== "") {
      labelChildren = label.replace(/[:|]\s*$/, "");
    }
    var tooltipProps = toTooltipProps(tooltip);
    if (tooltipProps) {
      var _tooltipProps$icon = tooltipProps.icon, icon = _tooltipProps$icon === void 0 ? /* @__PURE__ */ react.exports.createElement(QuestionCircleOutlined$1, null) : _tooltipProps$icon, restTooltipProps = __rest$k(tooltipProps, ["icon"]);
      var tooltipNode = /* @__PURE__ */ react.exports.createElement(Tooltip$1, _extends$2({}, restTooltipProps), /* @__PURE__ */ react.exports.cloneElement(icon, {
        className: "".concat(prefixCls, "-item-tooltip"),
        title: ""
      }));
      labelChildren = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, labelChildren, tooltipNode);
    }
    if (requiredMark === "optional" && !required4) {
      labelChildren = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, labelChildren, /* @__PURE__ */ react.exports.createElement("span", {
        className: "".concat(prefixCls, "-item-optional"),
        title: ""
      }, (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.optional)));
    }
    var labelClassName = classnamesExports((_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-item-required"), required4), _defineProperty$5(_classNames2, "".concat(prefixCls, "-item-required-mark-optional"), requiredMark === "optional"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-item-no-colon"), !computedColon), _classNames2));
    return /* @__PURE__ */ react.exports.createElement(Col$1, _extends$2({}, mergedLabelCol, {
      className: labelColClassName
    }), /* @__PURE__ */ react.exports.createElement("label", {
      htmlFor,
      className: labelClassName,
      title: typeof label === "string" ? label : ""
    }, labelChildren));
  });
};
const FormItemLabel$1 = FormItemLabel;
var FormItemInput = function FormItemInput2(props) {
  var prefixCls = props.prefixCls, status = props.status, wrapperCol = props.wrapperCol, children = props.children, errors = props.errors, warnings = props.warnings, formItemRender = props._internalItemRender, extra = props.extra, help = props.help, marginBottom = props.marginBottom, onErrorVisibleChanged = props.onErrorVisibleChanged;
  var baseClassName = "".concat(prefixCls, "-item");
  var formContext = react.exports.useContext(FormContext);
  var mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
  var className = classnamesExports("".concat(baseClassName, "-control"), mergedWrapperCol.className);
  var subFormContext = react.exports.useMemo(function() {
    return _extends$2({}, formContext);
  }, [formContext]);
  delete subFormContext.labelCol;
  delete subFormContext.wrapperCol;
  var inputDom = /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(baseClassName, "-control-input")
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(baseClassName, "-control-input-content")
  }, children));
  var formItemContext = react.exports.useMemo(function() {
    return {
      prefixCls,
      status
    };
  }, [prefixCls, status]);
  var errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      display: "flex",
      flexWrap: "nowrap"
    }
  }, /* @__PURE__ */ react.exports.createElement(FormItemPrefixContext.Provider, {
    value: formItemContext
  }, /* @__PURE__ */ react.exports.createElement(ErrorList, {
    errors,
    warnings,
    help,
    helpStatus: status,
    className: "".concat(baseClassName, "-explain-connected"),
    onVisibleChanged: onErrorVisibleChanged
  })), !!marginBottom && /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      width: 0,
      height: marginBottom
    }
  })) : null;
  var extraDom = extra ? /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(baseClassName, "-extra")
  }, extra) : null;
  var dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
    input: inputDom,
    errorList: errorListDom,
    extra: extraDom
  }) : /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, inputDom, errorListDom, extraDom);
  return /* @__PURE__ */ react.exports.createElement(FormContext.Provider, {
    value: subFormContext
  }, /* @__PURE__ */ react.exports.createElement(Col$1, _extends$2({}, mergedWrapperCol, {
    className
  }), dom));
};
const FormItemInput$1 = FormItemInput;
var __rest$j = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var iconMap = {
  success: CheckCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  error: CloseCircleFilled$1,
  validating: LoadingOutlined$1
};
function ItemHolder(props) {
  var _itemClassName;
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, help = props.help, errors = props.errors, warnings = props.warnings, validateStatus = props.validateStatus, meta = props.meta, hasFeedback = props.hasFeedback, hidden = props.hidden, children = props.children, fieldId = props.fieldId, isRequired = props.isRequired, onSubItemMetaChange = props.onSubItemMetaChange, restProps = __rest$j(props, ["prefixCls", "className", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "isRequired", "onSubItemMetaChange"]);
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var _React$useContext = react.exports.useContext(FormContext), requiredMark = _React$useContext.requiredMark;
  var itemRef2 = react.exports.useRef(null);
  var debounceErrors = useDebounce(errors);
  var debounceWarnings = useDebounce(warnings);
  var hasHelp = help !== void 0 && help !== null;
  var hasError = !!(hasHelp || errors.length || warnings.length);
  var _React$useState = react.exports.useState(null), _React$useState2 = _slicedToArray$3(_React$useState, 2), marginBottom = _React$useState2[0], setMarginBottom = _React$useState2[1];
  useLayoutEffect$1(function() {
    if (hasError && itemRef2.current) {
      var itemStyle = getComputedStyle(itemRef2.current);
      setMarginBottom(parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError]);
  var onErrorVisibleChanged = function onErrorVisibleChanged2(nextVisible) {
    if (!nextVisible) {
      setMarginBottom(null);
    }
  };
  var mergedValidateStatus = "";
  if (validateStatus !== void 0) {
    mergedValidateStatus = validateStatus;
  } else if (meta.validating) {
    mergedValidateStatus = "validating";
  } else if (debounceErrors.length) {
    mergedValidateStatus = "error";
  } else if (debounceWarnings.length) {
    mergedValidateStatus = "warning";
  } else if (meta.touched) {
    mergedValidateStatus = "success";
  }
  var formItemStatusContext = react.exports.useMemo(function() {
    var feedbackIcon;
    if (hasFeedback) {
      var IconNode = mergedValidateStatus && iconMap[mergedValidateStatus];
      feedbackIcon = IconNode ? /* @__PURE__ */ react.exports.createElement("span", {
        className: classnamesExports("".concat(itemPrefixCls, "-feedback-icon"), "".concat(itemPrefixCls, "-feedback-icon-").concat(mergedValidateStatus))
      }, /* @__PURE__ */ react.exports.createElement(IconNode, null)) : null;
    }
    return {
      status: mergedValidateStatus,
      hasFeedback,
      feedbackIcon,
      isFormItemInput: true
    };
  }, [mergedValidateStatus, hasFeedback]);
  var itemClassName = (_itemClassName = {}, _defineProperty$5(_itemClassName, itemPrefixCls, true), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-with-help"), hasHelp || debounceErrors.length || debounceWarnings.length), _defineProperty$5(_itemClassName, "".concat(className), !!className), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-has-feedback"), mergedValidateStatus && hasFeedback), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-has-success"), mergedValidateStatus === "success"), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-has-warning"), mergedValidateStatus === "warning"), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-has-error"), mergedValidateStatus === "error"), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-is-validating"), mergedValidateStatus === "validating"), _defineProperty$5(_itemClassName, "".concat(itemPrefixCls, "-hidden"), hidden), _itemClassName);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: classnamesExports(itemClassName),
    style: style2,
    ref: itemRef2
  }, /* @__PURE__ */ react.exports.createElement(Row$1, _extends$2({
    className: "".concat(itemPrefixCls, "-row")
  }, omit(restProps, ["_internalItemRender", "colon", "dependencies", "extra", "fieldKey", "getValueFromEvent", "getValueProps", "htmlFor", "id", "initialValue", "isListField", "label", "labelAlign", "labelCol", "labelWrap", "messageVariables", "name", "normalize", "noStyle", "preserve", "required", "requiredMark", "rules", "shouldUpdate", "trigger", "tooltip", "validateFirst", "validateTrigger", "valuePropName", "wrapperCol"])), /* @__PURE__ */ react.exports.createElement(FormItemLabel$1, _extends$2({
    htmlFor: fieldId,
    required: isRequired,
    requiredMark
  }, props, {
    prefixCls
  })), /* @__PURE__ */ react.exports.createElement(FormItemInput$1, _extends$2({}, props, meta, {
    errors: debounceErrors,
    warnings: debounceWarnings,
    prefixCls,
    status: mergedValidateStatus,
    help,
    marginBottom,
    onErrorVisibleChanged
  }), /* @__PURE__ */ react.exports.createElement(NoStyleItemContext.Provider, {
    value: onSubItemMetaChange
  }, /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Provider, {
    value: formItemStatusContext
  }, children)))), !!marginBottom && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(itemPrefixCls, "-margin-offset"),
    style: {
      marginBottom: -marginBottom
    }
  }));
}
var NAME_SPLIT = "__SPLIT__";
tuple("success", "warning", "error", "validating", "");
var MemoInput = /* @__PURE__ */ react.exports.memo(function(_ref) {
  var children = _ref.children;
  return children;
}, function(prev, next) {
  return prev.value === next.value && prev.update === next.update;
});
function hasValidName(name2) {
  return !(name2 === void 0 || name2 === null);
}
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: false,
    validating: false,
    name: []
  };
}
function InternalFormItem(props) {
  var name2 = props.name, noStyle = props.noStyle, dependencies = props.dependencies, customizePrefixCls = props.prefixCls, shouldUpdate = props.shouldUpdate, rules2 = props.rules, children = props.children, required4 = props.required, label = props.label, messageVariables = props.messageVariables, _props$trigger = props.trigger, trigger3 = _props$trigger === void 0 ? "onChange" : _props$trigger, validateTrigger = props.validateTrigger, hidden = props.hidden;
  var _useContext = react.exports.useContext(ConfigContext), getPrefixCls = _useContext.getPrefixCls;
  var _useContext2 = react.exports.useContext(FormContext), formName = _useContext2.name;
  var isRenderProps = typeof children === "function";
  var notifyParentMetaChange = react.exports.useContext(NoStyleItemContext);
  var _useContext3 = react.exports.useContext(Context), contextValidateTrigger = _useContext3.validateTrigger;
  var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
  var hasName = hasValidName(name2);
  var prefixCls = getPrefixCls("form", customizePrefixCls);
  var listContext = react.exports.useContext(ListContext$1);
  var fieldKeyPathRef = react.exports.useRef();
  var _useFrameState = useFrameState({}), _useFrameState2 = _slicedToArray$3(_useFrameState, 2), subFieldErrors = _useFrameState2[0], setSubFieldErrors = _useFrameState2[1];
  var _useState = useSafeState(function() {
    return genEmptyMeta();
  }), _useState2 = _slicedToArray$3(_useState, 2), meta = _useState2[0], setMeta = _useState2[1];
  var onMetaChange = function onMetaChange2(nextMeta) {
    var keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
    setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
    if (noStyle && notifyParentMetaChange) {
      var namePath = nextMeta.name;
      if (!nextMeta.destroy) {
        if (keyInfo !== void 0) {
          var _keyInfo = _slicedToArray$3(keyInfo, 2), fieldKey = _keyInfo[0], restPath = _keyInfo[1];
          namePath = [fieldKey].concat(_toConsumableArray(restPath));
          fieldKeyPathRef.current = namePath;
        }
      } else {
        namePath = fieldKeyPathRef.current || namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  };
  var onSubItemMetaChange = function onSubItemMetaChange2(subMeta, uniqueKeys) {
    setSubFieldErrors(function(prevSubFieldErrors) {
      var clone2 = _extends$2({}, prevSubFieldErrors);
      var mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
      var mergedNameKey = mergedNamePath.join(NAME_SPLIT);
      if (subMeta.destroy) {
        delete clone2[mergedNameKey];
      } else {
        clone2[mergedNameKey] = subMeta;
      }
      return clone2;
    });
  };
  var _React$useMemo = react.exports.useMemo(function() {
    var errorList = _toConsumableArray(meta.errors);
    var warningList = _toConsumableArray(meta.warnings);
    Object.values(subFieldErrors).forEach(function(subFieldError) {
      errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
      warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
    });
    return [errorList, warningList];
  }, [subFieldErrors, meta.errors, meta.warnings]), _React$useMemo2 = _slicedToArray$3(_React$useMemo, 2), mergedErrors = _React$useMemo2[0], mergedWarnings = _React$useMemo2[1];
  var getItemRef = useItemRef();
  function renderLayout(baseChildren, fieldId, isRequired) {
    if (noStyle && !hidden) {
      return baseChildren;
    }
    return /* @__PURE__ */ react.exports.createElement(ItemHolder, _extends$2({
      key: "row"
    }, props, {
      prefixCls,
      fieldId,
      isRequired,
      errors: mergedErrors,
      warnings: mergedWarnings,
      meta,
      onSubItemMetaChange
    }), baseChildren);
  }
  if (!hasName && !isRenderProps && !dependencies) {
    return renderLayout(children);
  }
  var variables = {};
  if (typeof label === "string") {
    variables.label = label;
  } else if (name2) {
    variables.label = String(name2);
  }
  if (messageVariables) {
    variables = _extends$2(_extends$2({}, variables), messageVariables);
  }
  return /* @__PURE__ */ react.exports.createElement(WrapperField, _extends$2({}, props, {
    messageVariables: variables,
    trigger: trigger3,
    validateTrigger: mergedValidateTrigger,
    onMetaChange
  }), function(control, renderMeta, context2) {
    var mergedName = toArray$1(name2).length && renderMeta ? renderMeta.name : [];
    var fieldId = getFieldId(mergedName, formName);
    var isRequired = required4 !== void 0 ? required4 : !!(rules2 && rules2.some(function(rule) {
      if (rule && _typeof$4(rule) === "object" && rule.required && !rule.warningOnly) {
        return true;
      }
      if (typeof rule === "function") {
        var ruleEntity = rule(context2);
        return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
      }
      return false;
    }));
    var mergedControl = _extends$2({}, control);
    var childNode = null;
    if (Array.isArray(children) && hasName) {
      childNode = children;
    } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName))
      ;
    else if (dependencies && !isRenderProps && !hasName)
      ;
    else if (isValidElement(children)) {
      var childProps = _extends$2(_extends$2({}, children.props), mergedControl);
      if (!childProps.id) {
        childProps.id = fieldId;
      }
      if (supportRef(children)) {
        childProps.ref = getItemRef(mergedName, children);
      }
      var triggers = new Set([].concat(_toConsumableArray(toArray$1(trigger3)), _toConsumableArray(toArray$1(mergedValidateTrigger))));
      triggers.forEach(function(eventName) {
        childProps[eventName] = function() {
          var _a2, _c2;
          var _a, _b, _c;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
          (_c = (_b = children.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
        };
      });
      childNode = /* @__PURE__ */ react.exports.createElement(MemoInput, {
        value: mergedControl[props.valuePropName || "value"],
        update: children
      }, cloneElement(children, childProps));
    } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
      childNode = children(context2);
    } else {
      childNode = children;
    }
    return renderLayout(childNode, fieldId, isRequired);
  });
}
var FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus$1;
const Item$2 = FormItem;
var __rest$i = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var FormList = function FormList2(_a) {
  var customizePrefixCls = _a.prefixCls, children = _a.children, props = __rest$i(_a, ["prefixCls", "children"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var prefixCls = getPrefixCls("form", customizePrefixCls);
  var contextValue = react.exports.useMemo(function() {
    return {
      prefixCls,
      status: "error"
    };
  }, [prefixCls]);
  return /* @__PURE__ */ react.exports.createElement(List$3, _extends$2({}, props), function(fields, operation, meta) {
    return /* @__PURE__ */ react.exports.createElement(FormItemPrefixContext.Provider, {
      value: contextValue
    }, children(fields.map(function(field) {
      return _extends$2(_extends$2({}, field), {
        fieldKey: field.key
      });
    }), operation, {
      errors: meta.errors,
      warnings: meta.warnings
    }));
  });
};
const List$1 = FormList;
function useFormInstance() {
  var _useContext = react.exports.useContext(FormContext), form2 = _useContext.form;
  return form2;
}
var Form2 = InternalForm$1;
Form2.Item = Item$2;
Form2.List = List$1;
Form2.ErrorList = ErrorList;
Form2.useForm = useForm;
Form2.useFormInstance = useFormInstance;
Form2.useWatch = useWatch;
Form2.Provider = FormProvider2;
Form2.create = function() {
};
const Form$1 = Form2;
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
const EyeOutlinedSvg = EyeOutlined$2;
var EyeOutlined = function EyeOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: EyeOutlinedSvg
  }));
};
EyeOutlined.displayName = "EyeOutlined";
const EyeOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EyeOutlined);
function getOffset(node) {
  var box = node.getBoundingClientRect();
  var docElem = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),
    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)
  };
}
var Group = function Group2(props) {
  var _classNames;
  var _useContext = react.exports.useContext(ConfigContext), getPrefixCls = _useContext.getPrefixCls, direction = _useContext.direction;
  var customizePrefixCls = props.prefixCls, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className;
  var prefixCls = getPrefixCls("input-group", customizePrefixCls);
  var cls = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-lg"), props.size === "large"), _defineProperty$5(_classNames, "".concat(prefixCls, "-sm"), props.size === "small"), _defineProperty$5(_classNames, "".concat(prefixCls, "-compact"), props.compact), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
  var formItemContext = react.exports.useContext(FormItemInputContext);
  var groupFormItemContext = react.exports.useMemo(function() {
    return _extends$2(_extends$2({}, formItemContext), {
      isFormItemInput: false
    });
  }, [formItemContext]);
  return /* @__PURE__ */ react.exports.createElement("span", {
    className: cls,
    style: props.style,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    onFocus: props.onFocus,
    onBlur: props.onBlur
  }, /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Provider, {
    value: groupFormItemContext
  }, props.children));
};
const Group$1 = Group;
function hasAddon$1(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function resolveOnChange$1(target, e2, onChange2, targetValue) {
  if (!onChange2) {
    return;
  }
  var event = e2;
  if (e2.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e2, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange2(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e2, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange2(event);
    return;
  }
  onChange2(event);
}
function triggerFocus$1(element, option) {
  if (!element)
    return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
function fixControlledValue$1(value2) {
  if (typeof value2 === "undefined" || value2 === null) {
    return "";
  }
  return String(value2);
}
var BaseInput = function BaseInput2(props) {
  var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix2 = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, wrapperClassName = props.wrapperClassName, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value2 = props.value, handleReset = props.handleReset, hidden = props.hidden;
  var containerRef = react.exports.useRef(null);
  var onInputMouseDown = function onInputMouseDown2(e2) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.contains(e2.target)) {
      triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
    }
  };
  var getClearIcon = function getClearIcon2() {
    var _classNames;
    if (!allowClear) {
      return null;
    }
    var needClear = !disabled && !readOnly && value2;
    var clearIconCls = "".concat(prefixCls, "-clear-icon");
    var iconNode = _typeof$4(allowClear) === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon) ? allowClear.clearIcon : "\u2716";
    return /* @__PURE__ */ React$a.createElement("span", {
      onClick: handleReset,
      onMouseDown: function onMouseDown(e2) {
        return e2.preventDefault();
      },
      className: classnamesExports(clearIconCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$5(_classNames, "".concat(clearIconCls, "-has-suffix"), !!suffix), _classNames)),
      role: "button",
      tabIndex: -1
    }, iconNode);
  };
  var element = /* @__PURE__ */ react.exports.cloneElement(inputElement, {
    value: value2,
    hidden
  });
  if (hasPrefixSuffix$1(props)) {
    var _classNames2;
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
    var affixWrapperCls = classnamesExports(affixWrapperPrefixCls, (_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$5(_classNames2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$5(_classNames2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$5(_classNames2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value2), _classNames2), !hasAddon$1(props) && className, affixWrapperClassName);
    var suffixNode = (suffix || allowClear) && /* @__PURE__ */ React$a.createElement("span", {
      className: "".concat(prefixCls, "-suffix")
    }, getClearIcon(), suffix);
    element = /* @__PURE__ */ React$a.createElement("span", {
      className: affixWrapperCls,
      style: style2,
      hidden: !hasAddon$1(props) && hidden,
      onMouseDown: onInputMouseDown,
      ref: containerRef
    }, prefix2 && /* @__PURE__ */ React$a.createElement("span", {
      className: "".concat(prefixCls, "-prefix")
    }, prefix2), /* @__PURE__ */ react.exports.cloneElement(inputElement, {
      style: null,
      value: value2,
      hidden: null
    }), suffixNode);
  }
  if (hasAddon$1(props)) {
    var wrapperCls = "".concat(prefixCls, "-group");
    var addonCls = "".concat(wrapperCls, "-addon");
    var mergedWrapperClassName = classnamesExports("".concat(prefixCls, "-wrapper"), wrapperCls, wrapperClassName);
    var mergedGroupClassName = classnamesExports("".concat(prefixCls, "-group-wrapper"), className, groupClassName);
    return /* @__PURE__ */ React$a.createElement("span", {
      className: mergedGroupClassName,
      style: style2,
      hidden
    }, /* @__PURE__ */ React$a.createElement("span", {
      className: mergedWrapperClassName
    }, addonBefore && /* @__PURE__ */ React$a.createElement("span", {
      className: addonCls
    }, addonBefore), /* @__PURE__ */ react.exports.cloneElement(element, {
      style: null,
      hidden: null
    }), addonAfter && /* @__PURE__ */ React$a.createElement("span", {
      className: addonCls
    }, addonAfter)));
  }
  return element;
};
var _excluded$9 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "inputClassName"];
var Input$3 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var autoComplete = props.autoComplete, onChange2 = props.onChange, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type4 = _props$type === void 0 ? "text" : _props$type, inputClassName = props.inputClassName, rest = _objectWithoutProperties$1(props, _excluded$9);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), value2 = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray$3(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
  var inputRef = react.exports.useRef(null);
  var focus = function focus2(option) {
    if (inputRef.current) {
      triggerFocus$1(inputRef.current, option);
    }
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus,
      blur: function blur() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
      },
      setSelectionRange: function setSelectionRange(start, end, direction) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction);
      },
      select: function select() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
      },
      input: inputRef.current
    };
  });
  react.exports.useEffect(function() {
    setFocused(function(prev) {
      return prev && disabled ? false : prev;
    });
  }, [disabled]);
  var handleChange = function handleChange2(e2) {
    if (props.value === void 0) {
      setValue2(e2.target.value);
    }
    if (inputRef.current) {
      resolveOnChange$1(inputRef.current, e2, onChange2);
    }
  };
  var handleKeyDown = function handleKeyDown2(e2) {
    if (onPressEnter && e2.key === "Enter") {
      onPressEnter(e2);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
  };
  var handleFocus = function handleFocus2(e2) {
    setFocused(true);
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e2);
  };
  var handleBlur = function handleBlur2(e2) {
    setFocused(false);
    onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
  };
  var handleReset = function handleReset2(e2) {
    setValue2("");
    focus();
    if (inputRef.current) {
      resolveOnChange$1(inputRef.current, e2, onChange2);
    }
  };
  var getInputElement = function getInputElement2() {
    var otherProps = omit(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      "defaultValue",
      "showCount",
      "affixWrapperClassName",
      "groupClassName",
      "inputClassName",
      "wrapperClassName",
      "htmlSize"
    ]);
    return /* @__PURE__ */ React$a.createElement("input", _objectSpread2$4(_objectSpread2$4({
      autoComplete
    }, otherProps), {}, {
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      className: classnamesExports(prefixCls, _defineProperty$5({}, "".concat(prefixCls, "-disabled"), disabled), inputClassName, !hasAddon$1(props) && !hasPrefixSuffix$1(props) && className),
      ref: inputRef,
      size: htmlSize,
      type: type4
    }));
  };
  var getSuffix = function getSuffix2() {
    var hasMaxLength = Number(maxLength) > 0;
    if (suffix || showCount) {
      var valueLength = _toConsumableArray(fixControlledValue$1(value2)).length;
      var dataCount = _typeof$4(showCount) === "object" ? showCount.formatter({
        count: valueLength,
        maxLength
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
      return /* @__PURE__ */ React$a.createElement(React$a.Fragment, null, !!showCount && /* @__PURE__ */ React$a.createElement("span", {
        className: classnamesExports("".concat(prefixCls, "-show-count-suffix"), _defineProperty$5({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix))
      }, dataCount), suffix);
    }
    return null;
  };
  return /* @__PURE__ */ React$a.createElement(BaseInput, _objectSpread2$4(_objectSpread2$4({}, rest), {}, {
    prefixCls,
    className,
    inputElement: getInputElement(),
    handleReset,
    value: fixControlledValue$1(value2),
    focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled
  }));
});
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
var __rest$h = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function fixControlledValue(value2) {
  if (typeof value2 === "undefined" || value2 === null) {
    return "";
  }
  return String(value2);
}
function resolveOnChange(target, e2, onChange2, targetValue) {
  if (!onChange2) {
    return;
  }
  var event = e2;
  if (e2.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e2, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange2(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e2, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange2(event);
    return;
  }
  onChange2(event);
}
function triggerFocus(element, option) {
  if (!element)
    return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
var Input$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames, _classNames2, _classNames4;
  var customizePrefixCls = props.prefixCls, _props$bordered = props.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, customStatus = props.status, customSize = props.size, customDisabled = props.disabled, onBlur2 = props.onBlur, onFocus2 = props.onFocus, suffix = props.suffix, allowClear = props.allowClear, addonAfter = props.addonAfter, addonBefore = props.addonBefore, rest = __rest$h(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore"]);
  var _React$useContext = React$a.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction, input = _React$useContext.input;
  var prefixCls = getPrefixCls("input", customizePrefixCls);
  var inputRef = react.exports.useRef(null);
  var size = React$a.useContext(SizeContext$1);
  var mergedSize = customSize || size;
  var disabled = React$a.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var _useContext = react.exports.useContext(FormItemInputContext), contextStatus = _useContext.status, hasFeedback = _useContext.hasFeedback, feedbackIcon = _useContext.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
  var prevHasPrefixSuffix = react.exports.useRef(inputHasPrefixSuffix);
  react.exports.useEffect(function() {
    if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current)
      ;
    prevHasPrefixSuffix.current = inputHasPrefixSuffix;
  }, [inputHasPrefixSuffix]);
  var removePasswordTimeoutRef = react.exports.useRef([]);
  var removePasswordTimeout = function removePasswordTimeout2() {
    removePasswordTimeoutRef.current.push(window.setTimeout(function() {
      var _a, _b, _c, _d;
      if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
        (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
      }
    }));
  };
  react.exports.useEffect(function() {
    removePasswordTimeout();
    return function() {
      return removePasswordTimeoutRef.current.forEach(function(item) {
        return window.clearTimeout(item);
      });
    };
  }, []);
  var handleBlur = function handleBlur2(e2) {
    removePasswordTimeout();
    onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
  };
  var handleFocus = function handleFocus2(e2) {
    removePasswordTimeout();
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e2);
  };
  var suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ React$a.createElement(React$a.Fragment, null, suffix, hasFeedback && feedbackIcon);
  var mergedAllowClear;
  if (_typeof$4(allowClear) === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /* @__PURE__ */ React$a.createElement(CloseCircleFilled$1, null)
    };
  }
  return /* @__PURE__ */ React$a.createElement(Input$3, _extends$2({
    ref: composeRef(ref, inputRef),
    prefixCls,
    autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
  }, rest, {
    disabled: mergedDisabled || void 0,
    onBlur: handleBlur,
    onFocus: handleFocus,
    suffix: suffixNode,
    allowClear: mergedAllowClear,
    addonAfter: addonAfter && /* @__PURE__ */ React$a.createElement(NoFormStyle, {
      override: true,
      status: true
    }, addonAfter),
    addonBefore: addonBefore && /* @__PURE__ */ React$a.createElement(NoFormStyle, {
      override: true,
      status: true
    }, addonBefore),
    inputClassName: classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-sm"), mergedSize === "small"), _defineProperty$5(_classNames, "".concat(prefixCls, "-lg"), mergedSize === "large"), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _classNames), !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus)),
    affixWrapperClassName: classnamesExports((_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-sm"), mergedSize === "small"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-lg"), mergedSize === "large"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _classNames2), getStatusClassNames("".concat(prefixCls, "-affix-wrapper"), mergedStatus, hasFeedback)),
    wrapperClassName: classnamesExports(_defineProperty$5({}, "".concat(prefixCls, "-group-rtl"), direction === "rtl")),
    groupClassName: classnamesExports((_classNames4 = {}, _defineProperty$5(_classNames4, "".concat(prefixCls, "-group-wrapper-sm"), mergedSize === "small"), _defineProperty$5(_classNames4, "".concat(prefixCls, "-group-wrapper-lg"), mergedSize === "large"), _defineProperty$5(_classNames4, "".concat(prefixCls, "-group-wrapper-rtl"), direction === "rtl"), _classNames4), getStatusClassNames("".concat(prefixCls, "-group-wrapper"), mergedStatus, hasFeedback))
  }));
});
const InternalInput = Input$2;
var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: EyeInvisibleOutlinedSvg
  }));
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
const EyeInvisibleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EyeInvisibleOutlined);
var __rest$g = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var ActionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
var Password = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray$3(_useState, 2), visible = _useState2[0], setVisible = _useState2[1];
  var onVisibleChange = function onVisibleChange2() {
    var disabled = props.disabled;
    if (disabled) {
      return;
    }
    setVisible(!visible);
  };
  var getIcon2 = function getIcon3(prefixCls) {
    var _iconProps;
    var action = props.action, _props$iconRender = props.iconRender, iconRender2 = _props$iconRender === void 0 ? function() {
      return null;
    } : _props$iconRender;
    var iconTrigger = ActionMap[action] || "";
    var icon = iconRender2(visible);
    var iconProps = (_iconProps = {}, _defineProperty$5(_iconProps, iconTrigger, onVisibleChange), _defineProperty$5(_iconProps, "className", "".concat(prefixCls, "-icon")), _defineProperty$5(_iconProps, "key", "passwordIcon"), _defineProperty$5(_iconProps, "onMouseDown", function onMouseDown(e2) {
      e2.preventDefault();
    }), _defineProperty$5(_iconProps, "onMouseUp", function onMouseUp(e2) {
      e2.preventDefault();
    }), _iconProps);
    return /* @__PURE__ */ react.exports.cloneElement(/* @__PURE__ */ react.exports.isValidElement(icon) ? icon : /* @__PURE__ */ react.exports.createElement("span", null, icon), iconProps);
  };
  var renderPassword = function renderPassword2(_ref) {
    var getPrefixCls = _ref.getPrefixCls;
    var className = props.className, customizePrefixCls = props.prefixCls, customizeInputPrefixCls = props.inputPrefixCls, size = props.size, visibilityToggle = props.visibilityToggle, restProps = __rest$g(props, ["className", "prefixCls", "inputPrefixCls", "size", "visibilityToggle"]);
    var inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
    var prefixCls = getPrefixCls("input-password", customizePrefixCls);
    var suffixIcon = visibilityToggle && getIcon2(prefixCls);
    var inputClassName = classnamesExports(prefixCls, className, _defineProperty$5({}, "".concat(prefixCls, "-").concat(size), !!size));
    var omittedProps = _extends$2(_extends$2({}, omit(restProps, ["suffix", "iconRender"])), {
      type: visible ? "text" : "password",
      className: inputClassName,
      prefixCls: inputPrefixCls,
      suffix: suffixIcon
    });
    if (size) {
      omittedProps.size = size;
    }
    return /* @__PURE__ */ react.exports.createElement(InternalInput, _extends$2({
      ref
    }, omittedProps));
  };
  return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, renderPassword);
});
Password.defaultProps = {
  action: "click",
  visibilityToggle: true,
  iconRender: function iconRender(visible) {
    return visible ? /* @__PURE__ */ react.exports.createElement(EyeOutlined$1, null) : /* @__PURE__ */ react.exports.createElement(EyeInvisibleOutlined$1, null);
  }
};
const Password$1 = Password;
var __rest$f = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Search = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var customizePrefixCls = props.prefixCls, customizeInputPrefixCls = props.inputPrefixCls, className = props.className, customizeSize = props.size, suffix = props.suffix, _props$enterButton = props.enterButton, enterButton = _props$enterButton === void 0 ? false : _props$enterButton, addonAfter = props.addonAfter, loading = props.loading, disabled = props.disabled, customOnSearch = props.onSearch, customOnChange = props.onChange, onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, restProps = __rest$f(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var contextSize = react.exports.useContext(SizeContext$1);
  var composedRef = react.exports.useRef(false);
  var size = customizeSize || contextSize;
  var inputRef = react.exports.useRef(null);
  var onChange2 = function onChange3(e2) {
    if (e2 && e2.target && e2.type === "click" && customOnSearch) {
      customOnSearch(e2.target.value, e2);
    }
    if (customOnChange) {
      customOnChange(e2);
    }
  };
  var onMouseDown = function onMouseDown2(e2) {
    var _a;
    if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
      e2.preventDefault();
    }
  };
  var onSearch = function onSearch2(e2) {
    var _a, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2);
    }
  };
  var onPressEnter = function onPressEnter2(e2) {
    if (composedRef.current) {
      return;
    }
    onSearch(e2);
  };
  var prefixCls = getPrefixCls("input-search", customizePrefixCls);
  var inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  var searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ react.exports.createElement(SearchOutlined$1, null) : null;
  var btnClassName = "".concat(prefixCls, "-button");
  var button;
  var enterButtonAsElement = enterButton || {};
  var isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button = cloneElement(enterButtonAsElement, _extends$2({
      onMouseDown,
      onClick: function onClick(e2) {
        var _a, _b;
        (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
        onSearch(e2);
      },
      key: "enterButton"
    }, isAntdButton ? {
      className: btnClassName,
      size
    } : {}));
  } else {
    button = /* @__PURE__ */ react.exports.createElement(Button$2, {
      className: btnClassName,
      type: enterButton ? "primary" : void 0,
      size,
      disabled,
      key: "enterButton",
      onMouseDown,
      onClick: onSearch,
      loading,
      icon: searchIcon
    }, enterButton);
  }
  if (addonAfter) {
    button = [button, cloneElement(addonAfter, {
      key: "addonAfter"
    })];
  }
  var cls = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(size), !!size), _defineProperty$5(_classNames, "".concat(prefixCls, "-with-button"), !!enterButton), _classNames), className);
  var handleOnCompositionStart = function handleOnCompositionStart2(e2) {
    composedRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
  };
  var handleOnCompositionEnd = function handleOnCompositionEnd2(e2) {
    composedRef.current = false;
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
  };
  return /* @__PURE__ */ react.exports.createElement(InternalInput, _extends$2({
    ref: composeRef(inputRef, ref),
    onPressEnter
  }, restProps, {
    size,
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    prefixCls: inputPrefixCls,
    addonAfter: button,
    suffix,
    onChange: onChange2,
    className: cls,
    disabled
  }));
});
const Search$1 = Search;
var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n";
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var nodeRef = node.getAttribute("id") || node.getAttribute("data-reactid") || node.getAttribute("name");
  if (useCache2 && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style2 = window.getComputedStyle(node);
  var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
  var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
  var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
  var sizingStyle = SIZING_STYLE.map(function(name2) {
    return "".concat(name2, ":").concat(style2.getPropertyValue(name2));
  }).join(";");
  var nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache2 && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateNodeHeight(uiTextNode) {
  var useCache2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache2), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  var minHeight = Number.MIN_SAFE_INTEGER;
  var maxHeight = Number.MAX_SAFE_INTEGER;
  var height = hiddenTextarea.scrollHeight;
  var overflowY;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  return {
    height,
    minHeight,
    maxHeight,
    overflowY,
    resize: "none"
  };
}
var RESIZE_STATUS;
(function(RESIZE_STATUS2) {
  RESIZE_STATUS2[RESIZE_STATUS2["NONE"] = 0] = "NONE";
  RESIZE_STATUS2[RESIZE_STATUS2["RESIZING"] = 1] = "RESIZING";
  RESIZE_STATUS2[RESIZE_STATUS2["RESIZED"] = 2] = "RESIZED";
})(RESIZE_STATUS || (RESIZE_STATUS = {}));
var ResizableTextArea = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(ResizableTextArea2, _React$Component);
  var _super = _createSuper$1(ResizableTextArea2);
  function ResizableTextArea2(props) {
    var _this;
    _classCallCheck$2(this, ResizableTextArea2);
    _this = _super.call(this, props);
    _this.nextFrameActionId = void 0;
    _this.resizeFrameId = void 0;
    _this.textArea = void 0;
    _this.saveTextArea = function(textArea) {
      _this.textArea = textArea;
    };
    _this.handleResize = function(size) {
      var resizeStatus = _this.state.resizeStatus;
      var _this$props = _this.props, autoSize = _this$props.autoSize, onResize2 = _this$props.onResize;
      if (resizeStatus !== RESIZE_STATUS.NONE) {
        return;
      }
      if (typeof onResize2 === "function") {
        onResize2(size);
      }
      if (autoSize) {
        _this.resizeOnNextFrame();
      }
    };
    _this.resizeOnNextFrame = function() {
      cancelAnimationFrame(_this.nextFrameActionId);
      _this.nextFrameActionId = requestAnimationFrame(_this.resizeTextarea);
    };
    _this.resizeTextarea = function() {
      var autoSize = _this.props.autoSize;
      if (!autoSize || !_this.textArea) {
        return;
      }
      var minRows = autoSize.minRows, maxRows = autoSize.maxRows;
      var textareaStyles = calculateNodeHeight(_this.textArea, false, minRows, maxRows);
      _this.setState({
        textareaStyles,
        resizeStatus: RESIZE_STATUS.RESIZING
      }, function() {
        cancelAnimationFrame(_this.resizeFrameId);
        _this.resizeFrameId = requestAnimationFrame(function() {
          _this.setState({
            resizeStatus: RESIZE_STATUS.RESIZED
          }, function() {
            _this.resizeFrameId = requestAnimationFrame(function() {
              _this.setState({
                resizeStatus: RESIZE_STATUS.NONE
              });
              _this.fixFirefoxAutoScroll();
            });
          });
        });
      });
    };
    _this.renderTextArea = function() {
      var _this$props2 = _this.props, _this$props2$prefixCl = _this$props2.prefixCls, prefixCls = _this$props2$prefixCl === void 0 ? "rc-textarea" : _this$props2$prefixCl, autoSize = _this$props2.autoSize, onResize2 = _this$props2.onResize, className = _this$props2.className, disabled = _this$props2.disabled;
      var _this$state = _this.state, textareaStyles = _this$state.textareaStyles, resizeStatus = _this$state.resizeStatus;
      var otherProps = omit(_this.props, ["prefixCls", "onPressEnter", "autoSize", "defaultValue", "onResize"]);
      var cls = classnamesExports(prefixCls, className, _defineProperty$5({}, "".concat(prefixCls, "-disabled"), disabled));
      if ("value" in otherProps) {
        otherProps.value = otherProps.value || "";
      }
      var style2 = _objectSpread2$4(_objectSpread2$4(_objectSpread2$4({}, _this.props.style), textareaStyles), resizeStatus === RESIZE_STATUS.RESIZING ? {
        overflowX: "hidden",
        overflowY: "hidden"
      } : null);
      return /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
        onResize: _this.handleResize,
        disabled: !(autoSize || onResize2)
      }, /* @__PURE__ */ react.exports.createElement("textarea", _extends$2({}, otherProps, {
        className: cls,
        style: style2,
        ref: _this.saveTextArea
      })));
    };
    _this.state = {
      textareaStyles: {},
      resizeStatus: RESIZE_STATUS.NONE
    };
    return _this;
  }
  _createClass$2(ResizableTextArea2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.value !== this.props.value || !shallowequal(prevProps.autoSize, this.props.autoSize)) {
        this.resizeTextarea();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      cancelAnimationFrame(this.nextFrameActionId);
      cancelAnimationFrame(this.resizeFrameId);
    }
  }, {
    key: "fixFirefoxAutoScroll",
    value: function fixFirefoxAutoScroll() {
      try {
        if (document.activeElement === this.textArea) {
          var currentStart = this.textArea.selectionStart;
          var currentEnd = this.textArea.selectionEnd;
          this.textArea.setSelectionRange(currentStart, currentEnd);
        }
      } catch (e2) {
      }
    }
  }, {
    key: "render",
    value: function render2() {
      return this.renderTextArea();
    }
  }]);
  return ResizableTextArea2;
}(react.exports.Component);
var TextArea$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(TextArea2, _React$Component);
  var _super = _createSuper$1(TextArea2);
  function TextArea2(props) {
    var _this;
    _classCallCheck$2(this, TextArea2);
    _this = _super.call(this, props);
    _this.resizableTextArea = void 0;
    _this.focus = function() {
      _this.resizableTextArea.textArea.focus();
    };
    _this.saveTextArea = function(resizableTextArea) {
      _this.resizableTextArea = resizableTextArea;
    };
    _this.handleChange = function(e2) {
      var onChange2 = _this.props.onChange;
      _this.setValue(e2.target.value, function() {
        _this.resizableTextArea.resizeTextarea();
      });
      if (onChange2) {
        onChange2(e2);
      }
    };
    _this.handleKeyDown = function(e2) {
      var _this$props = _this.props, onPressEnter = _this$props.onPressEnter, onKeyDown2 = _this$props.onKeyDown;
      if (e2.keyCode === 13 && onPressEnter) {
        onPressEnter(e2);
      }
      if (onKeyDown2) {
        onKeyDown2(e2);
      }
    };
    var value2 = typeof props.value === "undefined" || props.value === null ? props.defaultValue : props.value;
    _this.state = {
      value: value2
    };
    return _this;
  }
  _createClass$2(TextArea2, [{
    key: "setValue",
    value: function setValue2(value2, callback) {
      if (!("value" in this.props)) {
        this.setState({
          value: value2
        }, callback);
      }
    }
  }, {
    key: "blur",
    value: function blur() {
      this.resizableTextArea.textArea.blur();
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ResizableTextArea, _extends$2({}, this.props, {
        value: this.state.value,
        onKeyDown: this.handleKeyDown,
        onChange: this.handleChange,
        ref: this.saveTextArea
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps) {
      if ("value" in nextProps) {
        return {
          value: nextProps.value
        };
      }
      return null;
    }
  }]);
  return TextArea2;
}(react.exports.Component);
var ClearableInputType = tuple("text", "input");
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
var ClearableLabeledInput = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(ClearableLabeledInput2, _React$Component);
  var _super = _createSuper$1(ClearableLabeledInput2);
  function ClearableLabeledInput2() {
    _classCallCheck$2(this, ClearableLabeledInput2);
    return _super.apply(this, arguments);
  }
  _createClass$2(ClearableLabeledInput2, [{
    key: "renderClearIcon",
    value: function renderClearIcon(prefixCls) {
      var _classNames;
      var _this$props = this.props, value2 = _this$props.value, disabled = _this$props.disabled, readOnly = _this$props.readOnly, handleReset = _this$props.handleReset, suffix = _this$props.suffix;
      var needClear = !disabled && !readOnly && value2;
      var className = "".concat(prefixCls, "-clear-icon");
      return /* @__PURE__ */ react.exports.createElement(CloseCircleFilled$1, {
        onClick: handleReset,
        onMouseDown: function onMouseDown(e2) {
          return e2.preventDefault();
        },
        className: classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(className, "-hidden"), !needClear), _defineProperty$5(_classNames, "".concat(className, "-has-suffix"), !!suffix), _classNames), className),
        role: "button"
      });
    }
  }, {
    key: "renderTextAreaWithClearIcon",
    value: function renderTextAreaWithClearIcon(prefixCls, element, statusContext) {
      var _classNames2;
      var _this$props2 = this.props, value2 = _this$props2.value, allowClear = _this$props2.allowClear, className = _this$props2.className, style2 = _this$props2.style, direction = _this$props2.direction, bordered = _this$props2.bordered, hidden = _this$props2.hidden, customStatus = _this$props2.status;
      var contextStatus = statusContext.status, hasFeedback = statusContext.hasFeedback;
      if (!allowClear) {
        return cloneElement(element, {
          value: value2
        });
      }
      var affixWrapperCls = classnamesExports("".concat(prefixCls, "-affix-wrapper"), "".concat(prefixCls, "-affix-wrapper-textarea-with-clear-btn"), getStatusClassNames("".concat(prefixCls, "-affix-wrapper"), getMergedStatus(contextStatus, customStatus), hasFeedback), (_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$5(_classNames2, "".concat(className), !hasAddon(this.props) && className), _classNames2));
      return /* @__PURE__ */ react.exports.createElement("span", {
        className: affixWrapperCls,
        style: style2,
        hidden
      }, cloneElement(element, {
        style: null,
        value: value2
      }), this.renderClearIcon(prefixCls));
    }
  }, {
    key: "render",
    value: function render2() {
      var _this = this;
      return /* @__PURE__ */ react.exports.createElement(FormItemInputContext.Consumer, null, function(statusContext) {
        var _this$props3 = _this.props, prefixCls = _this$props3.prefixCls, inputType = _this$props3.inputType, element = _this$props3.element;
        if (inputType === ClearableInputType[0]) {
          return _this.renderTextAreaWithClearIcon(prefixCls, element, statusContext);
        }
      });
    }
  }]);
  return ClearableLabeledInput2;
}(react.exports.Component);
const ClearableLabeledInput$1 = ClearableLabeledInput;
var __rest$e = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function fixEmojiLength(value2, maxLength) {
  return _toConsumableArray(value2 || "").slice(0, maxLength).join("");
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  var newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
var TextArea = /* @__PURE__ */ react.exports.forwardRef(function(_a, ref) {
  var _classNames;
  var customizePrefixCls = _a.prefixCls, _a$bordered = _a.bordered, bordered = _a$bordered === void 0 ? true : _a$bordered, _a$showCount = _a.showCount, showCount = _a$showCount === void 0 ? false : _a$showCount, maxLength = _a.maxLength, className = _a.className, style2 = _a.style, customizeSize = _a.size, customDisabled = _a.disabled, onCompositionStart = _a.onCompositionStart, onCompositionEnd = _a.onCompositionEnd, onChange2 = _a.onChange, customStatus = _a.status, props = __rest$e(_a, ["prefixCls", "bordered", "showCount", "maxLength", "className", "style", "size", "disabled", "onCompositionStart", "onCompositionEnd", "onChange", "status"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext$1);
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var _React$useContext2 = react.exports.useContext(FormItemInputContext), contextStatus = _React$useContext2.status, hasFeedback = _React$useContext2.hasFeedback, isFormItemInput = _React$useContext2.isFormItemInput, feedbackIcon = _React$useContext2.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var innerRef = react.exports.useRef(null);
  var clearableInputRef = react.exports.useRef(null);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), compositing = _React$useState2[0], setCompositing = _React$useState2[1];
  var oldCompositionValueRef = react.exports.useRef();
  var oldSelectionStartRef = react.exports.useRef(0);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), value2 = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var hidden = props.hidden;
  var handleSetValue = function handleSetValue2(val2, callback) {
    if (props.value === void 0) {
      setValue2(val2);
      callback === null || callback === void 0 ? void 0 : callback();
    }
  };
  var hasMaxLength = Number(maxLength) > 0;
  var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
    setCompositing(true);
    oldCompositionValueRef.current = value2;
    oldSelectionStartRef.current = e2.currentTarget.selectionStart;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
  };
  var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
    var _a2;
    setCompositing(false);
    var triggerValue = e2.currentTarget.value;
    if (hasMaxLength) {
      var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_a2 = oldCompositionValueRef.current) === null || _a2 === void 0 ? void 0 : _a2.length);
      triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
    }
    if (triggerValue !== value2) {
      handleSetValue(triggerValue);
      resolveOnChange(e2.currentTarget, e2, onChange2, triggerValue);
    }
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
  };
  var handleChange = function handleChange2(e2) {
    var triggerValue = e2.target.value;
    if (!compositing && hasMaxLength) {
      var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;
      triggerValue = setTriggerValue(isCursorInEnd, value2, triggerValue, maxLength);
    }
    handleSetValue(triggerValue);
    resolveOnChange(e2.currentTarget, e2, onChange2, triggerValue);
  };
  var handleReset = function handleReset2(e2) {
    var _a2, _b, _c;
    handleSetValue("");
    (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    resolveOnChange((_c = (_b = innerRef.current) === null || _b === void 0 ? void 0 : _b.resizableTextArea) === null || _c === void 0 ? void 0 : _c.textArea, e2, onChange2);
  };
  var prefixCls = getPrefixCls("input", customizePrefixCls);
  react.exports.useImperativeHandle(ref, function() {
    var _a2;
    return {
      resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
      focus: function focus(option) {
        var _a3, _b;
        triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
      },
      blur: function blur() {
        var _a3;
        return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
      }
    };
  });
  var textArea = /* @__PURE__ */ react.exports.createElement(TextArea$2, _extends$2({}, omit(props, ["allowClear"]), {
    disabled: mergedDisabled,
    className: classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _defineProperty$5(_classNames, className, className && !showCount), _defineProperty$5(_classNames, "".concat(prefixCls, "-sm"), size === "small" || customizeSize === "small"), _defineProperty$5(_classNames, "".concat(prefixCls, "-lg"), size === "large" || customizeSize === "large"), _classNames), getStatusClassNames(prefixCls, mergedStatus)),
    style: showCount ? void 0 : style2,
    prefixCls,
    onCompositionStart: onInternalCompositionStart,
    onChange: handleChange,
    onCompositionEnd: onInternalCompositionEnd,
    ref: innerRef
  }));
  var val = fixControlledValue(value2);
  if (!compositing && hasMaxLength && (props.value === null || props.value === void 0)) {
    val = fixEmojiLength(val, maxLength);
  }
  var textareaNode = /* @__PURE__ */ react.exports.createElement(ClearableLabeledInput$1, _extends$2({
    disabled: mergedDisabled
  }, props, {
    prefixCls,
    direction,
    inputType: "text",
    value: val,
    element: textArea,
    handleReset,
    ref: clearableInputRef,
    bordered,
    status: customStatus,
    style: showCount ? void 0 : style2
  }));
  if (showCount || hasFeedback) {
    var _classNames2;
    var valueLength = _toConsumableArray(val).length;
    var dataCount = "";
    if (_typeof$4(showCount) === "object") {
      dataCount = showCount.formatter({
        count: valueLength,
        maxLength
      });
    } else {
      dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
    }
    return /* @__PURE__ */ react.exports.createElement("div", {
      hidden,
      className: classnamesExports("".concat(prefixCls, "-textarea"), (_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-textarea-rtl"), direction === "rtl"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-textarea-show-count"), showCount), _defineProperty$5(_classNames2, "".concat(prefixCls, "-textarea-in-form-item"), isFormItemInput), _classNames2), getStatusClassNames("".concat(prefixCls, "-textarea"), mergedStatus, hasFeedback), className),
      style: style2,
      "data-count": dataCount
    }, textareaNode, hasFeedback && /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-textarea-suffix")
    }, feedbackIcon));
  }
  return textareaNode;
});
const TextArea$1 = TextArea;
var Input2 = InternalInput;
Input2.Group = Group$1;
Input2.Search = Search$1;
Input2.TextArea = TextArea$1;
Input2.Password = Password$1;
const Input$1 = Input2;
var UpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, "name": "up", "theme": "outlined" };
const UpOutlinedSvg = UpOutlined$2;
var UpOutlined = function UpOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: UpOutlinedSvg
  }));
};
UpOutlined.displayName = "UpOutlined";
const UpOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(UpOutlined);
function supportBigInt() {
  return typeof BigInt === "function";
}
function trimNumber(numStr) {
  var str = numStr.trim();
  var negative = str.startsWith("-");
  if (negative) {
    str = str.slice(1);
  }
  str = str.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, "");
  if (str.startsWith(".")) {
    str = "0".concat(str);
  }
  var trimStr = str || "0";
  var splitNumber = trimStr.split(".");
  var integerStr = splitNumber[0] || "0";
  var decimalStr = splitNumber[1] || "0";
  if (integerStr === "0" && decimalStr === "0") {
    negative = false;
  }
  var negativeStr = negative ? "-" : "";
  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: "".concat(negativeStr).concat(trimStr)
  };
}
function isE(number4) {
  var str = String(number4);
  return !Number.isNaN(Number(str)) && str.includes("e");
}
function getNumberPrecision(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    var precision = Number(numStr.slice(numStr.indexOf("e-") + 2));
    var decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch === null || decimalMatch === void 0 ? void 0 : decimalMatch[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }
  return numStr.includes(".") && validateNumber(numStr) ? numStr.length - numStr.indexOf(".") - 1 : 0;
}
function num2str(number4) {
  var numStr = String(number4);
  if (isE(number4)) {
    if (number4 > Number.MAX_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MAX_SAFE_INTEGER);
    }
    if (number4 < Number.MIN_SAFE_INTEGER) {
      return String(supportBigInt() ? BigInt(number4).toString() : Number.MIN_SAFE_INTEGER);
    }
    numStr = number4.toFixed(getNumberPrecision(numStr));
  }
  return trimNumber(numStr).fullStr;
}
function validateNumber(num) {
  if (typeof num === "number") {
    return !Number.isNaN(num);
  }
  if (!num) {
    return false;
  }
  return /^\s*-?\d+(\.\d+)?\s*$/.test(num) || /^\s*-?\d+\.\s*$/.test(num) || /^\s*-?\.\d+\s*$/.test(num);
}
function getDecupleSteps(step) {
  var stepStr = typeof step === "number" ? num2str(step) : trimNumber(step).fullStr;
  var hasPoint = stepStr.includes(".");
  if (!hasPoint) {
    return step + "0";
  }
  return trimNumber(stepStr.replace(/(\d)\.(\d)/g, "$1$2.")).fullStr;
}
var NumberDecimal = /* @__PURE__ */ function() {
  function NumberDecimal2(value2) {
    _classCallCheck$2(this, NumberDecimal2);
    this.origin = "";
    this.number = void 0;
    this.empty = void 0;
    if (!value2 && value2 !== 0 || !String(value2).trim()) {
      this.empty = true;
      return;
    }
    this.origin = String(value2);
    this.number = Number(value2);
  }
  _createClass$2(NumberDecimal2, [{
    key: "negate",
    value: function negate() {
      return new NumberDecimal2(-this.toNumber());
    }
  }, {
    key: "add",
    value: function add(value2) {
      if (this.isInvalidate()) {
        return new NumberDecimal2(value2);
      }
      var target = Number(value2);
      if (Number.isNaN(target)) {
        return this;
      }
      var number4 = this.number + target;
      if (number4 > Number.MAX_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MAX_SAFE_INTEGER);
      }
      if (number4 < Number.MIN_SAFE_INTEGER) {
        return new NumberDecimal2(Number.MIN_SAFE_INTEGER);
      }
      var maxPrecision = Math.max(getNumberPrecision(this.number), getNumberPrecision(target));
      return new NumberDecimal2(number4.toFixed(maxPrecision));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return Number.isNaN(this.number);
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toNumber() === (target === null || target === void 0 ? void 0 : target.toNumber());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber2() {
      return this.number;
    }
  }, {
    key: "toString",
    value: function toString2() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return num2str(this.number);
    }
  }]);
  return NumberDecimal2;
}();
var BigIntDecimal = /* @__PURE__ */ function() {
  function BigIntDecimal2(value2) {
    _classCallCheck$2(this, BigIntDecimal2);
    this.origin = "";
    this.negative = void 0;
    this.integer = void 0;
    this.decimal = void 0;
    this.decimalLen = void 0;
    this.empty = void 0;
    this.nan = void 0;
    if (!value2 && value2 !== 0 || !String(value2).trim()) {
      this.empty = true;
      return;
    }
    this.origin = String(value2);
    if (value2 === "-") {
      this.nan = true;
      return;
    }
    var mergedValue = value2;
    if (isE(mergedValue)) {
      mergedValue = Number(mergedValue);
    }
    mergedValue = typeof mergedValue === "string" ? mergedValue : num2str(mergedValue);
    if (validateNumber(mergedValue)) {
      var trimRet = trimNumber(mergedValue);
      this.negative = trimRet.negative;
      var numbers = trimRet.trimStr.split(".");
      this.integer = BigInt(numbers[0]);
      var decimalStr = numbers[1] || "0";
      this.decimal = BigInt(decimalStr);
      this.decimalLen = decimalStr.length;
    } else {
      this.nan = true;
    }
  }
  _createClass$2(BigIntDecimal2, [{
    key: "getMark",
    value: function getMark2() {
      return this.negative ? "-" : "";
    }
  }, {
    key: "getIntegerStr",
    value: function getIntegerStr() {
      return this.integer.toString();
    }
  }, {
    key: "getDecimalStr",
    value: function getDecimalStr() {
      return this.decimal.toString().padStart(this.decimalLen, "0");
    }
  }, {
    key: "alignDecimal",
    value: function alignDecimal(decimalLength) {
      var str = "".concat(this.getMark()).concat(this.getIntegerStr()).concat(this.getDecimalStr().padEnd(decimalLength, "0"));
      return BigInt(str);
    }
  }, {
    key: "negate",
    value: function negate() {
      var clone2 = new BigIntDecimal2(this.toString());
      clone2.negative = !clone2.negative;
      return clone2;
    }
  }, {
    key: "add",
    value: function add(value2) {
      if (this.isInvalidate()) {
        return new BigIntDecimal2(value2);
      }
      var offset3 = new BigIntDecimal2(value2);
      if (offset3.isInvalidate()) {
        return this;
      }
      var maxDecimalLength = Math.max(this.getDecimalStr().length, offset3.getDecimalStr().length);
      var myAlignedDecimal = this.alignDecimal(maxDecimalLength);
      var offsetAlignedDecimal = offset3.alignDecimal(maxDecimalLength);
      var valueStr = (myAlignedDecimal + offsetAlignedDecimal).toString();
      var _trimNumber = trimNumber(valueStr), negativeStr = _trimNumber.negativeStr, trimStr = _trimNumber.trimStr;
      var hydrateValueStr = "".concat(negativeStr).concat(trimStr.padStart(maxDecimalLength + 1, "0"));
      return new BigIntDecimal2("".concat(hydrateValueStr.slice(0, -maxDecimalLength), ".").concat(hydrateValueStr.slice(-maxDecimalLength)));
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.empty;
    }
  }, {
    key: "isNaN",
    value: function isNaN2() {
      return this.nan;
    }
  }, {
    key: "isInvalidate",
    value: function isInvalidate() {
      return this.isEmpty() || this.isNaN();
    }
  }, {
    key: "equals",
    value: function equals(target) {
      return this.toString() === (target === null || target === void 0 ? void 0 : target.toString());
    }
  }, {
    key: "lessEquals",
    value: function lessEquals(target) {
      return this.add(target.negate().toString()).toNumber() <= 0;
    }
  }, {
    key: "toNumber",
    value: function toNumber2() {
      if (this.isNaN()) {
        return NaN;
      }
      return Number(this.toString());
    }
  }, {
    key: "toString",
    value: function toString2() {
      var safe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (!safe) {
        return this.origin;
      }
      if (this.isInvalidate()) {
        return "";
      }
      return trimNumber("".concat(this.getMark()).concat(this.getIntegerStr(), ".").concat(this.getDecimalStr())).fullStr;
    }
  }]);
  return BigIntDecimal2;
}();
function getMiniDecimal(value2) {
  if (supportBigInt()) {
    return new BigIntDecimal(value2);
  }
  return new NumberDecimal(value2);
}
function toFixed(numStr, separatorStr, precision) {
  var cutOnly = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (numStr === "") {
    return "";
  }
  var _trimNumber2 = trimNumber(numStr), negativeStr = _trimNumber2.negativeStr, integerStr = _trimNumber2.integerStr, decimalStr = _trimNumber2.decimalStr;
  var precisionDecimalStr = "".concat(separatorStr).concat(decimalStr);
  var numberWithoutDecimal = "".concat(negativeStr).concat(integerStr);
  if (precision >= 0) {
    var advancedNum = Number(decimalStr[precision]);
    if (advancedNum >= 5 && !cutOnly) {
      var advancedDecimal = getMiniDecimal(numStr).add("".concat(negativeStr, "0.").concat("0".repeat(precision)).concat(10 - advancedNum));
      return toFixed(advancedDecimal.toString(), separatorStr, precision, cutOnly);
    }
    if (precision === 0) {
      return numberWithoutDecimal;
    }
    return "".concat(numberWithoutDecimal).concat(separatorStr).concat(decimalStr.padEnd(precision, "0").slice(0, precision));
  }
  if (precisionDecimalStr === ".0") {
    return numberWithoutDecimal;
  }
  return "".concat(numberWithoutDecimal).concat(precisionDecimalStr);
}
var STEP_INTERVAL = 200;
var STEP_DELAY = 600;
function StepHandler(_ref) {
  var prefixCls = _ref.prefixCls, upNode = _ref.upNode, downNode = _ref.downNode, upDisabled = _ref.upDisabled, downDisabled = _ref.downDisabled, onStep = _ref.onStep;
  var stepTimeoutRef = react.exports.useRef();
  var onStepRef = react.exports.useRef();
  onStepRef.current = onStep;
  var onStepMouseDown = function onStepMouseDown2(e2, up) {
    e2.preventDefault();
    onStepRef.current(up);
    function loopStep() {
      onStepRef.current(up);
      stepTimeoutRef.current = setTimeout(loopStep, STEP_INTERVAL);
    }
    stepTimeoutRef.current = setTimeout(loopStep, STEP_DELAY);
  };
  var onStopStep = function onStopStep2() {
    clearTimeout(stepTimeoutRef.current);
  };
  react.exports.useEffect(function() {
    return onStopStep;
  }, []);
  if (isMobile()) {
    return null;
  }
  var handlerClassName = "".concat(prefixCls, "-handler");
  var upClassName = classnamesExports(handlerClassName, "".concat(handlerClassName, "-up"), _defineProperty$5({}, "".concat(handlerClassName, "-up-disabled"), upDisabled));
  var downClassName = classnamesExports(handlerClassName, "".concat(handlerClassName, "-down"), _defineProperty$5({}, "".concat(handlerClassName, "-down-disabled"), downDisabled));
  var sharedHandlerProps = {
    unselectable: "on",
    role: "button",
    onMouseUp: onStopStep,
    onMouseLeave: onStopStep
  };
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(handlerClassName, "-wrap")
  }, /* @__PURE__ */ react.exports.createElement("span", _extends$2({}, sharedHandlerProps, {
    onMouseDown: function onMouseDown(e2) {
      onStepMouseDown(e2, true);
    },
    "aria-label": "Increase Value",
    "aria-disabled": upDisabled,
    className: upClassName
  }), upNode || /* @__PURE__ */ react.exports.createElement("span", {
    unselectable: "on",
    className: "".concat(prefixCls, "-handler-up-inner")
  })), /* @__PURE__ */ react.exports.createElement("span", _extends$2({}, sharedHandlerProps, {
    onMouseDown: function onMouseDown(e2) {
      onStepMouseDown(e2, false);
    },
    "aria-label": "Decrease Value",
    "aria-disabled": downDisabled,
    className: downClassName
  }), downNode || /* @__PURE__ */ react.exports.createElement("span", {
    unselectable: "on",
    className: "".concat(prefixCls, "-handler-down-inner")
  })));
}
function useCursor(input, focused) {
  var selectionRef = react.exports.useRef(null);
  function recordCursor() {
    try {
      var start = input.selectionStart, end = input.selectionEnd, value2 = input.value;
      var beforeTxt = value2.substring(0, start);
      var afterTxt = value2.substring(end);
      selectionRef.current = {
        start,
        end,
        value: value2,
        beforeTxt,
        afterTxt
      };
    } catch (e2) {
    }
  }
  function restoreCursor() {
    if (input && selectionRef.current && focused) {
      try {
        var value2 = input.value;
        var _selectionRef$current = selectionRef.current, beforeTxt = _selectionRef$current.beforeTxt, afterTxt = _selectionRef$current.afterTxt, start = _selectionRef$current.start;
        var startPos = value2.length;
        if (value2.endsWith(afterTxt)) {
          startPos = value2.length - selectionRef.current.afterTxt.length;
        } else if (value2.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          var beforeLastChar = beforeTxt[start - 1];
          var newIndex = value2.indexOf(beforeLastChar, start - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.setSelectionRange(startPos, startPos);
      } catch (e2) {
        warningOnce(false, "Something warning of cursor restore. Please fire issue about this: ".concat(e2.message));
      }
    }
  }
  return [recordCursor, restoreCursor];
}
const useFrame = function() {
  var idRef = react.exports.useRef(0);
  var cleanUp = function cleanUp2() {
    wrapperRaf$1.cancel(idRef.current);
  };
  react.exports.useEffect(function() {
    return cleanUp;
  }, []);
  return function(callback) {
    cleanUp();
    idRef.current = wrapperRaf$1(function() {
      callback();
    });
  };
};
var _excluded$8 = ["prefixCls", "className", "style", "min", "max", "step", "defaultValue", "value", "disabled", "readOnly", "upHandler", "downHandler", "keyboard", "controls", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep"];
var getDecimalValue = function getDecimalValue2(stringMode, decimalValue) {
  if (stringMode || decimalValue.isEmpty()) {
    return decimalValue.toString();
  }
  return decimalValue.toNumber();
};
var getDecimalIfValidate = function getDecimalIfValidate2(value2) {
  var decimal2 = getMiniDecimal(value2);
  return decimal2.isInvalidate() ? null : decimal2;
};
var InputNumber$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input-number" : _props$prefixCls, className = props.className, style2 = props.style, min = props.min, max = props.max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, defaultValue = props.defaultValue, value2 = props.value, disabled = props.disabled, readOnly = props.readOnly, upHandler = props.upHandler, downHandler = props.downHandler, keyboard = props.keyboard, _props$controls = props.controls, controls = _props$controls === void 0 ? true : _props$controls, stringMode = props.stringMode, parser2 = props.parser, formatter2 = props.formatter, precision = props.precision, decimalSeparator = props.decimalSeparator, onChange2 = props.onChange, onInput = props.onInput, onPressEnter = props.onPressEnter, onStep = props.onStep, inputProps = _objectWithoutProperties$1(props, _excluded$8);
  var inputClassName = "".concat(prefixCls, "-input");
  var inputRef = react.exports.useRef(null);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), focus = _React$useState2[0], setFocus = _React$useState2[1];
  var userTypingRef = react.exports.useRef(false);
  var compositionRef = react.exports.useRef(false);
  var shiftKeyRef = react.exports.useRef(false);
  var _React$useState3 = react.exports.useState(function() {
    return getMiniDecimal(value2 !== null && value2 !== void 0 ? value2 : defaultValue);
  }), _React$useState4 = _slicedToArray$3(_React$useState3, 2), decimalValue = _React$useState4[0], setDecimalValue = _React$useState4[1];
  function setUncontrolledDecimalValue(newDecimal) {
    if (value2 === void 0) {
      setDecimalValue(newDecimal);
    }
  }
  var getPrecision = react.exports.useCallback(function(numStr, userTyping) {
    if (userTyping) {
      return void 0;
    }
    if (precision >= 0) {
      return precision;
    }
    return Math.max(getNumberPrecision(numStr), getNumberPrecision(step));
  }, [precision, step]);
  var mergedParser = react.exports.useCallback(function(num) {
    var numStr = String(num);
    if (parser2) {
      return parser2(numStr);
    }
    var parsedStr = numStr;
    if (decimalSeparator) {
      parsedStr = parsedStr.replace(decimalSeparator, ".");
    }
    return parsedStr.replace(/[^\w.-]+/g, "");
  }, [parser2, decimalSeparator]);
  var inputValueRef = react.exports.useRef("");
  var mergedFormatter = react.exports.useCallback(function(number4, userTyping) {
    if (formatter2) {
      return formatter2(number4, {
        userTyping,
        input: String(inputValueRef.current)
      });
    }
    var str = typeof number4 === "number" ? num2str(number4) : number4;
    if (!userTyping) {
      var mergedPrecision = getPrecision(str, userTyping);
      if (validateNumber(str) && (decimalSeparator || mergedPrecision >= 0)) {
        var separatorStr = decimalSeparator || ".";
        str = toFixed(str, separatorStr, mergedPrecision);
      }
    }
    return str;
  }, [formatter2, getPrecision, decimalSeparator]);
  var _React$useState5 = react.exports.useState(function() {
    var initValue = defaultValue !== null && defaultValue !== void 0 ? defaultValue : value2;
    if (decimalValue.isInvalidate() && ["string", "number"].includes(_typeof$4(initValue))) {
      return Number.isNaN(initValue) ? "" : initValue;
    }
    return mergedFormatter(decimalValue.toString(), false);
  }), _React$useState6 = _slicedToArray$3(_React$useState5, 2), inputValue = _React$useState6[0], setInternalInputValue = _React$useState6[1];
  inputValueRef.current = inputValue;
  function setInputValue(newValue, userTyping) {
    setInternalInputValue(mergedFormatter(newValue.isInvalidate() ? newValue.toString(false) : newValue.toString(!userTyping), userTyping));
  }
  var maxDecimal = react.exports.useMemo(function() {
    return getDecimalIfValidate(max);
  }, [max, precision]);
  var minDecimal = react.exports.useMemo(function() {
    return getDecimalIfValidate(min);
  }, [min, precision]);
  var upDisabled = react.exports.useMemo(function() {
    if (!maxDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return maxDecimal.lessEquals(decimalValue);
  }, [maxDecimal, decimalValue]);
  var downDisabled = react.exports.useMemo(function() {
    if (!minDecimal || !decimalValue || decimalValue.isInvalidate()) {
      return false;
    }
    return decimalValue.lessEquals(minDecimal);
  }, [minDecimal, decimalValue]);
  var _useCursor = useCursor(inputRef.current, focus), _useCursor2 = _slicedToArray$3(_useCursor, 2), recordCursor = _useCursor2[0], restoreCursor = _useCursor2[1];
  var getRangeValue = function getRangeValue2(target) {
    if (maxDecimal && !target.lessEquals(maxDecimal)) {
      return maxDecimal;
    }
    if (minDecimal && !minDecimal.lessEquals(target)) {
      return minDecimal;
    }
    return null;
  };
  var isInRange = function isInRange2(target) {
    return !getRangeValue(target);
  };
  var triggerValueUpdate = function triggerValueUpdate2(newValue, userTyping) {
    var updateValue = newValue;
    var isRangeValidate = isInRange(updateValue) || updateValue.isEmpty();
    if (!updateValue.isEmpty() && !userTyping) {
      updateValue = getRangeValue(updateValue) || updateValue;
      isRangeValidate = true;
    }
    if (!readOnly && !disabled && isRangeValidate) {
      var numStr = updateValue.toString();
      var mergedPrecision = getPrecision(numStr, userTyping);
      if (mergedPrecision >= 0) {
        updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision));
        if (!isInRange(updateValue)) {
          updateValue = getMiniDecimal(toFixed(numStr, ".", mergedPrecision, true));
        }
      }
      if (!updateValue.equals(decimalValue)) {
        setUncontrolledDecimalValue(updateValue);
        onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(updateValue.isEmpty() ? null : getDecimalValue(stringMode, updateValue));
        if (value2 === void 0) {
          setInputValue(updateValue, userTyping);
        }
      }
      return updateValue;
    }
    return decimalValue;
  };
  var onNextPromise = useFrame();
  var collectInputValue = function collectInputValue2(inputStr) {
    recordCursor();
    setInternalInputValue(inputStr);
    if (!compositionRef.current) {
      var finalValue = mergedParser(inputStr);
      var finalDecimal = getMiniDecimal(finalValue);
      if (!finalDecimal.isNaN()) {
        triggerValueUpdate(finalDecimal, true);
      }
    }
    onInput === null || onInput === void 0 ? void 0 : onInput(inputStr);
    onNextPromise(function() {
      var nextInputStr = inputStr;
      if (!parser2) {
        nextInputStr = inputStr.replace(//g, ".");
      }
      if (nextInputStr !== inputStr) {
        collectInputValue2(nextInputStr);
      }
    });
  };
  var onCompositionStart = function onCompositionStart2() {
    compositionRef.current = true;
  };
  var onCompositionEnd = function onCompositionEnd2() {
    compositionRef.current = false;
    collectInputValue(inputRef.current.value);
  };
  var onInternalInput = function onInternalInput2(e2) {
    collectInputValue(e2.target.value);
  };
  var onInternalStep = function onInternalStep2(up) {
    var _inputRef$current;
    if (up && upDisabled || !up && downDisabled) {
      return;
    }
    userTypingRef.current = false;
    var stepDecimal = getMiniDecimal(shiftKeyRef.current ? getDecupleSteps(step) : step);
    if (!up) {
      stepDecimal = stepDecimal.negate();
    }
    var target = (decimalValue || getMiniDecimal(0)).add(stepDecimal.toString());
    var updatedValue = triggerValueUpdate(target, false);
    onStep === null || onStep === void 0 ? void 0 : onStep(getDecimalValue(stringMode, updatedValue), {
      offset: shiftKeyRef.current ? getDecupleSteps(step) : step,
      type: up ? "up" : "down"
    });
    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.focus();
  };
  var flushInputValue = function flushInputValue2(userTyping) {
    var parsedValue = getMiniDecimal(mergedParser(inputValue));
    var formatValue = parsedValue;
    if (!parsedValue.isNaN()) {
      formatValue = triggerValueUpdate(parsedValue, userTyping);
    } else {
      formatValue = decimalValue;
    }
    if (value2 !== void 0) {
      setInputValue(decimalValue, false);
    } else if (!formatValue.isNaN()) {
      setInputValue(formatValue, false);
    }
  };
  var onKeyDown2 = function onKeyDown3(event) {
    var which = event.which, shiftKey = event.shiftKey;
    userTypingRef.current = true;
    if (shiftKey) {
      shiftKeyRef.current = true;
    } else {
      shiftKeyRef.current = false;
    }
    if (which === KeyCode.ENTER) {
      if (!compositionRef.current) {
        userTypingRef.current = false;
      }
      flushInputValue(false);
      onPressEnter === null || onPressEnter === void 0 ? void 0 : onPressEnter(event);
    }
    if (keyboard === false) {
      return;
    }
    if (!compositionRef.current && [KeyCode.UP, KeyCode.DOWN].includes(which)) {
      onInternalStep(KeyCode.UP === which);
      event.preventDefault();
    }
  };
  var onKeyUp2 = function onKeyUp3() {
    userTypingRef.current = false;
    shiftKeyRef.current = false;
  };
  var onBlur2 = function onBlur3() {
    flushInputValue(false);
    setFocus(false);
    userTypingRef.current = false;
  };
  useLayoutUpdateEffect(function() {
    if (!decimalValue.isInvalidate()) {
      setInputValue(decimalValue, false);
    }
  }, [precision]);
  useLayoutUpdateEffect(function() {
    var newValue = getMiniDecimal(value2);
    setDecimalValue(newValue);
    var currentParsedValue = getMiniDecimal(mergedParser(inputValue));
    if (!newValue.equals(currentParsedValue) || !userTypingRef.current || formatter2) {
      setInputValue(newValue, userTypingRef.current);
    }
  }, [value2]);
  useLayoutUpdateEffect(function() {
    if (formatter2) {
      restoreCursor();
    }
  }, [inputValue]);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: classnamesExports(prefixCls, className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-focused"), focus), _defineProperty$5(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$5(_classNames, "".concat(prefixCls, "-readonly"), readOnly), _defineProperty$5(_classNames, "".concat(prefixCls, "-not-a-number"), decimalValue.isNaN()), _defineProperty$5(_classNames, "".concat(prefixCls, "-out-of-range"), !decimalValue.isInvalidate() && !isInRange(decimalValue)), _classNames)),
    style: style2,
    onFocus: function onFocus2() {
      setFocus(true);
    },
    onBlur: onBlur2,
    onKeyDown: onKeyDown2,
    onKeyUp: onKeyUp2,
    onCompositionStart,
    onCompositionEnd
  }, controls && /* @__PURE__ */ react.exports.createElement(StepHandler, {
    prefixCls,
    upNode: upHandler,
    downNode: downHandler,
    upDisabled,
    downDisabled,
    onStep: onInternalStep
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(inputClassName, "-wrap")
  }, /* @__PURE__ */ react.exports.createElement("input", _extends$2({
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuenow": decimalValue.isInvalidate() ? null : decimalValue.toString(),
    step
  }, inputProps, {
    ref: composeRef(inputRef, ref),
    className: inputClassName,
    value: inputValue,
    onChange: onInternalInput,
    disabled,
    readOnly
  }))));
});
InputNumber$2.displayName = "InputNumber";
var __rest$d = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var InputNumber = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext$1);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), focused = _React$useState2[0], setFocus = _React$useState2[1];
  var inputRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return inputRef.current;
  });
  var className = props.className, customizeSize = props.size, customDisabled = props.disabled, customizePrefixCls = props.prefixCls, addonBefore = props.addonBefore, addonAfter = props.addonAfter, prefix2 = props.prefix, _props$bordered = props.bordered, bordered = _props$bordered === void 0 ? true : _props$bordered, readOnly = props.readOnly, customStatus = props.status, controls = props.controls, others = __rest$d(props, ["className", "size", "disabled", "prefixCls", "addonBefore", "addonAfter", "prefix", "bordered", "readOnly", "status", "controls"]);
  var prefixCls = getPrefixCls("input-number", customizePrefixCls);
  var upIcon = /* @__PURE__ */ react.exports.createElement(UpOutlined$1, {
    className: "".concat(prefixCls, "-handler-up-inner")
  });
  var downIcon = /* @__PURE__ */ react.exports.createElement(DownOutlined$1, {
    className: "".concat(prefixCls, "-handler-down-inner")
  });
  var controlsTemp = typeof controls === "boolean" ? controls : void 0;
  if (_typeof$4(controls) === "object") {
    upIcon = typeof controls.upIcon === "undefined" ? upIcon : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-handler-up-inner")
    }, controls.upIcon);
    downIcon = typeof controls.downIcon === "undefined" ? downIcon : /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-handler-down-inner")
    }, controls.downIcon);
  }
  var _useContext = react.exports.useContext(FormItemInputContext), hasFeedback = _useContext.hasFeedback, contextStatus = _useContext.status, isFormItemInput = _useContext.isFormItemInput, feedbackIcon = _useContext.feedbackIcon;
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var mergeSize = customizeSize || size;
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled;
  var inputNumberClass = classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-lg"), mergeSize === "large"), _defineProperty$5(_classNames, "".concat(prefixCls, "-sm"), mergeSize === "small"), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-borderless"), !bordered), _defineProperty$5(_classNames, "".concat(prefixCls, "-in-form-item"), isFormItemInput), _classNames), getStatusClassNames(prefixCls, mergedStatus), className);
  var element = /* @__PURE__ */ react.exports.createElement(InputNumber$2, _extends$2({
    ref: inputRef,
    disabled: mergedDisabled,
    className: inputNumberClass,
    upHandler: upIcon,
    downHandler: downIcon,
    prefixCls,
    readOnly,
    controls: controlsTemp
  }, others));
  if (prefix2 != null || hasFeedback) {
    var _classNames2;
    var affixWrapperCls = classnamesExports("".concat(prefixCls, "-affix-wrapper"), getStatusClassNames("".concat(prefixCls, "-affix-wrapper"), mergedStatus, hasFeedback), (_classNames2 = {}, _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-focused"), focused), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-disabled"), props.disabled), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-sm"), size === "small"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-lg"), size === "large"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-rtl"), direction === "rtl"), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-readonly"), readOnly), _defineProperty$5(_classNames2, "".concat(prefixCls, "-affix-wrapper-borderless"), !bordered), _defineProperty$5(_classNames2, "".concat(className), !(addonBefore || addonAfter) && className), _classNames2));
    element = /* @__PURE__ */ react.exports.createElement("div", {
      className: affixWrapperCls,
      style: props.style,
      onMouseUp: function onMouseUp() {
        return inputRef.current.focus();
      }
    }, prefix2 && /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-prefix")
    }, prefix2), cloneElement(element, {
      style: null,
      value: props.value,
      onFocus: function onFocus2(event) {
        var _a;
        setFocus(true);
        (_a = props.onFocus) === null || _a === void 0 ? void 0 : _a.call(props, event);
      },
      onBlur: function onBlur2(event) {
        var _a;
        setFocus(false);
        (_a = props.onBlur) === null || _a === void 0 ? void 0 : _a.call(props, event);
      }
    }), hasFeedback && /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-suffix")
    }, feedbackIcon));
  }
  if (addonBefore != null || addonAfter != null) {
    var _classNames4;
    var wrapperClassName = "".concat(prefixCls, "-group");
    var addonClassName = "".concat(wrapperClassName, "-addon");
    var addonBeforeNode = addonBefore ? /* @__PURE__ */ react.exports.createElement("div", {
      className: addonClassName
    }, addonBefore) : null;
    var addonAfterNode = addonAfter ? /* @__PURE__ */ react.exports.createElement("div", {
      className: addonClassName
    }, addonAfter) : null;
    var mergedWrapperClassName = classnamesExports("".concat(prefixCls, "-wrapper"), wrapperClassName, _defineProperty$5({}, "".concat(wrapperClassName, "-rtl"), direction === "rtl"));
    var mergedGroupClassName = classnamesExports("".concat(prefixCls, "-group-wrapper"), (_classNames4 = {}, _defineProperty$5(_classNames4, "".concat(prefixCls, "-group-wrapper-sm"), size === "small"), _defineProperty$5(_classNames4, "".concat(prefixCls, "-group-wrapper-lg"), size === "large"), _defineProperty$5(_classNames4, "".concat(prefixCls, "-group-wrapper-rtl"), direction === "rtl"), _classNames4), getStatusClassNames("".concat(prefixCls, "-group-wrapper"), mergedStatus, hasFeedback), className);
    element = /* @__PURE__ */ react.exports.createElement("div", {
      className: mergedGroupClassName,
      style: props.style
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: mergedWrapperClassName
    }, addonBeforeNode && /* @__PURE__ */ react.exports.createElement(NoFormStyle, {
      status: true,
      override: true
    }, addonBeforeNode), cloneElement(element, {
      style: null,
      disabled: mergedDisabled
    }), addonAfterNode && /* @__PURE__ */ react.exports.createElement(NoFormStyle, {
      status: true,
      override: true
    }, addonAfterNode)));
  }
  return element;
});
const InputNumber$1 = InputNumber;
var DoubleLeftOutlined$7 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
const DoubleLeftOutlinedSvg = DoubleLeftOutlined$7;
var DoubleLeftOutlined$5 = function DoubleLeftOutlined(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: DoubleLeftOutlinedSvg
  }));
};
DoubleLeftOutlined$5.displayName = "DoubleLeftOutlined";
const DoubleLeftOutlined$6 = /* @__PURE__ */ react.exports.forwardRef(DoubleLeftOutlined$5);
var DoubleRightOutlined$7 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
const DoubleRightOutlinedSvg = DoubleRightOutlined$7;
var DoubleRightOutlined$5 = function DoubleRightOutlined(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: DoubleRightOutlinedSvg
  }));
};
DoubleRightOutlined$5.displayName = "DoubleRightOutlined";
const DoubleRightOutlined$6 = /* @__PURE__ */ react.exports.forwardRef(DoubleRightOutlined$5);
var Pager = function Pager2(props) {
  var _classNames;
  var prefixCls = "".concat(props.rootPrefixCls, "-item");
  var cls = classnamesExports(prefixCls, "".concat(prefixCls, "-").concat(props.page), (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-active"), props.active), _defineProperty$5(_classNames, "".concat(prefixCls, "-disabled"), !props.page), _defineProperty$5(_classNames, props.className, !!props.className), _classNames));
  var handleClick = function handleClick2() {
    props.onClick(props.page);
  };
  var handleKeyPress = function handleKeyPress2(e2) {
    props.onKeyPress(e2, props.onClick, props.page);
  };
  return /* @__PURE__ */ React$a.createElement("li", {
    title: props.showTitle ? props.page : null,
    className: cls,
    onClick: handleClick,
    onKeyPress: handleKeyPress,
    tabIndex: "0"
  }, props.itemRender(props.page, "page", /* @__PURE__ */ React$a.createElement("a", {
    rel: "nofollow"
  }, props.page)));
};
const KEYCODE = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
};
var Options = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Options2, _React$Component);
  var _super = _createSuper$1(Options2);
  function Options2() {
    var _this;
    _classCallCheck$2(this, Options2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _this.state = {
      goInputText: ""
    };
    _this.buildOptionText = function(value2) {
      return "".concat(value2, " ").concat(_this.props.locale.items_per_page);
    };
    _this.changeSize = function(value2) {
      _this.props.changeSize(Number(value2));
    };
    _this.handleChange = function(e2) {
      _this.setState({
        goInputText: e2.target.value
      });
    };
    _this.handleBlur = function(e2) {
      var _this$props = _this.props, goButton = _this$props.goButton, quickGo = _this$props.quickGo, rootPrefixCls = _this$props.rootPrefixCls;
      var goInputText = _this.state.goInputText;
      if (goButton || goInputText === "") {
        return;
      }
      _this.setState({
        goInputText: ""
      });
      if (e2.relatedTarget && (e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item-link")) >= 0 || e2.relatedTarget.className.indexOf("".concat(rootPrefixCls, "-item")) >= 0)) {
        return;
      }
      quickGo(_this.getValidValue());
    };
    _this.go = function(e2) {
      var goInputText = _this.state.goInputText;
      if (goInputText === "") {
        return;
      }
      if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
        _this.setState({
          goInputText: ""
        });
        _this.props.quickGo(_this.getValidValue());
      }
    };
    return _this;
  }
  _createClass$2(Options2, [{
    key: "getValidValue",
    value: function getValidValue() {
      var goInputText = this.state.goInputText;
      return !goInputText || isNaN(goInputText) ? void 0 : Number(goInputText);
    }
  }, {
    key: "getPageSizeOptions",
    value: function getPageSizeOptions() {
      var _this$props2 = this.props, pageSize = _this$props2.pageSize, pageSizeOptions = _this$props2.pageSizeOptions;
      if (pageSizeOptions.some(function(option) {
        return option.toString() === pageSize.toString();
      })) {
        return pageSizeOptions;
      }
      return pageSizeOptions.concat([pageSize.toString()]).sort(function(a, b2) {
        var numberA = isNaN(Number(a)) ? 0 : Number(a);
        var numberB = isNaN(Number(b2)) ? 0 : Number(b2);
        return numberA - numberB;
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props3 = this.props, pageSize = _this$props3.pageSize, locale2 = _this$props3.locale, rootPrefixCls = _this$props3.rootPrefixCls, changeSize = _this$props3.changeSize, quickGo = _this$props3.quickGo, goButton = _this$props3.goButton, selectComponentClass = _this$props3.selectComponentClass, buildOptionText = _this$props3.buildOptionText, selectPrefixCls = _this$props3.selectPrefixCls, disabled = _this$props3.disabled;
      var goInputText = this.state.goInputText;
      var prefixCls = "".concat(rootPrefixCls, "-options");
      var Select2 = selectComponentClass;
      var changeSelect = null;
      var goInput = null;
      var gotoButton = null;
      if (!changeSize && !quickGo) {
        return null;
      }
      var pageSizeOptions = this.getPageSizeOptions();
      if (changeSize && Select2) {
        var options = pageSizeOptions.map(function(opt, i) {
          return /* @__PURE__ */ React$a.createElement(Select2.Option, {
            key: i,
            value: opt.toString()
          }, (buildOptionText || _this2.buildOptionText)(opt));
        });
        changeSelect = /* @__PURE__ */ React$a.createElement(Select2, {
          disabled,
          prefixCls: selectPrefixCls,
          showSearch: false,
          className: "".concat(prefixCls, "-size-changer"),
          optionLabelProp: "children",
          dropdownMatchSelectWidth: false,
          value: (pageSize || pageSizeOptions[0]).toString(),
          onChange: this.changeSize,
          getPopupContainer: function getPopupContainer(triggerNode) {
            return triggerNode.parentNode;
          },
          "aria-label": locale2.page_size,
          defaultOpen: false
        }, options);
      }
      if (quickGo) {
        if (goButton) {
          gotoButton = typeof goButton === "boolean" ? /* @__PURE__ */ React$a.createElement("button", {
            type: "button",
            onClick: this.go,
            onKeyUp: this.go,
            disabled,
            className: "".concat(prefixCls, "-quick-jumper-button")
          }, locale2.jump_to_confirm) : /* @__PURE__ */ React$a.createElement("span", {
            onClick: this.go,
            onKeyUp: this.go
          }, goButton);
        }
        goInput = /* @__PURE__ */ React$a.createElement("div", {
          className: "".concat(prefixCls, "-quick-jumper")
        }, locale2.jump_to, /* @__PURE__ */ React$a.createElement("input", {
          disabled,
          type: "text",
          value: goInputText,
          onChange: this.handleChange,
          onKeyUp: this.go,
          onBlur: this.handleBlur,
          "aria-label": locale2.page
        }), locale2.page, gotoButton);
      }
      return /* @__PURE__ */ React$a.createElement("li", {
        className: "".concat(prefixCls)
      }, changeSelect, goInput);
    }
  }]);
  return Options2;
}(React$a.Component);
Options.defaultProps = {
  pageSizeOptions: ["10", "20", "50", "100"]
};
const LOCALE = {
  items_per_page: "\u6761/\u9875",
  jump_to: "\u8DF3\u81F3",
  jump_to_confirm: "\u786E\u5B9A",
  page: "\u9875",
  prev_page: "\u4E0A\u4E00\u9875",
  next_page: "\u4E0B\u4E00\u9875",
  prev_5: "\u5411\u524D 5 \u9875",
  next_5: "\u5411\u540E 5 \u9875",
  prev_3: "\u5411\u524D 3 \u9875",
  next_3: "\u5411\u540E 3 \u9875",
  page_size: "\u9875\u7801"
};
function noop$1() {
}
function isInteger(v2) {
  var value2 = Number(v2);
  return typeof value2 === "number" && !isNaN(value2) && isFinite(value2) && Math.floor(value2) === value2;
}
function defaultItemRender(page, type4, element) {
  return element;
}
function calculatePage(p2, state, props) {
  var pageSize = typeof p2 === "undefined" ? state.pageSize : p2;
  return Math.floor((props.total - 1) / pageSize) + 1;
}
var Pagination$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Pagination3, _React$Component);
  var _super = _createSuper$1(Pagination3);
  function Pagination3(props) {
    var _this;
    _classCallCheck$2(this, Pagination3);
    _this = _super.call(this, props);
    _this.getJumpPrevPage = function() {
      return Math.max(1, _this.state.current - (_this.props.showLessItems ? 3 : 5));
    };
    _this.getJumpNextPage = function() {
      return Math.min(calculatePage(void 0, _this.state, _this.props), _this.state.current + (_this.props.showLessItems ? 3 : 5));
    };
    _this.getItemIcon = function(icon, label) {
      var prefixCls = _this.props.prefixCls;
      var iconNode = icon || /* @__PURE__ */ React$a.createElement("button", {
        type: "button",
        "aria-label": label,
        className: "".concat(prefixCls, "-item-link")
      });
      if (typeof icon === "function") {
        iconNode = /* @__PURE__ */ React$a.createElement(icon, _objectSpread2$4({}, _this.props));
      }
      return iconNode;
    };
    _this.savePaginationNode = function(node) {
      _this.paginationNode = node;
    };
    _this.isValid = function(page) {
      var total = _this.props.total;
      return isInteger(page) && page !== _this.state.current && isInteger(total) && total > 0;
    };
    _this.shouldDisplayQuickJumper = function() {
      var _this$props = _this.props, showQuickJumper = _this$props.showQuickJumper, total = _this$props.total;
      var pageSize = _this.state.pageSize;
      if (total <= pageSize) {
        return false;
      }
      return showQuickJumper;
    };
    _this.handleKeyDown = function(e2) {
      if (e2.keyCode === KEYCODE.ARROW_UP || e2.keyCode === KEYCODE.ARROW_DOWN) {
        e2.preventDefault();
      }
    };
    _this.handleKeyUp = function(e2) {
      var value2 = _this.getValidValue(e2);
      var currentInputValue = _this.state.currentInputValue;
      if (value2 !== currentInputValue) {
        _this.setState({
          currentInputValue: value2
        });
      }
      if (e2.keyCode === KEYCODE.ENTER) {
        _this.handleChange(value2);
      } else if (e2.keyCode === KEYCODE.ARROW_UP) {
        _this.handleChange(value2 - 1);
      } else if (e2.keyCode === KEYCODE.ARROW_DOWN) {
        _this.handleChange(value2 + 1);
      }
    };
    _this.handleBlur = function(e2) {
      var value2 = _this.getValidValue(e2);
      _this.handleChange(value2);
    };
    _this.changePageSize = function(size) {
      var current = _this.state.current;
      var newCurrent = calculatePage(size, _this.state, _this.props);
      current = current > newCurrent ? newCurrent : current;
      if (newCurrent === 0) {
        current = _this.state.current;
      }
      if (typeof size === "number") {
        if (!("pageSize" in _this.props)) {
          _this.setState({
            pageSize: size
          });
        }
        if (!("current" in _this.props)) {
          _this.setState({
            current,
            currentInputValue: current
          });
        }
      }
      _this.props.onShowSizeChange(current, size);
      if ("onChange" in _this.props && _this.props.onChange) {
        _this.props.onChange(current, size);
      }
    };
    _this.handleChange = function(page) {
      var _this$props2 = _this.props, disabled = _this$props2.disabled, onChange2 = _this$props2.onChange;
      var _this$state = _this.state, pageSize = _this$state.pageSize, current = _this$state.current, currentInputValue = _this$state.currentInputValue;
      if (_this.isValid(page) && !disabled) {
        var currentPage = calculatePage(void 0, _this.state, _this.props);
        var newPage = page;
        if (page > currentPage) {
          newPage = currentPage;
        } else if (page < 1) {
          newPage = 1;
        }
        if (!("current" in _this.props)) {
          _this.setState({
            current: newPage
          });
        }
        if (newPage !== currentInputValue) {
          _this.setState({
            currentInputValue: newPage
          });
        }
        onChange2(newPage, pageSize);
        return newPage;
      }
      return current;
    };
    _this.prev = function() {
      if (_this.hasPrev()) {
        _this.handleChange(_this.state.current - 1);
      }
    };
    _this.next = function() {
      if (_this.hasNext()) {
        _this.handleChange(_this.state.current + 1);
      }
    };
    _this.jumpPrev = function() {
      _this.handleChange(_this.getJumpPrevPage());
    };
    _this.jumpNext = function() {
      _this.handleChange(_this.getJumpNextPage());
    };
    _this.hasPrev = function() {
      return _this.state.current > 1;
    };
    _this.hasNext = function() {
      return _this.state.current < calculatePage(void 0, _this.state, _this.props);
    };
    _this.runIfEnter = function(event, callback) {
      if (event.key === "Enter" || event.charCode === 13) {
        for (var _len = arguments.length, restParams = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          restParams[_key - 2] = arguments[_key];
        }
        callback.apply(void 0, restParams);
      }
    };
    _this.runIfEnterPrev = function(e2) {
      _this.runIfEnter(e2, _this.prev);
    };
    _this.runIfEnterNext = function(e2) {
      _this.runIfEnter(e2, _this.next);
    };
    _this.runIfEnterJumpPrev = function(e2) {
      _this.runIfEnter(e2, _this.jumpPrev);
    };
    _this.runIfEnterJumpNext = function(e2) {
      _this.runIfEnter(e2, _this.jumpNext);
    };
    _this.handleGoTO = function(e2) {
      if (e2.keyCode === KEYCODE.ENTER || e2.type === "click") {
        _this.handleChange(_this.state.currentInputValue);
      }
    };
    var hasOnChange = props.onChange !== noop$1;
    var hasCurrent = "current" in props;
    if (hasCurrent && !hasOnChange) {
      console.warn("Warning: You provided a `current` prop to a Pagination component without an `onChange` handler. This will render a read-only component.");
    }
    var _current = props.defaultCurrent;
    if ("current" in props) {
      _current = props.current;
    }
    var _pageSize = props.defaultPageSize;
    if ("pageSize" in props) {
      _pageSize = props.pageSize;
    }
    _current = Math.min(_current, calculatePage(_pageSize, void 0, props));
    _this.state = {
      current: _current,
      currentInputValue: _current,
      pageSize: _pageSize
    };
    return _this;
  }
  _createClass$2(Pagination3, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var prefixCls = this.props.prefixCls;
      if (prevState.current !== this.state.current && this.paginationNode) {
        var lastCurrentNode = this.paginationNode.querySelector(".".concat(prefixCls, "-item-").concat(prevState.current));
        if (lastCurrentNode && document.activeElement === lastCurrentNode) {
          lastCurrentNode.blur();
        }
      }
    }
  }, {
    key: "getValidValue",
    value: function getValidValue(e2) {
      var inputValue = e2.target.value;
      var allPages = calculatePage(void 0, this.state, this.props);
      var currentInputValue = this.state.currentInputValue;
      var value2;
      if (inputValue === "") {
        value2 = inputValue;
      } else if (isNaN(Number(inputValue))) {
        value2 = currentInputValue;
      } else if (inputValue >= allPages) {
        value2 = allPages;
      } else {
        value2 = Number(inputValue);
      }
      return value2;
    }
  }, {
    key: "getShowSizeChanger",
    value: function getShowSizeChanger() {
      var _this$props3 = this.props, showSizeChanger = _this$props3.showSizeChanger, total = _this$props3.total, totalBoundaryShowSizeChanger = _this$props3.totalBoundaryShowSizeChanger;
      if (typeof showSizeChanger !== "undefined") {
        return showSizeChanger;
      }
      return total > totalBoundaryShowSizeChanger;
    }
  }, {
    key: "renderPrev",
    value: function renderPrev(prevPage) {
      var _this$props4 = this.props, prevIcon = _this$props4.prevIcon, itemRender = _this$props4.itemRender;
      var prevButton = itemRender(prevPage, "prev", this.getItemIcon(prevIcon, "prev page"));
      var disabled = !this.hasPrev();
      return /* @__PURE__ */ react.exports.isValidElement(prevButton) ? /* @__PURE__ */ react.exports.cloneElement(prevButton, {
        disabled
      }) : prevButton;
    }
  }, {
    key: "renderNext",
    value: function renderNext(nextPage) {
      var _this$props5 = this.props, nextIcon = _this$props5.nextIcon, itemRender = _this$props5.itemRender;
      var nextButton = itemRender(nextPage, "next", this.getItemIcon(nextIcon, "next page"));
      var disabled = !this.hasNext();
      return /* @__PURE__ */ react.exports.isValidElement(nextButton) ? /* @__PURE__ */ react.exports.cloneElement(nextButton, {
        disabled
      }) : nextButton;
    }
  }, {
    key: "render",
    value: function render2() {
      var _this2 = this;
      var _this$props6 = this.props, prefixCls = _this$props6.prefixCls, className = _this$props6.className, style2 = _this$props6.style, disabled = _this$props6.disabled, hideOnSinglePage = _this$props6.hideOnSinglePage, total = _this$props6.total, locale2 = _this$props6.locale, showQuickJumper = _this$props6.showQuickJumper, showLessItems = _this$props6.showLessItems, showTitle = _this$props6.showTitle, showTotal = _this$props6.showTotal, simple = _this$props6.simple, itemRender = _this$props6.itemRender, showPrevNextJumpers = _this$props6.showPrevNextJumpers, jumpPrevIcon = _this$props6.jumpPrevIcon, jumpNextIcon = _this$props6.jumpNextIcon, selectComponentClass = _this$props6.selectComponentClass, selectPrefixCls = _this$props6.selectPrefixCls, pageSizeOptions = _this$props6.pageSizeOptions;
      var _this$state2 = this.state, current = _this$state2.current, pageSize = _this$state2.pageSize, currentInputValue = _this$state2.currentInputValue;
      if (hideOnSinglePage === true && total <= pageSize) {
        return null;
      }
      var allPages = calculatePage(void 0, this.state, this.props);
      var pagerList = [];
      var jumpPrev = null;
      var jumpNext = null;
      var firstPager = null;
      var lastPager = null;
      var gotoButton = null;
      var goButton = showQuickJumper && showQuickJumper.goButton;
      var pageBufferSize = showLessItems ? 1 : 2;
      var prevPage = current - 1 > 0 ? current - 1 : 0;
      var nextPage = current + 1 < allPages ? current + 1 : allPages;
      var dataOrAriaAttributeProps = Object.keys(this.props).reduce(function(prev, key2) {
        if (key2.substr(0, 5) === "data-" || key2.substr(0, 5) === "aria-" || key2 === "role") {
          prev[key2] = _this2.props[key2];
        }
        return prev;
      }, {});
      if (simple) {
        if (goButton) {
          if (typeof goButton === "boolean") {
            gotoButton = /* @__PURE__ */ React$a.createElement("button", {
              type: "button",
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO
            }, locale2.jump_to_confirm);
          } else {
            gotoButton = /* @__PURE__ */ React$a.createElement("span", {
              onClick: this.handleGoTO,
              onKeyUp: this.handleGoTO
            }, goButton);
          }
          gotoButton = /* @__PURE__ */ React$a.createElement("li", {
            title: showTitle ? "".concat(locale2.jump_to).concat(current, "/").concat(allPages) : null,
            className: "".concat(prefixCls, "-simple-pager")
          }, gotoButton);
        }
        return /* @__PURE__ */ React$a.createElement("ul", _extends$2({
          className: classnamesExports(prefixCls, "".concat(prefixCls, "-simple"), _defineProperty$5({}, "".concat(prefixCls, "-disabled"), disabled), className),
          style: style2,
          ref: this.savePaginationNode
        }, dataOrAriaAttributeProps), /* @__PURE__ */ React$a.createElement("li", {
          title: showTitle ? locale2.prev_page : null,
          onClick: this.prev,
          tabIndex: this.hasPrev() ? 0 : null,
          onKeyPress: this.runIfEnterPrev,
          className: classnamesExports("".concat(prefixCls, "-prev"), _defineProperty$5({}, "".concat(prefixCls, "-disabled"), !this.hasPrev())),
          "aria-disabled": !this.hasPrev()
        }, this.renderPrev(prevPage)), /* @__PURE__ */ React$a.createElement("li", {
          title: showTitle ? "".concat(current, "/").concat(allPages) : null,
          className: "".concat(prefixCls, "-simple-pager")
        }, /* @__PURE__ */ React$a.createElement("input", {
          type: "text",
          value: currentInputValue,
          disabled,
          onKeyDown: this.handleKeyDown,
          onKeyUp: this.handleKeyUp,
          onChange: this.handleKeyUp,
          onBlur: this.handleBlur,
          size: "3"
        }), /* @__PURE__ */ React$a.createElement("span", {
          className: "".concat(prefixCls, "-slash")
        }, "/"), allPages), /* @__PURE__ */ React$a.createElement("li", {
          title: showTitle ? locale2.next_page : null,
          onClick: this.next,
          tabIndex: this.hasPrev() ? 0 : null,
          onKeyPress: this.runIfEnterNext,
          className: classnamesExports("".concat(prefixCls, "-next"), _defineProperty$5({}, "".concat(prefixCls, "-disabled"), !this.hasNext())),
          "aria-disabled": !this.hasNext()
        }, this.renderNext(nextPage)), gotoButton);
      }
      if (allPages <= 3 + pageBufferSize * 2) {
        var pagerProps = {
          locale: locale2,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          showTitle,
          itemRender
        };
        if (!allPages) {
          pagerList.push(/* @__PURE__ */ React$a.createElement(Pager, _extends$2({}, pagerProps, {
            key: "noPager",
            page: 1,
            className: "".concat(prefixCls, "-item-disabled")
          })));
        }
        for (var i = 1; i <= allPages; i += 1) {
          var active = current === i;
          pagerList.push(/* @__PURE__ */ React$a.createElement(Pager, _extends$2({}, pagerProps, {
            key: i,
            page: i,
            active
          })));
        }
      } else {
        var prevItemTitle = showLessItems ? locale2.prev_3 : locale2.prev_5;
        var nextItemTitle = showLessItems ? locale2.next_3 : locale2.next_5;
        if (showPrevNextJumpers) {
          jumpPrev = /* @__PURE__ */ React$a.createElement("li", {
            title: showTitle ? prevItemTitle : null,
            key: "prev",
            onClick: this.jumpPrev,
            tabIndex: "0",
            onKeyPress: this.runIfEnterJumpPrev,
            className: classnamesExports("".concat(prefixCls, "-jump-prev"), _defineProperty$5({}, "".concat(prefixCls, "-jump-prev-custom-icon"), !!jumpPrevIcon))
          }, itemRender(this.getJumpPrevPage(), "jump-prev", this.getItemIcon(jumpPrevIcon, "prev page")));
          jumpNext = /* @__PURE__ */ React$a.createElement("li", {
            title: showTitle ? nextItemTitle : null,
            key: "next",
            tabIndex: "0",
            onClick: this.jumpNext,
            onKeyPress: this.runIfEnterJumpNext,
            className: classnamesExports("".concat(prefixCls, "-jump-next"), _defineProperty$5({}, "".concat(prefixCls, "-jump-next-custom-icon"), !!jumpNextIcon))
          }, itemRender(this.getJumpNextPage(), "jump-next", this.getItemIcon(jumpNextIcon, "next page")));
        }
        lastPager = /* @__PURE__ */ React$a.createElement(Pager, {
          locale: locale2,
          last: true,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          key: allPages,
          page: allPages,
          active: false,
          showTitle,
          itemRender
        });
        firstPager = /* @__PURE__ */ React$a.createElement(Pager, {
          locale: locale2,
          rootPrefixCls: prefixCls,
          onClick: this.handleChange,
          onKeyPress: this.runIfEnter,
          key: 1,
          page: 1,
          active: false,
          showTitle,
          itemRender
        });
        var left = Math.max(1, current - pageBufferSize);
        var right = Math.min(current + pageBufferSize, allPages);
        if (current - 1 <= pageBufferSize) {
          right = 1 + pageBufferSize * 2;
        }
        if (allPages - current <= pageBufferSize) {
          left = allPages - pageBufferSize * 2;
        }
        for (var _i = left; _i <= right; _i += 1) {
          var _active = current === _i;
          pagerList.push(/* @__PURE__ */ React$a.createElement(Pager, {
            locale: locale2,
            rootPrefixCls: prefixCls,
            onClick: this.handleChange,
            onKeyPress: this.runIfEnter,
            key: _i,
            page: _i,
            active: _active,
            showTitle,
            itemRender
          }));
        }
        if (current - 1 >= pageBufferSize * 2 && current !== 1 + 2) {
          pagerList[0] = /* @__PURE__ */ react.exports.cloneElement(pagerList[0], {
            className: "".concat(prefixCls, "-item-after-jump-prev")
          });
          pagerList.unshift(jumpPrev);
        }
        if (allPages - current >= pageBufferSize * 2 && current !== allPages - 2) {
          pagerList[pagerList.length - 1] = /* @__PURE__ */ react.exports.cloneElement(pagerList[pagerList.length - 1], {
            className: "".concat(prefixCls, "-item-before-jump-next")
          });
          pagerList.push(jumpNext);
        }
        if (left !== 1) {
          pagerList.unshift(firstPager);
        }
        if (right !== allPages) {
          pagerList.push(lastPager);
        }
      }
      var totalText = null;
      if (showTotal) {
        totalText = /* @__PURE__ */ React$a.createElement("li", {
          className: "".concat(prefixCls, "-total-text")
        }, showTotal(total, [total === 0 ? 0 : (current - 1) * pageSize + 1, current * pageSize > total ? total : current * pageSize]));
      }
      var prevDisabled = !this.hasPrev() || !allPages;
      var nextDisabled = !this.hasNext() || !allPages;
      return /* @__PURE__ */ React$a.createElement("ul", _extends$2({
        className: classnamesExports(prefixCls, className, _defineProperty$5({}, "".concat(prefixCls, "-disabled"), disabled)),
        style: style2,
        unselectable: "unselectable",
        ref: this.savePaginationNode
      }, dataOrAriaAttributeProps), totalText, /* @__PURE__ */ React$a.createElement("li", {
        title: showTitle ? locale2.prev_page : null,
        onClick: this.prev,
        tabIndex: prevDisabled ? null : 0,
        onKeyPress: this.runIfEnterPrev,
        className: classnamesExports("".concat(prefixCls, "-prev"), _defineProperty$5({}, "".concat(prefixCls, "-disabled"), prevDisabled)),
        "aria-disabled": prevDisabled
      }, this.renderPrev(prevPage)), pagerList, /* @__PURE__ */ React$a.createElement("li", {
        title: showTitle ? locale2.next_page : null,
        onClick: this.next,
        tabIndex: nextDisabled ? null : 0,
        onKeyPress: this.runIfEnterNext,
        className: classnamesExports("".concat(prefixCls, "-next"), _defineProperty$5({}, "".concat(prefixCls, "-disabled"), nextDisabled)),
        "aria-disabled": nextDisabled
      }, this.renderNext(nextPage)), /* @__PURE__ */ React$a.createElement(Options, {
        disabled,
        locale: locale2,
        rootPrefixCls: prefixCls,
        selectComponentClass,
        selectPrefixCls,
        changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
        current,
        pageSize,
        pageSizeOptions,
        quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
        goButton
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var newState = {};
      if ("current" in props) {
        newState.current = props.current;
        if (props.current !== prevState.current) {
          newState.currentInputValue = newState.current;
        }
      }
      if ("pageSize" in props && props.pageSize !== prevState.pageSize) {
        var current = prevState.current;
        var newCurrent = calculatePage(props.pageSize, prevState, props);
        current = current > newCurrent ? newCurrent : current;
        if (!("current" in props)) {
          newState.current = current;
          newState.currentInputValue = current;
        }
        newState.pageSize = props.pageSize;
      }
      return newState;
    }
  }]);
  return Pagination3;
}(React$a.Component);
Pagination$2.defaultProps = {
  defaultCurrent: 1,
  total: 0,
  defaultPageSize: 10,
  onChange: noop$1,
  className: "",
  selectPrefixCls: "rc-select",
  prefixCls: "rc-pagination",
  selectComponentClass: null,
  hideOnSinglePage: false,
  showPrevNextJumpers: true,
  showQuickJumper: false,
  showLessItems: false,
  showTitle: true,
  onShowSizeChange: noop$1,
  locale: LOCALE,
  style: {},
  itemRender: defaultItemRender,
  totalBoundaryShowSizeChanger: 50
};
var MiniSelect = function MiniSelect2(props) {
  return /* @__PURE__ */ react.exports.createElement(Select$1, _extends$2({}, props, {
    size: "small"
  }));
};
var MiddleSelect = function MiddleSelect2(props) {
  return /* @__PURE__ */ react.exports.createElement(Select$1, _extends$2({}, props, {
    size: "middle"
  }));
};
MiniSelect.Option = Select$1.Option;
MiddleSelect.Option = Select$1.Option;
var __rest$c = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Pagination = function Pagination2(_a) {
  var customizePrefixCls = _a.prefixCls, customizeSelectPrefixCls = _a.selectPrefixCls, className = _a.className, size = _a.size, customLocale = _a.locale, selectComponentClass = _a.selectComponentClass, responsive = _a.responsive, showSizeChanger = _a.showSizeChanger, restProps = __rest$c(_a, ["prefixCls", "selectPrefixCls", "className", "size", "locale", "selectComponentClass", "responsive", "showSizeChanger"]);
  var _useBreakpoint = useBreakpoint(responsive), xs = _useBreakpoint.xs;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction, _React$useContext$pag = _React$useContext.pagination, pagination = _React$useContext$pag === void 0 ? {} : _React$useContext$pag;
  var prefixCls = getPrefixCls("pagination", customizePrefixCls);
  var mergedShowSizeChanger = showSizeChanger !== null && showSizeChanger !== void 0 ? showSizeChanger : pagination.showSizeChanger;
  var getIconsProps = function getIconsProps2() {
    var ellipsis = /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-item-ellipsis")
    }, "\u2022\u2022\u2022");
    var prevIcon = /* @__PURE__ */ react.exports.createElement("button", {
      className: "".concat(prefixCls, "-item-link"),
      type: "button",
      tabIndex: -1
    }, /* @__PURE__ */ react.exports.createElement(LeftOutlined$1, null));
    var nextIcon = /* @__PURE__ */ react.exports.createElement("button", {
      className: "".concat(prefixCls, "-item-link"),
      type: "button",
      tabIndex: -1
    }, /* @__PURE__ */ react.exports.createElement(RightOutlined$1, null));
    var jumpPrevIcon = /* @__PURE__ */ react.exports.createElement("a", {
      className: "".concat(prefixCls, "-item-link")
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-item-container")
    }, /* @__PURE__ */ react.exports.createElement(DoubleLeftOutlined$6, {
      className: "".concat(prefixCls, "-item-link-icon")
    }), ellipsis));
    var jumpNextIcon = /* @__PURE__ */ react.exports.createElement("a", {
      className: "".concat(prefixCls, "-item-link")
    }, /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-item-container")
    }, /* @__PURE__ */ react.exports.createElement(DoubleRightOutlined$6, {
      className: "".concat(prefixCls, "-item-link-icon")
    }), ellipsis));
    if (direction === "rtl") {
      var _ref = [nextIcon, prevIcon];
      prevIcon = _ref[0];
      nextIcon = _ref[1];
      var _ref2 = [jumpNextIcon, jumpPrevIcon];
      jumpPrevIcon = _ref2[0];
      jumpNextIcon = _ref2[1];
    }
    return {
      prevIcon,
      nextIcon,
      jumpPrevIcon,
      jumpNextIcon
    };
  };
  var renderPagination = function renderPagination2(contextLocale) {
    var _classNames;
    var locale2 = _extends$2(_extends$2({}, contextLocale), customLocale);
    var isSmall = size === "small" || !!(xs && !size && responsive);
    var selectPrefixCls = getPrefixCls("select", customizeSelectPrefixCls);
    var extendedClassName = classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-mini"), isSmall), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
    return /* @__PURE__ */ react.exports.createElement(Pagination$2, _extends$2({}, getIconsProps(), restProps, {
      prefixCls,
      selectPrefixCls,
      className: extendedClassName,
      selectComponentClass: selectComponentClass || (isSmall ? MiniSelect : MiddleSelect),
      locale: locale2,
      showSizeChanger: mergedShowSizeChanger
    }));
  };
  return /* @__PURE__ */ react.exports.createElement(LocaleReceiver, {
    componentName: "Pagination",
    defaultLocale: enUS$1
  }, renderPagination);
};
const Pagination$1 = Pagination;
var __rest$b = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
tuple("small", "default", "large");
var defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  var indicator = props.indicator;
  var dotClassName = "".concat(prefixCls, "-dot");
  if (indicator === null) {
    return null;
  }
  if (isValidElement(indicator)) {
    return cloneElement(indicator, {
      className: classnamesExports(indicator.props.className, dotClassName)
    });
  }
  if (isValidElement(defaultIndicator)) {
    return cloneElement(defaultIndicator, {
      className: classnamesExports(defaultIndicator.props.className, dotClassName)
    });
  }
  return /* @__PURE__ */ react.exports.createElement("span", {
    className: classnamesExports(dotClassName, "".concat(prefixCls, "-dot-spin"))
  }, /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }), /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }), /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }), /* @__PURE__ */ react.exports.createElement("i", {
    className: "".concat(prefixCls, "-dot-item")
  }));
}
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
var Spin = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Spin2, _React$Component);
  var _super = _createSuper$1(Spin2);
  function Spin2(props) {
    var _this;
    _classCallCheck$2(this, Spin2);
    _this = _super.call(this, props);
    _this.debouncifyUpdateSpinning = function(props2) {
      var _ref = props2 || _this.props, delay2 = _ref.delay;
      if (delay2) {
        _this.cancelExistingSpin();
        _this.updateSpinning = debounce_1(_this.originalUpdateSpinning, delay2);
      }
    };
    _this.updateSpinning = function() {
      var spinning2 = _this.props.spinning;
      var currentSpinning = _this.state.spinning;
      if (currentSpinning !== spinning2) {
        _this.setState({
          spinning: spinning2
        });
      }
    };
    _this.renderSpin = function(_ref2) {
      var _classNames;
      var direction = _ref2.direction;
      var _a = _this.props, prefixCls = _a.spinPrefixCls, className = _a.className, size = _a.size, tip = _a.tip, wrapperClassName = _a.wrapperClassName, style2 = _a.style, restProps = __rest$b(_a, ["spinPrefixCls", "className", "size", "tip", "wrapperClassName", "style"]);
      var spinning2 = _this.state.spinning;
      var spinClassName = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-sm"), size === "small"), _defineProperty$5(_classNames, "".concat(prefixCls, "-lg"), size === "large"), _defineProperty$5(_classNames, "".concat(prefixCls, "-spinning"), spinning2), _defineProperty$5(_classNames, "".concat(prefixCls, "-show-text"), !!tip), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
      var divProps = omit(restProps, ["spinning", "delay", "indicator", "prefixCls"]);
      var spinElement = /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, divProps, {
        style: style2,
        className: spinClassName,
        "aria-live": "polite",
        "aria-busy": spinning2
      }), renderIndicator(prefixCls, _this.props), tip ? /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(prefixCls, "-text")
      }, tip) : null);
      if (_this.isNestedPattern()) {
        var containerClassName = classnamesExports("".concat(prefixCls, "-container"), _defineProperty$5({}, "".concat(prefixCls, "-blur"), spinning2));
        return /* @__PURE__ */ react.exports.createElement("div", _extends$2({}, divProps, {
          className: classnamesExports("".concat(prefixCls, "-nested-loading"), wrapperClassName)
        }), spinning2 && /* @__PURE__ */ react.exports.createElement("div", {
          key: "loading"
        }, spinElement), /* @__PURE__ */ react.exports.createElement("div", {
          className: containerClassName,
          key: "container"
        }, _this.props.children));
      }
      return spinElement;
    };
    var spinning = props.spinning, delay = props.delay;
    var shouldBeDelayed = shouldDelay(spinning, delay);
    _this.state = {
      spinning: spinning && !shouldBeDelayed
    };
    _this.originalUpdateSpinning = _this.updateSpinning;
    _this.debouncifyUpdateSpinning(props);
    return _this;
  }
  _createClass$2(Spin2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateSpinning();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.debouncifyUpdateSpinning();
      this.updateSpinning();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelExistingSpin();
    }
  }, {
    key: "cancelExistingSpin",
    value: function cancelExistingSpin() {
      var updateSpinning = this.updateSpinning;
      if (updateSpinning && updateSpinning.cancel) {
        updateSpinning.cancel();
      }
    }
  }, {
    key: "isNestedPattern",
    value: function isNestedPattern() {
      return !!(this.props && typeof this.props.children !== "undefined");
    }
  }, {
    key: "render",
    value: function render2() {
      return /* @__PURE__ */ react.exports.createElement(ConfigConsumer, null, this.renderSpin);
    }
  }]);
  return Spin2;
}(react.exports.Component);
Spin.defaultProps = {
  spinning: true,
  size: "default",
  wrapperClassName: ""
};
var SpinFC = function SpinFC2(props) {
  var customizePrefixCls = props.prefixCls;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls;
  var spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
  var spinClassProps = _extends$2(_extends$2({}, props), {
    spinPrefixCls
  });
  return /* @__PURE__ */ react.exports.createElement(Spin, _extends$2({}, spinClassProps));
};
SpinFC.setDefaultIndicator = function(indicator) {
  defaultIndicator = indicator;
};
const Spin$1 = SpinFC;
var __rest$a = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Meta = function Meta2(_a) {
  var customizePrefixCls = _a.prefixCls, className = _a.className, avatar = _a.avatar, title = _a.title, description = _a.description, others = __rest$a(_a, ["prefixCls", "className", "avatar", "title", "description"]);
  var _useContext = react.exports.useContext(ConfigContext), getPrefixCls = _useContext.getPrefixCls;
  var prefixCls = getPrefixCls("list", customizePrefixCls);
  var classString = classnamesExports("".concat(prefixCls, "-item-meta"), className);
  var content2 = /* @__PURE__ */ React$a.createElement("div", {
    className: "".concat(prefixCls, "-item-meta-content")
  }, title && /* @__PURE__ */ React$a.createElement("h4", {
    className: "".concat(prefixCls, "-item-meta-title")
  }, title), description && /* @__PURE__ */ React$a.createElement("div", {
    className: "".concat(prefixCls, "-item-meta-description")
  }, description));
  return /* @__PURE__ */ React$a.createElement("div", _extends$2({}, others, {
    className: classString
  }), avatar && /* @__PURE__ */ React$a.createElement("div", {
    className: "".concat(prefixCls, "-item-meta-avatar")
  }, avatar), (title || description) && content2);
};
var InternalItem = function InternalItem2(_a, ref) {
  var customizePrefixCls = _a.prefixCls, children = _a.children, actions = _a.actions, extra = _a.extra, className = _a.className, colStyle = _a.colStyle, others = __rest$a(_a, ["prefixCls", "children", "actions", "extra", "className", "colStyle"]);
  var _useContext2 = react.exports.useContext(ListContext), grid = _useContext2.grid, itemLayout = _useContext2.itemLayout;
  var _useContext3 = react.exports.useContext(ConfigContext), getPrefixCls = _useContext3.getPrefixCls;
  var isItemContainsTextNodeAndNotSingular = function isItemContainsTextNodeAndNotSingular2() {
    var result;
    react.exports.Children.forEach(children, function(element) {
      if (typeof element === "string") {
        result = true;
      }
    });
    return result && react.exports.Children.count(children) > 1;
  };
  var isFlexMode = function isFlexMode2() {
    if (itemLayout === "vertical") {
      return !!extra;
    }
    return !isItemContainsTextNodeAndNotSingular();
  };
  var prefixCls = getPrefixCls("list", customizePrefixCls);
  var actionsContent = actions && actions.length > 0 && /* @__PURE__ */ React$a.createElement("ul", {
    className: "".concat(prefixCls, "-item-action"),
    key: "actions"
  }, actions.map(function(action, i) {
    return /* @__PURE__ */ React$a.createElement("li", {
      key: "".concat(prefixCls, "-item-action-").concat(i)
    }, action, i !== actions.length - 1 && /* @__PURE__ */ React$a.createElement("em", {
      className: "".concat(prefixCls, "-item-action-split")
    }));
  }));
  var Element2 = grid ? "div" : "li";
  var itemChildren = /* @__PURE__ */ React$a.createElement(Element2, _extends$2({}, others, !grid ? {
    ref
  } : {}, {
    className: classnamesExports("".concat(prefixCls, "-item"), _defineProperty$5({}, "".concat(prefixCls, "-item-no-flex"), !isFlexMode()), className)
  }), itemLayout === "vertical" && extra ? [/* @__PURE__ */ React$a.createElement("div", {
    className: "".concat(prefixCls, "-item-main"),
    key: "content"
  }, children, actionsContent), /* @__PURE__ */ React$a.createElement("div", {
    className: "".concat(prefixCls, "-item-extra"),
    key: "extra"
  }, extra)] : [children, actionsContent, cloneElement(extra, {
    key: "extra"
  })]);
  return grid ? /* @__PURE__ */ React$a.createElement(Col$1, {
    ref,
    flex: 1,
    style: colStyle
  }, itemChildren) : itemChildren;
};
var Item = /* @__PURE__ */ react.exports.forwardRef(InternalItem);
Item.Meta = Meta;
const Item$1 = Item;
var __rest$9 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var ListContext = /* @__PURE__ */ react.exports.createContext({});
ListContext.Consumer;
function List2(_a) {
  var _classNames;
  var _a$pagination = _a.pagination, pagination = _a$pagination === void 0 ? false : _a$pagination, customizePrefixCls = _a.prefixCls, _a$bordered = _a.bordered, bordered = _a$bordered === void 0 ? false : _a$bordered, _a$split = _a.split, split = _a$split === void 0 ? true : _a$split, className = _a.className, children = _a.children, itemLayout = _a.itemLayout, loadMore = _a.loadMore, grid = _a.grid, _a$dataSource = _a.dataSource, dataSource = _a$dataSource === void 0 ? [] : _a$dataSource, size = _a.size, header = _a.header, footer = _a.footer, _a$loading = _a.loading, loading = _a$loading === void 0 ? false : _a$loading, rowKey = _a.rowKey, renderItem = _a.renderItem, locale2 = _a.locale, rest = __rest$9(_a, ["pagination", "prefixCls", "bordered", "split", "className", "children", "itemLayout", "loadMore", "grid", "dataSource", "size", "header", "footer", "loading", "rowKey", "renderItem", "locale"]);
  var paginationObj = pagination && _typeof$4(pagination) === "object" ? pagination : {};
  var _React$useState = react.exports.useState(paginationObj.defaultCurrent || 1), _React$useState2 = _slicedToArray$3(_React$useState, 2), paginationCurrent = _React$useState2[0], setPaginationCurrent = _React$useState2[1];
  var _React$useState3 = react.exports.useState(paginationObj.defaultPageSize || 10), _React$useState4 = _slicedToArray$3(_React$useState3, 2), paginationSize = _React$useState4[0], setPaginationSize = _React$useState4[1];
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, renderEmpty = _React$useContext.renderEmpty, direction = _React$useContext.direction;
  var defaultPaginationProps = {
    current: 1,
    total: 0
  };
  var listItemsKeys = {};
  var triggerPaginationEvent = function triggerPaginationEvent2(eventName) {
    return function(page, pageSize) {
      setPaginationCurrent(page);
      setPaginationSize(pageSize);
      if (pagination && pagination[eventName]) {
        pagination[eventName](page, pageSize);
      }
    };
  };
  var onPaginationChange = triggerPaginationEvent("onChange");
  var onPaginationShowSizeChange = triggerPaginationEvent("onShowSizeChange");
  var renderInnerItem = function renderInnerItem2(item, index2) {
    if (!renderItem)
      return null;
    var key2;
    if (typeof rowKey === "function") {
      key2 = rowKey(item);
    } else if (rowKey) {
      key2 = item[rowKey];
    } else {
      key2 = item.key;
    }
    if (!key2) {
      key2 = "list-item-".concat(index2);
    }
    listItemsKeys[index2] = key2;
    return renderItem(item, index2);
  };
  var isSomethingAfterLastItem = function isSomethingAfterLastItem2() {
    return !!(loadMore || pagination || footer);
  };
  var renderEmptyFunc = function renderEmptyFunc2(prefixCls2, renderEmptyHandler) {
    return /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls2, "-empty-text")
    }, locale2 && locale2.emptyText || renderEmptyHandler("List"));
  };
  var prefixCls = getPrefixCls("list", customizePrefixCls);
  var loadingProp = loading;
  if (typeof loadingProp === "boolean") {
    loadingProp = {
      spinning: loadingProp
    };
  }
  var isLoading = loadingProp && loadingProp.spinning;
  var sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  var classString = classnamesExports(prefixCls, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-vertical"), itemLayout === "vertical"), _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(sizeCls), sizeCls), _defineProperty$5(_classNames, "".concat(prefixCls, "-split"), split), _defineProperty$5(_classNames, "".concat(prefixCls, "-bordered"), bordered), _defineProperty$5(_classNames, "".concat(prefixCls, "-loading"), isLoading), _defineProperty$5(_classNames, "".concat(prefixCls, "-grid"), !!grid), _defineProperty$5(_classNames, "".concat(prefixCls, "-something-after-last-item"), isSomethingAfterLastItem()), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
  var paginationProps = _extends$2(_extends$2(_extends$2({}, defaultPaginationProps), {
    total: dataSource.length,
    current: paginationCurrent,
    pageSize: paginationSize
  }), pagination || {});
  var largestPage = Math.ceil(paginationProps.total / paginationProps.pageSize);
  if (paginationProps.current > largestPage) {
    paginationProps.current = largestPage;
  }
  var paginationContent = pagination ? /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-pagination")
  }, /* @__PURE__ */ react.exports.createElement(Pagination$1, _extends$2({}, paginationProps, {
    onChange: onPaginationChange,
    onShowSizeChange: onPaginationShowSizeChange
  }))) : null;
  var splitDataSource = _toConsumableArray(dataSource);
  if (pagination) {
    if (dataSource.length > (paginationProps.current - 1) * paginationProps.pageSize) {
      splitDataSource = _toConsumableArray(dataSource).splice((paginationProps.current - 1) * paginationProps.pageSize, paginationProps.pageSize);
    }
  }
  var needResponsive = Object.keys(grid || {}).some(function(key2) {
    return ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key2);
  });
  var screens2 = useBreakpoint(needResponsive);
  var currentBreakpoint = react.exports.useMemo(function() {
    for (var i = 0; i < responsiveArray.length; i += 1) {
      var breakpoint = responsiveArray[i];
      if (screens2[breakpoint]) {
        return breakpoint;
      }
    }
    return void 0;
  }, [screens2]);
  var colStyle = react.exports.useMemo(function() {
    if (!grid) {
      return void 0;
    }
    var columnCount = currentBreakpoint && grid[currentBreakpoint] ? grid[currentBreakpoint] : grid.column;
    if (columnCount) {
      return {
        width: "".concat(100 / columnCount, "%"),
        maxWidth: "".concat(100 / columnCount, "%")
      };
    }
  }, [grid === null || grid === void 0 ? void 0 : grid.column, currentBreakpoint]);
  var childrenContent = isLoading && /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      minHeight: 53
    }
  });
  if (splitDataSource.length > 0) {
    var items = splitDataSource.map(function(item, index2) {
      return renderInnerItem(item, index2);
    });
    var childrenList = react.exports.Children.map(items, function(child, index2) {
      return /* @__PURE__ */ react.exports.createElement("div", {
        key: listItemsKeys[index2],
        style: colStyle
      }, child);
    });
    childrenContent = grid ? /* @__PURE__ */ react.exports.createElement(Row$1, {
      gutter: grid.gutter
    }, childrenList) : /* @__PURE__ */ react.exports.createElement("ul", {
      className: "".concat(prefixCls, "-items")
    }, items);
  } else if (!children && !isLoading) {
    childrenContent = renderEmptyFunc(prefixCls, renderEmpty || defaultRenderEmpty$1);
  }
  var paginationPosition = paginationProps.position || "bottom";
  var contextValue = react.exports.useMemo(function() {
    return {
      grid,
      itemLayout
    };
  }, [JSON.stringify(grid), itemLayout]);
  return /* @__PURE__ */ react.exports.createElement(ListContext.Provider, {
    value: contextValue
  }, /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classString
  }, rest), (paginationPosition === "top" || paginationPosition === "both") && paginationContent, header && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-header")
  }, header), /* @__PURE__ */ react.exports.createElement(Spin$1, _extends$2({}, loadingProp), childrenContent, children), footer && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-footer")
  }, footer), loadMore || (paginationPosition === "bottom" || paginationPosition === "both") && paginationContent));
}
List2.Item = Item$1;
var __rest$8 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
var TransButton = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var onKeyDown2 = function onKeyDown3(event) {
    var keyCode = event.keyCode;
    if (keyCode === KeyCode.ENTER) {
      event.preventDefault();
    }
  };
  var onKeyUp2 = function onKeyUp3(event) {
    var keyCode = event.keyCode;
    var onClick = props.onClick;
    if (keyCode === KeyCode.ENTER && onClick) {
      onClick();
    }
  };
  var style2 = props.style, noStyle = props.noStyle, disabled = props.disabled, restProps = __rest$8(props, ["style", "noStyle", "disabled"]);
  var mergedStyle = {};
  if (!noStyle) {
    mergedStyle = _extends$2({}, inlineStyle);
  }
  if (disabled) {
    mergedStyle.pointerEvents = "none";
  }
  mergedStyle = _extends$2(_extends$2({}, mergedStyle), style2);
  return /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    role: "button",
    tabIndex: 0,
    ref
  }, restProps, {
    onKeyDown: onKeyDown2,
    onKeyUp: onKeyUp2,
    style: mergedStyle
  }));
});
const TransButton$1 = TransButton;
var WarningFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "warning", "theme": "filled" };
const WarningFilledSvg = WarningFilled$2;
var WarningFilled = function WarningFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: WarningFilledSvg
  }));
};
WarningFilled.displayName = "WarningFilled";
const WarningFilled$1 = /* @__PURE__ */ react.exports.forwardRef(WarningFilled);
var NoFound = function NoFound2() {
  return /* @__PURE__ */ react.exports.createElement("svg", {
    width: "252",
    height: "294"
  }, /* @__PURE__ */ react.exports.createElement("defs", null, /* @__PURE__ */ react.exports.createElement("path", {
    d: "M0 .387h251.772v251.772H0z"
  })), /* @__PURE__ */ react.exports.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    transform: "translate(0 .012)"
  }, /* @__PURE__ */ react.exports.createElement("mask", {
    fill: "#fff"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
    fill: "#E4EBF7",
    mask: "url(#b)"
  })), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    stroke: "#FFF",
    strokeWidth: "2",
    d: "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
    fill: "#1890FF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
    fill: "#FFB594"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
    fill: "#CBD1D1"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
    fill: "#2B0849"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
    fill: "#A4AABA"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
    fill: "#CBD1D1"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
    fill: "#2B0849"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
    fill: "#A4AABA"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
    fill: "#7BB2F9"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M107.275 222.1s2.773-1.11 6.102-3.884",
    stroke: "#648BD8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
    fill: "#192064"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
    fill: "#192064"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
    fill: "#520038"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
    fill: "#552950"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    stroke: "#DB836E",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M110.846 74.481s1.79-.716 2.506.537",
    stroke: "#5C2552",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
    stroke: "#DB836E",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M103.287 72.93s1.83 1.113 4.137.954",
    stroke: "#5C2552",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
    stroke: "#DB836E",
    strokeWidth: "1.118",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
    stroke: "#E4EBF7",
    strokeWidth: "1.101",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M129.405 122.865s-5.272 7.403-9.422 10.768",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M119.306 107.329s.452 4.366-2.127 32.062",
    stroke: "#E4EBF7",
    strokeWidth: "1.101",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
    fill: "#F2D7AD"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
    fill: "#F4D19D"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
    fill: "#F2D7AD"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    fill: "#CC9B6E",
    d: "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
    fill: "#F4D19D"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    fill: "#CC9B6E",
    d: "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    fill: "#CC9B6E",
    d: "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
    stroke: "#DB836E",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
    stroke: "#DB836E",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
    stroke: "#DB836E",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
    fill: "#5BA02E"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
    fill: "#92C110"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
    fill: "#F2D7AD"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M88.979 89.48s7.776 5.384 16.6 2.842",
    stroke: "#E4EBF7",
    strokeWidth: "1.101",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
};
const noFound = NoFound;
var ServerError = function ServerError2() {
  return /* @__PURE__ */ react.exports.createElement("svg", {
    width: "254",
    height: "294"
  }, /* @__PURE__ */ react.exports.createElement("defs", null, /* @__PURE__ */ react.exports.createElement("path", {
    d: "M0 .335h253.49v253.49H0z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M0 293.665h253.49V.401H0z"
  })), /* @__PURE__ */ react.exports.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    transform: "translate(0 .067)"
  }, /* @__PURE__ */ react.exports.createElement("mask", {
    fill: "#fff"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
    fill: "#E4EBF7",
    mask: "url(#b)"
  })), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
    fill: "#FF603B"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
    fill: "#FFB594"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
    fill: "#FFB594"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
    fill: "#520038"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
    fill: "#552950"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    stroke: "#DB836E",
    strokeWidth: "1.063",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M99.926 73.284s1.8-.72 2.52.54",
    stroke: "#5C2552",
    strokeWidth: "1.117",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
    stroke: "#DB836E",
    strokeWidth: "1.117",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M92.326 71.724s1.84 1.12 4.16.96",
    stroke: "#5C2552",
    strokeWidth: "1.117",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
    stroke: "#DB836E",
    strokeWidth: "1.063",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
    stroke: "#E4EBF7",
    strokeWidth: "1.136",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
    stroke: "#E4EBF7",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
    fill: "#CBD1D1"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
    fill: "#2B0849"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
    fill: "#A4AABA"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
    fill: "#CBD1D1"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
    fill: "#2B0849"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
    fill: "#A4AABA"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
    fill: "#7BB2F9"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
    stroke: "#648BD8",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M96.973 219.373s2.882-1.153 6.34-4.034",
    stroke: "#648BD8",
    strokeWidth: "1.032",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
    stroke: "#648BD8",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
    fill: "#192064"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
    fill: "#192064"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
    stroke: "#648BD8",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
    stroke: "#E4EBF7",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
    stroke: "#DB836E",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
    stroke: "#E59788",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
    stroke: "#E59788",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M109.278 112.533s3.38-3.613 7.575-4.662",
    stroke: "#E4EBF7",
    strokeWidth: "1.085",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M107.375 123.006s9.697-2.745 11.445-.88",
    stroke: "#E59788",
    strokeWidth: ".774",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
    stroke: "#BFCDDD",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
    fill: "#A3B4C6"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
    fill: "#A3B4C6"
  }), /* @__PURE__ */ react.exports.createElement("mask", {
    fill: "#fff"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    fill: "#A3B4C6",
    mask: "url(#d)",
    d: "M154.098 190.096h70.513v-84.617h-70.513z"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
    fill: "#BFCDDD",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
    fill: "#FFF",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
    fill: "#BFCDDD",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
    stroke: "#7C90A5",
    strokeWidth: "1.124",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
    fill: "#FFF",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
    fill: "#BFCDDD",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M177.259 207.217v11.52M201.05 207.217v11.52",
    stroke: "#A3B4C6",
    strokeWidth: "1.124",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
    fill: "#5BA02E",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
    fill: "#92C110",
    mask: "url(#d)"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
    fill: "#F2D7AD",
    mask: "url(#d)"
  })));
};
const serverError = ServerError;
var Unauthorized = function Unauthorized2() {
  return /* @__PURE__ */ react.exports.createElement("svg", {
    width: "251",
    height: "294"
  }, /* @__PURE__ */ react.exports.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ react.exports.createElement("path", {
    d: "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
    fill: "#E4EBF7"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
    stroke: "#FFF",
    strokeWidth: "2"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    stroke: "#FFF",
    strokeWidth: "2",
    d: "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
    fill: "#A26EF4"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
    fill: "#5BA02E"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
    fill: "#92C110"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
    fill: "#F2D7AD"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
    fill: "#FFB594"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M78.18 94.656s.911 7.41-4.914 13.078",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
    stroke: "#E4EBF7",
    strokeWidth: ".932",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
    fill: "#FFB594"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
    fill: "#5C2552"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    stroke: "#DB836E",
    strokeWidth: "1.145",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
    fill: "#552950"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M91.132 86.786s5.269 4.957 12.679 2.327",
    stroke: "#DB836E",
    strokeWidth: "1.145",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
    fill: "#DB836E"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
    stroke: "#5C2552",
    strokeWidth: "1.526",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
    stroke: "#DB836E",
    strokeWidth: "1.145",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M66.508 86.763s-1.598 8.83-6.697 14.078",
    stroke: "#E4EBF7",
    strokeWidth: "1.114",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M128.31 87.934s3.013 4.121 4.06 11.785",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M64.09 84.816s-6.03 9.912-13.607 9.903",
    stroke: "#DB836E",
    strokeWidth: ".795",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
    fill: "#FFC6A0"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M130.532 85.488s4.588 5.757 11.619 6.214",
    stroke: "#DB836E",
    strokeWidth: ".75",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M121.708 105.73s-.393 8.564-1.34 13.612",
    stroke: "#E4EBF7",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M115.784 161.512s-3.57-1.488-2.678-7.14",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
    fill: "#CBD1D1"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
    fill: "#2B0849"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
    fill: "#A4AABA"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
    fill: "#CBD1D1"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
    fill: "#2B0849"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
    fill: "#A4AABA"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
    fill: "#7BB2F9"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M108.459 220.905s2.759-1.104 6.07-3.863",
    stroke: "#648BD8",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
    fill: "#192064"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
    fill: "#FFF"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
    fill: "#192064"
  }), /* @__PURE__ */ react.exports.createElement("path", {
    d: "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
    stroke: "#648BD8",
    strokeWidth: "1.051",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })));
};
const unauthorized = Unauthorized;
var IconMap = {
  success: CheckCircleFilled$1,
  error: CloseCircleFilled$1,
  info: ExclamationCircleFilled$1,
  warning: WarningFilled$1
};
var ExceptionMap = {
  "404": noFound,
  "500": serverError,
  "403": unauthorized
};
var ExceptionStatus = Object.keys(ExceptionMap);
var Icon = function Icon2(_ref) {
  var prefixCls = _ref.prefixCls, icon = _ref.icon, status = _ref.status;
  var className = classnamesExports("".concat(prefixCls, "-icon"));
  if (ExceptionStatus.includes("".concat(status))) {
    var SVGComponent = ExceptionMap[status];
    return /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(className, " ").concat(prefixCls, "-image")
    }, /* @__PURE__ */ react.exports.createElement(SVGComponent, null));
  }
  var iconNode = /* @__PURE__ */ react.exports.createElement(IconMap[status]);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className
  }, icon || iconNode);
};
var Extra = function Extra2(_ref2) {
  var prefixCls = _ref2.prefixCls, extra = _ref2.extra;
  if (!extra) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-extra")
  }, extra);
};
var Result = function Result2(_ref3) {
  var customizePrefixCls = _ref3.prefixCls, customizeClassName = _ref3.className, subTitle = _ref3.subTitle, title = _ref3.title, style2 = _ref3.style, children = _ref3.children, _ref3$status = _ref3.status, status = _ref3$status === void 0 ? "info" : _ref3$status, icon = _ref3.icon, extra = _ref3.extra;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var prefixCls = getPrefixCls("result", customizePrefixCls);
  var className = classnamesExports(prefixCls, "".concat(prefixCls, "-").concat(status), customizeClassName, _defineProperty$5({}, "".concat(prefixCls, "-rtl"), direction === "rtl"));
  return /* @__PURE__ */ react.exports.createElement("div", {
    className,
    style: style2
  }, /* @__PURE__ */ react.exports.createElement(Icon, {
    prefixCls,
    status,
    icon
  }), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-title")
  }, title), subTitle && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-subtitle")
  }, subTitle), /* @__PURE__ */ react.exports.createElement(Extra, {
    prefixCls,
    extra
  }), children && /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-content")
  }, children));
};
Result.PRESENTED_IMAGE_403 = ExceptionMap["403"];
Result.PRESENTED_IMAGE_404 = ExceptionMap["404"];
Result.PRESENTED_IMAGE_500 = ExceptionMap["500"];
const Result$1 = Result;
var Switch$2 = react.exports.forwardRef(function(_ref, ref) {
  var _classNames;
  var _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-switch" : _ref$prefixCls, className = _ref.className, checked = _ref.checked, defaultChecked = _ref.defaultChecked, disabled = _ref.disabled, loadingIcon = _ref.loadingIcon, checkedChildren = _ref.checkedChildren, unCheckedChildren = _ref.unCheckedChildren, onClick = _ref.onClick, onChange2 = _ref.onChange, onKeyDown2 = _ref.onKeyDown, restProps = _objectWithoutProperties$1(_ref, ["prefixCls", "className", "checked", "defaultChecked", "disabled", "loadingIcon", "checkedChildren", "unCheckedChildren", "onClick", "onChange", "onKeyDown"]);
  var _useMergedState = useMergedState(false, {
    value: checked,
    defaultValue: defaultChecked
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), innerChecked = _useMergedState2[0], setInnerChecked = _useMergedState2[1];
  function triggerChange(newChecked, event) {
    var mergedChecked = innerChecked;
    if (!disabled) {
      mergedChecked = newChecked;
      setInnerChecked(mergedChecked);
      onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(mergedChecked, event);
    }
    return mergedChecked;
  }
  function onInternalKeyDown(e2) {
    if (e2.which === KeyCode.LEFT) {
      triggerChange(false, e2);
    } else if (e2.which === KeyCode.RIGHT) {
      triggerChange(true, e2);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
  }
  function onInternalClick(e2) {
    var ret = triggerChange(!innerChecked, e2);
    onClick === null || onClick === void 0 ? void 0 : onClick(ret, e2);
  }
  var switchClassName = classnamesExports(prefixCls, className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-checked"), innerChecked), _defineProperty$5(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
  return react.exports.createElement("button", Object.assign({}, restProps, {
    type: "button",
    role: "switch",
    "aria-checked": innerChecked,
    disabled,
    className: switchClassName,
    ref,
    onKeyDown: onInternalKeyDown,
    onClick: onInternalClick
  }), loadingIcon, react.exports.createElement("span", {
    className: "".concat(prefixCls, "-inner")
  }, innerChecked ? checkedChildren : unCheckedChildren));
});
Switch$2.displayName = "Switch";
var __rest$7 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Switch = /* @__PURE__ */ react.exports.forwardRef(function(_a, ref) {
  var _classNames;
  var customizePrefixCls = _a.prefixCls, customizeSize = _a.size, customDisabled = _a.disabled, loading = _a.loading, _a$className = _a.className, className = _a$className === void 0 ? "" : _a$className, props = __rest$7(_a, ["prefixCls", "size", "disabled", "loading", "className"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var size = react.exports.useContext(SizeContext$1);
  var disabled = react.exports.useContext(DisabledContext$1);
  var mergedDisabled = customDisabled || disabled || loading;
  var prefixCls = getPrefixCls("switch", customizePrefixCls);
  var loadingIcon = /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-handle")
  }, loading && /* @__PURE__ */ react.exports.createElement(LoadingOutlined$1, {
    className: "".concat(prefixCls, "-loading-icon")
  }));
  var classes = classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-small"), (customizeSize || size) === "small"), _defineProperty$5(_classNames, "".concat(prefixCls, "-loading"), loading), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className);
  return /* @__PURE__ */ react.exports.createElement(Wave$1, {
    insertExtraNode: true
  }, /* @__PURE__ */ react.exports.createElement(Switch$2, _extends$2({}, props, {
    prefixCls,
    className: classes,
    disabled: mergedDisabled,
    ref,
    loadingIcon
  })));
});
Switch.__ANT_SWITCH = true;
const Switch$1 = Switch;
function ColumnGroup$1(_) {
  return null;
}
function Column$1(_) {
  return null;
}
var INTERNAL_KEY_PREFIX = "RC_TABLE_KEY";
function toArray(arr) {
  if (arr === void 0 || arr === null) {
    return [];
  }
  return Array.isArray(arr) ? arr : [arr];
}
function getPathValue(record, path) {
  if (!path && typeof path !== "number") {
    return record;
  }
  var pathList = toArray(path);
  var current = record;
  for (var i = 0; i < pathList.length; i += 1) {
    if (!current) {
      return null;
    }
    var prop = pathList[i];
    current = current[prop];
  }
  return current;
}
function getColumnsKey(columns) {
  var columnKeys = [];
  var keys2 = {};
  columns.forEach(function(column) {
    var _ref = column || {}, key2 = _ref.key, dataIndex = _ref.dataIndex;
    var mergedKey = key2 || toArray(dataIndex).join("-") || INTERNAL_KEY_PREFIX;
    while (keys2[mergedKey]) {
      mergedKey = "".concat(mergedKey, "_next");
    }
    keys2[mergedKey] = true;
    columnKeys.push(mergedKey);
  });
  return columnKeys;
}
function validateValue(val) {
  return val !== null && val !== void 0;
}
var StickyContext = /* @__PURE__ */ react.exports.createContext(false);
function createContext() {
  var Context2 = /* @__PURE__ */ react.exports.createContext(null);
  var Provider = function Provider2(_ref) {
    var value2 = _ref.value, children = _ref.children;
    var valueRef = react.exports.useRef(value2);
    valueRef.current = value2;
    var _React$useState = react.exports.useState(function() {
      return {
        getValue: function getValue2() {
          return valueRef.current;
        },
        listeners: /* @__PURE__ */ new Set()
      };
    }), _React$useState2 = _slicedToArray$3(_React$useState, 1), context2 = _React$useState2[0];
    useLayoutEffect$1(function() {
      context2.listeners.forEach(function(listener) {
        listener(value2);
      });
    }, [value2]);
    return /* @__PURE__ */ react.exports.createElement(Context2.Provider, {
      value: context2
    }, children);
  };
  return {
    Context: Context2,
    Provider
  };
}
function useContextSelector(holder, selector) {
  var eventSelector = useEvent(selector);
  var context2 = react.exports.useContext(holder === null || holder === void 0 ? void 0 : holder.Context);
  var _ref2 = context2 || {}, listeners2 = _ref2.listeners, getValue2 = _ref2.getValue;
  var _React$useState3 = react.exports.useState(function() {
    return eventSelector(context2 ? getValue2() : null);
  }), _React$useState4 = _slicedToArray$3(_React$useState3, 2), value2 = _React$useState4[0], setValue2 = _React$useState4[1];
  useLayoutEffect$1(function() {
    if (!context2) {
      return;
    }
    function trigger3(nextValue) {
      setValue2(function(prev) {
        var selectedValue = eventSelector(nextValue);
        return shallowequal(prev, selectedValue) ? prev : selectedValue;
      });
    }
    listeners2.add(trigger3);
    return function() {
      listeners2.delete(trigger3);
    };
  }, [context2]);
  return value2;
}
var HoverContext = createContext();
var BodyContext = /* @__PURE__ */ react.exports.createContext(null);
var PerfContext = /* @__PURE__ */ react.exports.createContext({
  renderWithProps: false
});
var _excluded$7 = ["colSpan", "rowSpan", "style", "className"];
function inHoverRange(cellStartRow, cellRowSpan, startRow, endRow) {
  var cellEndRow = cellStartRow + cellRowSpan - 1;
  return cellStartRow <= endRow && cellEndRow >= startRow;
}
function isRenderCell(data2) {
  return data2 && _typeof$4(data2) === "object" && !Array.isArray(data2) && !/* @__PURE__ */ react.exports.isValidElement(data2);
}
function isRefComponent(component) {
  if (typeof component === "string") {
    return true;
  }
  return supportRef(component);
}
var getTitleFromCellRenderChildren = function getTitleFromCellRenderChildren2(_ref) {
  var ellipsis = _ref.ellipsis, rowType = _ref.rowType, children = _ref.children;
  var title;
  var ellipsisConfig = ellipsis === true ? {
    showTitle: true
  } : ellipsis;
  if (ellipsisConfig && (ellipsisConfig.showTitle || rowType === "header")) {
    if (typeof children === "string" || typeof children === "number") {
      title = children.toString();
    } else if (/* @__PURE__ */ react.exports.isValidElement(children) && typeof children.props.children === "string") {
      title = children.props.children;
    }
  }
  return title;
};
function Cell(_ref2, ref) {
  var _ref4, _ref5, _classNames;
  var prefixCls = _ref2.prefixCls, className = _ref2.className, record = _ref2.record, index2 = _ref2.index, renderIndex = _ref2.renderIndex, dataIndex = _ref2.dataIndex, render2 = _ref2.render, children = _ref2.children, _ref2$component = _ref2.component, Component2 = _ref2$component === void 0 ? "td" : _ref2$component, colSpan = _ref2.colSpan, rowSpan = _ref2.rowSpan, fixLeft = _ref2.fixLeft, fixRight = _ref2.fixRight, firstFixLeft = _ref2.firstFixLeft, lastFixLeft = _ref2.lastFixLeft, firstFixRight = _ref2.firstFixRight, lastFixRight = _ref2.lastFixRight, appendNode = _ref2.appendNode, _ref2$additionalProps = _ref2.additionalProps, additionalProps = _ref2$additionalProps === void 0 ? {} : _ref2$additionalProps, ellipsis = _ref2.ellipsis, align = _ref2.align, rowType = _ref2.rowType, isSticky = _ref2.isSticky, hovering = _ref2.hovering, onHover = _ref2.onHover;
  var cellPrefixCls = "".concat(prefixCls, "-cell");
  var perfRecord = react.exports.useContext(PerfContext);
  var supportSticky = react.exports.useContext(StickyContext);
  var _React$useContext = react.exports.useContext(BodyContext), allColumnsFixedLeft = _React$useContext.allColumnsFixedLeft;
  var _React$useMemo = react.exports.useMemo(function() {
    if (validateValue(children)) {
      return [children];
    }
    var value2 = getPathValue(record, dataIndex);
    var returnChildNode = value2;
    var returnCellProps = void 0;
    if (render2) {
      var renderData = render2(value2, record, renderIndex);
      if (isRenderCell(renderData)) {
        returnChildNode = renderData.children;
        returnCellProps = renderData.props;
        perfRecord.renderWithProps = true;
      } else {
        returnChildNode = renderData;
      }
    }
    return [returnChildNode, returnCellProps];
  }, [
    perfRecord.renderWithProps ? Math.random() : 0,
    children,
    dataIndex,
    perfRecord,
    record,
    render2,
    renderIndex
  ]), _React$useMemo2 = _slicedToArray$3(_React$useMemo, 2), childNode = _React$useMemo2[0], legacyCellProps = _React$useMemo2[1];
  var mergedChildNode = childNode;
  if (_typeof$4(mergedChildNode) === "object" && !Array.isArray(mergedChildNode) && !/* @__PURE__ */ react.exports.isValidElement(mergedChildNode)) {
    mergedChildNode = null;
  }
  if (ellipsis && (lastFixLeft || firstFixRight)) {
    mergedChildNode = /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(cellPrefixCls, "-content")
    }, mergedChildNode);
  }
  var _ref3 = legacyCellProps || {}, cellColSpan = _ref3.colSpan, cellRowSpan = _ref3.rowSpan, cellStyle = _ref3.style, cellClassName = _ref3.className, restCellProps = _objectWithoutProperties$1(_ref3, _excluded$7);
  var mergedColSpan = (_ref4 = cellColSpan !== void 0 ? cellColSpan : colSpan) !== null && _ref4 !== void 0 ? _ref4 : 1;
  var mergedRowSpan = (_ref5 = cellRowSpan !== void 0 ? cellRowSpan : rowSpan) !== null && _ref5 !== void 0 ? _ref5 : 1;
  if (mergedColSpan === 0 || mergedRowSpan === 0) {
    return null;
  }
  var fixedStyle = {};
  var isFixLeft = typeof fixLeft === "number" && supportSticky;
  var isFixRight = typeof fixRight === "number" && supportSticky;
  if (isFixLeft) {
    fixedStyle.position = "sticky";
    fixedStyle.left = fixLeft;
  }
  if (isFixRight) {
    fixedStyle.position = "sticky";
    fixedStyle.right = fixRight;
  }
  var alignStyle = {};
  if (align) {
    alignStyle.textAlign = align;
  }
  var onMouseEnter = function onMouseEnter2(event) {
    var _additionalProps$onMo;
    if (record) {
      onHover(index2, index2 + mergedRowSpan - 1);
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo = additionalProps.onMouseEnter) === null || _additionalProps$onMo === void 0 ? void 0 : _additionalProps$onMo.call(additionalProps, event);
  };
  var onMouseLeave = function onMouseLeave2(event) {
    var _additionalProps$onMo2;
    if (record) {
      onHover(-1, -1);
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onMo2 = additionalProps.onMouseLeave) === null || _additionalProps$onMo2 === void 0 ? void 0 : _additionalProps$onMo2.call(additionalProps, event);
  };
  var title = getTitleFromCellRenderChildren({
    rowType,
    ellipsis,
    children: childNode
  });
  var componentProps = _objectSpread2$4(_objectSpread2$4(_objectSpread2$4({
    title
  }, restCellProps), additionalProps), {}, {
    colSpan: mergedColSpan !== 1 ? mergedColSpan : null,
    rowSpan: mergedRowSpan !== 1 ? mergedRowSpan : null,
    className: classnamesExports(cellPrefixCls, className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-left"), isFixLeft && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-left-first"), firstFixLeft && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-left-last"), lastFixLeft && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-left-all"), lastFixLeft && allColumnsFixedLeft && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-right"), isFixRight && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-right-first"), firstFixRight && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-right-last"), lastFixRight && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-ellipsis"), ellipsis), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-with-append"), appendNode), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-fix-sticky"), (isFixLeft || isFixRight) && isSticky && supportSticky), _defineProperty$5(_classNames, "".concat(cellPrefixCls, "-row-hover"), !legacyCellProps && hovering), _classNames), additionalProps.className, cellClassName),
    style: _objectSpread2$4(_objectSpread2$4(_objectSpread2$4(_objectSpread2$4({}, additionalProps.style), alignStyle), fixedStyle), cellStyle),
    onMouseEnter,
    onMouseLeave,
    ref: isRefComponent(Component2) ? ref : null
  });
  return /* @__PURE__ */ react.exports.createElement(Component2, componentProps, appendNode, mergedChildNode);
}
var RefCell = /* @__PURE__ */ react.exports.forwardRef(Cell);
RefCell.displayName = "Cell";
var comparePropList = ["expanded", "className", "hovering"];
var MemoCell = /* @__PURE__ */ react.exports.memo(RefCell, function(prev, next) {
  if (next.shouldCellUpdate) {
    return comparePropList.every(function(propName) {
      return prev[propName] === next[propName];
    }) && !next.shouldCellUpdate(next.record, prev.record);
  }
  return shallowequal(prev, next);
});
var WrappedCell = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var index2 = props.index, _props$additionalProp = props.additionalProps, additionalProps = _props$additionalProp === void 0 ? {} : _props$additionalProp, colSpan = props.colSpan, rowSpan = props.rowSpan;
  var cellColSpan = additionalProps.colSpan, cellRowSpan = additionalProps.rowSpan;
  var mergedColSpan = colSpan !== null && colSpan !== void 0 ? colSpan : cellColSpan;
  var mergedRowSpan = rowSpan !== null && rowSpan !== void 0 ? rowSpan : cellRowSpan;
  var _useContextSelector = useContextSelector(HoverContext, function(cxt) {
    var isHovering = inHoverRange(index2, mergedRowSpan || 1, cxt === null || cxt === void 0 ? void 0 : cxt.startRow, cxt === null || cxt === void 0 ? void 0 : cxt.endRow);
    return {
      onHover: cxt === null || cxt === void 0 ? void 0 : cxt.onHover,
      hovering: isHovering
    };
  }), onHover = _useContextSelector.onHover, hovering = _useContextSelector.hovering;
  return /* @__PURE__ */ react.exports.createElement(MemoCell, _extends$2({}, props, {
    colSpan: mergedColSpan,
    rowSpan: mergedRowSpan,
    hovering,
    ref,
    onHover
  }));
});
WrappedCell.displayName = "WrappedCell";
var TableContext = /* @__PURE__ */ react.exports.createContext(null);
function getCellFixedInfo(colStart, colEnd, columns, stickyOffsets, direction) {
  var startColumn = columns[colStart] || {};
  var endColumn = columns[colEnd] || {};
  var fixLeft;
  var fixRight;
  if (startColumn.fixed === "left") {
    fixLeft = stickyOffsets.left[colStart];
  } else if (endColumn.fixed === "right") {
    fixRight = stickyOffsets.right[colEnd];
  }
  var lastFixLeft = false;
  var firstFixRight = false;
  var lastFixRight = false;
  var firstFixLeft = false;
  var nextColumn = columns[colEnd + 1];
  var prevColumn = columns[colStart - 1];
  if (direction === "rtl") {
    if (fixLeft !== void 0) {
      var prevFixLeft = prevColumn && prevColumn.fixed === "left";
      firstFixLeft = !prevFixLeft;
    } else if (fixRight !== void 0) {
      var nextFixRight = nextColumn && nextColumn.fixed === "right";
      lastFixRight = !nextFixRight;
    }
  } else if (fixLeft !== void 0) {
    var nextFixLeft = nextColumn && nextColumn.fixed === "left";
    lastFixLeft = !nextFixLeft;
  } else if (fixRight !== void 0) {
    var prevFixRight = prevColumn && prevColumn.fixed === "right";
    firstFixRight = !prevFixRight;
  }
  return {
    fixLeft,
    fixRight,
    lastFixLeft,
    firstFixRight,
    lastFixRight,
    firstFixLeft,
    isSticky: stickyOffsets.isSticky
  };
}
function HeaderRow(_ref) {
  var cells = _ref.cells, stickyOffsets = _ref.stickyOffsets, flattenColumns = _ref.flattenColumns, RowComponent = _ref.rowComponent, CellComponent = _ref.cellComponent, onHeaderRow = _ref.onHeaderRow, index2 = _ref.index;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, direction = _React$useContext.direction;
  var rowProps;
  if (onHeaderRow) {
    rowProps = onHeaderRow(cells.map(function(cell) {
      return cell.column;
    }), index2);
  }
  var columnsKey = getColumnsKey(cells.map(function(cell) {
    return cell.column;
  }));
  return /* @__PURE__ */ react.exports.createElement(RowComponent, rowProps, cells.map(function(cell, cellIndex) {
    var column = cell.column;
    var fixedInfo = getCellFixedInfo(cell.colStart, cell.colEnd, flattenColumns, stickyOffsets, direction);
    var additionalProps;
    if (column && column.onHeaderCell) {
      additionalProps = cell.column.onHeaderCell(column);
    }
    return /* @__PURE__ */ react.exports.createElement(WrappedCell, _extends$2({}, cell, {
      ellipsis: column.ellipsis,
      align: column.align,
      component: CellComponent,
      prefixCls,
      key: columnsKey[cellIndex]
    }, fixedInfo, {
      additionalProps,
      rowType: "header"
    }));
  }));
}
HeaderRow.displayName = "HeaderRow";
function parseHeaderRows(rootColumns) {
  var rows = [];
  function fillRowCells(columns, colIndex) {
    var rowIndex2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    rows[rowIndex2] = rows[rowIndex2] || [];
    var currentColIndex = colIndex;
    var colSpans = columns.filter(Boolean).map(function(column) {
      var cell = {
        key: column.key,
        className: column.className || "",
        children: column.title,
        column,
        colStart: currentColIndex
      };
      var colSpan = 1;
      var subColumns = column.children;
      if (subColumns && subColumns.length > 0) {
        colSpan = fillRowCells(subColumns, currentColIndex, rowIndex2 + 1).reduce(function(total, count) {
          return total + count;
        }, 0);
        cell.hasSubColumns = true;
      }
      if ("colSpan" in column) {
        colSpan = column.colSpan;
      }
      if ("rowSpan" in column) {
        cell.rowSpan = column.rowSpan;
      }
      cell.colSpan = colSpan;
      cell.colEnd = cell.colStart + colSpan - 1;
      rows[rowIndex2].push(cell);
      currentColIndex += colSpan;
      return colSpan;
    });
    return colSpans;
  }
  fillRowCells(rootColumns, 0);
  var rowCount = rows.length;
  var _loop = function _loop2(rowIndex2) {
    rows[rowIndex2].forEach(function(cell) {
      if (!("rowSpan" in cell) && !cell.hasSubColumns) {
        cell.rowSpan = rowCount - rowIndex2;
      }
    });
  };
  for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
    _loop(rowIndex);
  }
  return rows;
}
function Header(_ref) {
  var stickyOffsets = _ref.stickyOffsets, columns = _ref.columns, flattenColumns = _ref.flattenColumns, onHeaderRow = _ref.onHeaderRow;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, getComponent = _React$useContext.getComponent;
  var rows = react.exports.useMemo(function() {
    return parseHeaderRows(columns);
  }, [columns]);
  var WrapperComponent = getComponent(["header", "wrapper"], "thead");
  var trComponent = getComponent(["header", "row"], "tr");
  var thComponent = getComponent(["header", "cell"], "th");
  return /* @__PURE__ */ react.exports.createElement(WrapperComponent, {
    className: "".concat(prefixCls, "-thead")
  }, rows.map(function(row, rowIndex) {
    var rowNode = /* @__PURE__ */ react.exports.createElement(HeaderRow, {
      key: rowIndex,
      flattenColumns,
      cells: row,
      stickyOffsets,
      rowComponent: trComponent,
      cellComponent: thComponent,
      onHeaderRow,
      index: rowIndex
    });
    return rowNode;
  }));
}
var ExpandedRowContext = /* @__PURE__ */ react.exports.createContext(null);
function ExpandedRow(_ref) {
  var prefixCls = _ref.prefixCls, children = _ref.children, Component2 = _ref.component, cellComponent = _ref.cellComponent, className = _ref.className, expanded = _ref.expanded, colSpan = _ref.colSpan, isEmpty = _ref.isEmpty;
  var _React$useContext = react.exports.useContext(TableContext), scrollbarSize = _React$useContext.scrollbarSize;
  var _React$useContext2 = react.exports.useContext(ExpandedRowContext), fixHeader = _React$useContext2.fixHeader, fixColumn = _React$useContext2.fixColumn, componentWidth = _React$useContext2.componentWidth, horizonScroll = _React$useContext2.horizonScroll;
  return react.exports.useMemo(function() {
    var contentNode = children;
    if (isEmpty ? horizonScroll : fixColumn) {
      contentNode = /* @__PURE__ */ react.exports.createElement("div", {
        style: {
          width: componentWidth - (fixHeader ? scrollbarSize : 0),
          position: "sticky",
          left: 0,
          overflow: "hidden"
        },
        className: "".concat(prefixCls, "-expanded-row-fixed")
      }, componentWidth !== 0 && contentNode);
    }
    return /* @__PURE__ */ react.exports.createElement(Component2, {
      className,
      style: {
        display: expanded ? null : "none"
      }
    }, /* @__PURE__ */ react.exports.createElement(WrappedCell, {
      component: cellComponent,
      prefixCls,
      colSpan
    }, contentNode));
  }, [children, Component2, className, expanded, colSpan, isEmpty, scrollbarSize, componentWidth, fixColumn, fixHeader, horizonScroll]);
}
var ResizeContext = /* @__PURE__ */ react.exports.createContext(null);
function BodyRow(props) {
  var className = props.className, style2 = props.style, record = props.record, index2 = props.index, renderIndex = props.renderIndex, rowKey = props.rowKey, rowExpandable = props.rowExpandable, expandedKeys = props.expandedKeys, onRow = props.onRow, _props$indent = props.indent, indent = _props$indent === void 0 ? 0 : _props$indent, RowComponent = props.rowComponent, cellComponent = props.cellComponent, childrenColumnName = props.childrenColumnName;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, fixedInfoList = _React$useContext.fixedInfoList;
  var _React$useContext2 = react.exports.useContext(BodyContext), flattenColumns = _React$useContext2.flattenColumns, expandableType = _React$useContext2.expandableType, expandRowByClick = _React$useContext2.expandRowByClick, onTriggerExpand = _React$useContext2.onTriggerExpand, rowClassName = _React$useContext2.rowClassName, expandedRowClassName = _React$useContext2.expandedRowClassName, indentSize = _React$useContext2.indentSize, expandIcon = _React$useContext2.expandIcon, expandedRowRender = _React$useContext2.expandedRowRender, expandIconColumnIndex = _React$useContext2.expandIconColumnIndex;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), expandRended = _React$useState2[0], setExpandRended = _React$useState2[1];
  var expanded = expandedKeys && expandedKeys.has(props.recordKey);
  react.exports.useEffect(function() {
    if (expanded) {
      setExpandRended(true);
    }
  }, [expanded]);
  var rowSupportExpand = expandableType === "row" && (!rowExpandable || rowExpandable(record));
  var nestExpandable = expandableType === "nest";
  var hasNestChildren = childrenColumnName && record && record[childrenColumnName];
  var mergedExpandable = rowSupportExpand || nestExpandable;
  var onExpandRef = react.exports.useRef(onTriggerExpand);
  onExpandRef.current = onTriggerExpand;
  var onInternalTriggerExpand = function onInternalTriggerExpand2() {
    onExpandRef.current.apply(onExpandRef, arguments);
  };
  var additionalProps = onRow === null || onRow === void 0 ? void 0 : onRow(record, index2);
  var onClick = function onClick2(event) {
    var _additionalProps$onCl;
    if (expandRowByClick && mergedExpandable) {
      onInternalTriggerExpand(record, event);
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    additionalProps === null || additionalProps === void 0 ? void 0 : (_additionalProps$onCl = additionalProps.onClick) === null || _additionalProps$onCl === void 0 ? void 0 : _additionalProps$onCl.call.apply(_additionalProps$onCl, [additionalProps, event].concat(args));
  };
  var computeRowClassName;
  if (typeof rowClassName === "string") {
    computeRowClassName = rowClassName;
  } else if (typeof rowClassName === "function") {
    computeRowClassName = rowClassName(record, index2, indent);
  }
  var columnsKey = getColumnsKey(flattenColumns);
  var baseRowNode = /* @__PURE__ */ react.exports.createElement(RowComponent, _extends$2({}, additionalProps, {
    "data-row-key": rowKey,
    className: classnamesExports(className, "".concat(prefixCls, "-row"), "".concat(prefixCls, "-row-level-").concat(indent), computeRowClassName, additionalProps && additionalProps.className),
    style: _objectSpread2$4(_objectSpread2$4({}, style2), additionalProps ? additionalProps.style : null),
    onClick
  }), flattenColumns.map(function(column, colIndex) {
    var render2 = column.render, dataIndex = column.dataIndex, columnClassName = column.className;
    var key2 = columnsKey[colIndex];
    var fixedInfo = fixedInfoList[colIndex];
    var appendCellNode;
    if (colIndex === (expandIconColumnIndex || 0) && nestExpandable) {
      appendCellNode = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement("span", {
        style: {
          paddingLeft: "".concat(indentSize * indent, "px")
        },
        className: "".concat(prefixCls, "-row-indent indent-level-").concat(indent)
      }), expandIcon({
        prefixCls,
        expanded,
        expandable: hasNestChildren,
        record,
        onExpand: onInternalTriggerExpand
      }));
    }
    var additionalCellProps;
    if (column.onCell) {
      additionalCellProps = column.onCell(record, index2);
    }
    return /* @__PURE__ */ react.exports.createElement(WrappedCell, _extends$2({
      className: columnClassName,
      ellipsis: column.ellipsis,
      align: column.align,
      component: cellComponent,
      prefixCls,
      key: key2,
      record,
      index: index2,
      renderIndex,
      dataIndex,
      render: render2,
      shouldCellUpdate: column.shouldCellUpdate,
      expanded: appendCellNode && expanded
    }, fixedInfo, {
      appendNode: appendCellNode,
      additionalProps: additionalCellProps
    }));
  }));
  var expandRowNode;
  if (rowSupportExpand && (expandRended || expanded)) {
    var expandContent = expandedRowRender(record, index2, indent + 1, expanded);
    var computedExpandedRowClassName = expandedRowClassName && expandedRowClassName(record, index2, indent);
    expandRowNode = /* @__PURE__ */ react.exports.createElement(ExpandedRow, {
      expanded,
      className: classnamesExports("".concat(prefixCls, "-expanded-row"), "".concat(prefixCls, "-expanded-row-level-").concat(indent + 1), computedExpandedRowClassName),
      prefixCls,
      component: RowComponent,
      cellComponent,
      colSpan: flattenColumns.length,
      isEmpty: false
    }, expandContent);
  }
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, baseRowNode, expandRowNode);
}
BodyRow.displayName = "BodyRow";
function flatRecord(record, indent, childrenColumnName, expandedKeys, getRowKey, index2) {
  var arr = [];
  arr.push({
    record,
    indent,
    index: index2
  });
  var key2 = getRowKey(record);
  var expanded = expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.has(key2);
  if (record && Array.isArray(record[childrenColumnName]) && expanded) {
    for (var i = 0; i < record[childrenColumnName].length; i += 1) {
      var tempArr = flatRecord(record[childrenColumnName][i], indent + 1, childrenColumnName, expandedKeys, getRowKey, i);
      arr.push.apply(arr, _toConsumableArray(tempArr));
    }
  }
  return arr;
}
function useFlattenRecords(data2, childrenColumnName, expandedKeys, getRowKey) {
  var arr = react.exports.useMemo(function() {
    if (expandedKeys === null || expandedKeys === void 0 ? void 0 : expandedKeys.size) {
      var temp = [];
      for (var i = 0; i < (data2 === null || data2 === void 0 ? void 0 : data2.length); i += 1) {
        var record = data2[i];
        temp.push.apply(temp, _toConsumableArray(flatRecord(record, 0, childrenColumnName, expandedKeys, getRowKey, i)));
      }
      return temp;
    }
    return data2 === null || data2 === void 0 ? void 0 : data2.map(function(item, index2) {
      return {
        record: item,
        indent: 0,
        index: index2
      };
    });
  }, [data2, childrenColumnName, expandedKeys, getRowKey]);
  return arr;
}
function MeasureCell(_ref) {
  var columnKey = _ref.columnKey, onColumnResize = _ref.onColumnResize;
  var cellRef = react.exports.useRef();
  react.exports.useEffect(function() {
    if (cellRef.current) {
      onColumnResize(columnKey, cellRef.current.offsetWidth);
    }
  }, []);
  return /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
    data: columnKey
  }, /* @__PURE__ */ react.exports.createElement("td", {
    ref: cellRef,
    style: {
      padding: 0,
      border: 0,
      height: 0
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      height: 0,
      overflow: "hidden"
    }
  }, "\xA0")));
}
function MeasureRow(_ref) {
  var prefixCls = _ref.prefixCls, columnsKey = _ref.columnsKey, onColumnResize = _ref.onColumnResize;
  return /* @__PURE__ */ react.exports.createElement("tr", {
    "aria-hidden": "true",
    className: "".concat(prefixCls, "-measure-row"),
    style: {
      height: 0,
      fontSize: 0
    }
  }, /* @__PURE__ */ react.exports.createElement(ResizeObserver.Collection, {
    onBatchResize: function onBatchResize(infoList) {
      infoList.forEach(function(_ref2) {
        var columnKey = _ref2.data, size = _ref2.size;
        onColumnResize(columnKey, size.offsetWidth);
      });
    }
  }, columnsKey.map(function(columnKey) {
    return /* @__PURE__ */ react.exports.createElement(MeasureCell, {
      key: columnKey,
      columnKey,
      onColumnResize
    });
  })));
}
function Body(_ref) {
  var data2 = _ref.data, getRowKey = _ref.getRowKey, measureColumnWidth = _ref.measureColumnWidth, expandedKeys = _ref.expandedKeys, onRow = _ref.onRow, rowExpandable = _ref.rowExpandable, emptyNode = _ref.emptyNode, childrenColumnName = _ref.childrenColumnName;
  var _React$useContext = react.exports.useContext(ResizeContext), onColumnResize = _React$useContext.onColumnResize;
  var _React$useContext2 = react.exports.useContext(TableContext), prefixCls = _React$useContext2.prefixCls, getComponent = _React$useContext2.getComponent;
  var _React$useContext3 = react.exports.useContext(BodyContext), flattenColumns = _React$useContext3.flattenColumns;
  var flattenData2 = useFlattenRecords(data2, childrenColumnName, expandedKeys, getRowKey);
  var perfRef = react.exports.useRef({
    renderWithProps: false
  });
  var _React$useState = react.exports.useState(-1), _React$useState2 = _slicedToArray$3(_React$useState, 2), startRow = _React$useState2[0], setStartRow = _React$useState2[1];
  var _React$useState3 = react.exports.useState(-1), _React$useState4 = _slicedToArray$3(_React$useState3, 2), endRow = _React$useState4[0], setEndRow = _React$useState4[1];
  var onHover = react.exports.useCallback(function(start, end) {
    setStartRow(start);
    setEndRow(end);
  }, []);
  var bodyNode = react.exports.useMemo(function() {
    var WrapperComponent = getComponent(["body", "wrapper"], "tbody");
    var trComponent = getComponent(["body", "row"], "tr");
    var tdComponent = getComponent(["body", "cell"], "td");
    var rows;
    if (data2.length) {
      rows = flattenData2.map(function(item, idx) {
        var record = item.record, indent = item.indent, renderIndex = item.index;
        var key2 = getRowKey(record, idx);
        return /* @__PURE__ */ react.exports.createElement(BodyRow, {
          key: key2,
          rowKey: key2,
          record,
          recordKey: key2,
          index: idx,
          renderIndex,
          rowComponent: trComponent,
          cellComponent: tdComponent,
          expandedKeys,
          onRow,
          getRowKey,
          rowExpandable,
          childrenColumnName,
          indent
        });
      });
    } else {
      rows = /* @__PURE__ */ react.exports.createElement(ExpandedRow, {
        expanded: true,
        className: "".concat(prefixCls, "-placeholder"),
        prefixCls,
        component: trComponent,
        cellComponent: tdComponent,
        colSpan: flattenColumns.length,
        isEmpty: true
      }, emptyNode);
    }
    var columnsKey = getColumnsKey(flattenColumns);
    return /* @__PURE__ */ react.exports.createElement(WrapperComponent, {
      className: "".concat(prefixCls, "-tbody")
    }, measureColumnWidth && /* @__PURE__ */ react.exports.createElement(MeasureRow, {
      prefixCls,
      columnsKey,
      onColumnResize
    }), rows);
  }, [data2, prefixCls, onRow, measureColumnWidth, expandedKeys, getRowKey, getComponent, emptyNode, flattenColumns, childrenColumnName, onColumnResize, rowExpandable, flattenData2]);
  return /* @__PURE__ */ react.exports.createElement(PerfContext.Provider, {
    value: perfRef.current
  }, /* @__PURE__ */ react.exports.createElement(HoverContext.Provider, {
    value: {
      startRow,
      endRow,
      onHover
    }
  }, bodyNode));
}
var MemoBody = /* @__PURE__ */ react.exports.memo(Body);
MemoBody.displayName = "Body";
var _excluded$6 = ["expandable"];
var INTERNAL_COL_DEFINE = "RC_TABLE_INTERNAL_COL_DEFINE";
function getExpandableProps(props) {
  var expandable = props.expandable, legacyExpandableConfig = _objectWithoutProperties$1(props, _excluded$6);
  var config;
  if ("expandable" in props) {
    config = _objectSpread2$4(_objectSpread2$4({}, legacyExpandableConfig), expandable);
  } else {
    config = legacyExpandableConfig;
  }
  if (config.showExpandColumn === false) {
    config.expandIconColumnIndex = -1;
  }
  return config;
}
var EXPAND_COLUMN = {};
var _excluded$5 = ["children"], _excluded2 = ["fixed"];
function convertChildrenToColumns(children) {
  return toArray$4(children).filter(function(node) {
    return /* @__PURE__ */ react.exports.isValidElement(node);
  }).map(function(_ref) {
    var key2 = _ref.key, props = _ref.props;
    var nodeChildren = props.children, restProps = _objectWithoutProperties$1(props, _excluded$5);
    var column = _objectSpread2$4({
      key: key2
    }, restProps);
    if (nodeChildren) {
      column.children = convertChildrenToColumns(nodeChildren);
    }
    return column;
  });
}
function flatColumns(columns) {
  return columns.reduce(function(list2, column) {
    var fixed = column.fixed;
    var parsedFixed = fixed === true ? "left" : fixed;
    var subColumns = column.children;
    if (subColumns && subColumns.length > 0) {
      return [].concat(_toConsumableArray(list2), _toConsumableArray(flatColumns(subColumns).map(function(subColum) {
        return _objectSpread2$4({
          fixed: parsedFixed
        }, subColum);
      })));
    }
    return [].concat(_toConsumableArray(list2), [_objectSpread2$4(_objectSpread2$4({}, column), {}, {
      fixed: parsedFixed
    })]);
  }, []);
}
function revertForRtl(columns) {
  return columns.map(function(column) {
    var fixed = column.fixed, restProps = _objectWithoutProperties$1(column, _excluded2);
    var parsedFixed = fixed;
    if (fixed === "left") {
      parsedFixed = "right";
    } else if (fixed === "right") {
      parsedFixed = "left";
    }
    return _objectSpread2$4({
      fixed: parsedFixed
    }, restProps);
  });
}
function useColumns(_ref2, transformColumns) {
  var prefixCls = _ref2.prefixCls, columns = _ref2.columns, children = _ref2.children, expandable = _ref2.expandable, expandedKeys = _ref2.expandedKeys, getRowKey = _ref2.getRowKey, onTriggerExpand = _ref2.onTriggerExpand, expandIcon = _ref2.expandIcon, rowExpandable = _ref2.rowExpandable, expandIconColumnIndex = _ref2.expandIconColumnIndex, direction = _ref2.direction, expandRowByClick = _ref2.expandRowByClick, columnWidth = _ref2.columnWidth, fixed = _ref2.fixed;
  var baseColumns = react.exports.useMemo(function() {
    return columns || convertChildrenToColumns(children);
  }, [columns, children]);
  var withExpandColumns = react.exports.useMemo(function() {
    if (expandable) {
      var _expandColumn;
      var cloneColumns = baseColumns.slice();
      if (!cloneColumns.includes(EXPAND_COLUMN)) {
        var expandColIndex = expandIconColumnIndex || 0;
        if (expandColIndex >= 0) {
          cloneColumns.splice(expandColIndex, 0, EXPAND_COLUMN);
        }
      }
      var expandColumnIndex = cloneColumns.indexOf(EXPAND_COLUMN);
      cloneColumns = cloneColumns.filter(function(column, index2) {
        return column !== EXPAND_COLUMN || index2 === expandColumnIndex;
      });
      var prevColumn = baseColumns[expandColumnIndex];
      var fixedColumn;
      if ((fixed === "left" || fixed) && !expandIconColumnIndex) {
        fixedColumn = "left";
      } else if ((fixed === "right" || fixed) && expandIconColumnIndex === baseColumns.length) {
        fixedColumn = "right";
      } else {
        fixedColumn = prevColumn ? prevColumn.fixed : null;
      }
      var expandColumn = (_expandColumn = {}, _defineProperty$5(_expandColumn, INTERNAL_COL_DEFINE, {
        className: "".concat(prefixCls, "-expand-icon-col"),
        columnType: "EXPAND_COLUMN"
      }), _defineProperty$5(_expandColumn, "title", ""), _defineProperty$5(_expandColumn, "fixed", fixedColumn), _defineProperty$5(_expandColumn, "className", "".concat(prefixCls, "-row-expand-icon-cell")), _defineProperty$5(_expandColumn, "width", columnWidth), _defineProperty$5(_expandColumn, "render", function render2(_, record, index2) {
        var rowKey = getRowKey(record, index2);
        var expanded = expandedKeys.has(rowKey);
        var recordExpandable = rowExpandable ? rowExpandable(record) : true;
        var icon = expandIcon({
          prefixCls,
          expanded,
          expandable: recordExpandable,
          record,
          onExpand: onTriggerExpand
        });
        if (expandRowByClick) {
          return /* @__PURE__ */ react.exports.createElement("span", {
            onClick: function onClick(e2) {
              return e2.stopPropagation();
            }
          }, icon);
        }
        return icon;
      }), _expandColumn);
      return cloneColumns.map(function(col) {
        return col === EXPAND_COLUMN ? expandColumn : col;
      });
    }
    return baseColumns.filter(function(col) {
      return col !== EXPAND_COLUMN;
    });
  }, [expandable, baseColumns, getRowKey, expandedKeys, expandIcon, direction]);
  var mergedColumns = react.exports.useMemo(function() {
    var finalColumns = withExpandColumns;
    if (transformColumns) {
      finalColumns = transformColumns(finalColumns);
    }
    if (!finalColumns.length) {
      finalColumns = [{
        render: function render2() {
          return null;
        }
      }];
    }
    return finalColumns;
  }, [transformColumns, withExpandColumns, direction]);
  var flattenColumns = react.exports.useMemo(function() {
    if (direction === "rtl") {
      return revertForRtl(flatColumns(mergedColumns));
    }
    return flatColumns(mergedColumns);
  }, [mergedColumns, direction]);
  return [mergedColumns, flattenColumns];
}
function useLayoutState(defaultState) {
  var stateRef = react.exports.useRef(defaultState);
  var _useState = react.exports.useState({}), _useState2 = _slicedToArray$3(_useState, 2), forceUpdate = _useState2[1];
  var lastPromiseRef = react.exports.useRef(null);
  var updateBatchRef = react.exports.useRef([]);
  function setFrameState(updater) {
    updateBatchRef.current.push(updater);
    var promise = Promise.resolve();
    lastPromiseRef.current = promise;
    promise.then(function() {
      if (lastPromiseRef.current === promise) {
        var prevBatch = updateBatchRef.current;
        var prevState = stateRef.current;
        updateBatchRef.current = [];
        prevBatch.forEach(function(batchUpdater) {
          stateRef.current = batchUpdater(stateRef.current);
        });
        lastPromiseRef.current = null;
        if (prevState !== stateRef.current) {
          forceUpdate({});
        }
      }
    });
  }
  react.exports.useEffect(function() {
    return function() {
      lastPromiseRef.current = null;
    };
  }, []);
  return [stateRef.current, setFrameState];
}
function useTimeoutLock(defaultState) {
  var frameRef = react.exports.useRef(defaultState || null);
  var timeoutRef = react.exports.useRef();
  function cleanUp() {
    window.clearTimeout(timeoutRef.current);
  }
  function setState(newState) {
    frameRef.current = newState;
    cleanUp();
    timeoutRef.current = window.setTimeout(function() {
      frameRef.current = null;
      timeoutRef.current = void 0;
    }, 100);
  }
  function getState() {
    return frameRef.current;
  }
  react.exports.useEffect(function() {
    return cleanUp;
  }, []);
  return [setState, getState];
}
function useStickyOffsets(colWidths, columnCount, direction) {
  var stickyOffsets = react.exports.useMemo(function() {
    var leftOffsets = [];
    var rightOffsets = [];
    var left = 0;
    var right = 0;
    for (var start = 0; start < columnCount; start += 1) {
      if (direction === "rtl") {
        rightOffsets[start] = right;
        right += colWidths[start] || 0;
        var end = columnCount - start - 1;
        leftOffsets[end] = left;
        left += colWidths[end] || 0;
      } else {
        leftOffsets[start] = left;
        left += colWidths[start] || 0;
        var _end = columnCount - start - 1;
        rightOffsets[_end] = right;
        right += colWidths[_end] || 0;
      }
    }
    return {
      left: leftOffsets,
      right: rightOffsets
    };
  }, [colWidths, columnCount, direction]);
  return stickyOffsets;
}
var _excluded$4 = ["columnType"];
function ColGroup(_ref) {
  var colWidths = _ref.colWidths, columns = _ref.columns, columCount = _ref.columCount;
  var cols = [];
  var len = columCount || columns.length;
  var mustInsert = false;
  for (var i = len - 1; i >= 0; i -= 1) {
    var width = colWidths[i];
    var column = columns && columns[i];
    var additionalProps = column && column[INTERNAL_COL_DEFINE];
    if (width || additionalProps || mustInsert) {
      var _ref2 = additionalProps || {};
      _ref2.columnType;
      var restAdditionalProps = _objectWithoutProperties$1(_ref2, _excluded$4);
      cols.unshift(/* @__PURE__ */ react.exports.createElement("col", _extends$2({
        key: i,
        style: {
          width
        }
      }, restAdditionalProps)));
      mustInsert = true;
    }
  }
  return /* @__PURE__ */ react.exports.createElement("colgroup", null, cols);
}
function Panel(_ref) {
  var className = _ref.className, children = _ref.children;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className
  }, children);
}
var SummaryContext = /* @__PURE__ */ react.exports.createContext({});
function SummaryCell(_ref) {
  var className = _ref.className, index2 = _ref.index, children = _ref.children, _ref$colSpan = _ref.colSpan, colSpan = _ref$colSpan === void 0 ? 1 : _ref$colSpan, rowSpan = _ref.rowSpan, align = _ref.align;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, direction = _React$useContext.direction;
  var _React$useContext2 = react.exports.useContext(SummaryContext), scrollColumnIndex = _React$useContext2.scrollColumnIndex, stickyOffsets = _React$useContext2.stickyOffsets, flattenColumns = _React$useContext2.flattenColumns;
  var lastIndex = index2 + colSpan - 1;
  var mergedColSpan = lastIndex + 1 === scrollColumnIndex ? colSpan + 1 : colSpan;
  var fixedInfo = getCellFixedInfo(index2, index2 + mergedColSpan - 1, flattenColumns, stickyOffsets, direction);
  return /* @__PURE__ */ react.exports.createElement(WrappedCell, _extends$2({
    className,
    index: index2,
    component: "td",
    prefixCls,
    record: null,
    dataIndex: null,
    align,
    colSpan: mergedColSpan,
    rowSpan,
    render: function render2() {
      return children;
    }
  }, fixedInfo));
}
var _excluded$3 = ["children"];
function FooterRow(_ref) {
  var children = _ref.children, props = _objectWithoutProperties$1(_ref, _excluded$3);
  return /* @__PURE__ */ react.exports.createElement("tr", props, children);
}
function Summary(_ref) {
  var children = _ref.children;
  return children;
}
Summary.Row = FooterRow;
Summary.Cell = SummaryCell;
function Footer(_ref) {
  var children = _ref.children, stickyOffsets = _ref.stickyOffsets, flattenColumns = _ref.flattenColumns;
  var tableContext = react.exports.useContext(TableContext);
  var prefixCls = tableContext.prefixCls;
  var lastColumnIndex = flattenColumns.length - 1;
  var scrollColumn = flattenColumns[lastColumnIndex];
  var summaryContext = react.exports.useMemo(function() {
    return {
      stickyOffsets,
      flattenColumns,
      scrollColumnIndex: (scrollColumn === null || scrollColumn === void 0 ? void 0 : scrollColumn.scrollbar) ? lastColumnIndex : null
    };
  }, [scrollColumn, flattenColumns, lastColumnIndex, stickyOffsets]);
  return /* @__PURE__ */ react.exports.createElement(SummaryContext.Provider, {
    value: summaryContext
  }, /* @__PURE__ */ react.exports.createElement("tfoot", {
    className: "".concat(prefixCls, "-summary")
  }, children));
}
var FooterComponents = Summary;
function renderExpandIcon$1(_ref) {
  var _classNames;
  var prefixCls = _ref.prefixCls, record = _ref.record, onExpand = _ref.onExpand, expanded = _ref.expanded, expandable = _ref.expandable;
  var expandClassName = "".concat(prefixCls, "-row-expand-icon");
  if (!expandable) {
    return /* @__PURE__ */ react.exports.createElement("span", {
      className: classnamesExports(expandClassName, "".concat(prefixCls, "-row-spaced"))
    });
  }
  var onClick = function onClick2(event) {
    onExpand(record, event);
    event.stopPropagation();
  };
  return /* @__PURE__ */ react.exports.createElement("span", {
    className: classnamesExports(expandClassName, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-row-expanded"), expanded), _defineProperty$5(_classNames, "".concat(prefixCls, "-row-collapsed"), !expanded), _classNames)),
    onClick
  });
}
function findAllChildrenKeys(data2, getRowKey, childrenColumnName) {
  var keys2 = [];
  function dig(list2) {
    (list2 || []).forEach(function(item, index2) {
      keys2.push(getRowKey(item, index2));
      dig(item[childrenColumnName]);
    });
  }
  dig(data2);
  return keys2;
}
var StickyScrollBar = function StickyScrollBar2(_ref, ref) {
  var _scrollBodyRef$curren, _scrollBodyRef$curren2;
  var scrollBodyRef = _ref.scrollBodyRef, onScroll = _ref.onScroll, offsetScroll = _ref.offsetScroll, container = _ref.container;
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls;
  var bodyScrollWidth = ((_scrollBodyRef$curren = scrollBodyRef.current) === null || _scrollBodyRef$curren === void 0 ? void 0 : _scrollBodyRef$curren.scrollWidth) || 0;
  var bodyWidth = ((_scrollBodyRef$curren2 = scrollBodyRef.current) === null || _scrollBodyRef$curren2 === void 0 ? void 0 : _scrollBodyRef$curren2.clientWidth) || 0;
  var scrollBarWidth = bodyScrollWidth && bodyWidth * (bodyWidth / bodyScrollWidth);
  var scrollBarRef = react.exports.useRef();
  var _useLayoutState = useLayoutState({
    scrollLeft: 0,
    isHiddenScrollBar: false
  }), _useLayoutState2 = _slicedToArray$3(_useLayoutState, 2), scrollState = _useLayoutState2[0], setScrollState = _useLayoutState2[1];
  var refState = react.exports.useRef({
    delta: 0,
    x: 0
  });
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), isActive2 = _React$useState2[0], setActive = _React$useState2[1];
  var onMouseUp = function onMouseUp2() {
    setActive(false);
  };
  var onMouseDown = function onMouseDown2(event) {
    event.persist();
    refState.current.delta = event.pageX - scrollState.scrollLeft;
    refState.current.x = 0;
    setActive(true);
    event.preventDefault();
  };
  var onMouseMove = function onMouseMove2(event) {
    var _window;
    var _ref2 = event || ((_window = window) === null || _window === void 0 ? void 0 : _window.event), buttons = _ref2.buttons;
    if (!isActive2 || buttons === 0) {
      if (isActive2) {
        setActive(false);
      }
      return;
    }
    var left = refState.current.x + event.pageX - refState.current.x - refState.current.delta;
    if (left <= 0) {
      left = 0;
    }
    if (left + scrollBarWidth >= bodyWidth) {
      left = bodyWidth - scrollBarWidth;
    }
    onScroll({
      scrollLeft: left / bodyWidth * (bodyScrollWidth + 2)
    });
    refState.current.x = event.pageX;
  };
  var onContainerScroll = function onContainerScroll2() {
    if (!scrollBodyRef.current) {
      return;
    }
    var tableOffsetTop = getOffset(scrollBodyRef.current).top;
    var tableBottomOffset = tableOffsetTop + scrollBodyRef.current.offsetHeight;
    var currentClientOffset = container === window ? document.documentElement.scrollTop + window.innerHeight : getOffset(container).top + container.clientHeight;
    if (tableBottomOffset - getScrollBarSize() <= currentClientOffset || tableOffsetTop >= currentClientOffset - offsetScroll) {
      setScrollState(function(state) {
        return _objectSpread2$4(_objectSpread2$4({}, state), {}, {
          isHiddenScrollBar: true
        });
      });
    } else {
      setScrollState(function(state) {
        return _objectSpread2$4(_objectSpread2$4({}, state), {}, {
          isHiddenScrollBar: false
        });
      });
    }
  };
  var setScrollLeft = function setScrollLeft2(left) {
    setScrollState(function(state) {
      return _objectSpread2$4(_objectSpread2$4({}, state), {}, {
        scrollLeft: left / bodyScrollWidth * bodyWidth || 0
      });
    });
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      setScrollLeft
    };
  });
  react.exports.useEffect(function() {
    var onMouseUpListener = addEventListenerWrap(document.body, "mouseup", onMouseUp, false);
    var onMouseMoveListener = addEventListenerWrap(document.body, "mousemove", onMouseMove, false);
    onContainerScroll();
    return function() {
      onMouseUpListener.remove();
      onMouseMoveListener.remove();
    };
  }, [scrollBarWidth, isActive2]);
  react.exports.useEffect(function() {
    var onScrollListener = addEventListenerWrap(container, "scroll", onContainerScroll, false);
    var onResizeListener = addEventListenerWrap(window, "resize", onContainerScroll, false);
    return function() {
      onScrollListener.remove();
      onResizeListener.remove();
    };
  }, [container]);
  react.exports.useEffect(function() {
    if (!scrollState.isHiddenScrollBar) {
      setScrollState(function(state) {
        var bodyNode = scrollBodyRef.current;
        if (!bodyNode) {
          return state;
        }
        return _objectSpread2$4(_objectSpread2$4({}, state), {}, {
          scrollLeft: bodyNode.scrollLeft / bodyNode.scrollWidth * bodyNode.clientWidth
        });
      });
    }
  }, [scrollState.isHiddenScrollBar]);
  if (bodyScrollWidth <= bodyWidth || !scrollBarWidth || scrollState.isHiddenScrollBar) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: {
      height: getScrollBarSize(),
      width: bodyWidth,
      bottom: offsetScroll
    },
    className: "".concat(prefixCls, "-sticky-scroll")
  }, /* @__PURE__ */ react.exports.createElement("div", {
    onMouseDown,
    ref: scrollBarRef,
    className: classnamesExports("".concat(prefixCls, "-sticky-scroll-bar"), _defineProperty$5({}, "".concat(prefixCls, "-sticky-scroll-bar-active"), isActive2)),
    style: {
      width: "".concat(scrollBarWidth, "px"),
      transform: "translate3d(".concat(scrollState.scrollLeft, "px, 0, 0)")
    }
  }));
};
const StickyScrollBar$1 = /* @__PURE__ */ react.exports.forwardRef(StickyScrollBar);
var defaultContainer = canUseDom() ? window : null;
function useSticky(sticky, prefixCls) {
  var _ref = _typeof$4(sticky) === "object" ? sticky : {}, _ref$offsetHeader = _ref.offsetHeader, offsetHeader = _ref$offsetHeader === void 0 ? 0 : _ref$offsetHeader, _ref$offsetSummary = _ref.offsetSummary, offsetSummary = _ref$offsetSummary === void 0 ? 0 : _ref$offsetSummary, _ref$offsetScroll = _ref.offsetScroll, offsetScroll = _ref$offsetScroll === void 0 ? 0 : _ref$offsetScroll, _ref$getContainer = _ref.getContainer, getContainer2 = _ref$getContainer === void 0 ? function() {
    return defaultContainer;
  } : _ref$getContainer;
  var container = getContainer2() || defaultContainer;
  return react.exports.useMemo(function() {
    var isSticky = !!sticky;
    return {
      isSticky,
      stickyClassName: isSticky ? "".concat(prefixCls, "-sticky-holder") : "",
      offsetHeader,
      offsetSummary,
      offsetScroll,
      container
    };
  }, [offsetScroll, offsetHeader, offsetSummary, prefixCls, container]);
}
var _excluded$2 = ["className", "noData", "columns", "flattenColumns", "colWidths", "columCount", "stickyOffsets", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName", "onScroll", "maxContentScroll", "children"];
function useColumnWidth(colWidths, columCount) {
  return react.exports.useMemo(function() {
    var cloneColumns = [];
    for (var i = 0; i < columCount; i += 1) {
      var val = colWidths[i];
      if (val !== void 0) {
        cloneColumns[i] = val;
      } else {
        return null;
      }
    }
    return cloneColumns;
  }, [colWidths.join("_"), columCount]);
}
var FixedHolder = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var className = _ref.className, noData = _ref.noData, columns = _ref.columns, flattenColumns = _ref.flattenColumns, colWidths = _ref.colWidths, columCount = _ref.columCount, stickyOffsets = _ref.stickyOffsets, direction = _ref.direction, fixHeader = _ref.fixHeader, stickyTopOffset = _ref.stickyTopOffset, stickyBottomOffset = _ref.stickyBottomOffset, stickyClassName = _ref.stickyClassName, onScroll = _ref.onScroll, maxContentScroll = _ref.maxContentScroll, children = _ref.children, props = _objectWithoutProperties$1(_ref, _excluded$2);
  var _React$useContext = react.exports.useContext(TableContext), prefixCls = _React$useContext.prefixCls, scrollbarSize = _React$useContext.scrollbarSize, isSticky = _React$useContext.isSticky;
  var combinationScrollBarSize = isSticky && !fixHeader ? 0 : scrollbarSize;
  var scrollRef = react.exports.useRef(null);
  var setScrollRef = react.exports.useCallback(function(element) {
    fillRef(ref, element);
    fillRef(scrollRef, element);
  }, []);
  react.exports.useEffect(function() {
    var _scrollRef$current;
    function onWheel(e2) {
      var currentTarget = e2.currentTarget, deltaX = e2.deltaX;
      if (deltaX) {
        onScroll({
          currentTarget,
          scrollLeft: currentTarget.scrollLeft + deltaX
        });
        e2.preventDefault();
      }
    }
    (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.addEventListener("wheel", onWheel);
    return function() {
      var _scrollRef$current2;
      (_scrollRef$current2 = scrollRef.current) === null || _scrollRef$current2 === void 0 ? void 0 : _scrollRef$current2.removeEventListener("wheel", onWheel);
    };
  }, []);
  var allFlattenColumnsWithWidth = react.exports.useMemo(function() {
    return flattenColumns.every(function(column) {
      return column.width >= 0;
    });
  }, [flattenColumns]);
  var lastColumn = flattenColumns[flattenColumns.length - 1];
  var ScrollBarColumn = {
    fixed: lastColumn ? lastColumn.fixed : null,
    scrollbar: true,
    onHeaderCell: function onHeaderCell() {
      return {
        className: "".concat(prefixCls, "-cell-scrollbar")
      };
    }
  };
  var columnsWithScrollbar = react.exports.useMemo(function() {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(columns), [ScrollBarColumn]) : columns;
  }, [combinationScrollBarSize, columns]);
  var flattenColumnsWithScrollbar = react.exports.useMemo(function() {
    return combinationScrollBarSize ? [].concat(_toConsumableArray(flattenColumns), [ScrollBarColumn]) : flattenColumns;
  }, [combinationScrollBarSize, flattenColumns]);
  var headerStickyOffsets = react.exports.useMemo(function() {
    var right = stickyOffsets.right, left = stickyOffsets.left;
    return _objectSpread2$4(_objectSpread2$4({}, stickyOffsets), {}, {
      left: direction === "rtl" ? [].concat(_toConsumableArray(left.map(function(width) {
        return width + combinationScrollBarSize;
      })), [0]) : left,
      right: direction === "rtl" ? right : [].concat(_toConsumableArray(right.map(function(width) {
        return width + combinationScrollBarSize;
      })), [0]),
      isSticky
    });
  }, [combinationScrollBarSize, stickyOffsets, isSticky]);
  var mergedColumnWidth = useColumnWidth(colWidths, columCount);
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: _objectSpread2$4({
      overflow: "hidden"
    }, isSticky ? {
      top: stickyTopOffset,
      bottom: stickyBottomOffset
    } : {}),
    ref: setScrollRef,
    className: classnamesExports(className, _defineProperty$5({}, stickyClassName, !!stickyClassName))
  }, /* @__PURE__ */ react.exports.createElement("table", {
    style: {
      tableLayout: "fixed",
      visibility: noData || mergedColumnWidth ? null : "hidden"
    }
  }, (!noData || !maxContentScroll || allFlattenColumnsWithWidth) && /* @__PURE__ */ react.exports.createElement(ColGroup, {
    colWidths: mergedColumnWidth ? [].concat(_toConsumableArray(mergedColumnWidth), [combinationScrollBarSize]) : [],
    columCount: columCount + 1,
    columns: flattenColumnsWithScrollbar
  }), children(_objectSpread2$4(_objectSpread2$4({}, props), {}, {
    stickyOffsets: headerStickyOffsets,
    columns: columnsWithScrollbar,
    flattenColumns: flattenColumnsWithScrollbar
  }))));
});
FixedHolder.displayName = "FixedHolder";
var EMPTY_DATA = [];
var EMPTY_SCROLL_TARGET = {};
var INTERNAL_HOOKS = "rc-table-internal-hook";
var MemoTableContent = /* @__PURE__ */ react.exports.memo(function(_ref) {
  var children = _ref.children;
  return children;
}, function(prev, next) {
  if (!shallowequal(prev.props, next.props)) {
    return false;
  }
  return prev.pingLeft !== next.pingLeft || prev.pingRight !== next.pingRight;
});
function Table$2(props) {
  var _classNames;
  var prefixCls = props.prefixCls, className = props.className, rowClassName = props.rowClassName, style2 = props.style, data2 = props.data, rowKey = props.rowKey, scroll = props.scroll, tableLayout = props.tableLayout, direction = props.direction, title = props.title, footer = props.footer, summary = props.summary, id2 = props.id, showHeader = props.showHeader, components = props.components, emptyText2 = props.emptyText, onRow = props.onRow, onHeaderRow = props.onHeaderRow, internalHooks = props.internalHooks, transformColumns = props.transformColumns, internalRefs = props.internalRefs, sticky = props.sticky;
  var mergedData = data2 || EMPTY_DATA;
  var hasData = !!mergedData.length;
  var getComponent = react.exports.useCallback(function(path, defaultComponent) {
    return getPathValue(components || {}, path) || defaultComponent;
  }, [components]);
  var getRowKey = react.exports.useMemo(function() {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return function(record) {
      var key2 = record && record[rowKey];
      return key2;
    };
  }, [rowKey]);
  var expandableConfig = getExpandableProps(props);
  var expandIcon = expandableConfig.expandIcon, expandedRowKeys = expandableConfig.expandedRowKeys, defaultExpandedRowKeys = expandableConfig.defaultExpandedRowKeys, defaultExpandAllRows = expandableConfig.defaultExpandAllRows, expandedRowRender = expandableConfig.expandedRowRender, onExpand = expandableConfig.onExpand, onExpandedRowsChange = expandableConfig.onExpandedRowsChange, expandRowByClick = expandableConfig.expandRowByClick, rowExpandable = expandableConfig.rowExpandable, expandIconColumnIndex = expandableConfig.expandIconColumnIndex, expandedRowClassName = expandableConfig.expandedRowClassName, childrenColumnName = expandableConfig.childrenColumnName, indentSize = expandableConfig.indentSize;
  var mergedExpandIcon = expandIcon || renderExpandIcon$1;
  var mergedChildrenColumnName = childrenColumnName || "children";
  var expandableType = react.exports.useMemo(function() {
    if (expandedRowRender) {
      return "row";
    }
    if (props.expandable && internalHooks === INTERNAL_HOOKS && props.expandable.__PARENT_RENDER_ICON__ || mergedData.some(function(record) {
      return record && _typeof$4(record) === "object" && record[mergedChildrenColumnName];
    })) {
      return "nest";
    }
    return false;
  }, [!!expandedRowRender, mergedData]);
  var _React$useState = react.exports.useState(function() {
    if (defaultExpandedRowKeys) {
      return defaultExpandedRowKeys;
    }
    if (defaultExpandAllRows) {
      return findAllChildrenKeys(mergedData, getRowKey, mergedChildrenColumnName);
    }
    return [];
  }), _React$useState2 = _slicedToArray$3(_React$useState, 2), innerExpandedKeys = _React$useState2[0], setInnerExpandedKeys = _React$useState2[1];
  var mergedExpandedKeys = react.exports.useMemo(function() {
    return new Set(expandedRowKeys || innerExpandedKeys || []);
  }, [expandedRowKeys, innerExpandedKeys]);
  var onTriggerExpand = react.exports.useCallback(function(record) {
    var key2 = getRowKey(record, mergedData.indexOf(record));
    var newExpandedKeys;
    var hasKey = mergedExpandedKeys.has(key2);
    if (hasKey) {
      mergedExpandedKeys.delete(key2);
      newExpandedKeys = _toConsumableArray(mergedExpandedKeys);
    } else {
      newExpandedKeys = [].concat(_toConsumableArray(mergedExpandedKeys), [key2]);
    }
    setInnerExpandedKeys(newExpandedKeys);
    if (onExpand) {
      onExpand(!hasKey, record);
    }
    if (onExpandedRowsChange) {
      onExpandedRowsChange(newExpandedKeys);
    }
  }, [getRowKey, mergedExpandedKeys, mergedData, onExpand, onExpandedRowsChange]);
  var _React$useState3 = react.exports.useState(0), _React$useState4 = _slicedToArray$3(_React$useState3, 2), componentWidth = _React$useState4[0], setComponentWidth = _React$useState4[1];
  var _useColumns = useColumns(_objectSpread2$4(_objectSpread2$4(_objectSpread2$4({}, props), expandableConfig), {}, {
    expandable: !!expandedRowRender,
    expandedKeys: mergedExpandedKeys,
    getRowKey,
    onTriggerExpand,
    expandIcon: mergedExpandIcon,
    expandIconColumnIndex,
    direction
  }), internalHooks === INTERNAL_HOOKS ? transformColumns : null), _useColumns2 = _slicedToArray$3(_useColumns, 2), columns = _useColumns2[0], flattenColumns = _useColumns2[1];
  var columnContext = react.exports.useMemo(function() {
    return {
      columns,
      flattenColumns
    };
  }, [columns, flattenColumns]);
  var fullTableRef = react.exports.useRef();
  var scrollHeaderRef = react.exports.useRef();
  var scrollBodyRef = react.exports.useRef();
  var scrollBodyContainerRef = react.exports.useRef();
  var scrollSummaryRef = react.exports.useRef();
  var _React$useState5 = react.exports.useState(false), _React$useState6 = _slicedToArray$3(_React$useState5, 2), pingedLeft = _React$useState6[0], setPingedLeft = _React$useState6[1];
  var _React$useState7 = react.exports.useState(false), _React$useState8 = _slicedToArray$3(_React$useState7, 2), pingedRight = _React$useState8[0], setPingedRight = _React$useState8[1];
  var _useLayoutState = useLayoutState(/* @__PURE__ */ new Map()), _useLayoutState2 = _slicedToArray$3(_useLayoutState, 2), colsWidths = _useLayoutState2[0], updateColsWidths = _useLayoutState2[1];
  var colsKeys = getColumnsKey(flattenColumns);
  var pureColWidths = colsKeys.map(function(columnKey) {
    return colsWidths.get(columnKey);
  });
  var colWidths = react.exports.useMemo(function() {
    return pureColWidths;
  }, [pureColWidths.join("_")]);
  var stickyOffsets = useStickyOffsets(colWidths, flattenColumns.length, direction);
  var fixHeader = scroll && validateValue(scroll.y);
  var horizonScroll = scroll && validateValue(scroll.x) || Boolean(expandableConfig.fixed);
  var fixColumn = horizonScroll && flattenColumns.some(function(_ref2) {
    var fixed = _ref2.fixed;
    return fixed;
  });
  var stickyRef = react.exports.useRef();
  var _useSticky = useSticky(sticky, prefixCls), isSticky = _useSticky.isSticky, offsetHeader = _useSticky.offsetHeader, offsetSummary = _useSticky.offsetSummary, offsetScroll = _useSticky.offsetScroll, stickyClassName = _useSticky.stickyClassName, container = _useSticky.container;
  var summaryNode = summary === null || summary === void 0 ? void 0 : summary(mergedData);
  var fixFooter = (fixHeader || isSticky) && /* @__PURE__ */ react.exports.isValidElement(summaryNode) && summaryNode.type === Summary && summaryNode.props.fixed;
  var scrollXStyle;
  var scrollYStyle;
  var scrollTableStyle;
  if (fixHeader) {
    scrollYStyle = {
      overflowY: "scroll",
      maxHeight: scroll.y
    };
  }
  if (horizonScroll) {
    scrollXStyle = {
      overflowX: "auto"
    };
    if (!fixHeader) {
      scrollYStyle = {
        overflowY: "hidden"
      };
    }
    scrollTableStyle = {
      width: (scroll === null || scroll === void 0 ? void 0 : scroll.x) === true ? "auto" : scroll === null || scroll === void 0 ? void 0 : scroll.x,
      minWidth: "100%"
    };
  }
  var onColumnResize = react.exports.useCallback(function(columnKey, width) {
    if (isVisible(fullTableRef.current)) {
      updateColsWidths(function(widths) {
        if (widths.get(columnKey) !== width) {
          var newWidths = new Map(widths);
          newWidths.set(columnKey, width);
          return newWidths;
        }
        return widths;
      });
    }
  }, []);
  var _useTimeoutLock = useTimeoutLock(null), _useTimeoutLock2 = _slicedToArray$3(_useTimeoutLock, 2), setScrollTarget = _useTimeoutLock2[0], getScrollTarget = _useTimeoutLock2[1];
  function forceScroll(scrollLeft, target) {
    if (!target) {
      return;
    }
    if (typeof target === "function") {
      target(scrollLeft);
    } else if (target.scrollLeft !== scrollLeft) {
      target.scrollLeft = scrollLeft;
    }
  }
  var onScroll = function onScroll2(_ref3) {
    var currentTarget = _ref3.currentTarget, scrollLeft = _ref3.scrollLeft;
    var isRTL = direction === "rtl";
    var mergedScrollLeft = typeof scrollLeft === "number" ? scrollLeft : currentTarget.scrollLeft;
    var compareTarget = currentTarget || EMPTY_SCROLL_TARGET;
    if (!getScrollTarget() || getScrollTarget() === compareTarget) {
      var _stickyRef$current;
      setScrollTarget(compareTarget);
      forceScroll(mergedScrollLeft, scrollHeaderRef.current);
      forceScroll(mergedScrollLeft, scrollBodyRef.current);
      forceScroll(mergedScrollLeft, scrollSummaryRef.current);
      forceScroll(mergedScrollLeft, (_stickyRef$current = stickyRef.current) === null || _stickyRef$current === void 0 ? void 0 : _stickyRef$current.setScrollLeft);
    }
    if (currentTarget) {
      var scrollWidth = currentTarget.scrollWidth, clientWidth = currentTarget.clientWidth;
      if (scrollWidth === clientWidth) {
        setPingedLeft(false);
        setPingedRight(false);
        return;
      }
      if (isRTL) {
        setPingedLeft(-mergedScrollLeft < scrollWidth - clientWidth);
        setPingedRight(-mergedScrollLeft > 0);
      } else {
        setPingedLeft(mergedScrollLeft > 0);
        setPingedRight(mergedScrollLeft < scrollWidth - clientWidth);
      }
    }
  };
  var triggerOnScroll = function triggerOnScroll2() {
    if (horizonScroll && scrollBodyRef.current) {
      onScroll({
        currentTarget: scrollBodyRef.current
      });
    } else {
      setPingedLeft(false);
      setPingedRight(false);
    }
  };
  var onFullTableResize = function onFullTableResize2(_ref4) {
    var width = _ref4.width;
    if (width !== componentWidth) {
      triggerOnScroll();
      setComponentWidth(fullTableRef.current ? fullTableRef.current.offsetWidth : width);
    }
  };
  var mounted = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (mounted.current) {
      triggerOnScroll();
    }
  }, [horizonScroll, data2, columns.length]);
  react.exports.useEffect(function() {
    mounted.current = true;
  }, []);
  var _React$useState9 = react.exports.useState(0), _React$useState10 = _slicedToArray$3(_React$useState9, 2), scrollbarSize = _React$useState10[0], setScrollbarSize = _React$useState10[1];
  var _React$useState11 = react.exports.useState(true), _React$useState12 = _slicedToArray$3(_React$useState11, 2), supportSticky = _React$useState12[0], setSupportSticky = _React$useState12[1];
  react.exports.useEffect(function() {
    if (scrollBodyRef.current instanceof Element) {
      setScrollbarSize(getTargetScrollBarSize(scrollBodyRef.current).width);
    } else {
      setScrollbarSize(getTargetScrollBarSize(scrollBodyContainerRef.current).width);
    }
    setSupportSticky(isStyleSupport("position", "sticky"));
  }, []);
  react.exports.useEffect(function() {
    if (internalHooks === INTERNAL_HOOKS && internalRefs) {
      internalRefs.body.current = scrollBodyRef.current;
    }
  });
  var TableComponent = getComponent(["table"], "table");
  var mergedTableLayout = react.exports.useMemo(function() {
    if (tableLayout) {
      return tableLayout;
    }
    if (fixColumn) {
      return (scroll === null || scroll === void 0 ? void 0 : scroll.x) === "max-content" ? "auto" : "fixed";
    }
    if (fixHeader || isSticky || flattenColumns.some(function(_ref5) {
      var ellipsis = _ref5.ellipsis;
      return ellipsis;
    })) {
      return "fixed";
    }
    return "auto";
  }, [fixHeader, fixColumn, flattenColumns, tableLayout, isSticky]);
  var groupTableNode;
  var headerProps = {
    colWidths,
    columCount: flattenColumns.length,
    stickyOffsets,
    onHeaderRow,
    fixHeader,
    scroll
  };
  var emptyNode = react.exports.useMemo(function() {
    if (hasData) {
      return null;
    }
    if (typeof emptyText2 === "function") {
      return emptyText2();
    }
    return emptyText2;
  }, [hasData, emptyText2]);
  var bodyTable = /* @__PURE__ */ react.exports.createElement(MemoBody, {
    data: mergedData,
    measureColumnWidth: fixHeader || horizonScroll || isSticky,
    expandedKeys: mergedExpandedKeys,
    rowExpandable,
    getRowKey,
    onRow,
    emptyNode,
    childrenColumnName: mergedChildrenColumnName
  });
  var bodyColGroup = /* @__PURE__ */ react.exports.createElement(ColGroup, {
    colWidths: flattenColumns.map(function(_ref6) {
      var width = _ref6.width;
      return width;
    }),
    columns: flattenColumns
  });
  var customizeScrollBody = getComponent(["body"]);
  if (fixHeader || isSticky) {
    var bodyContent;
    if (typeof customizeScrollBody === "function") {
      bodyContent = customizeScrollBody(mergedData, {
        scrollbarSize,
        ref: scrollBodyRef,
        onScroll
      });
      headerProps.colWidths = flattenColumns.map(function(_ref7, index2) {
        var width = _ref7.width;
        var colWidth = index2 === columns.length - 1 ? width - scrollbarSize : width;
        if (typeof colWidth === "number" && !Number.isNaN(colWidth)) {
          return colWidth;
        }
        warningOnce(false, "When use `components.body` with render props. Each column should have a fixed `width` value.");
        return 0;
      });
    } else {
      bodyContent = /* @__PURE__ */ react.exports.createElement("div", {
        style: _objectSpread2$4(_objectSpread2$4({}, scrollXStyle), scrollYStyle),
        onScroll,
        ref: scrollBodyRef,
        className: classnamesExports("".concat(prefixCls, "-body"))
      }, /* @__PURE__ */ react.exports.createElement(TableComponent, {
        style: _objectSpread2$4(_objectSpread2$4({}, scrollTableStyle), {}, {
          tableLayout: mergedTableLayout
        })
      }, bodyColGroup, bodyTable, !fixFooter && summaryNode && /* @__PURE__ */ react.exports.createElement(Footer, {
        stickyOffsets,
        flattenColumns
      }, summaryNode)));
    }
    var fixedHolderProps = _objectSpread2$4(_objectSpread2$4(_objectSpread2$4({
      noData: !mergedData.length,
      maxContentScroll: horizonScroll && scroll.x === "max-content"
    }, headerProps), columnContext), {}, {
      direction,
      stickyClassName,
      onScroll
    });
    groupTableNode = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, showHeader !== false && /* @__PURE__ */ react.exports.createElement(FixedHolder, _extends$2({}, fixedHolderProps, {
      stickyTopOffset: offsetHeader,
      className: "".concat(prefixCls, "-header"),
      ref: scrollHeaderRef
    }), function(fixedHolderPassProps) {
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Header, fixedHolderPassProps), fixFooter === "top" && /* @__PURE__ */ react.exports.createElement(Footer, fixedHolderPassProps, summaryNode));
    }), bodyContent, fixFooter && fixFooter !== "top" && /* @__PURE__ */ react.exports.createElement(FixedHolder, _extends$2({}, fixedHolderProps, {
      stickyBottomOffset: offsetSummary,
      className: "".concat(prefixCls, "-summary"),
      ref: scrollSummaryRef
    }), function(fixedHolderPassProps) {
      return /* @__PURE__ */ react.exports.createElement(Footer, fixedHolderPassProps, summaryNode);
    }), isSticky && /* @__PURE__ */ react.exports.createElement(StickyScrollBar$1, {
      ref: stickyRef,
      offsetScroll,
      scrollBodyRef,
      onScroll,
      container
    }));
  } else {
    groupTableNode = /* @__PURE__ */ react.exports.createElement("div", {
      style: _objectSpread2$4(_objectSpread2$4({}, scrollXStyle), scrollYStyle),
      className: classnamesExports("".concat(prefixCls, "-content")),
      onScroll,
      ref: scrollBodyRef
    }, /* @__PURE__ */ react.exports.createElement(TableComponent, {
      style: _objectSpread2$4(_objectSpread2$4({}, scrollTableStyle), {}, {
        tableLayout: mergedTableLayout
      })
    }, bodyColGroup, showHeader !== false && /* @__PURE__ */ react.exports.createElement(Header, _extends$2({}, headerProps, columnContext)), bodyTable, summaryNode && /* @__PURE__ */ react.exports.createElement(Footer, {
      stickyOffsets,
      flattenColumns
    }, summaryNode)));
  }
  var ariaProps = pickAttrs(props, {
    aria: true,
    data: true
  });
  var fullTable = /* @__PURE__ */ react.exports.createElement("div", _extends$2({
    className: classnamesExports(prefixCls, className, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _defineProperty$5(_classNames, "".concat(prefixCls, "-ping-left"), pingedLeft), _defineProperty$5(_classNames, "".concat(prefixCls, "-ping-right"), pingedRight), _defineProperty$5(_classNames, "".concat(prefixCls, "-layout-fixed"), tableLayout === "fixed"), _defineProperty$5(_classNames, "".concat(prefixCls, "-fixed-header"), fixHeader), _defineProperty$5(_classNames, "".concat(prefixCls, "-fixed-column"), fixColumn), _defineProperty$5(_classNames, "".concat(prefixCls, "-scroll-horizontal"), horizonScroll), _defineProperty$5(_classNames, "".concat(prefixCls, "-has-fix-left"), flattenColumns[0] && flattenColumns[0].fixed), _defineProperty$5(_classNames, "".concat(prefixCls, "-has-fix-right"), flattenColumns[flattenColumns.length - 1] && flattenColumns[flattenColumns.length - 1].fixed === "right"), _classNames)),
    style: style2,
    id: id2,
    ref: fullTableRef
  }, ariaProps), /* @__PURE__ */ react.exports.createElement(MemoTableContent, {
    pingLeft: pingedLeft,
    pingRight: pingedRight,
    props: _objectSpread2$4(_objectSpread2$4({}, props), {}, {
      stickyOffsets,
      mergedExpandedKeys
    })
  }, title && /* @__PURE__ */ react.exports.createElement(Panel, {
    className: "".concat(prefixCls, "-title")
  }, title(mergedData)), /* @__PURE__ */ react.exports.createElement("div", {
    ref: scrollBodyContainerRef,
    className: "".concat(prefixCls, "-container")
  }, groupTableNode), footer && /* @__PURE__ */ react.exports.createElement(Panel, {
    className: "".concat(prefixCls, "-footer")
  }, footer(mergedData))));
  if (horizonScroll) {
    fullTable = /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
      onResize: onFullTableResize
    }, fullTable);
  }
  var TableContextValue = react.exports.useMemo(function() {
    return {
      prefixCls,
      getComponent,
      scrollbarSize,
      direction,
      fixedInfoList: flattenColumns.map(function(_, colIndex) {
        return getCellFixedInfo(colIndex, colIndex, flattenColumns, stickyOffsets, direction);
      }),
      isSticky
    };
  }, [prefixCls, getComponent, scrollbarSize, direction, flattenColumns, stickyOffsets, isSticky]);
  var BodyContextValue = react.exports.useMemo(function() {
    return _objectSpread2$4(_objectSpread2$4({}, columnContext), {}, {
      tableLayout: mergedTableLayout,
      rowClassName,
      expandedRowClassName,
      expandIcon: mergedExpandIcon,
      expandableType,
      expandRowByClick,
      expandedRowRender,
      onTriggerExpand,
      expandIconColumnIndex,
      indentSize,
      allColumnsFixedLeft: columnContext.flattenColumns.every(function(col) {
        return col.fixed === "left";
      })
    });
  }, [columnContext, mergedTableLayout, rowClassName, expandedRowClassName, mergedExpandIcon, expandableType, expandRowByClick, expandedRowRender, onTriggerExpand, expandIconColumnIndex, indentSize]);
  var ExpandedRowContextValue = react.exports.useMemo(function() {
    return {
      componentWidth,
      fixHeader,
      fixColumn,
      horizonScroll
    };
  }, [componentWidth, fixHeader, fixColumn, horizonScroll]);
  var ResizeContextValue = react.exports.useMemo(function() {
    return {
      onColumnResize
    };
  }, [onColumnResize]);
  return /* @__PURE__ */ react.exports.createElement(StickyContext.Provider, {
    value: supportSticky
  }, /* @__PURE__ */ react.exports.createElement(TableContext.Provider, {
    value: TableContextValue
  }, /* @__PURE__ */ react.exports.createElement(BodyContext.Provider, {
    value: BodyContextValue
  }, /* @__PURE__ */ react.exports.createElement(ExpandedRowContext.Provider, {
    value: ExpandedRowContextValue
  }, /* @__PURE__ */ react.exports.createElement(ResizeContext.Provider, {
    value: ResizeContextValue
  }, fullTable)))));
}
Table$2.EXPAND_COLUMN = EXPAND_COLUMN;
Table$2.Column = Column$1;
Table$2.ColumnGroup = ColumnGroup$1;
Table$2.Summary = FooterComponents;
Table$2.defaultProps = {
  rowKey: "key",
  prefixCls: "rc-table",
  emptyText: function emptyText() {
    return "No Data";
  }
};
function Column(_) {
  return null;
}
function ColumnGroup(_) {
  return null;
}
function renderExpandIcon(locale2) {
  return function expandIcon(_ref) {
    var _classNames;
    var prefixCls = _ref.prefixCls, onExpand = _ref.onExpand, record = _ref.record, expanded = _ref.expanded, expandable = _ref.expandable;
    var iconPrefix = "".concat(prefixCls, "-row-expand-icon");
    return /* @__PURE__ */ react.exports.createElement("button", {
      type: "button",
      onClick: function onClick(e2) {
        onExpand(record, e2);
        e2.stopPropagation();
      },
      className: classnamesExports(iconPrefix, (_classNames = {}, _defineProperty$5(_classNames, "".concat(iconPrefix, "-spaced"), !expandable), _defineProperty$5(_classNames, "".concat(iconPrefix, "-expanded"), expandable && expanded), _defineProperty$5(_classNames, "".concat(iconPrefix, "-collapsed"), expandable && !expanded), _classNames)),
      "aria-label": expanded ? locale2.collapse : locale2.expand,
      "aria-expanded": expanded
    });
  };
}
function getColumnKey(column, defaultKey) {
  if ("key" in column && column.key !== void 0 && column.key !== null) {
    return column.key;
  }
  if (column.dataIndex) {
    return Array.isArray(column.dataIndex) ? column.dataIndex.join(".") : column.dataIndex;
  }
  return defaultKey;
}
function getColumnPos(index2, pos) {
  return pos ? "".concat(pos, "-").concat(index2) : "".concat(index2);
}
function renderColumnTitle(title, props) {
  if (typeof title === "function") {
    return title(props);
  }
  return title;
}
var FilterFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, "name": "filter", "theme": "filled" };
const FilterFilledSvg = FilterFilled$2;
var FilterFilled = function FilterFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: FilterFilledSvg
  }));
};
FilterFilled.displayName = "FilterFilled";
const FilterFilled$1 = /* @__PURE__ */ react.exports.forwardRef(FilterFilled);
var HolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M300 276.5a56 56 0 1056-97 56 56 0 00-56 97zm0 284a56 56 0 1056-97 56 56 0 00-56 97zM640 228a56 56 0 10112 0 56 56 0 00-112 0zm0 284a56 56 0 10112 0 56 56 0 00-112 0zM300 844.5a56 56 0 1056-97 56 56 0 00-56 97zM640 796a56 56 0 10112 0 56 56 0 00-112 0z" } }] }, "name": "holder", "theme": "outlined" };
const HolderOutlinedSvg = HolderOutlined$2;
var HolderOutlined = function HolderOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: HolderOutlinedSvg
  }));
};
HolderOutlined.displayName = "HolderOutlined";
const HolderOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(HolderOutlined);
var _excluded$1 = ["className", "style", "motion", "motionNodes", "motionType", "onMotionStart", "onMotionEnd", "active", "treeNodeRequiredProps"];
var MotionTreeNode = function MotionTreeNode2(_ref, ref) {
  var className = _ref.className, style2 = _ref.style, motion = _ref.motion, motionNodes = _ref.motionNodes, motionType = _ref.motionType, onOriginMotionStart = _ref.onMotionStart, onOriginMotionEnd = _ref.onMotionEnd, active = _ref.active, treeNodeRequiredProps = _ref.treeNodeRequiredProps, props = _objectWithoutProperties$1(_ref, _excluded$1);
  var _React$useState = react.exports.useState(true), _React$useState2 = _slicedToArray$3(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
  var _React$useContext = react.exports.useContext(TreeContext), prefixCls = _React$useContext.prefixCls;
  var motionedRef = react.exports.useRef(false);
  var onMotionEnd = function onMotionEnd2() {
    if (!motionedRef.current) {
      onOriginMotionEnd();
    }
    motionedRef.current = true;
  };
  react.exports.useEffect(function() {
    if (motionNodes && motionType === "hide" && visible) {
      setVisible(false);
    }
  }, [motionNodes]);
  react.exports.useEffect(function() {
    if (motionNodes) {
      onOriginMotionStart();
    }
    return function() {
      if (motionNodes) {
        onMotionEnd();
      }
    };
  }, []);
  if (motionNodes) {
    return /* @__PURE__ */ react.exports.createElement(CSSMotion, _extends$2({
      ref,
      visible
    }, motion, {
      motionAppear: motionType === "show",
      onAppearEnd: onMotionEnd,
      onLeaveEnd: onMotionEnd
    }), function(_ref2, motionRef) {
      var motionClassName = _ref2.className, motionStyle = _ref2.style;
      return /* @__PURE__ */ react.exports.createElement("div", {
        ref: motionRef,
        className: classnamesExports("".concat(prefixCls, "-treenode-motion"), motionClassName),
        style: motionStyle
      }, motionNodes.map(function(treeNode) {
        var restProps = _extends$2({}, treeNode.data), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
        delete restProps.children;
        var treeNodeProps = getTreeNodeProps(key2, treeNodeRequiredProps);
        return /* @__PURE__ */ react.exports.createElement(ContextTreeNode, _extends$2({}, restProps, treeNodeProps, {
          title,
          active,
          data: treeNode.data,
          key: key2,
          isStart,
          isEnd
        }));
      }));
    });
  }
  return /* @__PURE__ */ react.exports.createElement(ContextTreeNode, _extends$2({
    domRef: ref,
    className,
    style: style2
  }, props, {
    active
  }));
};
MotionTreeNode.displayName = "MotionTreeNode";
var RefMotionTreeNode = /* @__PURE__ */ react.exports.forwardRef(MotionTreeNode);
function findExpandedKeys() {
  var prev = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var next = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var prevLen = prev.length;
  var nextLen = next.length;
  if (Math.abs(prevLen - nextLen) !== 1) {
    return {
      add: false,
      key: null
    };
  }
  function find2(shorter, longer) {
    var cache2 = /* @__PURE__ */ new Map();
    shorter.forEach(function(key2) {
      cache2.set(key2, true);
    });
    var keys2 = longer.filter(function(key2) {
      return !cache2.has(key2);
    });
    return keys2.length === 1 ? keys2[0] : null;
  }
  if (prevLen < nextLen) {
    return {
      add: true,
      key: find2(prev, next)
    };
  }
  return {
    add: false,
    key: find2(next, prev)
  };
}
function getExpandRange(shorter, longer, key2) {
  var shorterStartIndex = shorter.findIndex(function(data2) {
    return data2.key === key2;
  });
  var shorterEndNode = shorter[shorterStartIndex + 1];
  var longerStartIndex = longer.findIndex(function(data2) {
    return data2.key === key2;
  });
  if (shorterEndNode) {
    var longerEndIndex = longer.findIndex(function(data2) {
      return data2.key === shorterEndNode.key;
    });
    return longer.slice(longerStartIndex + 1, longerEndIndex);
  }
  return longer.slice(longerStartIndex + 1);
}
var _excluded = ["prefixCls", "data", "selectable", "checkable", "expandedKeys", "selectedKeys", "checkedKeys", "loadedKeys", "loadingKeys", "halfCheckedKeys", "keyEntities", "disabled", "dragging", "dragOverNodeKey", "dropPosition", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabIndex", "onKeyDown", "onFocus", "onBlur", "onActiveChange", "onListChangeStart", "onListChangeEnd"];
var HIDDEN_STYLE = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
};
var noop = function noop2() {
};
var MOTION_KEY = "RC_TREE_MOTION_".concat(Math.random());
var MotionNode = {
  key: MOTION_KEY
};
var MotionEntity = {
  key: MOTION_KEY,
  level: 0,
  index: 0,
  pos: "0",
  node: MotionNode,
  nodes: [MotionNode]
};
var MotionFlattenData = {
  parent: null,
  children: [],
  pos: MotionEntity.pos,
  data: MotionNode,
  title: null,
  key: MOTION_KEY,
  isStart: [],
  isEnd: []
};
function getMinimumRangeTransitionRange(list2, virtual2, height, itemHeight) {
  if (virtual2 === false || !height) {
    return list2;
  }
  return list2.slice(0, Math.ceil(height / itemHeight) + 1);
}
function itemKey(item) {
  var key2 = item.key, pos = item.pos;
  return getKey(key2, pos);
}
function getAccessibilityPath(item) {
  var path = String(item.data.key);
  var current = item;
  while (current.parent) {
    current = current.parent;
    path = "".concat(current.data.key, " > ").concat(path);
  }
  return path;
}
var NodeList = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, data2 = props.data;
  props.selectable;
  props.checkable;
  var expandedKeys = props.expandedKeys, selectedKeys = props.selectedKeys, checkedKeys = props.checkedKeys, loadedKeys = props.loadedKeys, loadingKeys = props.loadingKeys, halfCheckedKeys = props.halfCheckedKeys, keyEntities = props.keyEntities, disabled = props.disabled, dragging = props.dragging, dragOverNodeKey = props.dragOverNodeKey, dropPosition = props.dropPosition, motion = props.motion, height = props.height, itemHeight = props.itemHeight, virtual2 = props.virtual, focusable2 = props.focusable, activeItem = props.activeItem, focused = props.focused, tabIndex = props.tabIndex, onKeyDown2 = props.onKeyDown, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onActiveChange = props.onActiveChange, onListChangeStart = props.onListChangeStart, onListChangeEnd = props.onListChangeEnd, domProps = _objectWithoutProperties$1(props, _excluded);
  var listRef = react.exports.useRef(null);
  var indentMeasurerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return {
      scrollTo: function scrollTo2(scroll) {
        listRef.current.scrollTo(scroll);
      },
      getIndentWidth: function getIndentWidth() {
        return indentMeasurerRef.current.offsetWidth;
      }
    };
  });
  var _React$useState = react.exports.useState(expandedKeys), _React$useState2 = _slicedToArray$3(_React$useState, 2), prevExpandedKeys = _React$useState2[0], setPrevExpandedKeys = _React$useState2[1];
  var _React$useState3 = react.exports.useState(data2), _React$useState4 = _slicedToArray$3(_React$useState3, 2), prevData = _React$useState4[0], setPrevData = _React$useState4[1];
  var _React$useState5 = react.exports.useState(data2), _React$useState6 = _slicedToArray$3(_React$useState5, 2), transitionData = _React$useState6[0], setTransitionData = _React$useState6[1];
  var _React$useState7 = react.exports.useState([]), _React$useState8 = _slicedToArray$3(_React$useState7, 2), transitionRange = _React$useState8[0], setTransitionRange = _React$useState8[1];
  var _React$useState9 = react.exports.useState(null), _React$useState10 = _slicedToArray$3(_React$useState9, 2), motionType = _React$useState10[0], setMotionType = _React$useState10[1];
  var dataRef = react.exports.useRef(data2);
  dataRef.current = data2;
  function onMotionEnd() {
    var latestData = dataRef.current;
    setPrevData(latestData);
    setTransitionData(latestData);
    setTransitionRange([]);
    setMotionType(null);
    onListChangeEnd();
  }
  react.exports.useEffect(function() {
    setPrevExpandedKeys(expandedKeys);
    var diffExpanded = findExpandedKeys(prevExpandedKeys, expandedKeys);
    if (diffExpanded.key !== null) {
      if (diffExpanded.add) {
        var keyIndex = prevData.findIndex(function(_ref) {
          var key2 = _ref.key;
          return key2 === diffExpanded.key;
        });
        var rangeNodes = getMinimumRangeTransitionRange(getExpandRange(prevData, data2, diffExpanded.key), virtual2, height, itemHeight);
        var newTransitionData = prevData.slice();
        newTransitionData.splice(keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(newTransitionData);
        setTransitionRange(rangeNodes);
        setMotionType("show");
      } else {
        var _keyIndex = data2.findIndex(function(_ref2) {
          var key2 = _ref2.key;
          return key2 === diffExpanded.key;
        });
        var _rangeNodes = getMinimumRangeTransitionRange(getExpandRange(data2, prevData, diffExpanded.key), virtual2, height, itemHeight);
        var _newTransitionData = data2.slice();
        _newTransitionData.splice(_keyIndex + 1, 0, MotionFlattenData);
        setTransitionData(_newTransitionData);
        setTransitionRange(_rangeNodes);
        setMotionType("hide");
      }
    } else if (prevData !== data2) {
      setPrevData(data2);
      setTransitionData(data2);
    }
  }, [expandedKeys, data2]);
  react.exports.useEffect(function() {
    if (!dragging) {
      onMotionEnd();
    }
  }, [dragging]);
  var mergedData = motion ? transitionData : data2;
  var treeNodeRequiredProps = {
    expandedKeys,
    selectedKeys,
    loadedKeys,
    loadingKeys,
    checkedKeys,
    halfCheckedKeys,
    dragOverNodeKey,
    dropPosition,
    keyEntities
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, focused && activeItem && /* @__PURE__ */ react.exports.createElement("span", {
    style: HIDDEN_STYLE,
    "aria-live": "assertive"
  }, getAccessibilityPath(activeItem)), /* @__PURE__ */ react.exports.createElement("div", null, /* @__PURE__ */ react.exports.createElement("input", {
    style: HIDDEN_STYLE,
    disabled: focusable2 === false || disabled,
    tabIndex: focusable2 !== false ? tabIndex : null,
    onKeyDown: onKeyDown2,
    onFocus: onFocus2,
    onBlur: onBlur2,
    value: "",
    onChange: noop,
    "aria-label": "for screen reader"
  })), /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-treenode"),
    "aria-hidden": true,
    style: {
      position: "absolute",
      pointerEvents: "none",
      visibility: "hidden",
      height: 0,
      overflow: "hidden"
    }
  }, /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-indent")
  }, /* @__PURE__ */ react.exports.createElement("div", {
    ref: indentMeasurerRef,
    className: "".concat(prefixCls, "-indent-unit")
  }))), /* @__PURE__ */ react.exports.createElement(List$2, _extends$2({}, domProps, {
    data: mergedData,
    itemKey,
    height,
    fullHeight: false,
    virtual: virtual2,
    itemHeight,
    prefixCls: "".concat(prefixCls, "-list"),
    ref: listRef,
    onVisibleChange: function onVisibleChange(originList, fullList) {
      var originSet = new Set(originList);
      var restList = fullList.filter(function(item) {
        return !originSet.has(item);
      });
      if (restList.some(function(item) {
        return itemKey(item) === MOTION_KEY;
      })) {
        onMotionEnd();
      }
    }
  }), function(treeNode) {
    var pos = treeNode.pos, restProps = _extends$2({}, treeNode.data), title = treeNode.title, key2 = treeNode.key, isStart = treeNode.isStart, isEnd = treeNode.isEnd;
    var mergedKey = getKey(key2, pos);
    delete restProps.key;
    delete restProps.children;
    var treeNodeProps = getTreeNodeProps(mergedKey, treeNodeRequiredProps);
    return /* @__PURE__ */ react.exports.createElement(RefMotionTreeNode, _extends$2({}, restProps, treeNodeProps, {
      title,
      active: !!activeItem && key2 === activeItem.key,
      pos,
      data: treeNode.data,
      isStart,
      isEnd,
      motion,
      motionNodes: key2 === MOTION_KEY ? transitionRange : null,
      motionType,
      onMotionStart: onListChangeStart,
      onMotionEnd,
      treeNodeRequiredProps,
      onMouseMove: function onMouseMove() {
        onActiveChange(null);
      }
    }));
  }));
});
NodeList.displayName = "NodeList";
function DropIndicator(_ref) {
  var dropPosition = _ref.dropPosition, dropLevelOffset = _ref.dropLevelOffset, indent = _ref.indent;
  var style2 = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: 2
  };
  switch (dropPosition) {
    case -1:
      style2.top = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 1:
      style2.bottom = 0;
      style2.left = -dropLevelOffset * indent;
      break;
    case 0:
      style2.bottom = 0;
      style2.left = indent;
      break;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    style: style2
  });
}
var MAX_RETRY_TIMES = 10;
var Tree$2 = /* @__PURE__ */ function(_React$Component) {
  _inherits$1(Tree2, _React$Component);
  var _super = _createSuper$1(Tree2);
  function Tree2() {
    var _this;
    _classCallCheck$2(this, Tree2);
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(_args));
    _this.destroyed = false;
    _this.delayedDragEnterLogic = void 0;
    _this.loadingRetryTimes = {};
    _this.state = {
      keyEntities: {},
      indent: null,
      selectedKeys: [],
      checkedKeys: [],
      halfCheckedKeys: [],
      loadedKeys: [],
      loadingKeys: [],
      expandedKeys: [],
      draggingNodeKey: null,
      dragChildrenKeys: [],
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: true,
      dragOverNodeKey: null,
      treeData: [],
      flattenNodes: [],
      focused: false,
      activeKey: null,
      listChanging: false,
      prevProps: null,
      fieldNames: fillFieldNames()
    };
    _this.dragStartMousePosition = null;
    _this.dragNode = void 0;
    _this.currentMouseOverDroppableNodeKey = null;
    _this.listRef = /* @__PURE__ */ react.exports.createRef();
    _this.onNodeDragStart = function(event, node) {
      var _this$state = _this.state, expandedKeys = _this$state.expandedKeys, keyEntities = _this$state.keyEntities;
      var onDragStart = _this.props.onDragStart;
      var eventKey = node.props.eventKey;
      _this.dragNode = node;
      _this.dragStartMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
      var newExpandedKeys = arrDel(expandedKeys, eventKey);
      _this.setState({
        draggingNodeKey: eventKey,
        dragChildrenKeys: getDragChildrenKeys(eventKey, keyEntities),
        indent: _this.listRef.current.getIndentWidth()
      });
      _this.setExpandedKeys(newExpandedKeys);
      window.addEventListener("dragend", _this.onWindowDragEnd);
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragEnter = function(event, node) {
      var _this$state2 = _this.state, expandedKeys = _this$state2.expandedKeys, keyEntities = _this$state2.keyEntities, dragChildrenKeys = _this$state2.dragChildrenKeys, flattenNodes = _this$state2.flattenNodes, indent = _this$state2.indent;
      var _this$props = _this.props, onDragEnter = _this$props.onDragEnter, onExpand = _this$props.onExpand, allowDrop2 = _this$props.allowDrop, direction = _this$props.direction;
      var _node$props = node.props, pos = _node$props.pos, eventKey = _node$props.eventKey;
      var _assertThisInitialize = _assertThisInitialized$1(_this), dragNode = _assertThisInitialize.dragNode;
      if (_this.currentMouseOverDroppableNodeKey !== eventKey) {
        _this.currentMouseOverDroppableNodeKey = eventKey;
      }
      if (!dragNode) {
        _this.resetDragState();
        return;
      }
      var _calcDropPosition = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition.dropPosition, dropLevelOffset = _calcDropPosition.dropLevelOffset, dropTargetKey = _calcDropPosition.dropTargetKey, dropContainerKey = _calcDropPosition.dropContainerKey, dropTargetPos = _calcDropPosition.dropTargetPos, dropAllowed = _calcDropPosition.dropAllowed, dragOverNodeKey = _calcDropPosition.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        _this.resetDragState();
        return;
      }
      if (!_this.delayedDragEnterLogic) {
        _this.delayedDragEnterLogic = {};
      }
      Object.keys(_this.delayedDragEnterLogic).forEach(function(key2) {
        clearTimeout(_this.delayedDragEnterLogic[key2]);
      });
      if (dragNode.props.eventKey !== node.props.eventKey) {
        event.persist();
        _this.delayedDragEnterLogic[pos] = window.setTimeout(function() {
          if (_this.state.draggingNodeKey === null)
            return;
          var newExpandedKeys = _toConsumableArray(expandedKeys);
          var entity = keyEntities[node.props.eventKey];
          if (entity && (entity.children || []).length) {
            newExpandedKeys = arrAdd(expandedKeys, node.props.eventKey);
          }
          if (!("expandedKeys" in _this.props)) {
            _this.setExpandedKeys(newExpandedKeys);
          }
          onExpand === null || onExpand === void 0 ? void 0 : onExpand(newExpandedKeys, {
            node: convertNodePropsToEventData(node.props),
            expanded: true,
            nativeEvent: event.nativeEvent
          });
        }, 800);
      }
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        _this.resetDragState();
        return;
      }
      _this.setState({
        dragOverNodeKey,
        dropPosition,
        dropLevelOffset,
        dropTargetKey,
        dropContainerKey,
        dropTargetPos,
        dropAllowed
      });
      onDragEnter === null || onDragEnter === void 0 ? void 0 : onDragEnter({
        event,
        node: convertNodePropsToEventData(node.props),
        expandedKeys
      });
    };
    _this.onNodeDragOver = function(event, node) {
      var _this$state3 = _this.state, dragChildrenKeys = _this$state3.dragChildrenKeys, flattenNodes = _this$state3.flattenNodes, keyEntities = _this$state3.keyEntities, expandedKeys = _this$state3.expandedKeys, indent = _this$state3.indent;
      var _this$props2 = _this.props, onDragOver = _this$props2.onDragOver, allowDrop2 = _this$props2.allowDrop, direction = _this$props2.direction;
      var _assertThisInitialize2 = _assertThisInitialized$1(_this), dragNode = _assertThisInitialize2.dragNode;
      if (!dragNode) {
        return;
      }
      var _calcDropPosition2 = calcDropPosition(event, dragNode, node, indent, _this.dragStartMousePosition, allowDrop2, flattenNodes, keyEntities, expandedKeys, direction), dropPosition = _calcDropPosition2.dropPosition, dropLevelOffset = _calcDropPosition2.dropLevelOffset, dropTargetKey = _calcDropPosition2.dropTargetKey, dropContainerKey = _calcDropPosition2.dropContainerKey, dropAllowed = _calcDropPosition2.dropAllowed, dropTargetPos = _calcDropPosition2.dropTargetPos, dragOverNodeKey = _calcDropPosition2.dragOverNodeKey;
      if (dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {
        return;
      }
      if (dragNode.props.eventKey === dropTargetKey && dropLevelOffset === 0) {
        if (!(_this.state.dropPosition === null && _this.state.dropLevelOffset === null && _this.state.dropTargetKey === null && _this.state.dropContainerKey === null && _this.state.dropTargetPos === null && _this.state.dropAllowed === false && _this.state.dragOverNodeKey === null)) {
          _this.resetDragState();
        }
      } else if (!(dropPosition === _this.state.dropPosition && dropLevelOffset === _this.state.dropLevelOffset && dropTargetKey === _this.state.dropTargetKey && dropContainerKey === _this.state.dropContainerKey && dropTargetPos === _this.state.dropTargetPos && dropAllowed === _this.state.dropAllowed && dragOverNodeKey === _this.state.dragOverNodeKey)) {
        _this.setState({
          dropPosition,
          dropLevelOffset,
          dropTargetKey,
          dropContainerKey,
          dropTargetPos,
          dropAllowed,
          dragOverNodeKey
        });
      }
      onDragOver === null || onDragOver === void 0 ? void 0 : onDragOver({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onNodeDragLeave = function(event, node) {
      if (_this.currentMouseOverDroppableNodeKey === node.props.eventKey && !event.currentTarget.contains(event.relatedTarget)) {
        _this.resetDragState();
        _this.currentMouseOverDroppableNodeKey = null;
      }
      var onDragLeave = _this.props.onDragLeave;
      onDragLeave === null || onDragLeave === void 0 ? void 0 : onDragLeave({
        event,
        node: convertNodePropsToEventData(node.props)
      });
    };
    _this.onWindowDragEnd = function(event) {
      _this.onNodeDragEnd(event, null, true);
      window.removeEventListener("dragend", _this.onWindowDragEnd);
    };
    _this.onNodeDragEnd = function(event, node) {
      var onDragEnd = _this.props.onDragEnd;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd({
        event,
        node: convertNodePropsToEventData(node.props)
      });
      _this.dragNode = null;
      window.removeEventListener("dragend", _this.onWindowDragEnd);
    };
    _this.onNodeDrop = function(event, node) {
      var _this$getActiveItem;
      var outsideTree = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var _this$state4 = _this.state, dragChildrenKeys = _this$state4.dragChildrenKeys, dropPosition = _this$state4.dropPosition, dropTargetKey = _this$state4.dropTargetKey, dropTargetPos = _this$state4.dropTargetPos, dropAllowed = _this$state4.dropAllowed;
      if (!dropAllowed)
        return;
      var onDrop = _this.props.onDrop;
      _this.setState({
        dragOverNodeKey: null
      });
      _this.cleanDragState();
      if (dropTargetKey === null)
        return;
      var abstractDropNodeProps = _objectSpread2$4(_objectSpread2$4({}, getTreeNodeProps(dropTargetKey, _this.getTreeNodeRequiredProps())), {}, {
        active: ((_this$getActiveItem = _this.getActiveItem()) === null || _this$getActiveItem === void 0 ? void 0 : _this$getActiveItem.key) === dropTargetKey,
        data: _this.state.keyEntities[dropTargetKey].node
      });
      var dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;
      warningOnce(!dropToChild, "Can not drop to dragNode's children node. This is a bug of rc-tree. Please report an issue.");
      var posArr = posToArr(dropTargetPos);
      var dropResult = {
        event,
        node: convertNodePropsToEventData(abstractDropNodeProps),
        dragNode: _this.dragNode ? convertNodePropsToEventData(_this.dragNode.props) : null,
        dragNodesKeys: [_this.dragNode.props.eventKey].concat(dragChildrenKeys),
        dropToGap: dropPosition !== 0,
        dropPosition: dropPosition + Number(posArr[posArr.length - 1])
      };
      if (!outsideTree) {
        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);
      }
      _this.dragNode = null;
    };
    _this.cleanDragState = function() {
      var draggingNodeKey = _this.state.draggingNodeKey;
      if (draggingNodeKey !== null) {
        _this.setState({
          draggingNodeKey: null,
          dropPosition: null,
          dropContainerKey: null,
          dropTargetKey: null,
          dropLevelOffset: null,
          dropAllowed: true,
          dragOverNodeKey: null
        });
      }
      _this.dragStartMousePosition = null;
      _this.currentMouseOverDroppableNodeKey = null;
    };
    _this.triggerExpandActionExpand = function(e2, treeNode) {
      var _this$state5 = _this.state, expandedKeys = _this$state5.expandedKeys, flattenNodes = _this$state5.flattenNodes;
      var expanded = treeNode.expanded, key2 = treeNode.key, isLeaf = treeNode.isLeaf;
      if (isLeaf || e2.shiftKey || e2.metaKey || e2.ctrlKey) {
        return;
      }
      var node = flattenNodes.filter(function(nodeItem) {
        return nodeItem.key === key2;
      })[0];
      var eventNode = convertNodePropsToEventData(_objectSpread2$4(_objectSpread2$4({}, getTreeNodeProps(key2, _this.getTreeNodeRequiredProps())), {}, {
        data: node.data
      }));
      _this.setExpandedKeys(expanded ? arrDel(expandedKeys, key2) : arrAdd(expandedKeys, key2));
      _this.onNodeExpand(e2, eventNode);
    };
    _this.onNodeClick = function(e2, treeNode) {
      var _this$props3 = _this.props, onClick = _this$props3.onClick, expandAction = _this$props3.expandAction;
      if (expandAction === "click") {
        _this.triggerExpandActionExpand(e2, treeNode);
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(e2, treeNode);
    };
    _this.onNodeDoubleClick = function(e2, treeNode) {
      var _this$props4 = _this.props, onDoubleClick = _this$props4.onDoubleClick, expandAction = _this$props4.expandAction;
      if (expandAction === "doubleClick") {
        _this.triggerExpandActionExpand(e2, treeNode);
      }
      onDoubleClick === null || onDoubleClick === void 0 ? void 0 : onDoubleClick(e2, treeNode);
    };
    _this.onNodeSelect = function(e2, treeNode) {
      var selectedKeys = _this.state.selectedKeys;
      var _this$state6 = _this.state, keyEntities = _this$state6.keyEntities, fieldNames = _this$state6.fieldNames;
      var _this$props5 = _this.props, onSelect = _this$props5.onSelect, multiple = _this$props5.multiple;
      var selected = treeNode.selected;
      var key2 = treeNode[fieldNames.key];
      var targetSelected = !selected;
      if (!targetSelected) {
        selectedKeys = arrDel(selectedKeys, key2);
      } else if (!multiple) {
        selectedKeys = [key2];
      } else {
        selectedKeys = arrAdd(selectedKeys, key2);
      }
      var selectedNodes = selectedKeys.map(function(selectedKey) {
        var entity = keyEntities[selectedKey];
        if (!entity)
          return null;
        return entity.node;
      }).filter(function(node) {
        return node;
      });
      _this.setUncontrolledState({
        selectedKeys
      });
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectedKeys, {
        event: "select",
        selected: targetSelected,
        node: treeNode,
        selectedNodes,
        nativeEvent: e2.nativeEvent
      });
    };
    _this.onNodeCheck = function(e2, treeNode, checked) {
      var _this$state7 = _this.state, keyEntities = _this$state7.keyEntities, oriCheckedKeys = _this$state7.checkedKeys, oriHalfCheckedKeys = _this$state7.halfCheckedKeys;
      var _this$props6 = _this.props, checkStrictly = _this$props6.checkStrictly, onCheck = _this$props6.onCheck;
      var key2 = treeNode.key;
      var checkedObj;
      var eventObj = {
        event: "check",
        node: treeNode,
        checked,
        nativeEvent: e2.nativeEvent
      };
      if (checkStrictly) {
        var checkedKeys = checked ? arrAdd(oriCheckedKeys, key2) : arrDel(oriCheckedKeys, key2);
        var halfCheckedKeys = arrDel(oriHalfCheckedKeys, key2);
        checkedObj = {
          checked: checkedKeys,
          halfChecked: halfCheckedKeys
        };
        eventObj.checkedNodes = checkedKeys.map(function(checkedKey) {
          return keyEntities[checkedKey];
        }).filter(function(entity) {
          return entity;
        }).map(function(entity) {
          return entity.node;
        });
        _this.setUncontrolledState({
          checkedKeys
        });
      } else {
        var _conductCheck = conductCheck([].concat(_toConsumableArray(oriCheckedKeys), [key2]), true, keyEntities), _checkedKeys = _conductCheck.checkedKeys, _halfCheckedKeys = _conductCheck.halfCheckedKeys;
        if (!checked) {
          var keySet = new Set(_checkedKeys);
          keySet.delete(key2);
          var _conductCheck2 = conductCheck(Array.from(keySet), {
            checked: false,
            halfCheckedKeys: _halfCheckedKeys
          }, keyEntities);
          _checkedKeys = _conductCheck2.checkedKeys;
          _halfCheckedKeys = _conductCheck2.halfCheckedKeys;
        }
        checkedObj = _checkedKeys;
        eventObj.checkedNodes = [];
        eventObj.checkedNodesPositions = [];
        eventObj.halfCheckedKeys = _halfCheckedKeys;
        _checkedKeys.forEach(function(checkedKey) {
          var entity = keyEntities[checkedKey];
          if (!entity)
            return;
          var node = entity.node, pos = entity.pos;
          eventObj.checkedNodes.push(node);
          eventObj.checkedNodesPositions.push({
            node,
            pos
          });
        });
        _this.setUncontrolledState({
          checkedKeys: _checkedKeys
        }, false, {
          halfCheckedKeys: _halfCheckedKeys
        });
      }
      onCheck === null || onCheck === void 0 ? void 0 : onCheck(checkedObj, eventObj);
    };
    _this.onNodeLoad = function(treeNode) {
      var key2 = treeNode.key;
      var loadPromise = new Promise(function(resolve, reject) {
        _this.setState(function(_ref) {
          var _ref$loadedKeys = _ref.loadedKeys, loadedKeys = _ref$loadedKeys === void 0 ? [] : _ref$loadedKeys, _ref$loadingKeys = _ref.loadingKeys, loadingKeys = _ref$loadingKeys === void 0 ? [] : _ref$loadingKeys;
          var _this$props7 = _this.props, loadData = _this$props7.loadData, onLoad = _this$props7.onLoad;
          if (!loadData || loadedKeys.indexOf(key2) !== -1 || loadingKeys.indexOf(key2) !== -1) {
            return null;
          }
          var promise = loadData(treeNode);
          promise.then(function() {
            var currentLoadedKeys = _this.state.loadedKeys;
            var newLoadedKeys = arrAdd(currentLoadedKeys, key2);
            onLoad === null || onLoad === void 0 ? void 0 : onLoad(newLoadedKeys, {
              event: "load",
              node: treeNode
            });
            _this.setUncontrolledState({
              loadedKeys: newLoadedKeys
            });
            _this.setState(function(prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key2)
              };
            });
            resolve();
          }).catch(function(e2) {
            _this.setState(function(prevState) {
              return {
                loadingKeys: arrDel(prevState.loadingKeys, key2)
              };
            });
            _this.loadingRetryTimes[key2] = (_this.loadingRetryTimes[key2] || 0) + 1;
            if (_this.loadingRetryTimes[key2] >= MAX_RETRY_TIMES) {
              var currentLoadedKeys = _this.state.loadedKeys;
              warningOnce(false, "Retry for `loadData` many times but still failed. No more retry.");
              _this.setUncontrolledState({
                loadedKeys: arrAdd(currentLoadedKeys, key2)
              });
              resolve();
            }
            reject(e2);
          });
          return {
            loadingKeys: arrAdd(loadingKeys, key2)
          };
        });
      });
      loadPromise.catch(function() {
      });
      return loadPromise;
    };
    _this.onNodeMouseEnter = function(event, node) {
      var onMouseEnter = _this.props.onMouseEnter;
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        event,
        node
      });
    };
    _this.onNodeMouseLeave = function(event, node) {
      var onMouseLeave = _this.props.onMouseLeave;
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        event,
        node
      });
    };
    _this.onNodeContextMenu = function(event, node) {
      var onRightClick = _this.props.onRightClick;
      if (onRightClick) {
        event.preventDefault();
        onRightClick({
          event,
          node
        });
      }
    };
    _this.onFocus = function() {
      var onFocus2 = _this.props.onFocus;
      _this.setState({
        focused: true
      });
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2.apply(void 0, args);
    };
    _this.onBlur = function() {
      var onBlur2 = _this.props.onBlur;
      _this.setState({
        focused: false
      });
      _this.onActiveChange(null);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2.apply(void 0, args);
    };
    _this.getTreeNodeRequiredProps = function() {
      var _this$state8 = _this.state, expandedKeys = _this$state8.expandedKeys, selectedKeys = _this$state8.selectedKeys, loadedKeys = _this$state8.loadedKeys, loadingKeys = _this$state8.loadingKeys, checkedKeys = _this$state8.checkedKeys, halfCheckedKeys = _this$state8.halfCheckedKeys, dragOverNodeKey = _this$state8.dragOverNodeKey, dropPosition = _this$state8.dropPosition, keyEntities = _this$state8.keyEntities;
      return {
        expandedKeys: expandedKeys || [],
        selectedKeys: selectedKeys || [],
        loadedKeys: loadedKeys || [],
        loadingKeys: loadingKeys || [],
        checkedKeys: checkedKeys || [],
        halfCheckedKeys: halfCheckedKeys || [],
        dragOverNodeKey,
        dropPosition,
        keyEntities
      };
    };
    _this.setExpandedKeys = function(expandedKeys) {
      var _this$state9 = _this.state, treeData = _this$state9.treeData, fieldNames = _this$state9.fieldNames;
      var flattenNodes = flattenTreeData(treeData, expandedKeys, fieldNames);
      _this.setUncontrolledState({
        expandedKeys,
        flattenNodes
      }, true);
    };
    _this.onNodeExpand = function(e2, treeNode) {
      var expandedKeys = _this.state.expandedKeys;
      var _this$state10 = _this.state, listChanging = _this$state10.listChanging, fieldNames = _this$state10.fieldNames;
      var _this$props8 = _this.props, onExpand = _this$props8.onExpand, loadData = _this$props8.loadData;
      var expanded = treeNode.expanded;
      var key2 = treeNode[fieldNames.key];
      if (listChanging) {
        return;
      }
      var index2 = expandedKeys.indexOf(key2);
      var targetExpanded = !expanded;
      warningOnce(expanded && index2 !== -1 || !expanded && index2 === -1, "Expand state not sync with index check");
      if (targetExpanded) {
        expandedKeys = arrAdd(expandedKeys, key2);
      } else {
        expandedKeys = arrDel(expandedKeys, key2);
      }
      _this.setExpandedKeys(expandedKeys);
      onExpand === null || onExpand === void 0 ? void 0 : onExpand(expandedKeys, {
        node: treeNode,
        expanded: targetExpanded,
        nativeEvent: e2.nativeEvent
      });
      if (targetExpanded && loadData) {
        var loadPromise = _this.onNodeLoad(treeNode);
        if (loadPromise) {
          loadPromise.then(function() {
            var newFlattenTreeData = flattenTreeData(_this.state.treeData, expandedKeys, fieldNames);
            _this.setUncontrolledState({
              flattenNodes: newFlattenTreeData
            });
          }).catch(function() {
            var currentExpandedKeys = _this.state.expandedKeys;
            var expandedKeysToRestore = arrDel(currentExpandedKeys, key2);
            _this.setExpandedKeys(expandedKeysToRestore);
          });
        }
      }
    };
    _this.onListChangeStart = function() {
      _this.setUncontrolledState({
        listChanging: true
      });
    };
    _this.onListChangeEnd = function() {
      setTimeout(function() {
        _this.setUncontrolledState({
          listChanging: false
        });
      });
    };
    _this.onActiveChange = function(newActiveKey) {
      var activeKey = _this.state.activeKey;
      var onActiveChange = _this.props.onActiveChange;
      if (activeKey === newActiveKey) {
        return;
      }
      _this.setState({
        activeKey: newActiveKey
      });
      if (newActiveKey !== null) {
        _this.scrollTo({
          key: newActiveKey
        });
      }
      onActiveChange === null || onActiveChange === void 0 ? void 0 : onActiveChange(newActiveKey);
    };
    _this.getActiveItem = function() {
      var _this$state11 = _this.state, activeKey = _this$state11.activeKey, flattenNodes = _this$state11.flattenNodes;
      if (activeKey === null) {
        return null;
      }
      return flattenNodes.find(function(_ref2) {
        var key2 = _ref2.key;
        return key2 === activeKey;
      }) || null;
    };
    _this.offsetActiveKey = function(offset3) {
      var _this$state12 = _this.state, flattenNodes = _this$state12.flattenNodes, activeKey = _this$state12.activeKey;
      var index2 = flattenNodes.findIndex(function(_ref3) {
        var key3 = _ref3.key;
        return key3 === activeKey;
      });
      if (index2 === -1 && offset3 < 0) {
        index2 = flattenNodes.length;
      }
      index2 = (index2 + offset3 + flattenNodes.length) % flattenNodes.length;
      var item = flattenNodes[index2];
      if (item) {
        var key2 = item.key;
        _this.onActiveChange(key2);
      } else {
        _this.onActiveChange(null);
      }
    };
    _this.onKeyDown = function(event) {
      var _this$state13 = _this.state, activeKey = _this$state13.activeKey, expandedKeys = _this$state13.expandedKeys, checkedKeys = _this$state13.checkedKeys, fieldNames = _this$state13.fieldNames;
      var _this$props9 = _this.props, onKeyDown2 = _this$props9.onKeyDown, checkable = _this$props9.checkable, selectable = _this$props9.selectable;
      switch (event.which) {
        case KeyCode.UP: {
          _this.offsetActiveKey(-1);
          event.preventDefault();
          break;
        }
        case KeyCode.DOWN: {
          _this.offsetActiveKey(1);
          event.preventDefault();
          break;
        }
      }
      var activeItem = _this.getActiveItem();
      if (activeItem && activeItem.data) {
        var treeNodeRequiredProps = _this.getTreeNodeRequiredProps();
        var expandable = activeItem.data.isLeaf === false || !!(activeItem.data[fieldNames.children] || []).length;
        var eventNode = convertNodePropsToEventData(_objectSpread2$4(_objectSpread2$4({}, getTreeNodeProps(activeKey, treeNodeRequiredProps)), {}, {
          data: activeItem.data,
          active: true
        }));
        switch (event.which) {
          case KeyCode.LEFT: {
            if (expandable && expandedKeys.includes(activeKey)) {
              _this.onNodeExpand({}, eventNode);
            } else if (activeItem.parent) {
              _this.onActiveChange(activeItem.parent.key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.RIGHT: {
            if (expandable && !expandedKeys.includes(activeKey)) {
              _this.onNodeExpand({}, eventNode);
            } else if (activeItem.children && activeItem.children.length) {
              _this.onActiveChange(activeItem.children[0].key);
            }
            event.preventDefault();
            break;
          }
          case KeyCode.ENTER:
          case KeyCode.SPACE: {
            if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {
              _this.onNodeCheck({}, eventNode, !checkedKeys.includes(activeKey));
            } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {
              _this.onNodeSelect({}, eventNode);
            }
            break;
          }
        }
      }
      onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(event);
    };
    _this.setUncontrolledState = function(state) {
      var atomic = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var forceState = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!_this.destroyed) {
        var needSync = false;
        var allPassed = true;
        var newState = {};
        Object.keys(state).forEach(function(name2) {
          if (name2 in _this.props) {
            allPassed = false;
            return;
          }
          needSync = true;
          newState[name2] = state[name2];
        });
        if (needSync && (!atomic || allPassed)) {
          _this.setState(_objectSpread2$4(_objectSpread2$4({}, newState), forceState));
        }
      }
    };
    _this.scrollTo = function(scroll) {
      _this.listRef.current.scrollTo(scroll);
    };
    return _this;
  }
  _createClass$2(Tree2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.destroyed = false;
      this.onUpdated();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.onUpdated();
    }
  }, {
    key: "onUpdated",
    value: function onUpdated() {
      var activeKey = this.props.activeKey;
      if (activeKey !== void 0 && activeKey !== this.state.activeKey) {
        this.setState({
          activeKey
        });
        if (activeKey !== null) {
          this.scrollTo({
            key: activeKey
          });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener("dragend", this.onWindowDragEnd);
      this.destroyed = true;
    }
  }, {
    key: "resetDragState",
    value: function resetDragState() {
      this.setState({
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: false
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$state14 = this.state, focused = _this$state14.focused, flattenNodes = _this$state14.flattenNodes, keyEntities = _this$state14.keyEntities, draggingNodeKey = _this$state14.draggingNodeKey, activeKey = _this$state14.activeKey, dropLevelOffset = _this$state14.dropLevelOffset, dropContainerKey = _this$state14.dropContainerKey, dropTargetKey = _this$state14.dropTargetKey, dropPosition = _this$state14.dropPosition, dragOverNodeKey = _this$state14.dragOverNodeKey, indent = _this$state14.indent;
      var _this$props10 = this.props, prefixCls = _this$props10.prefixCls, className = _this$props10.className, style2 = _this$props10.style, showLine = _this$props10.showLine, focusable2 = _this$props10.focusable, _this$props10$tabInde = _this$props10.tabIndex, tabIndex = _this$props10$tabInde === void 0 ? 0 : _this$props10$tabInde, selectable = _this$props10.selectable, showIcon = _this$props10.showIcon, icon = _this$props10.icon, switcherIcon = _this$props10.switcherIcon, draggable = _this$props10.draggable, checkable = _this$props10.checkable, checkStrictly = _this$props10.checkStrictly, disabled = _this$props10.disabled, motion = _this$props10.motion, loadData = _this$props10.loadData, filterTreeNode = _this$props10.filterTreeNode, height = _this$props10.height, itemHeight = _this$props10.itemHeight, virtual2 = _this$props10.virtual, titleRender = _this$props10.titleRender, dropIndicatorRender2 = _this$props10.dropIndicatorRender, onContextMenu = _this$props10.onContextMenu, onScroll = _this$props10.onScroll, direction = _this$props10.direction, rootClassName = _this$props10.rootClassName, rootStyle = _this$props10.rootStyle;
      var domProps = pickAttrs(this.props, {
        aria: true,
        data: true
      });
      var draggableConfig;
      if (draggable) {
        if (_typeof$4(draggable) === "object") {
          draggableConfig = draggable;
        } else if (typeof draggable === "function") {
          draggableConfig = {
            nodeDraggable: draggable
          };
        } else {
          draggableConfig = {};
        }
      }
      return /* @__PURE__ */ react.exports.createElement(TreeContext.Provider, {
        value: {
          prefixCls,
          selectable,
          showIcon,
          icon,
          switcherIcon,
          draggable: draggableConfig,
          draggingNodeKey,
          checkable,
          checkStrictly,
          disabled,
          keyEntities,
          dropLevelOffset,
          dropContainerKey,
          dropTargetKey,
          dropPosition,
          dragOverNodeKey,
          indent,
          direction,
          dropIndicatorRender: dropIndicatorRender2,
          loadData,
          filterTreeNode,
          titleRender,
          onNodeClick: this.onNodeClick,
          onNodeDoubleClick: this.onNodeDoubleClick,
          onNodeExpand: this.onNodeExpand,
          onNodeSelect: this.onNodeSelect,
          onNodeCheck: this.onNodeCheck,
          onNodeLoad: this.onNodeLoad,
          onNodeMouseEnter: this.onNodeMouseEnter,
          onNodeMouseLeave: this.onNodeMouseLeave,
          onNodeContextMenu: this.onNodeContextMenu,
          onNodeDragStart: this.onNodeDragStart,
          onNodeDragEnter: this.onNodeDragEnter,
          onNodeDragOver: this.onNodeDragOver,
          onNodeDragLeave: this.onNodeDragLeave,
          onNodeDragEnd: this.onNodeDragEnd,
          onNodeDrop: this.onNodeDrop
        }
      }, /* @__PURE__ */ react.exports.createElement("div", {
        role: "tree",
        className: classnamesExports(prefixCls, className, rootClassName, (_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-show-line"), showLine), _defineProperty$5(_classNames, "".concat(prefixCls, "-focused"), focused), _defineProperty$5(_classNames, "".concat(prefixCls, "-active-focused"), activeKey !== null), _classNames)),
        style: rootStyle
      }, /* @__PURE__ */ react.exports.createElement(NodeList, _extends$2({
        ref: this.listRef,
        prefixCls,
        style: style2,
        data: flattenNodes,
        disabled,
        selectable,
        checkable: !!checkable,
        motion,
        dragging: draggingNodeKey !== null,
        height,
        itemHeight,
        virtual: virtual2,
        focusable: focusable2,
        focused,
        tabIndex,
        activeItem: this.getActiveItem(),
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onKeyDown: this.onKeyDown,
        onActiveChange: this.onActiveChange,
        onListChangeStart: this.onListChangeStart,
        onListChangeEnd: this.onListChangeEnd,
        onContextMenu,
        onScroll
      }, this.getTreeNodeRequiredProps(), domProps))));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, prevState) {
      var prevProps = prevState.prevProps;
      var newState = {
        prevProps: props
      };
      function needSync(name2) {
        return !prevProps && name2 in props || prevProps && prevProps[name2] !== props[name2];
      }
      var treeData;
      var fieldNames = prevState.fieldNames;
      if (needSync("fieldNames")) {
        fieldNames = fillFieldNames(props.fieldNames);
        newState.fieldNames = fieldNames;
      }
      if (needSync("treeData")) {
        treeData = props.treeData;
      } else if (needSync("children")) {
        warningOnce(false, "`children` of Tree is deprecated. Please use `treeData` instead.");
        treeData = convertTreeToData(props.children);
      }
      if (treeData) {
        newState.treeData = treeData;
        var entitiesMap = convertDataToEntities(treeData, {
          fieldNames
        });
        newState.keyEntities = _objectSpread2$4(_defineProperty$5({}, MOTION_KEY, MotionEntity), entitiesMap.keyEntities);
      }
      var keyEntities = newState.keyEntities || prevState.keyEntities;
      if (needSync("expandedKeys") || prevProps && needSync("autoExpandParent")) {
        newState.expandedKeys = props.autoExpandParent || !prevProps && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities) : props.expandedKeys;
      } else if (!prevProps && props.defaultExpandAll) {
        var cloneKeyEntities = _objectSpread2$4({}, keyEntities);
        delete cloneKeyEntities[MOTION_KEY];
        newState.expandedKeys = Object.keys(cloneKeyEntities).map(function(key2) {
          return cloneKeyEntities[key2].key;
        });
      } else if (!prevProps && props.defaultExpandedKeys) {
        newState.expandedKeys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities) : props.defaultExpandedKeys;
      }
      if (!newState.expandedKeys) {
        delete newState.expandedKeys;
      }
      if (treeData || newState.expandedKeys) {
        var flattenNodes = flattenTreeData(treeData || prevState.treeData, newState.expandedKeys || prevState.expandedKeys, fieldNames);
        newState.flattenNodes = flattenNodes;
      }
      if (props.selectable) {
        if (needSync("selectedKeys")) {
          newState.selectedKeys = calcSelectedKeys(props.selectedKeys, props);
        } else if (!prevProps && props.defaultSelectedKeys) {
          newState.selectedKeys = calcSelectedKeys(props.defaultSelectedKeys, props);
        }
      }
      if (props.checkable) {
        var checkedKeyEntity;
        if (needSync("checkedKeys")) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};
        } else if (!prevProps && props.defaultCheckedKeys) {
          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};
        } else if (treeData) {
          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {
            checkedKeys: prevState.checkedKeys,
            halfCheckedKeys: prevState.halfCheckedKeys
          };
        }
        if (checkedKeyEntity) {
          var _checkedKeyEntity = checkedKeyEntity, _checkedKeyEntity$che = _checkedKeyEntity.checkedKeys, checkedKeys = _checkedKeyEntity$che === void 0 ? [] : _checkedKeyEntity$che, _checkedKeyEntity$hal = _checkedKeyEntity.halfCheckedKeys, halfCheckedKeys = _checkedKeyEntity$hal === void 0 ? [] : _checkedKeyEntity$hal;
          if (!props.checkStrictly) {
            var conductKeys = conductCheck(checkedKeys, true, keyEntities);
            checkedKeys = conductKeys.checkedKeys;
            halfCheckedKeys = conductKeys.halfCheckedKeys;
          }
          newState.checkedKeys = checkedKeys;
          newState.halfCheckedKeys = halfCheckedKeys;
        }
      }
      if (needSync("loadedKeys")) {
        newState.loadedKeys = props.loadedKeys;
      }
      return newState;
    }
  }]);
  return Tree2;
}(react.exports.Component);
Tree$2.defaultProps = {
  prefixCls: "rc-tree",
  showLine: false,
  showIcon: true,
  selectable: true,
  multiple: false,
  checkable: false,
  disabled: false,
  checkStrictly: false,
  draggable: false,
  defaultExpandParent: true,
  autoExpandParent: false,
  defaultExpandAll: false,
  defaultExpandedKeys: [],
  defaultCheckedKeys: [],
  defaultSelectedKeys: [],
  dropIndicatorRender: DropIndicator,
  allowDrop: function allowDrop() {
    return true;
  },
  expandAction: false
};
Tree$2.TreeNode = ContextTreeNode;
var FileOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, "name": "file", "theme": "outlined" };
const FileOutlinedSvg = FileOutlined$2;
var FileOutlined = function FileOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: FileOutlinedSvg
  }));
};
FileOutlined.displayName = "FileOutlined";
const FileOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FileOutlined);
var FolderOpenOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, "name": "folder-open", "theme": "outlined" };
const FolderOpenOutlinedSvg = FolderOpenOutlined$2;
var FolderOpenOutlined = function FolderOpenOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: FolderOpenOutlinedSvg
  }));
};
FolderOpenOutlined.displayName = "FolderOpenOutlined";
const FolderOpenOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FolderOpenOutlined);
var FolderOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, "name": "folder", "theme": "outlined" };
const FolderOutlinedSvg = FolderOutlined$2;
var FolderOutlined = function FolderOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: FolderOutlinedSvg
  }));
};
FolderOutlined.displayName = "FolderOutlined";
const FolderOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FolderOutlined);
var Record;
(function(Record2) {
  Record2[Record2["None"] = 0] = "None";
  Record2[Record2["Start"] = 1] = "Start";
  Record2[Record2["End"] = 2] = "End";
})(Record || (Record = {}));
function traverseNodesKey(treeData, callback) {
  function processNode(dataNode) {
    var key2 = dataNode.key, children = dataNode.children;
    if (callback(key2, dataNode) !== false) {
      traverseNodesKey(children || [], callback);
    }
  }
  treeData.forEach(processNode);
}
function calcRangeKeys(_ref) {
  var treeData = _ref.treeData, expandedKeys = _ref.expandedKeys, startKey = _ref.startKey, endKey = _ref.endKey;
  var keys2 = [];
  var record = Record.None;
  if (startKey && startKey === endKey) {
    return [startKey];
  }
  if (!startKey || !endKey) {
    return [];
  }
  function matchKey(key2) {
    return key2 === startKey || key2 === endKey;
  }
  traverseNodesKey(treeData, function(key2) {
    if (record === Record.End) {
      return false;
    }
    if (matchKey(key2)) {
      keys2.push(key2);
      if (record === Record.None) {
        record = Record.Start;
      } else if (record === Record.Start) {
        record = Record.End;
        return false;
      }
    } else if (record === Record.Start) {
      keys2.push(key2);
    }
    if (expandedKeys.indexOf(key2) === -1) {
      return false;
    }
    return true;
  });
  return keys2;
}
function convertDirectoryKeysToNodes(treeData, keys2) {
  var restKeys = _toConsumableArray(keys2);
  var nodes = [];
  traverseNodesKey(treeData, function(key2, node) {
    var index2 = restKeys.indexOf(key2);
    if (index2 !== -1) {
      nodes.push(node);
      restKeys.splice(index2, 1);
    }
    return !!restKeys.length;
  });
  return nodes;
}
var __rest$6 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function getIcon(props) {
  var isLeaf = props.isLeaf, expanded = props.expanded;
  if (isLeaf) {
    return /* @__PURE__ */ react.exports.createElement(FileOutlined$1, null);
  }
  return expanded ? /* @__PURE__ */ react.exports.createElement(FolderOpenOutlined$1, null) : /* @__PURE__ */ react.exports.createElement(FolderOutlined$1, null);
}
function getTreeData(_ref) {
  var treeData = _ref.treeData, children = _ref.children;
  return treeData || convertTreeToData(children);
}
var DirectoryTree = function DirectoryTree2(_a, ref) {
  var defaultExpandAll = _a.defaultExpandAll, defaultExpandParent = _a.defaultExpandParent, defaultExpandedKeys = _a.defaultExpandedKeys, props = __rest$6(_a, ["defaultExpandAll", "defaultExpandParent", "defaultExpandedKeys"]);
  var lastSelectedKey = react.exports.useRef();
  var cachedSelectedKeys = react.exports.useRef();
  var treeRef = /* @__PURE__ */ react.exports.createRef();
  react.exports.useImperativeHandle(ref, function() {
    return treeRef.current;
  });
  var getInitExpandedKeys = function getInitExpandedKeys2() {
    var _convertDataToEntitie = convertDataToEntities(getTreeData(props)), keyEntities = _convertDataToEntitie.keyEntities;
    var initExpandedKeys;
    if (defaultExpandAll) {
      initExpandedKeys = Object.keys(keyEntities);
    } else if (defaultExpandParent) {
      initExpandedKeys = conductExpandParent(props.expandedKeys || defaultExpandedKeys || [], keyEntities);
    } else {
      initExpandedKeys = props.expandedKeys || defaultExpandedKeys;
    }
    return initExpandedKeys;
  };
  var _React$useState = react.exports.useState(props.selectedKeys || props.defaultSelectedKeys || []), _React$useState2 = _slicedToArray$3(_React$useState, 2), selectedKeys = _React$useState2[0], setSelectedKeys = _React$useState2[1];
  var _React$useState3 = react.exports.useState(getInitExpandedKeys()), _React$useState4 = _slicedToArray$3(_React$useState3, 2), expandedKeys = _React$useState4[0], setExpandedKeys = _React$useState4[1];
  react.exports.useEffect(function() {
    if ("selectedKeys" in props) {
      setSelectedKeys(props.selectedKeys);
    }
  }, [props.selectedKeys]);
  react.exports.useEffect(function() {
    if ("expandedKeys" in props) {
      setExpandedKeys(props.expandedKeys);
    }
  }, [props.expandedKeys]);
  var onExpand = function onExpand2(keys2, info2) {
    var _a2;
    if (!("expandedKeys" in props)) {
      setExpandedKeys(keys2);
    }
    return (_a2 = props.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(props, keys2, info2);
  };
  var onSelect = function onSelect2(keys2, event) {
    var _a2;
    var multiple = props.multiple;
    var node = event.node, nativeEvent = event.nativeEvent;
    var _node$key = node.key, key2 = _node$key === void 0 ? "" : _node$key;
    var treeData = getTreeData(props);
    var newEvent = _extends$2(_extends$2({}, event), {
      selected: true
    });
    var ctrlPick = (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.ctrlKey) || (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.metaKey);
    var shiftPick = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.shiftKey;
    var newSelectedKeys;
    if (multiple && ctrlPick) {
      newSelectedKeys = keys2;
      lastSelectedKey.current = key2;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    } else if (multiple && shiftPick) {
      newSelectedKeys = Array.from(new Set([].concat(_toConsumableArray(cachedSelectedKeys.current || []), _toConsumableArray(calcRangeKeys({
        treeData,
        expandedKeys,
        startKey: key2,
        endKey: lastSelectedKey.current
      })))));
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    } else {
      newSelectedKeys = [key2];
      lastSelectedKey.current = key2;
      cachedSelectedKeys.current = newSelectedKeys;
      newEvent.selectedNodes = convertDirectoryKeysToNodes(treeData, newSelectedKeys);
    }
    (_a2 = props.onSelect) === null || _a2 === void 0 ? void 0 : _a2.call(props, newSelectedKeys, newEvent);
    if (!("selectedKeys" in props)) {
      setSelectedKeys(newSelectedKeys);
    }
  };
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var customizePrefixCls = props.prefixCls, className = props.className, otherProps = __rest$6(props, ["prefixCls", "className"]);
  var prefixCls = getPrefixCls("tree", customizePrefixCls);
  var connectClassName = classnamesExports("".concat(prefixCls, "-directory"), _defineProperty$5({}, "".concat(prefixCls, "-directory-rtl"), direction === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement(Tree$1, _extends$2({
    icon: getIcon,
    ref: treeRef,
    blockNode: true
  }, otherProps, {
    prefixCls,
    className: connectClassName,
    expandedKeys,
    selectedKeys,
    onSelect,
    onExpand
  }));
};
var ForwardDirectoryTree = /* @__PURE__ */ react.exports.forwardRef(DirectoryTree);
ForwardDirectoryTree.defaultProps = {
  showIcon: true,
  expandAction: "click"
};
const DirectoryTree$1 = ForwardDirectoryTree;
var offset2 = 4;
function dropIndicatorRender(props) {
  var _style;
  var dropPosition = props.dropPosition, dropLevelOffset = props.dropLevelOffset, prefixCls = props.prefixCls, indent = props.indent, _props$direction = props.direction, direction = _props$direction === void 0 ? "ltr" : _props$direction;
  var startPosition = direction === "ltr" ? "left" : "right";
  var endPosition = direction === "ltr" ? "right" : "left";
  var style2 = (_style = {}, _defineProperty$5(_style, startPosition, -dropLevelOffset * indent + offset2), _defineProperty$5(_style, endPosition, 0), _style);
  switch (dropPosition) {
    case -1:
      style2.top = -3;
      break;
    case 1:
      style2.bottom = -3;
      break;
    default:
      style2.bottom = -3;
      style2[startPosition] = indent + offset2;
      break;
  }
  return /* @__PURE__ */ React$a.createElement("div", {
    style: style2,
    className: "".concat(prefixCls, "-drop-indicator")
  });
}
var CaretDownFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "filled" };
const CaretDownFilledSvg = CaretDownFilled$2;
var CaretDownFilled = function CaretDownFilled2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CaretDownFilledSvg
  }));
};
CaretDownFilled.displayName = "CaretDownFilled";
const CaretDownFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CaretDownFilled);
var MinusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "minus-square", "theme": "outlined" };
const MinusSquareOutlinedSvg = MinusSquareOutlined$2;
var MinusSquareOutlined = function MinusSquareOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: MinusSquareOutlinedSvg
  }));
};
MinusSquareOutlined.displayName = "MinusSquareOutlined";
const MinusSquareOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(MinusSquareOutlined);
var PlusSquareOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { "tag": "path", "attrs": { "d": "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, "name": "plus-square", "theme": "outlined" };
const PlusSquareOutlinedSvg = PlusSquareOutlined$2;
var PlusSquareOutlined = function PlusSquareOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: PlusSquareOutlinedSvg
  }));
};
PlusSquareOutlined.displayName = "PlusSquareOutlined";
const PlusSquareOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(PlusSquareOutlined);
function renderSwitcherIcon(prefixCls, switcherIcon, showLine, treeNodeProps) {
  var isLeaf = treeNodeProps.isLeaf, expanded = treeNodeProps.expanded, loading = treeNodeProps.loading;
  if (loading) {
    return /* @__PURE__ */ react.exports.createElement(LoadingOutlined$1, {
      className: "".concat(prefixCls, "-switcher-loading-icon")
    });
  }
  var showLeafIcon;
  if (showLine && _typeof$4(showLine) === "object") {
    showLeafIcon = showLine.showLeafIcon;
  }
  if (isLeaf) {
    if (showLine) {
      if (_typeof$4(showLine) === "object" && !showLeafIcon) {
        return /* @__PURE__ */ react.exports.createElement("span", {
          className: "".concat(prefixCls, "-switcher-leaf-line")
        });
      }
      return /* @__PURE__ */ react.exports.createElement(FileOutlined$1, {
        className: "".concat(prefixCls, "-switcher-line-icon")
      });
    }
    return null;
  }
  var switcherCls = "".concat(prefixCls, "-switcher-icon");
  var switcher = typeof switcherIcon === "function" ? switcherIcon(treeNodeProps) : switcherIcon;
  if (isValidElement(switcher)) {
    return cloneElement(switcher, {
      className: classnamesExports(switcher.props.className || "", switcherCls)
    });
  }
  if (switcher) {
    return switcher;
  }
  if (showLine) {
    return expanded ? /* @__PURE__ */ react.exports.createElement(MinusSquareOutlined$1, {
      className: "".concat(prefixCls, "-switcher-line-icon")
    }) : /* @__PURE__ */ react.exports.createElement(PlusSquareOutlined$1, {
      className: "".concat(prefixCls, "-switcher-line-icon")
    });
  }
  return /* @__PURE__ */ react.exports.createElement(CaretDownFilled$1, {
    className: switcherCls
  });
}
var Tree = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction, virtual2 = _React$useContext.virtual;
  var customizePrefixCls = props.prefixCls, className = props.className, showIcon = props.showIcon, showLine = props.showLine, _switcherIcon = props.switcherIcon, blockNode = props.blockNode, children = props.children, checkable = props.checkable, selectable = props.selectable, draggable = props.draggable;
  var prefixCls = getPrefixCls("tree", customizePrefixCls);
  var newProps = _extends$2(_extends$2({}, props), {
    showLine: Boolean(showLine),
    dropIndicatorRender
  });
  var draggableConfig = react.exports.useMemo(function() {
    if (!draggable) {
      return false;
    }
    var mergedDraggable = {};
    switch (_typeof$4(draggable)) {
      case "function":
        mergedDraggable.nodeDraggable = draggable;
        break;
      case "object":
        mergedDraggable = _extends$2({}, draggable);
        break;
    }
    if (mergedDraggable.icon !== false) {
      mergedDraggable.icon = mergedDraggable.icon || /* @__PURE__ */ react.exports.createElement(HolderOutlined$1, null);
    }
    return mergedDraggable;
  }, [draggable]);
  return /* @__PURE__ */ react.exports.createElement(Tree$2, _extends$2({
    itemHeight: 20,
    ref,
    virtual: virtual2
  }, newProps, {
    prefixCls,
    className: classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-icon-hide"), !showIcon), _defineProperty$5(_classNames, "".concat(prefixCls, "-block-node"), blockNode), _defineProperty$5(_classNames, "".concat(prefixCls, "-unselectable"), !selectable), _defineProperty$5(_classNames, "".concat(prefixCls, "-rtl"), direction === "rtl"), _classNames), className),
    direction,
    checkable: checkable ? /* @__PURE__ */ react.exports.createElement("span", {
      className: "".concat(prefixCls, "-checkbox-inner")
    }) : checkable,
    selectable,
    switcherIcon: function switcherIcon(nodeProps) {
      return renderSwitcherIcon(prefixCls, _switcherIcon, showLine, nodeProps);
    },
    draggable: draggableConfig
  }), children);
});
Tree.TreeNode = ContextTreeNode;
Tree.DirectoryTree = DirectoryTree$1;
Tree.defaultProps = {
  checkable: false,
  selectable: true,
  showIcon: false,
  motion: _extends$2(_extends$2({}, collapseMotion$1), {
    motionAppear: false
  }),
  blockNode: false
};
const Tree$1 = Tree;
function useSyncState(initialValue) {
  var ref = react.exports.useRef(initialValue);
  var forceUpdate = useForceUpdate();
  return [function() {
    return ref.current;
  }, function(newValue) {
    ref.current = newValue;
    forceUpdate();
  }];
}
var FilterSearch = function FilterSearch2(_ref) {
  var value2 = _ref.value, onChange2 = _ref.onChange, filterSearch = _ref.filterSearch, tablePrefixCls = _ref.tablePrefixCls, locale2 = _ref.locale;
  if (!filterSearch) {
    return null;
  }
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(tablePrefixCls, "-filter-dropdown-search")
  }, /* @__PURE__ */ react.exports.createElement(Input$1, {
    prefix: /* @__PURE__ */ react.exports.createElement(SearchOutlined$1, null),
    placeholder: locale2.filterSearchPlaceholder,
    onChange: onChange2,
    value: value2,
    htmlSize: 1,
    className: "".concat(tablePrefixCls, "-filter-dropdown-search-input")
  }));
};
const FilterSearch$1 = FilterSearch;
var FilterDropdownMenuWrapper = function FilterDropdownMenuWrapper2(props) {
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: props.className,
    onClick: function onClick(e2) {
      return e2.stopPropagation();
    }
  }, props.children);
};
const FilterDropdownMenuWrapper$1 = FilterDropdownMenuWrapper;
function hasSubMenu(filters) {
  return filters.some(function(_ref) {
    var children = _ref.children;
    return children;
  });
}
function searchValueMatched(searchValue, text2) {
  if (typeof text2 === "string" || typeof text2 === "number") {
    return text2 === null || text2 === void 0 ? void 0 : text2.toString().toLowerCase().includes(searchValue.trim().toLowerCase());
  }
  return false;
}
function renderFilterItems(_ref2) {
  var filters = _ref2.filters, prefixCls = _ref2.prefixCls, filteredKeys = _ref2.filteredKeys, filterMultiple = _ref2.filterMultiple, searchValue = _ref2.searchValue, filterSearch = _ref2.filterSearch;
  return filters.map(function(filter, index2) {
    var key2 = String(filter.value);
    if (filter.children) {
      return {
        key: key2 || index2,
        label: filter.text,
        popupClassName: "".concat(prefixCls, "-dropdown-submenu"),
        children: renderFilterItems({
          filters: filter.children,
          prefixCls,
          filteredKeys,
          filterMultiple,
          searchValue,
          filterSearch
        })
      };
    }
    var Component2 = filterMultiple ? Checkbox$1 : Radio$1;
    var item = {
      key: filter.value !== void 0 ? key2 : index2,
      label: /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Component2, {
        checked: filteredKeys.includes(key2)
      }), /* @__PURE__ */ react.exports.createElement("span", null, filter.text))
    };
    if (searchValue.trim()) {
      if (typeof filterSearch === "function") {
        return filterSearch(searchValue, filter) ? item : null;
      }
      return searchValueMatched(searchValue, filter.text) ? item : null;
    }
    return item;
  });
}
function FilterDropdown(props) {
  var _a;
  var tablePrefixCls = props.tablePrefixCls, prefixCls = props.prefixCls, column = props.column, dropdownPrefixCls = props.dropdownPrefixCls, columnKey = props.columnKey, filterMultiple = props.filterMultiple, _props$filterMode = props.filterMode, filterMode = _props$filterMode === void 0 ? "menu" : _props$filterMode, _props$filterSearch = props.filterSearch, filterSearch = _props$filterSearch === void 0 ? false : _props$filterSearch, filterState = props.filterState, triggerFilter = props.triggerFilter, locale2 = props.locale, children = props.children, getPopupContainer = props.getPopupContainer;
  var filterDropdownVisible = column.filterDropdownVisible, onFilterDropdownVisibleChange = column.onFilterDropdownVisibleChange, filterResetToDefaultFilteredValue = column.filterResetToDefaultFilteredValue, defaultFilteredValue = column.defaultFilteredValue;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), visible = _React$useState2[0], setVisible = _React$useState2[1];
  var filtered = !!(filterState && (((_a = filterState.filteredKeys) === null || _a === void 0 ? void 0 : _a.length) || filterState.forceFiltered));
  var triggerVisible = function triggerVisible2(newVisible) {
    setVisible(newVisible);
    onFilterDropdownVisibleChange === null || onFilterDropdownVisibleChange === void 0 ? void 0 : onFilterDropdownVisibleChange(newVisible);
  };
  var mergedVisible = typeof filterDropdownVisible === "boolean" ? filterDropdownVisible : visible;
  var propFilteredKeys = filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys;
  var _useSyncState = useSyncState(propFilteredKeys || []), _useSyncState2 = _slicedToArray$3(_useSyncState, 2), getFilteredKeysSync = _useSyncState2[0], setFilteredKeysSync = _useSyncState2[1];
  var onSelectKeys = function onSelectKeys2(_ref3) {
    var selectedKeys2 = _ref3.selectedKeys;
    setFilteredKeysSync(selectedKeys2);
  };
  var onCheck = function onCheck2(keys2, _ref4) {
    var node = _ref4.node, checked = _ref4.checked;
    if (!filterMultiple) {
      onSelectKeys({
        selectedKeys: checked && node.key ? [node.key] : []
      });
    } else {
      onSelectKeys({
        selectedKeys: keys2
      });
    }
  };
  react.exports.useEffect(function() {
    if (!visible) {
      return;
    }
    onSelectKeys({
      selectedKeys: propFilteredKeys || []
    });
  }, [propFilteredKeys]);
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray$3(_React$useState3, 2), openKeys = _React$useState4[0], setOpenKeys = _React$useState4[1];
  var onOpenChange = function onOpenChange2(keys2) {
    setOpenKeys(keys2);
  };
  var _React$useState5 = react.exports.useState(""), _React$useState6 = _slicedToArray$3(_React$useState5, 2), searchValue = _React$useState6[0], setSearchValue = _React$useState6[1];
  var onSearch = function onSearch2(e2) {
    var value2 = e2.target.value;
    setSearchValue(value2);
  };
  react.exports.useEffect(function() {
    if (!visible) {
      setSearchValue("");
    }
  }, [visible]);
  var internalTriggerFilter = function internalTriggerFilter2(keys2) {
    var mergedKeys = keys2 && keys2.length ? keys2 : null;
    if (mergedKeys === null && (!filterState || !filterState.filteredKeys)) {
      return null;
    }
    if (isEqual_1(mergedKeys, filterState === null || filterState === void 0 ? void 0 : filterState.filteredKeys)) {
      return null;
    }
    triggerFilter({
      column,
      key: columnKey,
      filteredKeys: mergedKeys
    });
  };
  var onConfirm = function onConfirm2() {
    triggerVisible(false);
    internalTriggerFilter(getFilteredKeysSync());
  };
  var onReset = function onReset2() {
    var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      confirm: false,
      closeDropdown: false
    }, confirm = _ref5.confirm, closeDropdown = _ref5.closeDropdown;
    if (confirm) {
      internalTriggerFilter([]);
    }
    if (closeDropdown) {
      triggerVisible(false);
    }
    setSearchValue("");
    if (filterResetToDefaultFilteredValue) {
      setFilteredKeysSync((defaultFilteredValue || []).map(function(key2) {
        return String(key2);
      }));
    } else {
      setFilteredKeysSync([]);
    }
  };
  var doFilter = function doFilter2() {
    var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      closeDropdown: true
    }, closeDropdown = _ref6.closeDropdown;
    if (closeDropdown) {
      triggerVisible(false);
    }
    internalTriggerFilter(getFilteredKeysSync());
  };
  var onVisibleChange = function onVisibleChange2(newVisible) {
    if (newVisible && propFilteredKeys !== void 0) {
      setFilteredKeysSync(propFilteredKeys || []);
    }
    triggerVisible(newVisible);
    if (!newVisible && !column.filterDropdown) {
      onConfirm();
    }
  };
  var dropdownMenuClass = classnamesExports(_defineProperty$5({}, "".concat(dropdownPrefixCls, "-menu-without-submenu"), !hasSubMenu(column.filters || [])));
  var onCheckAll = function onCheckAll2(e2) {
    if (e2.target.checked) {
      var allFilterKeys = flattenKeys(column === null || column === void 0 ? void 0 : column.filters).map(function(key2) {
        return String(key2);
      });
      setFilteredKeysSync(allFilterKeys);
    } else {
      setFilteredKeysSync([]);
    }
  };
  var getTreeData2 = function getTreeData3(_ref7) {
    var filters = _ref7.filters;
    return (filters || []).map(function(filter, index2) {
      var key2 = String(filter.value);
      var item = {
        title: filter.text,
        key: filter.value !== void 0 ? key2 : index2
      };
      if (filter.children) {
        item.children = getTreeData3({
          filters: filter.children
        });
      }
      return item;
    });
  };
  var dropdownContent;
  if (typeof column.filterDropdown === "function") {
    dropdownContent = column.filterDropdown({
      prefixCls: "".concat(dropdownPrefixCls, "-custom"),
      setSelectedKeys: function setSelectedKeys(selectedKeys2) {
        return onSelectKeys({
          selectedKeys: selectedKeys2
        });
      },
      selectedKeys: getFilteredKeysSync(),
      confirm: doFilter,
      clearFilters: onReset,
      filters: column.filters,
      visible: mergedVisible
    });
  } else if (column.filterDropdown) {
    dropdownContent = column.filterDropdown;
  } else {
    var selectedKeys = getFilteredKeysSync() || [];
    var getFilterComponent = function getFilterComponent2() {
      if ((column.filters || []).length === 0) {
        return /* @__PURE__ */ react.exports.createElement(Empty$1, {
          image: Empty$1.PRESENTED_IMAGE_SIMPLE,
          description: locale2.filterEmptyText,
          imageStyle: {
            height: 24
          },
          style: {
            margin: 0,
            padding: "16px 0"
          }
        });
      }
      if (filterMode === "tree") {
        return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(FilterSearch$1, {
          filterSearch,
          value: searchValue,
          onChange: onSearch,
          tablePrefixCls,
          locale: locale2
        }), /* @__PURE__ */ react.exports.createElement("div", {
          className: "".concat(tablePrefixCls, "-filter-dropdown-tree")
        }, filterMultiple ? /* @__PURE__ */ react.exports.createElement(Checkbox$1, {
          checked: selectedKeys.length === flattenKeys(column.filters).length,
          indeterminate: selectedKeys.length > 0 && selectedKeys.length < flattenKeys(column.filters).length,
          className: "".concat(tablePrefixCls, "-filter-dropdown-checkall"),
          onChange: onCheckAll
        }, locale2.filterCheckall) : null, /* @__PURE__ */ react.exports.createElement(Tree$1, {
          checkable: true,
          selectable: false,
          blockNode: true,
          multiple: filterMultiple,
          checkStrictly: !filterMultiple,
          className: "".concat(dropdownPrefixCls, "-menu"),
          onCheck,
          checkedKeys: selectedKeys,
          selectedKeys,
          showIcon: false,
          treeData: getTreeData2({
            filters: column.filters
          }),
          autoExpandParent: true,
          defaultExpandAll: true,
          filterTreeNode: searchValue.trim() ? function(node) {
            return searchValueMatched(searchValue, node.title);
          } : void 0
        })));
      }
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(FilterSearch$1, {
        filterSearch,
        value: searchValue,
        onChange: onSearch,
        tablePrefixCls,
        locale: locale2
      }), /* @__PURE__ */ react.exports.createElement(Menu$1, {
        selectable: true,
        multiple: filterMultiple,
        prefixCls: "".concat(dropdownPrefixCls, "-menu"),
        className: dropdownMenuClass,
        onSelect: onSelectKeys,
        onDeselect: onSelectKeys,
        selectedKeys,
        getPopupContainer,
        openKeys,
        onOpenChange,
        items: renderFilterItems({
          filters: column.filters || [],
          filterSearch,
          prefixCls,
          filteredKeys: getFilteredKeysSync(),
          filterMultiple,
          searchValue
        })
      }));
    };
    var getResetDisabled = function getResetDisabled2() {
      if (filterResetToDefaultFilteredValue) {
        return isEqual_1((defaultFilteredValue || []).map(function(key2) {
          return String(key2);
        }), selectedKeys);
      }
      return selectedKeys.length === 0;
    };
    dropdownContent = /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, getFilterComponent(), /* @__PURE__ */ react.exports.createElement("div", {
      className: "".concat(prefixCls, "-dropdown-btns")
    }, /* @__PURE__ */ react.exports.createElement(Button$2, {
      type: "link",
      size: "small",
      disabled: getResetDisabled(),
      onClick: function onClick() {
        return onReset();
      }
    }, locale2.filterReset), /* @__PURE__ */ react.exports.createElement(Button$2, {
      type: "primary",
      size: "small",
      onClick: onConfirm
    }, locale2.filterConfirm)));
  }
  if (column.filterDropdown) {
    dropdownContent = /* @__PURE__ */ react.exports.createElement(OverrideProvider, {
      selectable: void 0
    }, dropdownContent);
  }
  var menu = /* @__PURE__ */ react.exports.createElement(FilterDropdownMenuWrapper$1, {
    className: "".concat(prefixCls, "-dropdown")
  }, dropdownContent);
  var filterIcon;
  if (typeof column.filterIcon === "function") {
    filterIcon = column.filterIcon(filtered);
  } else if (column.filterIcon) {
    filterIcon = column.filterIcon;
  } else {
    filterIcon = /* @__PURE__ */ react.exports.createElement(FilterFilled$1, null);
  }
  var _React$useContext = react.exports.useContext(ConfigContext), direction = _React$useContext.direction;
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: "".concat(prefixCls, "-column")
  }, /* @__PURE__ */ react.exports.createElement("span", {
    className: "".concat(tablePrefixCls, "-column-title")
  }, children), /* @__PURE__ */ react.exports.createElement(Dropdown$1, {
    overlay: menu,
    trigger: ["click"],
    visible: mergedVisible,
    onVisibleChange,
    getPopupContainer,
    placement: direction === "rtl" ? "bottomLeft" : "bottomRight"
  }, /* @__PURE__ */ react.exports.createElement("span", {
    role: "button",
    tabIndex: -1,
    className: classnamesExports("".concat(prefixCls, "-trigger"), {
      active: filtered
    }),
    onClick: function onClick(e2) {
      e2.stopPropagation();
    }
  }, filterIcon)));
}
function collectFilterStates(columns, init, pos) {
  var filterStates = [];
  (columns || []).forEach(function(column, index2) {
    var _a;
    var columnPos = getColumnPos(index2, pos);
    if (column.filters || "filterDropdown" in column || "onFilter" in column) {
      if ("filteredValue" in column) {
        var filteredValues = column.filteredValue;
        if (!("filterDropdown" in column)) {
          filteredValues = (_a = filteredValues === null || filteredValues === void 0 ? void 0 : filteredValues.map(String)) !== null && _a !== void 0 ? _a : filteredValues;
        }
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: filteredValues,
          forceFiltered: column.filtered
        });
      } else {
        filterStates.push({
          column,
          key: getColumnKey(column, columnPos),
          filteredKeys: init && column.defaultFilteredValue ? column.defaultFilteredValue : void 0,
          forceFiltered: column.filtered
        });
      }
    }
    if ("children" in column) {
      filterStates = [].concat(_toConsumableArray(filterStates), _toConsumableArray(collectFilterStates(column.children, init, columnPos)));
    }
  });
  return filterStates;
}
function injectFilter(prefixCls, dropdownPrefixCls, columns, filterStates, triggerFilter, getPopupContainer, locale2, pos) {
  return columns.map(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    var _column$filterMultipl = column.filterMultiple, filterMultiple = _column$filterMultipl === void 0 ? true : _column$filterMultipl, filterMode = column.filterMode, filterSearch = column.filterSearch;
    var newColumn = column;
    if (newColumn.filters || newColumn.filterDropdown) {
      var columnKey = getColumnKey(newColumn, columnPos);
      var filterState = filterStates.find(function(_ref) {
        var key2 = _ref.key;
        return columnKey === key2;
      });
      newColumn = _extends$2(_extends$2({}, newColumn), {
        title: function title(renderProps) {
          return /* @__PURE__ */ react.exports.createElement(FilterDropdown, {
            tablePrefixCls: prefixCls,
            prefixCls: "".concat(prefixCls, "-filter"),
            dropdownPrefixCls,
            column: newColumn,
            columnKey,
            filterState,
            filterMultiple,
            filterMode,
            filterSearch,
            triggerFilter,
            locale: locale2,
            getPopupContainer
          }, renderColumnTitle(column.title, renderProps));
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends$2(_extends$2({}, newColumn), {
        children: injectFilter(prefixCls, dropdownPrefixCls, newColumn.children, filterStates, triggerFilter, getPopupContainer, locale2, columnPos)
      });
    }
    return newColumn;
  });
}
function flattenKeys(filters) {
  var keys2 = [];
  (filters || []).forEach(function(_ref2) {
    var value2 = _ref2.value, children = _ref2.children;
    keys2.push(value2);
    if (children) {
      keys2 = [].concat(_toConsumableArray(keys2), _toConsumableArray(flattenKeys(children)));
    }
  });
  return keys2;
}
function generateFilterInfo(filterStates) {
  var currentFilters = {};
  filterStates.forEach(function(_ref3) {
    var key2 = _ref3.key, filteredKeys = _ref3.filteredKeys, column = _ref3.column;
    var filters = column.filters, filterDropdown = column.filterDropdown;
    if (filterDropdown) {
      currentFilters[key2] = filteredKeys || null;
    } else if (Array.isArray(filteredKeys)) {
      var keys2 = flattenKeys(filters);
      currentFilters[key2] = keys2.filter(function(originKey) {
        return filteredKeys.includes(String(originKey));
      });
    } else {
      currentFilters[key2] = null;
    }
  });
  return currentFilters;
}
function getFilterData(data2, filterStates) {
  return filterStates.reduce(function(currentData, filterState) {
    var _filterState$column = filterState.column, onFilter = _filterState$column.onFilter, filters = _filterState$column.filters, filteredKeys = filterState.filteredKeys;
    if (onFilter && filteredKeys && filteredKeys.length) {
      return currentData.filter(function(record) {
        return filteredKeys.some(function(key2) {
          var keys2 = flattenKeys(filters);
          var keyIndex = keys2.findIndex(function(k2) {
            return String(k2) === String(key2);
          });
          var realKey = keyIndex !== -1 ? keys2[keyIndex] : key2;
          return onFilter(realKey, record);
        });
      });
    }
    return currentData;
  }, data2);
}
function useFilter(_ref4) {
  var prefixCls = _ref4.prefixCls, dropdownPrefixCls = _ref4.dropdownPrefixCls, mergedColumns = _ref4.mergedColumns, onFilterChange = _ref4.onFilterChange, getPopupContainer = _ref4.getPopupContainer, tableLocale = _ref4.locale;
  var _React$useState = react.exports.useState(collectFilterStates(mergedColumns, true)), _React$useState2 = _slicedToArray$3(_React$useState, 2), filterStates = _React$useState2[0], setFilterStates = _React$useState2[1];
  var mergedFilterStates = react.exports.useMemo(function() {
    var collectedStates = collectFilterStates(mergedColumns, false);
    var filteredKeysIsAllNotControlled = true;
    collectedStates.forEach(function(_ref5) {
      var filteredKeys = _ref5.filteredKeys;
      if (filteredKeys !== void 0) {
        filteredKeysIsAllNotControlled = false;
      }
    });
    if (filteredKeysIsAllNotControlled) {
      return filterStates;
    }
    return collectedStates;
  }, [mergedColumns, filterStates]);
  var getFilters = react.exports.useCallback(function() {
    return generateFilterInfo(mergedFilterStates);
  }, [mergedFilterStates]);
  var triggerFilter = function triggerFilter2(filterState) {
    var newFilterStates = mergedFilterStates.filter(function(_ref6) {
      var key2 = _ref6.key;
      return key2 !== filterState.key;
    });
    newFilterStates.push(filterState);
    setFilterStates(newFilterStates);
    onFilterChange(generateFilterInfo(newFilterStates), newFilterStates);
  };
  var transformColumns = function transformColumns2(innerColumns) {
    return injectFilter(prefixCls, dropdownPrefixCls, innerColumns, mergedFilterStates, triggerFilter, getPopupContainer, tableLocale);
  };
  return [transformColumns, mergedFilterStates, getFilters];
}
function useLazyKVMap(data2, childrenColumnName, getRowKey) {
  var mapCacheRef = react.exports.useRef({});
  function getRecordByKey(key2) {
    if (!mapCacheRef.current || mapCacheRef.current.data !== data2 || mapCacheRef.current.childrenColumnName !== childrenColumnName || mapCacheRef.current.getRowKey !== getRowKey) {
      let dig = function(records) {
        records.forEach(function(record, index2) {
          var rowKey = getRowKey(record, index2);
          kvMap.set(rowKey, record);
          if (record && _typeof$4(record) === "object" && childrenColumnName in record) {
            dig(record[childrenColumnName] || []);
          }
        });
      };
      var kvMap = /* @__PURE__ */ new Map();
      dig(data2);
      mapCacheRef.current = {
        data: data2,
        childrenColumnName,
        kvMap,
        getRowKey
      };
    }
    return mapCacheRef.current.kvMap.get(key2);
  }
  return [getRecordByKey];
}
var __rest$5 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var DEFAULT_PAGE_SIZE = 10;
function getPaginationParam(pagination, mergedPagination) {
  var param = {
    current: mergedPagination.current,
    pageSize: mergedPagination.pageSize
  };
  var paginationObj = pagination && _typeof$4(pagination) === "object" ? pagination : {};
  Object.keys(paginationObj).forEach(function(pageProp) {
    var value2 = mergedPagination[pageProp];
    if (typeof value2 !== "function") {
      param[pageProp] = value2;
    }
  });
  return param;
}
function extendsObject() {
  var result = {};
  for (var _len = arguments.length, list2 = new Array(_len), _key = 0; _key < _len; _key++) {
    list2[_key] = arguments[_key];
  }
  list2.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key2) {
        var val = obj[key2];
        if (val !== void 0) {
          result[key2] = val;
        }
      });
    }
  });
  return result;
}
function usePagination(total, pagination, onChange2) {
  var _a = pagination && _typeof$4(pagination) === "object" ? pagination : {}, _a$total = _a.total, paginationTotal = _a$total === void 0 ? 0 : _a$total, paginationObj = __rest$5(_a, ["total"]);
  var _useState = react.exports.useState(function() {
    return {
      current: "defaultCurrent" in paginationObj ? paginationObj.defaultCurrent : 1,
      pageSize: "defaultPageSize" in paginationObj ? paginationObj.defaultPageSize : DEFAULT_PAGE_SIZE
    };
  }), _useState2 = _slicedToArray$3(_useState, 2), innerPagination = _useState2[0], setInnerPagination = _useState2[1];
  var mergedPagination = extendsObject(innerPagination, paginationObj, {
    total: paginationTotal > 0 ? paginationTotal : total
  });
  var maxPage = Math.ceil((paginationTotal || total) / mergedPagination.pageSize);
  if (mergedPagination.current > maxPage) {
    mergedPagination.current = maxPage || 1;
  }
  var refreshPagination = function refreshPagination2(current, pageSize) {
    setInnerPagination({
      current: current !== null && current !== void 0 ? current : 1,
      pageSize: pageSize || mergedPagination.pageSize
    });
  };
  var onInternalChange = function onInternalChange2(current, pageSize) {
    var _a2;
    if (pagination) {
      (_a2 = pagination.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(pagination, current, pageSize);
    }
    refreshPagination(current, pageSize);
    onChange2(current, pageSize || (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.pageSize));
  };
  if (pagination === false) {
    return [{}, function() {
    }];
  }
  return [_extends$2(_extends$2({}, mergedPagination), {
    onChange: onInternalChange
  }), refreshPagination];
}
var SELECTION_COLUMN = {};
var SELECTION_ALL = "SELECT_ALL";
var SELECTION_INVERT = "SELECT_INVERT";
var SELECTION_NONE = "SELECT_NONE";
var EMPTY_LIST$1 = [];
function flattenData(data2, childrenColumnName) {
  var list2 = [];
  (data2 || []).forEach(function(record) {
    list2.push(record);
    if (record && _typeof$4(record) === "object" && childrenColumnName in record) {
      list2 = [].concat(_toConsumableArray(list2), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));
    }
  });
  return list2;
}
function useSelection(rowSelection, config) {
  var _ref = rowSelection || {}, preserveSelectedRowKeys = _ref.preserveSelectedRowKeys, selectedRowKeys = _ref.selectedRowKeys, defaultSelectedRowKeys = _ref.defaultSelectedRowKeys, getCheckboxProps = _ref.getCheckboxProps, onSelectionChange = _ref.onChange, onSelect = _ref.onSelect, onSelectAll = _ref.onSelectAll, onSelectInvert = _ref.onSelectInvert, onSelectNone = _ref.onSelectNone, onSelectMultiple = _ref.onSelectMultiple, selectionColWidth = _ref.columnWidth, selectionType = _ref.type, selections = _ref.selections, fixed = _ref.fixed, customizeRenderCell = _ref.renderCell, hideSelectAll = _ref.hideSelectAll, _ref$checkStrictly = _ref.checkStrictly, checkStrictly = _ref$checkStrictly === void 0 ? true : _ref$checkStrictly;
  var prefixCls = config.prefixCls, data2 = config.data, pageData = config.pageData, getRecordByKey = config.getRecordByKey, getRowKey = config.getRowKey, expandType = config.expandType, childrenColumnName = config.childrenColumnName, tableLocale = config.locale, getPopupContainer = config.getPopupContainer;
  var _useMergedState = useMergedState(selectedRowKeys || defaultSelectedRowKeys || EMPTY_LIST$1, {
    value: selectedRowKeys
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), mergedSelectedKeys = _useMergedState2[0], setMergedSelectedKeys = _useMergedState2[1];
  var preserveRecordsRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var updatePreserveRecordsCache = react.exports.useCallback(function(keys2) {
    if (preserveSelectedRowKeys) {
      var newCache = /* @__PURE__ */ new Map();
      keys2.forEach(function(key2) {
        var record = getRecordByKey(key2);
        if (!record && preserveRecordsRef.current.has(key2)) {
          record = preserveRecordsRef.current.get(key2);
        }
        newCache.set(key2, record);
      });
      preserveRecordsRef.current = newCache;
    }
  }, [getRecordByKey, preserveSelectedRowKeys]);
  react.exports.useEffect(function() {
    updatePreserveRecordsCache(mergedSelectedKeys);
  }, [mergedSelectedKeys]);
  var _useMemo = react.exports.useMemo(function() {
    return checkStrictly ? {
      keyEntities: null
    } : convertDataToEntities(data2, {
      externalGetKey: getRowKey,
      childrenPropName: childrenColumnName
    });
  }, [data2, getRowKey, checkStrictly, childrenColumnName]), keyEntities = _useMemo.keyEntities;
  var flattedData = react.exports.useMemo(function() {
    return flattenData(pageData, childrenColumnName);
  }, [pageData, childrenColumnName]);
  var checkboxPropsMap = react.exports.useMemo(function() {
    var map = /* @__PURE__ */ new Map();
    flattedData.forEach(function(record, index2) {
      var key2 = getRowKey(record, index2);
      var checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};
      map.set(key2, checkboxProps);
    });
    return map;
  }, [flattedData, getRowKey, getCheckboxProps]);
  var isCheckboxDisabled = react.exports.useCallback(function(r2) {
    var _a;
    return !!((_a = checkboxPropsMap.get(getRowKey(r2))) === null || _a === void 0 ? void 0 : _a.disabled);
  }, [checkboxPropsMap, getRowKey]);
  var _useMemo2 = react.exports.useMemo(function() {
    if (checkStrictly) {
      return [mergedSelectedKeys || [], []];
    }
    var _conductCheck = conductCheck(mergedSelectedKeys, true, keyEntities, isCheckboxDisabled), checkedKeys = _conductCheck.checkedKeys, halfCheckedKeys = _conductCheck.halfCheckedKeys;
    return [checkedKeys || [], halfCheckedKeys];
  }, [mergedSelectedKeys, checkStrictly, keyEntities, isCheckboxDisabled]), _useMemo3 = _slicedToArray$3(_useMemo2, 2), derivedSelectedKeys = _useMemo3[0], derivedHalfSelectedKeys = _useMemo3[1];
  var derivedSelectedKeySet = react.exports.useMemo(function() {
    var keys2 = selectionType === "radio" ? derivedSelectedKeys.slice(0, 1) : derivedSelectedKeys;
    return new Set(keys2);
  }, [derivedSelectedKeys, selectionType]);
  var derivedHalfSelectedKeySet = react.exports.useMemo(function() {
    return selectionType === "radio" ? /* @__PURE__ */ new Set() : new Set(derivedHalfSelectedKeys);
  }, [derivedHalfSelectedKeys, selectionType]);
  var _useState = react.exports.useState(null), _useState2 = _slicedToArray$3(_useState, 2), lastSelectedKey = _useState2[0], setLastSelectedKey = _useState2[1];
  react.exports.useEffect(function() {
    if (!rowSelection) {
      setMergedSelectedKeys(EMPTY_LIST$1);
    }
  }, [!!rowSelection]);
  var setSelectedKeys = react.exports.useCallback(function(keys2, method4) {
    var availableKeys;
    var records;
    updatePreserveRecordsCache(keys2);
    if (preserveSelectedRowKeys) {
      availableKeys = keys2;
      records = keys2.map(function(key2) {
        return preserveRecordsRef.current.get(key2);
      });
    } else {
      availableKeys = [];
      records = [];
      keys2.forEach(function(key2) {
        var record = getRecordByKey(key2);
        if (record !== void 0) {
          availableKeys.push(key2);
          records.push(record);
        }
      });
    }
    setMergedSelectedKeys(availableKeys);
    onSelectionChange === null || onSelectionChange === void 0 ? void 0 : onSelectionChange(availableKeys, records, {
      type: method4
    });
  }, [setMergedSelectedKeys, getRecordByKey, onSelectionChange, preserveSelectedRowKeys]);
  var triggerSingleSelection = react.exports.useCallback(function(key2, selected, keys2, event) {
    if (onSelect) {
      var rows = keys2.map(function(k2) {
        return getRecordByKey(k2);
      });
      onSelect(getRecordByKey(key2), selected, rows, event);
    }
    setSelectedKeys(keys2, "single");
  }, [onSelect, getRecordByKey, setSelectedKeys]);
  var mergedSelections = react.exports.useMemo(function() {
    if (!selections || hideSelectAll) {
      return null;
    }
    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT, SELECTION_NONE] : selections;
    return selectionList.map(function(selection) {
      if (selection === SELECTION_ALL) {
        return {
          key: "all",
          text: tableLocale.selectionAll,
          onSelect: function onSelect2() {
            setSelectedKeys(data2.map(function(record, index2) {
              return getRowKey(record, index2);
            }).filter(function(key2) {
              var checkProps = checkboxPropsMap.get(key2);
              return !(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled) || derivedSelectedKeySet.has(key2);
            }), "all");
          }
        };
      }
      if (selection === SELECTION_INVERT) {
        return {
          key: "invert",
          text: tableLocale.selectInvert,
          onSelect: function onSelect2() {
            var keySet = new Set(derivedSelectedKeySet);
            pageData.forEach(function(record, index2) {
              var key2 = getRowKey(record, index2);
              var checkProps = checkboxPropsMap.get(key2);
              if (!(checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled)) {
                if (keySet.has(key2)) {
                  keySet["delete"](key2);
                } else {
                  keySet.add(key2);
                }
              }
            });
            var keys2 = Array.from(keySet);
            if (onSelectInvert) {
              onSelectInvert(keys2);
            }
            setSelectedKeys(keys2, "invert");
          }
        };
      }
      if (selection === SELECTION_NONE) {
        return {
          key: "none",
          text: tableLocale.selectNone,
          onSelect: function onSelect2() {
            onSelectNone === null || onSelectNone === void 0 ? void 0 : onSelectNone();
            setSelectedKeys(Array.from(derivedSelectedKeySet).filter(function(key2) {
              var checkProps = checkboxPropsMap.get(key2);
              return checkProps === null || checkProps === void 0 ? void 0 : checkProps.disabled;
            }), "none");
          }
        };
      }
      return selection;
    }).map(function(selection) {
      return _extends$2(_extends$2({}, selection), {
        onSelect: function onSelect2() {
          var _a2;
          var _a;
          for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
            rest[_key] = arguments[_key];
          }
          (_a = selection.onSelect) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [selection].concat(rest));
          setLastSelectedKey(null);
        }
      });
    });
  }, [selections, derivedSelectedKeySet, pageData, getRowKey, onSelectInvert, setSelectedKeys]);
  var transformColumns = react.exports.useCallback(function(columns) {
    var _a;
    if (!rowSelection) {
      return columns.filter(function(col) {
        return col !== SELECTION_COLUMN;
      });
    }
    var cloneColumns = _toConsumableArray(columns);
    var keySet = new Set(derivedSelectedKeySet);
    var recordKeys = flattedData.map(getRowKey).filter(function(key2) {
      return !checkboxPropsMap.get(key2).disabled;
    });
    var checkedCurrentAll = recordKeys.every(function(key2) {
      return keySet.has(key2);
    });
    var checkedCurrentSome = recordKeys.some(function(key2) {
      return keySet.has(key2);
    });
    var onSelectAllChange = function onSelectAllChange2() {
      var changeKeys = [];
      if (checkedCurrentAll) {
        recordKeys.forEach(function(key2) {
          keySet["delete"](key2);
          changeKeys.push(key2);
        });
      } else {
        recordKeys.forEach(function(key2) {
          if (!keySet.has(key2)) {
            keySet.add(key2);
            changeKeys.push(key2);
          }
        });
      }
      var keys2 = Array.from(keySet);
      onSelectAll === null || onSelectAll === void 0 ? void 0 : onSelectAll(!checkedCurrentAll, keys2.map(function(k2) {
        return getRecordByKey(k2);
      }), changeKeys.map(function(k2) {
        return getRecordByKey(k2);
      }));
      setSelectedKeys(keys2, "all");
      setLastSelectedKey(null);
    };
    var title;
    if (selectionType !== "radio") {
      var customizeSelections;
      if (mergedSelections) {
        var menu = /* @__PURE__ */ react.exports.createElement(Menu$1, {
          getPopupContainer,
          items: mergedSelections.map(function(selection, index2) {
            var key2 = selection.key, text2 = selection.text, onSelectionClick = selection.onSelect;
            return {
              key: key2 || index2,
              onClick: function onClick() {
                onSelectionClick === null || onSelectionClick === void 0 ? void 0 : onSelectionClick(recordKeys);
              },
              label: text2
            };
          })
        });
        customizeSelections = /* @__PURE__ */ react.exports.createElement("div", {
          className: "".concat(prefixCls, "-selection-extra")
        }, /* @__PURE__ */ react.exports.createElement(Dropdown$1, {
          overlay: menu,
          getPopupContainer
        }, /* @__PURE__ */ react.exports.createElement("span", null, /* @__PURE__ */ react.exports.createElement(DownOutlined$1, null))));
      }
      var allDisabledData = flattedData.map(function(record, index2) {
        var key2 = getRowKey(record, index2);
        var checkboxProps = checkboxPropsMap.get(key2) || {};
        return _extends$2({
          checked: keySet.has(key2)
        }, checkboxProps);
      }).filter(function(_ref2) {
        var disabled = _ref2.disabled;
        return disabled;
      });
      var allDisabled = !!allDisabledData.length && allDisabledData.length === flattedData.length;
      var allDisabledAndChecked = allDisabled && allDisabledData.every(function(_ref3) {
        var checked = _ref3.checked;
        return checked;
      });
      var allDisabledSomeChecked = allDisabled && allDisabledData.some(function(_ref4) {
        var checked = _ref4.checked;
        return checked;
      });
      title = !hideSelectAll && /* @__PURE__ */ react.exports.createElement("div", {
        className: "".concat(prefixCls, "-selection")
      }, /* @__PURE__ */ react.exports.createElement(Checkbox$1, {
        checked: !allDisabled ? !!flattedData.length && checkedCurrentAll : allDisabledAndChecked,
        indeterminate: !allDisabled ? !checkedCurrentAll && checkedCurrentSome : !allDisabledAndChecked && allDisabledSomeChecked,
        onChange: onSelectAllChange,
        disabled: flattedData.length === 0 || allDisabled,
        skipGroup: true
      }), customizeSelections);
    }
    var renderCell;
    if (selectionType === "radio") {
      renderCell = function renderCell2(_, record, index2) {
        var key2 = getRowKey(record, index2);
        var checked = keySet.has(key2);
        return {
          node: /* @__PURE__ */ react.exports.createElement(Radio$1, _extends$2({}, checkboxPropsMap.get(key2), {
            checked,
            onClick: function onClick(e2) {
              return e2.stopPropagation();
            },
            onChange: function onChange2(event) {
              if (!keySet.has(key2)) {
                triggerSingleSelection(key2, true, [key2], event.nativeEvent);
              }
            }
          })),
          checked
        };
      };
    } else {
      renderCell = function renderCell2(_, record, index2) {
        var _a2;
        var key2 = getRowKey(record, index2);
        var checked = keySet.has(key2);
        var indeterminate = derivedHalfSelectedKeySet.has(key2);
        var checkboxProps = checkboxPropsMap.get(key2);
        var mergedIndeterminate;
        if (expandType === "nest") {
          mergedIndeterminate = indeterminate;
        } else {
          mergedIndeterminate = (_a2 = checkboxProps === null || checkboxProps === void 0 ? void 0 : checkboxProps.indeterminate) !== null && _a2 !== void 0 ? _a2 : indeterminate;
        }
        return {
          node: /* @__PURE__ */ react.exports.createElement(Checkbox$1, _extends$2({}, checkboxProps, {
            indeterminate: mergedIndeterminate,
            checked,
            skipGroup: true,
            onClick: function onClick(e2) {
              return e2.stopPropagation();
            },
            onChange: function onChange2(_ref5) {
              var nativeEvent = _ref5.nativeEvent;
              var shiftKey = nativeEvent.shiftKey;
              var startIndex = -1;
              var endIndex = -1;
              if (shiftKey && checkStrictly) {
                var pointKeys = /* @__PURE__ */ new Set([lastSelectedKey, key2]);
                recordKeys.some(function(recordKey, recordIndex) {
                  if (pointKeys.has(recordKey)) {
                    if (startIndex === -1) {
                      startIndex = recordIndex;
                    } else {
                      endIndex = recordIndex;
                      return true;
                    }
                  }
                  return false;
                });
              }
              if (endIndex !== -1 && startIndex !== endIndex && checkStrictly) {
                var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);
                var changedKeys = [];
                if (checked) {
                  rangeKeys.forEach(function(recordKey) {
                    if (keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet["delete"](recordKey);
                    }
                  });
                } else {
                  rangeKeys.forEach(function(recordKey) {
                    if (!keySet.has(recordKey)) {
                      changedKeys.push(recordKey);
                      keySet.add(recordKey);
                    }
                  });
                }
                var keys2 = Array.from(keySet);
                onSelectMultiple === null || onSelectMultiple === void 0 ? void 0 : onSelectMultiple(!checked, keys2.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }), changedKeys.map(function(recordKey) {
                  return getRecordByKey(recordKey);
                }));
                setSelectedKeys(keys2, "multiple");
              } else {
                var originCheckedKeys = derivedSelectedKeys;
                if (checkStrictly) {
                  var checkedKeys = checked ? arrDel(originCheckedKeys, key2) : arrAdd(originCheckedKeys, key2);
                  triggerSingleSelection(key2, !checked, checkedKeys, nativeEvent);
                } else {
                  var result = conductCheck([].concat(_toConsumableArray(originCheckedKeys), [key2]), true, keyEntities, isCheckboxDisabled);
                  var _checkedKeys = result.checkedKeys, halfCheckedKeys = result.halfCheckedKeys;
                  var nextCheckedKeys = _checkedKeys;
                  if (checked) {
                    var tempKeySet = new Set(_checkedKeys);
                    tempKeySet["delete"](key2);
                    nextCheckedKeys = conductCheck(Array.from(tempKeySet), {
                      checked: false,
                      halfCheckedKeys
                    }, keyEntities, isCheckboxDisabled).checkedKeys;
                  }
                  triggerSingleSelection(key2, !checked, nextCheckedKeys, nativeEvent);
                }
              }
              if (checked) {
                setLastSelectedKey(null);
              } else {
                setLastSelectedKey(key2);
              }
            }
          })),
          checked
        };
      };
    }
    var renderSelectionCell = function renderSelectionCell2(_, record, index2) {
      var _renderCell = renderCell(_, record, index2), node = _renderCell.node, checked = _renderCell.checked;
      if (customizeRenderCell) {
        return customizeRenderCell(checked, record, index2, node);
      }
      return node;
    };
    if (!cloneColumns.includes(SELECTION_COLUMN)) {
      if (cloneColumns.findIndex(function(col) {
        var _a2;
        return ((_a2 = col[INTERNAL_COL_DEFINE]) === null || _a2 === void 0 ? void 0 : _a2.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        var _cloneColumns = cloneColumns, _cloneColumns2 = _toArray(_cloneColumns), expandColumn = _cloneColumns2[0], restColumns = _cloneColumns2.slice(1);
        cloneColumns = [expandColumn, SELECTION_COLUMN].concat(_toConsumableArray(restColumns));
      } else {
        cloneColumns = [SELECTION_COLUMN].concat(_toConsumableArray(cloneColumns));
      }
    }
    var selectionColumnIndex = cloneColumns.indexOf(SELECTION_COLUMN);
    cloneColumns = cloneColumns.filter(function(column, index2) {
      return column !== SELECTION_COLUMN || index2 === selectionColumnIndex;
    });
    var prevCol = cloneColumns[selectionColumnIndex - 1];
    var nextCol = cloneColumns[selectionColumnIndex + 1];
    var mergedFixed = fixed;
    if (mergedFixed === void 0) {
      if ((nextCol === null || nextCol === void 0 ? void 0 : nextCol.fixed) !== void 0) {
        mergedFixed = nextCol.fixed;
      } else if ((prevCol === null || prevCol === void 0 ? void 0 : prevCol.fixed) !== void 0) {
        mergedFixed = prevCol.fixed;
      }
    }
    if (mergedFixed && prevCol && ((_a = prevCol[INTERNAL_COL_DEFINE]) === null || _a === void 0 ? void 0 : _a.columnType) === "EXPAND_COLUMN" && prevCol.fixed === void 0) {
      prevCol.fixed = mergedFixed;
    }
    var selectionColumn = _defineProperty$5({
      fixed: mergedFixed,
      width: selectionColWidth,
      className: "".concat(prefixCls, "-selection-column"),
      title: rowSelection.columnTitle || title,
      render: renderSelectionCell
    }, INTERNAL_COL_DEFINE, {
      className: "".concat(prefixCls, "-selection-col")
    });
    return cloneColumns.map(function(col) {
      return col === SELECTION_COLUMN ? selectionColumn : col;
    });
  }, [getRowKey, flattedData, rowSelection, derivedSelectedKeys, derivedSelectedKeySet, derivedHalfSelectedKeySet, selectionColWidth, mergedSelections, expandType, lastSelectedKey, checkboxPropsMap, onSelectMultiple, triggerSingleSelection, isCheckboxDisabled]);
  return [transformColumns, derivedSelectedKeySet];
}
var CaretDownOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, "name": "caret-down", "theme": "outlined" };
const CaretDownOutlinedSvg = CaretDownOutlined$2;
var CaretDownOutlined = function CaretDownOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CaretDownOutlinedSvg
  }));
};
CaretDownOutlined.displayName = "CaretDownOutlined";
const CaretDownOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CaretDownOutlined);
var CaretUpOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, "name": "caret-up", "theme": "outlined" };
const CaretUpOutlinedSvg = CaretUpOutlined$2;
var CaretUpOutlined = function CaretUpOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CaretUpOutlinedSvg
  }));
};
CaretUpOutlined.displayName = "CaretUpOutlined";
const CaretUpOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CaretUpOutlined);
var ASCEND = "ascend";
var DESCEND = "descend";
function getMultiplePriority(column) {
  if (_typeof$4(column.sorter) === "object" && typeof column.sorter.multiple === "number") {
    return column.sorter.multiple;
  }
  return false;
}
function getSortFunction(sorter) {
  if (typeof sorter === "function") {
    return sorter;
  }
  if (sorter && _typeof$4(sorter) === "object" && sorter.compare) {
    return sorter.compare;
  }
  return false;
}
function nextSortDirection(sortDirections, current) {
  if (!current) {
    return sortDirections[0];
  }
  return sortDirections[sortDirections.indexOf(current) + 1];
}
function collectSortStates(columns, init, pos) {
  var sortStates = [];
  function pushState(column, columnPos) {
    sortStates.push({
      column,
      key: getColumnKey(column, columnPos),
      multiplePriority: getMultiplePriority(column),
      sortOrder: column.sortOrder
    });
  }
  (columns || []).forEach(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    if (column.children) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      }
      sortStates = [].concat(_toConsumableArray(sortStates), _toConsumableArray(collectSortStates(column.children, init, columnPos)));
    } else if (column.sorter) {
      if ("sortOrder" in column) {
        pushState(column, columnPos);
      } else if (init && column.defaultSortOrder) {
        sortStates.push({
          column,
          key: getColumnKey(column, columnPos),
          multiplePriority: getMultiplePriority(column),
          sortOrder: column.defaultSortOrder
        });
      }
    }
  });
  return sortStates;
}
function injectSorter(prefixCls, columns, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, pos) {
  return (columns || []).map(function(column, index2) {
    var columnPos = getColumnPos(index2, pos);
    var newColumn = column;
    if (newColumn.sorter) {
      var sortDirections = newColumn.sortDirections || defaultSortDirections;
      var showSorterTooltip = newColumn.showSorterTooltip === void 0 ? tableShowSorterTooltip : newColumn.showSorterTooltip;
      var columnKey = getColumnKey(newColumn, columnPos);
      var sorterState = sorterStates.find(function(_ref) {
        var key2 = _ref.key;
        return key2 === columnKey;
      });
      var sorterOrder = sorterState ? sorterState.sortOrder : null;
      var nextSortOrder = nextSortDirection(sortDirections, sorterOrder);
      var upNode = sortDirections.includes(ASCEND) && /* @__PURE__ */ react.exports.createElement(CaretUpOutlined$1, {
        className: classnamesExports("".concat(prefixCls, "-column-sorter-up"), {
          active: sorterOrder === ASCEND
        })
      });
      var downNode = sortDirections.includes(DESCEND) && /* @__PURE__ */ react.exports.createElement(CaretDownOutlined$1, {
        className: classnamesExports("".concat(prefixCls, "-column-sorter-down"), {
          active: sorterOrder === DESCEND
        })
      });
      var _ref2 = tableLocale || {}, cancelSort = _ref2.cancelSort, triggerAsc = _ref2.triggerAsc, triggerDesc = _ref2.triggerDesc;
      var sortTip = cancelSort;
      if (nextSortOrder === DESCEND) {
        sortTip = triggerDesc;
      } else if (nextSortOrder === ASCEND) {
        sortTip = triggerAsc;
      }
      var tooltipProps = _typeof$4(showSorterTooltip) === "object" ? showSorterTooltip : {
        title: sortTip
      };
      newColumn = _extends$2(_extends$2({}, newColumn), {
        className: classnamesExports(newColumn.className, _defineProperty$5({}, "".concat(prefixCls, "-column-sort"), sorterOrder)),
        title: function title(renderProps) {
          var renderSortTitle = /* @__PURE__ */ react.exports.createElement("div", {
            className: "".concat(prefixCls, "-column-sorters")
          }, /* @__PURE__ */ react.exports.createElement("span", {
            className: "".concat(prefixCls, "-column-title")
          }, renderColumnTitle(column.title, renderProps)), /* @__PURE__ */ react.exports.createElement("span", {
            className: classnamesExports("".concat(prefixCls, "-column-sorter"), _defineProperty$5({}, "".concat(prefixCls, "-column-sorter-full"), !!(upNode && downNode)))
          }, /* @__PURE__ */ react.exports.createElement("span", {
            className: "".concat(prefixCls, "-column-sorter-inner")
          }, upNode, downNode)));
          return showSorterTooltip ? /* @__PURE__ */ react.exports.createElement(Tooltip$1, _extends$2({}, tooltipProps), renderSortTitle) : renderSortTitle;
        },
        onHeaderCell: function onHeaderCell(col) {
          var cell = column.onHeaderCell && column.onHeaderCell(col) || {};
          var originOnClick = cell.onClick;
          var originOKeyDown = cell.onKeyDown;
          cell.onClick = function(event) {
            triggerSorter({
              column,
              key: columnKey,
              sortOrder: nextSortOrder,
              multiplePriority: getMultiplePriority(column)
            });
            originOnClick === null || originOnClick === void 0 ? void 0 : originOnClick(event);
          };
          cell.onKeyDown = function(event) {
            if (event.keyCode === KeyCode.ENTER) {
              triggerSorter({
                column,
                key: columnKey,
                sortOrder: nextSortOrder,
                multiplePriority: getMultiplePriority(column)
              });
              originOKeyDown === null || originOKeyDown === void 0 ? void 0 : originOKeyDown(event);
            }
          };
          if (sorterOrder) {
            if (sorterOrder === "ascend") {
              cell["aria-sort"] = "ascending";
            } else {
              cell["aria-sort"] = "descending";
            }
          }
          cell.className = classnamesExports(cell.className, "".concat(prefixCls, "-column-has-sorters"));
          cell.tabIndex = 0;
          return cell;
        }
      });
    }
    if ("children" in newColumn) {
      newColumn = _extends$2(_extends$2({}, newColumn), {
        children: injectSorter(prefixCls, newColumn.children, sorterStates, triggerSorter, defaultSortDirections, tableLocale, tableShowSorterTooltip, columnPos)
      });
    }
    return newColumn;
  });
}
function stateToInfo(sorterStates) {
  var column = sorterStates.column, sortOrder = sorterStates.sortOrder;
  return {
    column,
    order: sortOrder,
    field: column.dataIndex,
    columnKey: column.key
  };
}
function generateSorterInfo(sorterStates) {
  var list2 = sorterStates.filter(function(_ref3) {
    var sortOrder = _ref3.sortOrder;
    return sortOrder;
  }).map(stateToInfo);
  if (list2.length === 0 && sorterStates.length) {
    return _extends$2(_extends$2({}, stateToInfo(sorterStates[sorterStates.length - 1])), {
      column: void 0
    });
  }
  if (list2.length <= 1) {
    return list2[0] || {};
  }
  return list2;
}
function getSortData(data2, sortStates, childrenColumnName) {
  var innerSorterStates = sortStates.slice().sort(function(a, b2) {
    return b2.multiplePriority - a.multiplePriority;
  });
  var cloneData = data2.slice();
  var runningSorters = innerSorterStates.filter(function(_ref4) {
    var sorter = _ref4.column.sorter, sortOrder = _ref4.sortOrder;
    return getSortFunction(sorter) && sortOrder;
  });
  if (!runningSorters.length) {
    return cloneData;
  }
  return cloneData.sort(function(record1, record2) {
    for (var i = 0; i < runningSorters.length; i += 1) {
      var sorterState = runningSorters[i];
      var sorter = sorterState.column.sorter, sortOrder = sorterState.sortOrder;
      var compareFn = getSortFunction(sorter);
      if (compareFn && sortOrder) {
        var compareResult = compareFn(record1, record2, sortOrder);
        if (compareResult !== 0) {
          return sortOrder === ASCEND ? compareResult : -compareResult;
        }
      }
    }
    return 0;
  }).map(function(record) {
    var subRecords = record[childrenColumnName];
    if (subRecords) {
      return _extends$2(_extends$2({}, record), _defineProperty$5({}, childrenColumnName, getSortData(subRecords, sortStates, childrenColumnName)));
    }
    return record;
  });
}
function useFilterSorter(_ref5) {
  var prefixCls = _ref5.prefixCls, mergedColumns = _ref5.mergedColumns, onSorterChange = _ref5.onSorterChange, sortDirections = _ref5.sortDirections, tableLocale = _ref5.tableLocale, showSorterTooltip = _ref5.showSorterTooltip;
  var _React$useState = react.exports.useState(collectSortStates(mergedColumns, true)), _React$useState2 = _slicedToArray$3(_React$useState, 2), sortStates = _React$useState2[0], setSortStates = _React$useState2[1];
  var mergedSorterStates = react.exports.useMemo(function() {
    var validate = true;
    var collectedStates = collectSortStates(mergedColumns, false);
    if (!collectedStates.length) {
      return sortStates;
    }
    var validateStates = [];
    function patchStates(state) {
      if (validate) {
        validateStates.push(state);
      } else {
        validateStates.push(_extends$2(_extends$2({}, state), {
          sortOrder: null
        }));
      }
    }
    var multipleMode = null;
    collectedStates.forEach(function(state) {
      if (multipleMode === null) {
        patchStates(state);
        if (state.sortOrder) {
          if (state.multiplePriority === false) {
            validate = false;
          } else {
            multipleMode = true;
          }
        }
      } else if (multipleMode && state.multiplePriority !== false) {
        patchStates(state);
      } else {
        validate = false;
        patchStates(state);
      }
    });
    return validateStates;
  }, [mergedColumns, sortStates]);
  var columnTitleSorterProps = react.exports.useMemo(function() {
    var sortColumns = mergedSorterStates.map(function(_ref6) {
      var column = _ref6.column, sortOrder = _ref6.sortOrder;
      return {
        column,
        order: sortOrder
      };
    });
    return {
      sortColumns,
      sortColumn: sortColumns[0] && sortColumns[0].column,
      sortOrder: sortColumns[0] && sortColumns[0].order
    };
  }, [mergedSorterStates]);
  function triggerSorter(sortState) {
    var newSorterStates;
    if (sortState.multiplePriority === false || !mergedSorterStates.length || mergedSorterStates[0].multiplePriority === false) {
      newSorterStates = [sortState];
    } else {
      newSorterStates = [].concat(_toConsumableArray(mergedSorterStates.filter(function(_ref7) {
        var key2 = _ref7.key;
        return key2 !== sortState.key;
      })), [sortState]);
    }
    setSortStates(newSorterStates);
    onSorterChange(generateSorterInfo(newSorterStates), newSorterStates);
  }
  var transformColumns = function transformColumns2(innerColumns) {
    return injectSorter(prefixCls, innerColumns, mergedSorterStates, triggerSorter, sortDirections, tableLocale, showSorterTooltip);
  };
  var getSorters = function getSorters2() {
    return generateSorterInfo(mergedSorterStates);
  };
  return [transformColumns, mergedSorterStates, columnTitleSorterProps, getSorters];
}
function fillTitle(columns, columnTitleProps) {
  return columns.map(function(column) {
    var cloneColumn = _extends$2({}, column);
    cloneColumn.title = renderColumnTitle(column.title, columnTitleProps);
    if ("children" in cloneColumn) {
      cloneColumn.children = fillTitle(cloneColumn.children, columnTitleProps);
    }
    return cloneColumn;
  });
}
function useTitleColumns(columnTitleProps) {
  var filledColumns = react.exports.useCallback(function(columns) {
    return fillTitle(columns, columnTitleProps);
  }, [columnTitleProps]);
  return [filledColumns];
}
var EMPTY_LIST = [];
function InternalTable(props, ref) {
  var _classNames3;
  var customizePrefixCls = props.prefixCls, className = props.className, style2 = props.style, customizeSize = props.size, bordered = props.bordered, customizeDropdownPrefixCls = props.dropdownPrefixCls, dataSource = props.dataSource, pagination = props.pagination, rowSelection = props.rowSelection, rowKey = props.rowKey, rowClassName = props.rowClassName, columns = props.columns, children = props.children, legacyChildrenColumnName = props.childrenColumnName, onChange2 = props.onChange, getPopupContainer = props.getPopupContainer, loading = props.loading, expandIcon = props.expandIcon, expandable = props.expandable, expandedRowRender = props.expandedRowRender, expandIconColumnIndex = props.expandIconColumnIndex, indentSize = props.indentSize, scroll = props.scroll, sortDirections = props.sortDirections, locale2 = props.locale, _props$showSorterTool = props.showSorterTooltip, showSorterTooltip = _props$showSorterTool === void 0 ? true : _props$showSorterTool;
  var baseColumns = react.exports.useMemo(function() {
    return columns || convertChildrenToColumns(children);
  }, [columns, children]);
  var needResponsive = react.exports.useMemo(function() {
    return baseColumns.some(function(col) {
      return col.responsive;
    });
  }, [baseColumns]);
  var screens2 = useBreakpoint(needResponsive);
  var mergedColumns = react.exports.useMemo(function() {
    var matched = new Set(Object.keys(screens2).filter(function(m2) {
      return screens2[m2];
    }));
    return baseColumns.filter(function(c2) {
      return !c2.responsive || c2.responsive.some(function(r2) {
        return matched.has(r2);
      });
    });
  }, [baseColumns, screens2]);
  var tableProps = omit(props, ["className", "style", "columns"]);
  var size = react.exports.useContext(SizeContext$1);
  var _React$useContext = react.exports.useContext(ConfigContext), _React$useContext$loc = _React$useContext.locale, contextLocale = _React$useContext$loc === void 0 ? defaultLocale : _React$useContext$loc, renderEmpty = _React$useContext.renderEmpty, direction = _React$useContext.direction;
  var mergedSize = customizeSize || size;
  var tableLocale = _extends$2(_extends$2({}, contextLocale.Table), locale2);
  var rawData = dataSource || EMPTY_LIST;
  var _React$useContext2 = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext2.getPrefixCls;
  var prefixCls = getPrefixCls("table", customizePrefixCls);
  var dropdownPrefixCls = getPrefixCls("dropdown", customizeDropdownPrefixCls);
  var mergedExpandable = _extends$2({
    childrenColumnName: legacyChildrenColumnName,
    expandIconColumnIndex
  }, expandable);
  var _mergedExpandable$chi = mergedExpandable.childrenColumnName, childrenColumnName = _mergedExpandable$chi === void 0 ? "children" : _mergedExpandable$chi;
  var expandType = react.exports.useMemo(function() {
    if (rawData.some(function(item) {
      return item === null || item === void 0 ? void 0 : item[childrenColumnName];
    })) {
      return "nest";
    }
    if (expandedRowRender || expandable && expandable.expandedRowRender) {
      return "row";
    }
    return null;
  }, [rawData]);
  var internalRefs = {
    body: react.exports.useRef()
  };
  var getRowKey = react.exports.useMemo(function() {
    if (typeof rowKey === "function") {
      return rowKey;
    }
    return function(record) {
      return record === null || record === void 0 ? void 0 : record[rowKey];
    };
  }, [rowKey]);
  var _useLazyKVMap = useLazyKVMap(rawData, childrenColumnName, getRowKey), _useLazyKVMap2 = _slicedToArray$3(_useLazyKVMap, 1), getRecordByKey = _useLazyKVMap2[0];
  var changeEventInfo = {};
  var triggerOnChange = function triggerOnChange2(info2, action) {
    var reset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var changeInfo = _extends$2(_extends$2({}, changeEventInfo), info2);
    if (reset) {
      changeEventInfo.resetPagination();
      if (changeInfo.pagination.current) {
        changeInfo.pagination.current = 1;
      }
      if (pagination && pagination.onChange) {
        pagination.onChange(1, changeInfo.pagination.pageSize);
      }
    }
    if (scroll && scroll.scrollToFirstRowOnChange !== false && internalRefs.body.current) {
      scrollTo(0, {
        getContainer: function getContainer2() {
          return internalRefs.body.current;
        }
      });
    }
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(changeInfo.pagination, changeInfo.filters, changeInfo.sorter, {
      currentDataSource: getFilterData(getSortData(rawData, changeInfo.sorterStates, childrenColumnName), changeInfo.filterStates),
      action
    });
  };
  var onSorterChange = function onSorterChange2(sorter, sorterStates) {
    triggerOnChange({
      sorter,
      sorterStates
    }, "sort", false);
  };
  var _useSorter = useFilterSorter({
    prefixCls,
    mergedColumns,
    onSorterChange,
    sortDirections: sortDirections || ["ascend", "descend"],
    tableLocale,
    showSorterTooltip
  }), _useSorter2 = _slicedToArray$3(_useSorter, 4), transformSorterColumns = _useSorter2[0], sortStates = _useSorter2[1], sorterTitleProps = _useSorter2[2], getSorters = _useSorter2[3];
  var sortedData = react.exports.useMemo(function() {
    return getSortData(rawData, sortStates, childrenColumnName);
  }, [rawData, sortStates]);
  changeEventInfo.sorter = getSorters();
  changeEventInfo.sorterStates = sortStates;
  var onFilterChange = function onFilterChange2(filters, filterStates2) {
    triggerOnChange({
      filters,
      filterStates: filterStates2
    }, "filter", true);
  };
  var _useFilter = useFilter({
    prefixCls,
    locale: tableLocale,
    dropdownPrefixCls,
    mergedColumns,
    onFilterChange,
    getPopupContainer
  }), _useFilter2 = _slicedToArray$3(_useFilter, 3), transformFilterColumns = _useFilter2[0], filterStates = _useFilter2[1], getFilters = _useFilter2[2];
  var mergedData = getFilterData(sortedData, filterStates);
  changeEventInfo.filters = getFilters();
  changeEventInfo.filterStates = filterStates;
  var columnTitleProps = react.exports.useMemo(function() {
    return _extends$2({}, sorterTitleProps);
  }, [sorterTitleProps]);
  var _useTitleColumns = useTitleColumns(columnTitleProps), _useTitleColumns2 = _slicedToArray$3(_useTitleColumns, 1), transformTitleColumns = _useTitleColumns2[0];
  var onPaginationChange = function onPaginationChange2(current, pageSize) {
    triggerOnChange({
      pagination: _extends$2(_extends$2({}, changeEventInfo.pagination), {
        current,
        pageSize
      })
    }, "paginate");
  };
  var _usePagination = usePagination(mergedData.length, pagination, onPaginationChange), _usePagination2 = _slicedToArray$3(_usePagination, 2), mergedPagination = _usePagination2[0], resetPagination = _usePagination2[1];
  changeEventInfo.pagination = pagination === false ? {} : getPaginationParam(pagination, mergedPagination);
  changeEventInfo.resetPagination = resetPagination;
  var pageData = react.exports.useMemo(function() {
    if (pagination === false || !mergedPagination.pageSize) {
      return mergedData;
    }
    var _mergedPagination$cur = mergedPagination.current, current = _mergedPagination$cur === void 0 ? 1 : _mergedPagination$cur, total = mergedPagination.total, _mergedPagination$pag = mergedPagination.pageSize, pageSize = _mergedPagination$pag === void 0 ? DEFAULT_PAGE_SIZE : _mergedPagination$pag;
    if (mergedData.length < total) {
      if (mergedData.length > pageSize) {
        return mergedData.slice((current - 1) * pageSize, current * pageSize);
      }
      return mergedData;
    }
    return mergedData.slice((current - 1) * pageSize, current * pageSize);
  }, [!!pagination, mergedData, mergedPagination && mergedPagination.current, mergedPagination && mergedPagination.pageSize, mergedPagination && mergedPagination.total]);
  var _useSelection = useSelection(rowSelection, {
    prefixCls,
    data: mergedData,
    pageData,
    getRowKey,
    getRecordByKey,
    expandType,
    childrenColumnName,
    locale: tableLocale,
    getPopupContainer
  }), _useSelection2 = _slicedToArray$3(_useSelection, 2), transformSelectionColumns = _useSelection2[0], selectedKeySet = _useSelection2[1];
  var internalRowClassName = function internalRowClassName2(record, index2, indent) {
    var mergedRowClassName;
    if (typeof rowClassName === "function") {
      mergedRowClassName = classnamesExports(rowClassName(record, index2, indent));
    } else {
      mergedRowClassName = classnamesExports(rowClassName);
    }
    return classnamesExports(_defineProperty$5({}, "".concat(prefixCls, "-row-selected"), selectedKeySet.has(getRowKey(record, index2))), mergedRowClassName);
  };
  mergedExpandable.__PARENT_RENDER_ICON__ = mergedExpandable.expandIcon;
  mergedExpandable.expandIcon = mergedExpandable.expandIcon || expandIcon || renderExpandIcon(tableLocale);
  if (expandType === "nest" && mergedExpandable.expandIconColumnIndex === void 0) {
    mergedExpandable.expandIconColumnIndex = rowSelection ? 1 : 0;
  } else if (mergedExpandable.expandIconColumnIndex > 0 && rowSelection) {
    mergedExpandable.expandIconColumnIndex -= 1;
  }
  if (typeof mergedExpandable.indentSize !== "number") {
    mergedExpandable.indentSize = typeof indentSize === "number" ? indentSize : 15;
  }
  var transformColumns = react.exports.useCallback(function(innerColumns) {
    return transformTitleColumns(transformSelectionColumns(transformFilterColumns(transformSorterColumns(innerColumns))));
  }, [transformSorterColumns, transformFilterColumns, transformSelectionColumns]);
  var topPaginationNode;
  var bottomPaginationNode;
  if (pagination !== false && (mergedPagination === null || mergedPagination === void 0 ? void 0 : mergedPagination.total)) {
    var paginationSize;
    if (mergedPagination.size) {
      paginationSize = mergedPagination.size;
    } else {
      paginationSize = mergedSize === "small" || mergedSize === "middle" ? "small" : void 0;
    }
    var renderPagination = function renderPagination2(position3) {
      return /* @__PURE__ */ react.exports.createElement(Pagination$1, _extends$2({}, mergedPagination, {
        className: classnamesExports("".concat(prefixCls, "-pagination ").concat(prefixCls, "-pagination-").concat(position3), mergedPagination.className),
        size: paginationSize
      }));
    };
    var defaultPosition = direction === "rtl" ? "left" : "right";
    var position2 = mergedPagination.position;
    if (position2 !== null && Array.isArray(position2)) {
      var topPos = position2.find(function(p2) {
        return p2.indexOf("top") !== -1;
      });
      var bottomPos = position2.find(function(p2) {
        return p2.indexOf("bottom") !== -1;
      });
      var isDisable = position2.every(function(p2) {
        return "".concat(p2) === "none";
      });
      if (!topPos && !bottomPos && !isDisable) {
        bottomPaginationNode = renderPagination(defaultPosition);
      }
      if (topPos) {
        topPaginationNode = renderPagination(topPos.toLowerCase().replace("top", ""));
      }
      if (bottomPos) {
        bottomPaginationNode = renderPagination(bottomPos.toLowerCase().replace("bottom", ""));
      }
    } else {
      bottomPaginationNode = renderPagination(defaultPosition);
    }
  }
  var spinProps;
  if (typeof loading === "boolean") {
    spinProps = {
      spinning: loading
    };
  } else if (_typeof$4(loading) === "object") {
    spinProps = _extends$2({
      spinning: true
    }, loading);
  }
  var wrapperClassNames = classnamesExports("".concat(prefixCls, "-wrapper"), _defineProperty$5({}, "".concat(prefixCls, "-wrapper-rtl"), direction === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement("div", {
    ref,
    className: wrapperClassNames,
    style: style2
  }, /* @__PURE__ */ react.exports.createElement(Spin$1, _extends$2({
    spinning: false
  }, spinProps), topPaginationNode, /* @__PURE__ */ react.exports.createElement(Table$2, _extends$2({}, tableProps, {
    columns: mergedColumns,
    direction,
    expandable: mergedExpandable,
    prefixCls,
    className: classnamesExports((_classNames3 = {}, _defineProperty$5(_classNames3, "".concat(prefixCls, "-middle"), mergedSize === "middle"), _defineProperty$5(_classNames3, "".concat(prefixCls, "-small"), mergedSize === "small"), _defineProperty$5(_classNames3, "".concat(prefixCls, "-bordered"), bordered), _defineProperty$5(_classNames3, "".concat(prefixCls, "-empty"), rawData.length === 0), _classNames3)),
    data: pageData,
    rowKey: getRowKey,
    rowClassName: internalRowClassName,
    emptyText: locale2 && locale2.emptyText || (renderEmpty || defaultRenderEmpty$1)("Table"),
    internalHooks: INTERNAL_HOOKS,
    internalRefs,
    transformColumns
  })), bottomPaginationNode));
}
var ForwardTable = /* @__PURE__ */ react.exports.forwardRef(InternalTable);
var Table = ForwardTable;
Table.defaultProps = {
  rowKey: "key"
};
Table.SELECTION_COLUMN = SELECTION_COLUMN;
Table.EXPAND_COLUMN = Table$2.EXPAND_COLUMN;
Table.SELECTION_ALL = SELECTION_ALL;
Table.SELECTION_INVERT = SELECTION_INVERT;
Table.SELECTION_NONE = SELECTION_NONE;
Table.Column = Column;
Table.ColumnGroup = ColumnGroup;
Table.Summary = FooterComponents;
const Table$1 = Table;
var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
const CopyOutlinedSvg = CopyOutlined$2;
var CopyOutlined2 = function CopyOutlined3(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: CopyOutlinedSvg
  }));
};
CopyOutlined2.displayName = "CopyOutlined";
const CopyOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CopyOutlined2);
var EditOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
const EditOutlinedSvg = EditOutlined$2;
var EditOutlined = function EditOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: EditOutlinedSvg
  }));
};
EditOutlined.displayName = "EditOutlined";
const EditOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EditOutlined);
var EnterOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
const EnterOutlinedSvg = EnterOutlined$2;
var EnterOutlined = function EnterOutlined2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(AntdIcon, _objectSpread2$4(_objectSpread2$4({}, props), {}, {
    ref,
    icon: EnterOutlinedSvg
  }));
};
EnterOutlined.displayName = "EnterOutlined";
const EnterOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EnterOutlined);
var Editable = function Editable2(_ref) {
  var prefixCls = _ref.prefixCls, ariaLabel = _ref["aria-label"], className = _ref.className, style2 = _ref.style, direction = _ref.direction, maxLength = _ref.maxLength, _ref$autoSize = _ref.autoSize, autoSize = _ref$autoSize === void 0 ? true : _ref$autoSize, value2 = _ref.value, onSave = _ref.onSave, onCancel = _ref.onCancel, onEnd = _ref.onEnd, component = _ref.component, _ref$enterIcon = _ref.enterIcon, enterIcon = _ref$enterIcon === void 0 ? /* @__PURE__ */ react.exports.createElement(EnterOutlined$1, null) : _ref$enterIcon;
  var ref = react.exports.useRef();
  var inComposition = react.exports.useRef(false);
  var lastKeyCode = react.exports.useRef();
  var _React$useState = react.exports.useState(value2), _React$useState2 = _slicedToArray$3(_React$useState, 2), current = _React$useState2[0], setCurrent = _React$useState2[1];
  react.exports.useEffect(function() {
    setCurrent(value2);
  }, [value2]);
  react.exports.useEffect(function() {
    if (ref.current && ref.current.resizableTextArea) {
      var textArea = ref.current.resizableTextArea.textArea;
      textArea.focus();
      var length = textArea.value.length;
      textArea.setSelectionRange(length, length);
    }
  }, []);
  var onChange2 = function onChange3(_ref2) {
    var target = _ref2.target;
    setCurrent(target.value.replace(/[\n\r]/g, ""));
  };
  var onCompositionStart = function onCompositionStart2() {
    inComposition.current = true;
  };
  var onCompositionEnd = function onCompositionEnd2() {
    inComposition.current = false;
  };
  var onKeyDown2 = function onKeyDown3(_ref3) {
    var keyCode = _ref3.keyCode;
    if (inComposition.current)
      return;
    lastKeyCode.current = keyCode;
  };
  var confirmChange = function confirmChange2() {
    onSave(current.trim());
  };
  var onKeyUp2 = function onKeyUp3(_ref4) {
    var keyCode = _ref4.keyCode, ctrlKey = _ref4.ctrlKey, altKey = _ref4.altKey, metaKey = _ref4.metaKey, shiftKey = _ref4.shiftKey;
    if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
      if (keyCode === KeyCode.ENTER) {
        confirmChange();
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      } else if (keyCode === KeyCode.ESC) {
        onCancel();
      }
    }
  };
  var onBlur2 = function onBlur3() {
    confirmChange();
  };
  var textClassName = component ? "".concat(prefixCls, "-").concat(component) : "";
  var textAreaClassName = classnamesExports(prefixCls, "".concat(prefixCls, "-edit-content"), _defineProperty$5({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), className, textClassName);
  return /* @__PURE__ */ react.exports.createElement("div", {
    className: textAreaClassName,
    style: style2
  }, /* @__PURE__ */ react.exports.createElement(TextArea$1, {
    ref,
    maxLength,
    value: current,
    onChange: onChange2,
    onKeyDown: onKeyDown2,
    onKeyUp: onKeyUp2,
    onCompositionStart,
    onCompositionEnd,
    onBlur: onBlur2,
    "aria-label": ariaLabel,
    rows: 1,
    autoSize
  }), enterIcon !== null ? cloneElement(enterIcon, {
    className: "".concat(prefixCls, "-edit-content-confirm")
  }) : null);
};
const Editable$1 = Editable;
function useMergedConfig(propConfig, templateConfig) {
  return react.exports.useMemo(function() {
    var support = !!propConfig;
    return [support, _extends$2(_extends$2({}, templateConfig), support && _typeof$4(propConfig) === "object" ? propConfig : null)];
  }, [propConfig]);
}
const useUpdatedEffect = function(callback, conditions) {
  var mountRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (mountRef.current) {
      callback();
    } else {
      mountRef.current = true;
    }
  }, conditions);
};
var __rest$4 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Typography$2 = function Typography(_a, ref) {
  var customizePrefixCls = _a.prefixCls, _a$component = _a.component, component = _a$component === void 0 ? "article" : _a$component, className = _a.className, ariaLabel = _a["aria-label"], setContentRef = _a.setContentRef, children = _a.children, restProps = __rest$4(_a, ["prefixCls", "component", "className", "aria-label", "setContentRef", "children"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var mergedRef = ref;
  if (setContentRef) {
    mergedRef = composeRef(ref, setContentRef);
  }
  var Component2 = component;
  var prefixCls = getPrefixCls("typography", customizePrefixCls);
  var componentClassName = classnamesExports(prefixCls, _defineProperty$5({}, "".concat(prefixCls, "-rtl"), direction === "rtl"), className);
  return /* @__PURE__ */ react.exports.createElement(Component2, _extends$2({
    className: componentClassName,
    "aria-label": ariaLabel,
    ref: mergedRef
  }, restProps), children);
};
var RefTypography = /* @__PURE__ */ react.exports.forwardRef(Typography$2);
var ExportTypography = RefTypography;
const OriginTypography = ExportTypography;
function cuttable(node) {
  var type4 = _typeof$4(node);
  return type4 === "string" || type4 === "number";
}
function getNodesLen(nodeList) {
  var totalLen = 0;
  nodeList.forEach(function(node) {
    if (cuttable(node)) {
      totalLen += String(node).length;
    } else {
      totalLen += 1;
    }
  });
  return totalLen;
}
function sliceNodes(nodeList, len) {
  var currLen = 0;
  var currentNodeList = [];
  for (var i = 0; i < nodeList.length; i += 1) {
    if (currLen === len) {
      return currentNodeList;
    }
    var node = nodeList[i];
    var canCut = cuttable(node);
    var nodeLen = canCut ? String(node).length : 1;
    var nextLen = currLen + nodeLen;
    if (nextLen > len) {
      var restLen = len - currLen;
      currentNodeList.push(String(node).slice(0, restLen));
      return currentNodeList;
    }
    currentNodeList.push(node);
    currLen = nextLen;
  }
  return nodeList;
}
var NONE = 0;
var PREPARE = 1;
var WALKING = 2;
var DONE_WITH_ELLIPSIS = 3;
var DONE_WITHOUT_ELLIPSIS = 4;
var Ellipsis = function Ellipsis2(_ref) {
  var enabledMeasure = _ref.enabledMeasure, children = _ref.children, text2 = _ref.text, width = _ref.width, rows = _ref.rows, onEllipsis = _ref.onEllipsis;
  var _React$useState = react.exports.useState([0, 0, 0]), _React$useState2 = _slicedToArray$3(_React$useState, 2), cutLength = _React$useState2[0], setCutLength = _React$useState2[1];
  var _React$useState3 = react.exports.useState(NONE), _React$useState4 = _slicedToArray$3(_React$useState3, 2), walkingState = _React$useState4[0], setWalkingState = _React$useState4[1];
  var _cutLength = _slicedToArray$3(cutLength, 3), startLen = _cutLength[0], midLen = _cutLength[1], endLen = _cutLength[2];
  var _React$useState5 = react.exports.useState(0), _React$useState6 = _slicedToArray$3(_React$useState5, 2), singleRowHeight = _React$useState6[0], setSingleRowHeight = _React$useState6[1];
  var singleRowRef = react.exports.useRef(null);
  var midRowRef = react.exports.useRef(null);
  var nodeList = react.exports.useMemo(function() {
    return toArray$4(text2);
  }, [text2]);
  var totalLen = react.exports.useMemo(function() {
    return getNodesLen(nodeList);
  }, [nodeList]);
  var mergedChildren = react.exports.useMemo(function() {
    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {
      return children(nodeList, false);
    }
    return children(sliceNodes(nodeList, midLen), midLen < totalLen);
  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);
  useLayoutEffect$1(function() {
    if (enabledMeasure && width && totalLen) {
      setWalkingState(PREPARE);
      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);
    }
  }, [enabledMeasure, width, text2, totalLen, rows]);
  useLayoutEffect$1(function() {
    var _a;
    if (walkingState === PREPARE) {
      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);
    }
  }, [walkingState]);
  useLayoutEffect$1(function() {
    var _a, _b;
    if (singleRowHeight) {
      if (walkingState === PREPARE) {
        var midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
        var maxHeight = rows * singleRowHeight;
        if (midHeight <= maxHeight) {
          setWalkingState(DONE_WITHOUT_ELLIPSIS);
          onEllipsis(false);
        } else {
          setWalkingState(WALKING);
        }
      } else if (walkingState === WALKING) {
        if (startLen !== endLen) {
          var _midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
          var _maxHeight = rows * singleRowHeight;
          var nextStartLen = startLen;
          var nextEndLen = endLen;
          if (startLen === endLen - 1) {
            nextEndLen = startLen;
          } else if (_midHeight <= _maxHeight) {
            nextStartLen = midLen;
          } else {
            nextEndLen = midLen;
          }
          var nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);
          setCutLength([nextStartLen, nextMidLen, nextEndLen]);
        } else {
          setWalkingState(DONE_WITH_ELLIPSIS);
          onEllipsis(true);
        }
      }
    }
  }, [walkingState, startLen, endLen, rows, singleRowHeight]);
  var measureStyle = {
    width,
    whiteSpace: "normal",
    margin: 0,
    padding: 0
  };
  var renderMeasure = function renderMeasure2(content2, ref, style2) {
    return /* @__PURE__ */ react.exports.createElement("span", {
      "aria-hidden": true,
      ref,
      style: _extends$2({
        position: "fixed",
        display: "block",
        left: 0,
        top: 0,
        zIndex: -9999,
        visibility: "hidden",
        pointerEvents: "none"
      }, style2)
    }, content2);
  };
  var renderMeasureSlice = function renderMeasureSlice2(len, ref) {
    var sliceNodeList = sliceNodes(nodeList, len);
    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);
  };
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, renderMeasure("lg", singleRowRef, {
    wordBreak: "keep-all",
    whiteSpace: "nowrap"
  }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)));
};
const Ellipsis$1 = Ellipsis;
var EllipsisTooltip = function EllipsisTooltip2(_ref) {
  var enabledEllipsis = _ref.enabledEllipsis, isEllipsis = _ref.isEllipsis, children = _ref.children, tooltipProps = _ref.tooltipProps;
  if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enabledEllipsis) {
    return children;
  }
  return /* @__PURE__ */ react.exports.createElement(Tooltip$1, _extends$2({
    visible: isEllipsis ? void 0 : false
  }, tooltipProps), children);
};
const EllipsisTooltip$1 = EllipsisTooltip;
var __rest$3 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
function wrapperDecorations(_ref, content2) {
  var mark2 = _ref.mark, code = _ref.code, underline = _ref.underline, del = _ref["delete"], strong = _ref.strong, keyboard = _ref.keyboard, italic = _ref.italic;
  var currentContent = content2;
  function wrap2(needed, tag) {
    if (!needed)
      return;
    currentContent = /* @__PURE__ */ react.exports.createElement(tag, {}, currentContent);
  }
  wrap2(strong, "strong");
  wrap2(underline, "u");
  wrap2(del, "del");
  wrap2(code, "code");
  wrap2(mark2, "mark");
  wrap2(keyboard, "kbd");
  wrap2(italic, "i");
  return currentContent;
}
function getNode(dom, defaultNode, needDom) {
  if (dom === true || dom === void 0) {
    return defaultNode;
  }
  return dom || needDom && defaultNode;
}
function toList(val) {
  return Array.isArray(val) ? val : [val];
}
var ELLIPSIS_STR = "...";
var Base = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var customizePrefixCls = props.prefixCls, className = props.className, style2 = props.style, type4 = props.type, disabled = props.disabled, children = props.children, ellipsis = props.ellipsis, editable = props.editable, copyable = props.copyable, component = props.component, title = props.title, restProps = __rest$3(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]);
  var _React$useContext = react.exports.useContext(ConfigContext), getPrefixCls = _React$useContext.getPrefixCls, direction = _React$useContext.direction;
  var textLocale = useLocaleReceiver("Text")[0];
  var typographyRef = react.exports.useRef(null);
  var editIconRef = react.exports.useRef(null);
  var prefixCls = getPrefixCls("typography", customizePrefixCls);
  var textProps = omit(restProps, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]);
  var _useMergedConfig = useMergedConfig(editable), _useMergedConfig2 = _slicedToArray$3(_useMergedConfig, 2), enableEdit = _useMergedConfig2[0], editConfig = _useMergedConfig2[1];
  var _useMergedState = useMergedState(false, {
    value: editConfig.editing
  }), _useMergedState2 = _slicedToArray$3(_useMergedState, 2), editing = _useMergedState2[0], setEditing = _useMergedState2[1];
  var _editConfig$triggerTy = editConfig.triggerType, triggerType = _editConfig$triggerTy === void 0 ? ["icon"] : _editConfig$triggerTy;
  var triggerEdit = function triggerEdit2(edit) {
    var _a;
    if (edit) {
      (_a = editConfig.onStart) === null || _a === void 0 ? void 0 : _a.call(editConfig);
    }
    setEditing(edit);
  };
  useUpdatedEffect(function() {
    var _a;
    if (!editing) {
      (_a = editIconRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }, [editing]);
  var onEditClick = function onEditClick2(e2) {
    e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
    triggerEdit(true);
  };
  var onEditChange = function onEditChange2(value2) {
    var _a;
    (_a = editConfig.onChange) === null || _a === void 0 ? void 0 : _a.call(editConfig, value2);
    triggerEdit(false);
  };
  var onEditCancel = function onEditCancel2() {
    var _a;
    (_a = editConfig.onCancel) === null || _a === void 0 ? void 0 : _a.call(editConfig);
    triggerEdit(false);
  };
  var _useMergedConfig3 = useMergedConfig(copyable), _useMergedConfig4 = _slicedToArray$3(_useMergedConfig3, 2), enableCopy = _useMergedConfig4[0], copyConfig = _useMergedConfig4[1];
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray$3(_React$useState, 2), copied = _React$useState2[0], setCopied = _React$useState2[1];
  var copyIdRef = react.exports.useRef();
  var copyOptions = {};
  if (copyConfig.format) {
    copyOptions.format = copyConfig.format;
  }
  var cleanCopyId = function cleanCopyId2() {
    clearTimeout(copyIdRef.current);
  };
  var onCopyClick = function onCopyClick2(e2) {
    var _a;
    e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
    e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
    copyToClipboard$2(copyConfig.text || String(children) || "", copyOptions);
    setCopied(true);
    cleanCopyId();
    copyIdRef.current = setTimeout(function() {
      setCopied(false);
    }, 3e3);
    (_a = copyConfig.onCopy) === null || _a === void 0 ? void 0 : _a.call(copyConfig, e2);
  };
  react.exports.useEffect(function() {
    return cleanCopyId;
  }, []);
  var _React$useState3 = react.exports.useState(false), _React$useState4 = _slicedToArray$3(_React$useState3, 2), isLineClampSupport = _React$useState4[0], setIsLineClampSupport = _React$useState4[1];
  var _React$useState5 = react.exports.useState(false), _React$useState6 = _slicedToArray$3(_React$useState5, 2), isTextOverflowSupport = _React$useState6[0], setIsTextOverflowSupport = _React$useState6[1];
  var _React$useState7 = react.exports.useState(false), _React$useState8 = _slicedToArray$3(_React$useState7, 2), expanded = _React$useState8[0], setExpanded = _React$useState8[1];
  var _React$useState9 = react.exports.useState(false), _React$useState10 = _slicedToArray$3(_React$useState9, 2), isJsEllipsis = _React$useState10[0], setIsJsEllipsis = _React$useState10[1];
  var _React$useState11 = react.exports.useState(false), _React$useState12 = _slicedToArray$3(_React$useState11, 2), isNativeEllipsis = _React$useState12[0], setIsNativeEllipsis = _React$useState12[1];
  var _useMergedConfig5 = useMergedConfig(ellipsis, {
    expandable: false
  }), _useMergedConfig6 = _slicedToArray$3(_useMergedConfig5, 2), enableEllipsis = _useMergedConfig6[0], ellipsisConfig = _useMergedConfig6[1];
  var mergedEnableEllipsis = enableEllipsis && !expanded;
  var _ellipsisConfig$rows = ellipsisConfig.rows, rows = _ellipsisConfig$rows === void 0 ? 1 : _ellipsisConfig$rows;
  var needMeasureEllipsis = react.exports.useMemo(function() {
    return !mergedEnableEllipsis || ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || ellipsisConfig.expandable || enableEdit || enableCopy;
  }, [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
  useLayoutEffect$1(function() {
    if (enableEllipsis && !needMeasureEllipsis) {
      setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
      setIsTextOverflowSupport(isStyleSupport("textOverflow"));
    }
  }, [needMeasureEllipsis, enableEllipsis]);
  var cssEllipsis = react.exports.useMemo(function() {
    if (needMeasureEllipsis) {
      return false;
    }
    if (rows === 1) {
      return isTextOverflowSupport;
    }
    return isLineClampSupport;
  }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  var isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
  var cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
  var cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
  var onExpandClick = function onExpandClick2(e2) {
    var _a;
    setExpanded(true);
    (_a = ellipsisConfig.onExpand) === null || _a === void 0 ? void 0 : _a.call(ellipsisConfig, e2);
  };
  var _React$useState13 = react.exports.useState(0), _React$useState14 = _slicedToArray$3(_React$useState13, 2), ellipsisWidth = _React$useState14[0], setEllipsisWidth = _React$useState14[1];
  var onResize2 = function onResize3(_ref2) {
    var offsetWidth = _ref2.offsetWidth;
    setEllipsisWidth(offsetWidth);
  };
  var onJsEllipsis = function onJsEllipsis2(jsEllipsis) {
    var _a;
    setIsJsEllipsis(jsEllipsis);
    if (isJsEllipsis !== jsEllipsis) {
      (_a = ellipsisConfig.onEllipsis) === null || _a === void 0 ? void 0 : _a.call(ellipsisConfig, jsEllipsis);
    }
  };
  react.exports.useEffect(function() {
    var textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      var currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
      if (isNativeEllipsis !== currentEllipsis) {
        setIsNativeEllipsis(currentEllipsis);
      }
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp]);
  var tooltipProps = {};
  if (ellipsisConfig.tooltip === true) {
    tooltipProps = {
      title: children
    };
  } else if (/* @__PURE__ */ react.exports.isValidElement(ellipsisConfig.tooltip)) {
    tooltipProps = {
      title: ellipsisConfig.tooltip
    };
  } else if (_typeof$4(ellipsisConfig.tooltip) === "object") {
    tooltipProps = _extends$2({
      title: children
    }, ellipsisConfig.tooltip);
  } else {
    tooltipProps = {
      title: ellipsisConfig.tooltip
    };
  }
  var topAriaLabel = react.exports.useMemo(function() {
    var isValid = function isValid2(val) {
      return ["string", "number"].includes(_typeof$4(val));
    };
    if (!enableEllipsis || cssEllipsis) {
      return void 0;
    }
    if (isValid(children)) {
      return children;
    }
    if (isValid(title)) {
      return title;
    }
    if (isValid(tooltipProps.title)) {
      return tooltipProps.title;
    }
    return void 0;
  }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
  if (editing) {
    return /* @__PURE__ */ react.exports.createElement(Editable$1, {
      value: typeof children === "string" ? children : "",
      onSave: onEditChange,
      onCancel: onEditCancel,
      onEnd: editConfig.onEnd,
      prefixCls,
      className,
      style: style2,
      direction,
      component,
      maxLength: editConfig.maxLength,
      autoSize: editConfig.autoSize,
      enterIcon: editConfig.enterIcon
    });
  }
  var renderExpand = function renderExpand2() {
    var expandable = ellipsisConfig.expandable, symbol = ellipsisConfig.symbol;
    if (!expandable)
      return null;
    var expandContent;
    if (symbol) {
      expandContent = symbol;
    } else {
      expandContent = textLocale.expand;
    }
    return /* @__PURE__ */ react.exports.createElement("a", {
      key: "expand",
      className: "".concat(prefixCls, "-expand"),
      onClick: onExpandClick,
      "aria-label": textLocale.expand
    }, expandContent);
  };
  var renderEdit = function renderEdit2() {
    if (!enableEdit)
      return;
    var icon = editConfig.icon, tooltip = editConfig.tooltip;
    var editTitle = toArray$4(tooltip)[0] || textLocale.edit;
    var ariaLabel = typeof editTitle === "string" ? editTitle : "";
    return triggerType.includes("icon") ? /* @__PURE__ */ react.exports.createElement(Tooltip$1, {
      key: "edit",
      title: tooltip === false ? "" : editTitle
    }, /* @__PURE__ */ react.exports.createElement(TransButton$1, {
      ref: editIconRef,
      className: "".concat(prefixCls, "-edit"),
      onClick: onEditClick,
      "aria-label": ariaLabel
    }, icon || /* @__PURE__ */ react.exports.createElement(EditOutlined$1, {
      role: "button"
    }))) : null;
  };
  var renderCopy = function renderCopy2() {
    if (!enableCopy)
      return;
    var tooltips = copyConfig.tooltips, icon = copyConfig.icon;
    var tooltipNodes = toList(tooltips);
    var iconNodes = toList(icon);
    var copyTitle = copied ? getNode(tooltipNodes[1], textLocale.copied) : getNode(tooltipNodes[0], textLocale.copy);
    var systemStr = copied ? textLocale.copied : textLocale.copy;
    var ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
    return /* @__PURE__ */ react.exports.createElement(Tooltip$1, {
      key: "copy",
      title: copyTitle
    }, /* @__PURE__ */ react.exports.createElement(TransButton$1, {
      className: classnamesExports("".concat(prefixCls, "-copy"), copied && "".concat(prefixCls, "-copy-success")),
      onClick: onCopyClick,
      "aria-label": ariaLabel
    }, copied ? getNode(iconNodes[1], /* @__PURE__ */ react.exports.createElement(CheckOutlined$1, null), true) : getNode(iconNodes[0], /* @__PURE__ */ react.exports.createElement(CopyOutlined$1, null), true)));
  };
  var renderOperations = function renderOperations2(renderExpanded) {
    return [renderExpanded && renderExpand(), renderEdit(), renderCopy()];
  };
  var renderEllipsis = function renderEllipsis2(needEllipsis) {
    return [needEllipsis && /* @__PURE__ */ react.exports.createElement("span", {
      "aria-hidden": true,
      key: "ellipsis"
    }, ELLIPSIS_STR), ellipsisConfig.suffix, renderOperations(needEllipsis)];
  };
  return /* @__PURE__ */ react.exports.createElement(ResizeObserver, {
    onResize: onResize2,
    disabled: !mergedEnableEllipsis || cssEllipsis
  }, function(resizeRef) {
    var _classNames;
    return /* @__PURE__ */ react.exports.createElement(EllipsisTooltip$1, {
      tooltipProps,
      enabledEllipsis: mergedEnableEllipsis,
      isEllipsis: isMergedEllipsis
    }, /* @__PURE__ */ react.exports.createElement(OriginTypography, _extends$2({
      className: classnamesExports((_classNames = {}, _defineProperty$5(_classNames, "".concat(prefixCls, "-").concat(type4), type4), _defineProperty$5(_classNames, "".concat(prefixCls, "-disabled"), disabled), _defineProperty$5(_classNames, "".concat(prefixCls, "-ellipsis"), enableEllipsis), _defineProperty$5(_classNames, "".concat(prefixCls, "-single-line"), mergedEnableEllipsis && rows === 1), _defineProperty$5(_classNames, "".concat(prefixCls, "-ellipsis-single-line"), cssTextOverflow), _defineProperty$5(_classNames, "".concat(prefixCls, "-ellipsis-multiple-line"), cssLineClamp), _classNames), className),
      style: _extends$2(_extends$2({}, style2), {
        WebkitLineClamp: cssLineClamp ? rows : void 0
      }),
      component,
      ref: composeRef(resizeRef, typographyRef, ref),
      direction,
      onClick: triggerType.includes("text") ? onEditClick : null,
      "aria-label": topAriaLabel,
      title
    }, textProps), /* @__PURE__ */ react.exports.createElement(Ellipsis$1, {
      enabledMeasure: mergedEnableEllipsis && !cssEllipsis,
      text: children,
      rows,
      width: ellipsisWidth,
      onEllipsis: onJsEllipsis
    }, function(node, needEllipsis) {
      var renderNode = node;
      if (node.length && needEllipsis && topAriaLabel) {
        renderNode = /* @__PURE__ */ react.exports.createElement("span", {
          key: "show-content",
          "aria-hidden": true
        }, renderNode);
      }
      var wrappedContext = wrapperDecorations(props, /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, renderNode, renderEllipsis(needEllipsis)));
      return wrappedContext;
    })));
  });
});
const Base$1 = Base;
var __rest$2 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Link = function Link2(_a, ref) {
  var ellipsis = _a.ellipsis, rel = _a.rel, restProps = __rest$2(_a, ["ellipsis", "rel"]);
  var baseRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return baseRef.current;
  });
  var mergedProps = _extends$2(_extends$2({}, restProps), {
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
  });
  delete mergedProps.navigate;
  return /* @__PURE__ */ react.exports.createElement(Base$1, _extends$2({}, mergedProps, {
    ref: baseRef,
    ellipsis: !!ellipsis,
    component: "a"
  }));
};
const Link$1 = /* @__PURE__ */ react.exports.forwardRef(Link);
var Paragraph = function Paragraph2(props, ref) {
  return /* @__PURE__ */ react.exports.createElement(Base$1, _extends$2({
    ref
  }, props, {
    component: "div"
  }));
};
const Paragraph$1 = /* @__PURE__ */ react.exports.forwardRef(Paragraph);
var __rest$1 = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var Text$1 = function Text(_a, ref) {
  var ellipsis = _a.ellipsis, restProps = __rest$1(_a, ["ellipsis"]);
  var mergedEllipsis = react.exports.useMemo(function() {
    if (ellipsis && _typeof$4(ellipsis) === "object") {
      return omit(ellipsis, ["expandable", "rows"]);
    }
    return ellipsis;
  }, [ellipsis]);
  return /* @__PURE__ */ react.exports.createElement(Base$1, _extends$2({
    ref
  }, restProps, {
    ellipsis: mergedEllipsis,
    component: "span"
  }));
};
const Text$2 = /* @__PURE__ */ react.exports.forwardRef(Text$1);
var __rest = globalThis && globalThis.__rest || function(s, e2) {
  var t2 = {};
  for (var p2 in s) {
    if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s[p2];
  }
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var TITLE_ELE_LIST = tupleNum(1, 2, 3, 4, 5);
var Title$1 = function Title(props, ref) {
  var _props$level = props.level, level = _props$level === void 0 ? 1 : _props$level, restProps = __rest(props, ["level"]);
  var component;
  if (TITLE_ELE_LIST.indexOf(level) !== -1) {
    component = "h".concat(level);
  } else {
    component = "h1";
  }
  return /* @__PURE__ */ react.exports.createElement(Base$1, _extends$2({
    ref
  }, restProps, {
    component
  }));
};
const Title$2 = /* @__PURE__ */ react.exports.forwardRef(Title$1);
var Typography2 = OriginTypography;
Typography2.Text = Text$2;
Typography2.Link = Link$1;
Typography2.Title = Title$2;
Typography2.Paragraph = Paragraph$1;
const Typography$1 = Typography2;
function copyToClipboard(str) {
  copyToClipboard$1(str);
  message.success("Copy successfully !");
}
function LinkCopy({ route }) {
  return /* @__PURE__ */ React$a.createElement(LinkOutlined2, {
    className: "copy-link-icon",
    onClick: (e2) => {
      e2.stopPropagation();
      e2.preventDefault();
      const { origin, pathname } = location;
      copyToClipboard(`${origin}${pathname}#${route}`);
    }
  });
}
const index$2 = "";
var baseSlice = _baseSlice, toInteger = toInteger_1;
function dropRight(array4, n2, guard) {
  var length = array4 == null ? 0 : array4.length;
  if (!length) {
    return [];
  }
  n2 = guard || n2 === void 0 ? 1 : toInteger(n2);
  n2 = length - n2;
  return baseSlice(array4, 0, n2 < 0 ? 0 : n2);
}
var dropRight_1 = dropRight;
const SUSPENSE_PROMISE = Symbol();
const isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];
const isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;
const cancelSuspensePromise = (suspensePromise) => {
  var _a, _b;
  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);
};
const isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {
  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;
  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;
  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);
};
const createSuspensePromise = (promise) => {
  const objectToAttach = {
    o: promise,
    c: null
  };
  const suspensePromise = new Promise((resolve) => {
    objectToAttach.c = () => {
      objectToAttach.c = null;
      resolve();
    };
    promise.then(objectToAttach.c, objectToAttach.c);
  });
  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;
  return suspensePromise;
};
const hasInitialValue = (atom2) => "init" in atom2;
const READ_ATOM = "r";
const WRITE_ATOM = "w";
const COMMIT_ATOM = "c";
const SUBSCRIBE_ATOM = "s";
const RESTORE_ATOMS = "h";
const DEV_SUBSCRIBE_STATE = "n";
const DEV_GET_MOUNTED_ATOMS = "l";
const DEV_GET_ATOM_STATE = "a";
const DEV_GET_MOUNTED = "m";
const createStore = (initialValues) => {
  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let stateListeners;
  let mountedAtoms;
  if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
    stateListeners = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  if (initialValues) {
    for (const [atom2, value2] of initialValues) {
      const atomState = { v: value2, r: 0, d: /* @__PURE__ */ new Map() };
      if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
        Object.freeze(atomState);
        if (!hasInitialValue(atom2)) {
          console.warn("Found initial value for derived atom which can cause unexpected behavior", atom2);
        }
      }
      committedAtomStateMap.set(atom2, atomState);
    }
  }
  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();
  const addSuspensePromiseToCache = (version2, atom2, suspensePromise) => {
    let cache2 = suspensePromiseCacheMap.get(atom2);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new Map();
      suspensePromiseCacheMap.set(atom2, cache2);
    }
    suspensePromise.then(() => {
      if (cache2.get(version2) === suspensePromise) {
        cache2.delete(version2);
        if (!cache2.size) {
          suspensePromiseCacheMap.delete(atom2);
        }
      }
    });
    cache2.set(version2, suspensePromise);
  };
  const cancelAllSuspensePromiseInCache = (atom2) => {
    const versionSet = /* @__PURE__ */ new Set();
    const cache2 = suspensePromiseCacheMap.get(atom2);
    if (cache2) {
      suspensePromiseCacheMap.delete(atom2);
      cache2.forEach((suspensePromise, version2) => {
        cancelSuspensePromise(suspensePromise);
        versionSet.add(version2);
      });
    }
    return versionSet;
  };
  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();
  const getVersionedAtomStateMap = (version2) => {
    let versionedAtomStateMap = versionedAtomStateMapMap.get(version2);
    if (!versionedAtomStateMap) {
      versionedAtomStateMap = /* @__PURE__ */ new Map();
      versionedAtomStateMapMap.set(version2, versionedAtomStateMap);
    }
    return versionedAtomStateMap;
  };
  const getAtomState = (version2, atom2) => {
    if (version2) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version2);
      let atomState = versionedAtomStateMap.get(atom2);
      if (!atomState) {
        atomState = getAtomState(version2.p, atom2);
        if (atomState) {
          versionedAtomStateMap.set(atom2, atomState);
        }
      }
      return atomState;
    }
    return committedAtomStateMap.get(atom2);
  };
  const setAtomState = (version2, atom2, atomState) => {
    if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      Object.freeze(atomState);
    }
    if (version2) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version2);
      versionedAtomStateMap.set(atom2, atomState);
    } else {
      const prevAtomState = committedAtomStateMap.get(atom2);
      committedAtomStateMap.set(atom2, atomState);
      if (!pendingMap.has(atom2)) {
        pendingMap.set(atom2, prevAtomState);
      }
    }
  };
  const createReadDependencies = (version2, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {
    if (!dependencies) {
      return prevReadDependencies;
    }
    const readDependencies = /* @__PURE__ */ new Map();
    let changed = false;
    dependencies.forEach((atom2) => {
      var _a;
      const revision = ((_a = getAtomState(version2, atom2)) == null ? void 0 : _a.r) || 0;
      readDependencies.set(atom2, revision);
      if (prevReadDependencies.get(atom2) !== revision) {
        changed = true;
      }
    });
    if (prevReadDependencies.size === readDependencies.size && !changed) {
      return prevReadDependencies;
    }
    return readDependencies;
  };
  const setAtomValue = (version2, atom2, value2, dependencies, suspensePromise) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      v: value2,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)
    };
    let changed = false;
    if (!atomState || !("v" in atomState) || !Object.is(atomState.v, value2)) {
      changed = true;
      ++nextAtomState.r;
      if (nextAtomState.d.has(atom2)) {
        nextAtomState.d = new Map(nextAtomState.d).set(atom2, nextAtomState.r);
      }
    } else if ("i" in atomState || nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {
      changed = true;
      Promise.resolve().then(() => {
        flushPending(version2);
      });
    }
    if (atomState && !changed) {
      return atomState;
    }
    setAtomState(version2, atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomReadError = (version2, atom2, error, dependencies, suspensePromise) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      e: error,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version2, atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomSuspensePromise = (version2, atom2, suspensePromise, dependencies) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState && "p" in atomState) {
      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {
        return atomState;
      }
      cancelSuspensePromise(atomState.p);
    }
    addSuspensePromiseToCache(version2, atom2, suspensePromise);
    const nextAtomState = {
      p: suspensePromise,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      d: createReadDependencies(version2, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version2, atom2, nextAtomState);
    return nextAtomState;
  };
  const setAtomPromiseOrValue = (version2, atom2, promiseOrValue, dependencies) => {
    if (promiseOrValue instanceof Promise) {
      const suspensePromise = createSuspensePromise(promiseOrValue.then((value2) => {
        setAtomValue(version2, atom2, value2, dependencies, suspensePromise);
      }).catch((e2) => {
        if (e2 instanceof Promise) {
          if (isSuspensePromise(e2)) {
            return e2.then(() => {
              readAtomState(version2, atom2, true);
            });
          }
          return e2;
        }
        setAtomReadError(version2, atom2, e2, dependencies, suspensePromise);
      }));
      return setAtomSuspensePromise(version2, atom2, suspensePromise, dependencies);
    }
    return setAtomValue(version2, atom2, promiseOrValue, dependencies);
  };
  const setAtomInvalidated = (version2, atom2) => {
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      const nextAtomState = {
        ...atomState,
        i: atomState.r
      };
      setAtomState(version2, atom2, nextAtomState);
    } else if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      console.warn("[Bug] could not invalidate non existing atom", atom2);
    }
  };
  const readAtomState = (version2, atom2, force) => {
    if (!force) {
      const atomState = getAtomState(version2, atom2);
      if (atomState) {
        if (atomState.r !== atomState.i && "p" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
          return atomState;
        }
        atomState.d.forEach((_, a) => {
          if (a !== atom2) {
            if (!mountedMap.has(a)) {
              readAtomState(version2, a);
            } else {
              const aState = getAtomState(version2, a);
              if (aState && aState.r === aState.i) {
                readAtomState(version2, a);
              }
            }
          }
        });
        if (Array.from(atomState.d).every(([a, r2]) => {
          const aState = getAtomState(version2, a);
          return aState && "v" in aState && aState.r === r2;
        })) {
          return atomState;
        }
      }
    }
    const dependencies = /* @__PURE__ */ new Set();
    try {
      const promiseOrValue = atom2.read((a) => {
        dependencies.add(a);
        const aState = a === atom2 ? getAtomState(version2, a) : readAtomState(version2, a);
        if (aState) {
          if ("e" in aState) {
            throw aState.e;
          }
          if ("p" in aState) {
            throw aState.p;
          }
          return aState.v;
        }
        if (hasInitialValue(a)) {
          return a.init;
        }
        throw new Error("no atom init");
      });
      return setAtomPromiseOrValue(version2, atom2, promiseOrValue, dependencies);
    } catch (errorOrPromise) {
      if (errorOrPromise instanceof Promise) {
        const suspensePromise = createSuspensePromise(errorOrPromise);
        return setAtomSuspensePromise(version2, atom2, suspensePromise, dependencies);
      }
      return setAtomReadError(version2, atom2, errorOrPromise, dependencies);
    }
  };
  const readAtom = (readingAtom, version2) => {
    const atomState = readAtomState(version2, readingAtom);
    return atomState;
  };
  const addAtom = (version2, addingAtom) => {
    let mounted = mountedMap.get(addingAtom);
    if (!mounted) {
      mounted = mountAtom(version2, addingAtom);
    }
    return mounted;
  };
  const canUnmountAtom = (atom2, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom2));
  const delAtom = (version2, deletingAtom) => {
    const mounted = mountedMap.get(deletingAtom);
    if (mounted && canUnmountAtom(deletingAtom, mounted)) {
      unmountAtom(version2, deletingAtom);
    }
  };
  const invalidateDependents = (version2, atom2) => {
    const mounted = mountedMap.get(atom2);
    mounted == null ? void 0 : mounted.t.forEach((dependent) => {
      if (dependent !== atom2) {
        setAtomInvalidated(version2, dependent);
        invalidateDependents(version2, dependent);
      }
    });
  };
  const writeAtomState = (version2, atom2, update) => {
    let isSync = true;
    const writeGetter = (a, options) => {
      const aState = readAtomState(version2, a);
      if ("e" in aState) {
        throw aState.e;
      }
      if ("p" in aState) {
        if (options == null ? void 0 : options.unstable_promise) {
          return aState.p.then(() => writeGetter(a, options));
        }
        if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
          console.info("Reading pending atom state in write operation. We throw a promise for now.", a);
        }
        throw aState.p;
      }
      if ("v" in aState) {
        return aState.v;
      }
      if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
        console.warn("[Bug] no value found while reading atom in write operation. This is probably a bug.", a);
      }
      throw new Error("no value found");
    };
    const setter = (a, v2) => {
      let promiseOrVoid2;
      if (a === atom2) {
        if (!hasInitialValue(a)) {
          throw new Error("atom not writable");
        }
        const versionSet = cancelAllSuspensePromiseInCache(a);
        versionSet.forEach((cancelledVersion) => {
          if (cancelledVersion !== version2) {
            setAtomPromiseOrValue(cancelledVersion, a, v2);
          }
        });
        const prevAtomState = getAtomState(version2, a);
        const nextAtomState = setAtomPromiseOrValue(version2, a, v2);
        if (prevAtomState !== nextAtomState) {
          invalidateDependents(version2, a);
        }
      } else {
        promiseOrVoid2 = writeAtomState(version2, a, v2);
      }
      if (!isSync) {
        flushPending(version2);
      }
      return promiseOrVoid2;
    };
    const promiseOrVoid = atom2.write(writeGetter, setter, update);
    isSync = false;
    return promiseOrVoid;
  };
  const writeAtom = (writingAtom, update, version2) => {
    const promiseOrVoid = writeAtomState(version2, writingAtom, update);
    flushPending(version2);
    return promiseOrVoid;
  };
  const isActuallyWritableAtom = (atom2) => !!atom2.write;
  const mountAtom = (version2, atom2, initialDependent) => {
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom2, mounted);
    if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      mountedAtoms.add(atom2);
    }
    const atomState = readAtomState(void 0, atom2);
    atomState.d.forEach((_, a) => {
      const aMounted = mountedMap.get(a);
      if (aMounted) {
        aMounted.t.add(atom2);
      } else {
        if (a !== atom2) {
          mountAtom(version2, a, atom2);
        }
      }
    });
    if (isActuallyWritableAtom(atom2) && atom2.onMount) {
      const setAtom = (update) => writeAtom(atom2, update, version2);
      const onUnmount = atom2.onMount(setAtom);
      version2 = void 0;
      if (onUnmount) {
        mounted.u = onUnmount;
      }
    }
    return mounted;
  };
  const unmountAtom = (version2, atom2) => {
    var _a;
    const onUnmount = (_a = mountedMap.get(atom2)) == null ? void 0 : _a.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom2);
    if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      mountedAtoms.delete(atom2);
    }
    const atomState = getAtomState(version2, atom2);
    if (atomState) {
      atomState.d.forEach((_, a) => {
        if (a !== atom2) {
          const mounted = mountedMap.get(a);
          if (mounted) {
            mounted.t.delete(atom2);
            if (canUnmountAtom(a, mounted)) {
              unmountAtom(version2, a);
            }
          }
        }
      });
    } else if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom2);
    }
  };
  const mountDependencies = (version2, atom2, atomState, prevReadDependencies) => {
    const dependencies = new Set(atomState.d.keys());
    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {
      if (dependencies.has(a)) {
        dependencies.delete(a);
        return;
      }
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.delete(atom2);
        if (canUnmountAtom(a, mounted)) {
          unmountAtom(version2, a);
        }
      }
    });
    dependencies.forEach((a) => {
      const mounted = mountedMap.get(a);
      if (mounted) {
        mounted.t.add(atom2);
      } else if (mountedMap.has(atom2)) {
        mountAtom(version2, a, atom2);
      }
    });
  };
  const flushPending = (version2) => {
    if (version2) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version2);
      versionedAtomStateMap.forEach((atomState, atom2) => {
        const committedAtomState = committedAtomStateMap.get(atom2);
        if (atomState !== committedAtomState) {
          const mounted = mountedMap.get(atom2);
          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version2));
        }
      });
      return;
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom2, prevAtomState]) => {
        const atomState = getAtomState(void 0, atom2);
        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(void 0, atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
        if (prevAtomState && "i" in prevAtomState && atomState && !("i" in atomState)) {
          return;
        }
        const mounted = mountedMap.get(atom2);
        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());
      });
    }
    if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
      stateListeners.forEach((l2) => l2());
    }
  };
  const commitVersionedAtomStateMap = (version2) => {
    const versionedAtomStateMap = getVersionedAtomStateMap(version2);
    versionedAtomStateMap.forEach((atomState, atom2) => {
      const prevAtomState = committedAtomStateMap.get(atom2);
      if (!prevAtomState || atomState.r > prevAtomState.r || "v" in atomState && atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {
        committedAtomStateMap.set(atom2, atomState);
        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(version2, atom2, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
      }
    });
  };
  const commitAtom = (_atom, version2) => {
    if (version2) {
      commitVersionedAtomStateMap(version2);
    }
    flushPending(void 0);
  };
  const subscribeAtom = (atom2, callback, version2) => {
    const mounted = addAtom(version2, atom2);
    const listeners2 = mounted.l;
    listeners2.add(callback);
    return () => {
      listeners2.delete(callback);
      delAtom(version2, atom2);
    };
  };
  const restoreAtoms = (values, version2) => {
    for (const [atom2, value2] of values) {
      if (hasInitialValue(atom2)) {
        setAtomPromiseOrValue(version2, atom2, value2);
        invalidateDependents(version2, atom2);
      }
    }
    flushPending(version2);
  };
  if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production") {
    return {
      [READ_ATOM]: readAtom,
      [WRITE_ATOM]: writeAtom,
      [COMMIT_ATOM]: commitAtom,
      [SUBSCRIBE_ATOM]: subscribeAtom,
      [RESTORE_ATOMS]: restoreAtoms,
      [DEV_SUBSCRIBE_STATE]: (l2) => {
        stateListeners.add(l2);
        return () => {
          stateListeners.delete(l2);
        };
      },
      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),
      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),
      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)
    };
  }
  return {
    [READ_ATOM]: readAtom,
    [WRITE_ATOM]: writeAtom,
    [COMMIT_ATOM]: commitAtom,
    [SUBSCRIBE_ATOM]: subscribeAtom,
    [RESTORE_ATOMS]: restoreAtoms
  };
};
const createScopeContainer = (initialValues, unstable_createStore) => {
  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);
  return { s: store };
};
const ScopeContextMap = /* @__PURE__ */ new Map();
const getScopeContext = (scope) => {
  if (!ScopeContextMap.has(scope)) {
    ScopeContextMap.set(scope, react.exports.createContext(createScopeContainer()));
  }
  return ScopeContextMap.get(scope);
};
let keyCount = 0;
function atom(read, write) {
  const key2 = `atom${++keyCount}`;
  const config = {
    toString: () => key2
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = (get2) => get2(config);
    config.write = (get2, set2, update) => set2(config, typeof update === "function" ? update(get2(config)) : update);
  }
  if (write) {
    config.write = write;
  }
  return config;
}
function useAtomValue(atom2, scope) {
  const ScopeContext = getScopeContext(scope);
  const scopeContainer = react.exports.useContext(ScopeContext);
  const { s: store, v: versionFromProvider } = scopeContainer;
  const getAtomValue = (version22) => {
    const atomState = store[READ_ATOM](atom2, version22);
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      throw atomState.p;
    }
    if ("v" in atomState) {
      return atomState.v;
    }
    throw new Error("no atom value");
  };
  const [[version2, valueFromReducer, atomFromReducer], rerenderIfChanged] = react.exports.useReducer((prev, nextVersion) => {
    const nextValue = getAtomValue(nextVersion);
    if (Object.is(prev[1], nextValue) && prev[2] === atom2) {
      return prev;
    }
    return [nextVersion, nextValue, atom2];
  }, versionFromProvider, (initialVersion) => {
    const initialValue = getAtomValue(initialVersion);
    return [initialVersion, initialValue, atom2];
  });
  let value2 = valueFromReducer;
  if (atomFromReducer !== atom2) {
    rerenderIfChanged(version2);
    value2 = getAtomValue(version2);
  }
  react.exports.useEffect(() => {
    const { v: versionFromProvider2 } = scopeContainer;
    if (versionFromProvider2) {
      store[COMMIT_ATOM](atom2, versionFromProvider2);
    }
    const unsubscribe2 = store[SUBSCRIBE_ATOM](atom2, rerenderIfChanged, versionFromProvider2);
    rerenderIfChanged(versionFromProvider2);
    return unsubscribe2;
  }, [store, atom2, scopeContainer]);
  react.exports.useEffect(() => {
    store[COMMIT_ATOM](atom2, version2);
  });
  react.exports.useDebugValue(value2);
  return value2;
}
function useSetAtom(atom2, scope) {
  const ScopeContext = getScopeContext(scope);
  const { s: store, w: versionedWrite } = react.exports.useContext(ScopeContext);
  const setAtom = react.exports.useCallback((update) => {
    if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production" && !("write" in atom2)) {
      throw new Error("not writable atom");
    }
    const write = (version2) => store[WRITE_ATOM](atom2, update, version2);
    return versionedWrite ? versionedWrite(write) : write();
  }, [store, versionedWrite, atom2]);
  return setAtom;
}
function useAtom(atom2, scope) {
  if ("scope" in atom2) {
    console.warn("atom.scope is deprecated. Please do useAtom(atom, scope) instead.");
    scope = atom2.scope;
  }
  return [
    useAtomValue(atom2, scope),
    useSetAtom(atom2, scope)
  ];
}
const propertiesStore = atom({});
const propertiesPropsStore = atom({
  current: void 0,
  defaultProps: {},
  props: {}
});
const useSetPartialProperties = () => {
  const [storeProps, setStore] = useAtom(propertiesPropsStore);
  return useMemoizedFn((props) => {
    setStore({
      ...storeProps,
      ...props
    });
  });
};
const ComponentBlock = (props) => {
  const { children, lang, value: content2, error, pathHash, renderer } = props;
  const beforeChildren = dropRight_1(children, 1);
  const [checkCode, { toggle }] = useBoolean();
  const [{ current }] = useAtom(propertiesPropsStore);
  const eventBus = useEventEmitter();
  const active = current !== void 0 && current === content2;
  return /* @__PURE__ */ React$a.createElement("div", {
    className: classNames("component-area", {
      active
    })
  }, !!beforeChildren.length && /* @__PURE__ */ React$a.createElement("div", {
    className: "code-box-demo-description markdown-body"
  }, beforeChildren), /* @__PURE__ */ React$a.createElement(ComponentArea, {
    pathHash,
    error,
    renderer,
    lang,
    content: content2,
    eventBus
  }), /* @__PURE__ */ React$a.createElement("div", {
    className: "code-box-actions"
  }, /* @__PURE__ */ React$a.createElement(Tooltip$1, {
    title: "Debug",
    onClick: eventBus.emit
  }, /* @__PURE__ */ React$a.createElement(BugOutlined2, {
    className: classNames("code-box-code-action", { active })
  })), /* @__PURE__ */ React$a.createElement(CopyIcon, {
    content: content2
  }), /* @__PURE__ */ React$a.createElement(Tooltip$1, {
    title: checkCode ? "Hide Code" : "View Code",
    onClick: () => toggle()
  }, /* @__PURE__ */ React$a.createElement(CodeOutlined2, {
    className: classNames("code-box-code-action", checkCode && "active")
  }))), checkCode && /* @__PURE__ */ React$a.createElement(HighLighter, {
    lang,
    children: content2
  }));
};
function ComponentArea(props) {
  const { renderer, content: content2, eventBus, pathHash, error } = props;
  const componentRef = react.exports.useRef();
  const invoked = react.exports.useRef(false);
  const newComp = react.exports.useRef(/* @__PURE__ */ new Map());
  let [{ defaultProps, props: componentStateProps, current }] = useAtom(propertiesPropsStore);
  const setPartialProps = useSetPartialProperties();
  const defaultPropsRef = react.exports.useRef();
  const componentProps = useCreation(() => {
    if (!current) {
      return componentStateProps;
    }
    if (current === content2) {
      return componentStateProps;
    }
    return {};
  }, [componentStateProps, current]);
  eventBus.useSubscription(() => {
    let content22 = props.content;
    if (current !== void 0 && current === content22) {
      content22 = void 0;
    }
    setPartialProps({
      current: content22,
      defaultProps: defaultPropsRef.current || {}
    });
  });
  const setDefaultProps = useMemoizedFn((props2) => {
    defaultPropsRef.current = props2;
    if (!Object.keys(defaultProps).length) {
      setPartialProps({
        defaultProps: props2
      });
    }
  });
  const wrapProps = useMemoizedFn((Component2, { React: OutReact }) => {
    var _a;
    if (((_a = newComp.current.get(Component2)) == null ? void 0 : _a.visionProps) === componentProps) {
      return newComp.current.get(Component2);
    }
    const outputComp = (props2) => {
      if (!invoked.current) {
        setDefaultProps(props2);
        invoked.current = true;
      }
      const finalProps = Object.assign({}, props2, componentProps);
      return OutReact.createElement(Component2, finalProps);
    };
    Object.assign(outputComp, Component2);
    outputComp.visionProps = componentProps;
    outputComp.origin$ = Component2;
    outputComp.wrap$ = (Component22) => wrapProps(Component22, { React: OutReact });
    newComp.current.set(Component2, outputComp);
    return outputComp;
  });
  react.exports.useEffect(() => {
    renderer(componentRef.current, {
      wrap: wrapProps
    });
  }, [renderer, componentProps]);
  return /* @__PURE__ */ React$a.createElement(React$a.Fragment, null, error ? /* @__PURE__ */ React$a.createElement(Result$1, {
    status: "warning",
    title: "Resource load failed",
    subTitle: /* @__PURE__ */ React$a.createElement("span", {
      style: { whiteSpace: "pre-wrap", textAlign: "left" }
    }, error.message)
  }) : /* @__PURE__ */ React$a.createElement("div", {
    className: pathHash
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "component-container",
    id: "vite-component-container",
    ref: componentRef
  })));
}
function CopyIcon({ content: content2 }) {
  const [copied, { setTrue, setFalse }] = useBoolean();
  const copy2 = useMemoizedFn(() => {
    copyToClipboard(content2);
    setTrue();
  });
  return /* @__PURE__ */ React$a.createElement(Tooltip$1, {
    title: copied ? "Copied!" : "Copy Code",
    onClick: copy2,
    onVisibleChange: (v2) => {
      !v2 && setTimeout(() => {
        setFalse();
      }, 500);
    }
  }, copied ? /* @__PURE__ */ React$a.createElement(CheckOutlined$3, {
    className: "code-box-code-action",
    style: { color: "#52c41a" }
  }) : /* @__PURE__ */ React$a.createElement(CopyOutlined$3, {
    className: "code-box-code-action"
  }));
}
function renderProperty({ loading = false, properties }) {
  const { props = {} } = properties;
  const dateSource = Object.values(props).map((val) => {
    if (!!val.defaultValue) {
      val.defaultValue.value = `${val.defaultValue.value}`;
    }
    return val;
  });
  return /* @__PURE__ */ React$a.createElement(Table$1, {
    loading,
    scroll: { x: "100%" },
    dataSource: dateSource,
    pagination: false,
    bordered: true
  }, /* @__PURE__ */ React$a.createElement(Table$1.Column, {
    dataIndex: "name",
    title: "Property"
  }), /* @__PURE__ */ React$a.createElement(Table$1.Column, {
    dataIndex: "description",
    title: "Description"
  }), /* @__PURE__ */ React$a.createElement(Table$1.Column, {
    dataIndex: ["type", "name"],
    title: "Type"
  }), /* @__PURE__ */ React$a.createElement(Table$1.Column, {
    dataIndex: ["defaultValue", "value"],
    title: "Default"
  }));
}
function PropertyArea(props) {
  const { renderer } = props;
  const componentRef = react.exports.useRef();
  const [, setTypes] = useAtom(propertiesStore);
  react.exports.useEffect(() => {
    renderer(componentRef.current, {
      renderType$: (types2, mountNode = componentRef.current) => {
        setTypes(types2);
        return ReactDOM.render(/* @__PURE__ */ React$a.createElement(renderProperty, {
          loading: false,
          properties: types2
        }), mountNode);
      }
    });
  }, [renderer]);
  return /* @__PURE__ */ React$a.createElement("div", {
    className: "property-container",
    ref: componentRef
  }, /* @__PURE__ */ React$a.createElement(renderProperty, {
    properties: {},
    loading: true
  }));
}
var format = { exports: {} };
(function(module) {
  (function() {
    var namespace;
    {
      namespace = module.exports = format2;
    }
    namespace.format = format2;
    namespace.vsprintf = vsprintf;
    if (typeof console !== "undefined" && typeof console.log === "function") {
      namespace.printf = printf;
    }
    function printf() {
      console.log(format2.apply(null, arguments));
    }
    function vsprintf(fmt, replacements) {
      return format2.apply(null, [fmt].concat(replacements));
    }
    function format2(fmt) {
      var argIndex = 1, args = [].slice.call(arguments), i = 0, n2 = fmt.length, result = "", c2, escaped = false, arg, tmp, leadingZero = false, precision, nextArg = function() {
        return args[argIndex++];
      }, slurpNumber = function() {
        var digits = "";
        while (/\d/.test(fmt[i])) {
          digits += fmt[i++];
          c2 = fmt[i];
        }
        return digits.length > 0 ? parseInt(digits) : null;
      };
      for (; i < n2; ++i) {
        c2 = fmt[i];
        if (escaped) {
          escaped = false;
          if (c2 == ".") {
            leadingZero = false;
            c2 = fmt[++i];
          } else if (c2 == "0" && fmt[i + 1] == ".") {
            leadingZero = true;
            i += 2;
            c2 = fmt[i];
          } else {
            leadingZero = true;
          }
          precision = slurpNumber();
          switch (c2) {
            case "b":
              result += parseInt(nextArg(), 10).toString(2);
              break;
            case "c":
              arg = nextArg();
              if (typeof arg === "string" || arg instanceof String)
                result += arg;
              else
                result += String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
              result += parseInt(nextArg(), 10);
              break;
            case "f":
              tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
              result += leadingZero ? tmp : tmp.replace(/^0/, "");
              break;
            case "j":
              result += JSON.stringify(nextArg());
              break;
            case "o":
              result += "0" + parseInt(nextArg(), 10).toString(8);
              break;
            case "s":
              result += nextArg();
              break;
            case "x":
              result += "0x" + parseInt(nextArg(), 10).toString(16);
              break;
            case "X":
              result += "0x" + parseInt(nextArg(), 10).toString(16).toUpperCase();
              break;
            default:
              result += c2;
              break;
          }
        } else if (c2 === "%") {
          escaped = true;
        } else {
          result += c2;
        }
      }
      return result;
    }
  })();
})(format);
const formatter = format.exports;
const fault = Object.assign(create(Error), {
  eval: create(EvalError),
  range: create(RangeError),
  reference: create(ReferenceError),
  syntax: create(SyntaxError),
  type: create(TypeError),
  uri: create(URIError)
});
function create(Constructor) {
  FormattedError.displayName = Constructor.displayName || Constructor.name;
  return FormattedError;
  function FormattedError(format2, ...values) {
    const reason = format2 ? formatter(format2, ...values) : format2;
    return new Constructor(reason);
  }
}
const own = {}.hasOwnProperty;
const markers = {
  yaml: "-",
  toml: "+"
};
function matters(options = "yaml") {
  const results = [];
  let index2 = -1;
  if (!Array.isArray(options)) {
    options = [options];
  }
  while (++index2 < options.length) {
    results[index2] = matter(options[index2]);
  }
  return results;
}
function matter(option) {
  let result = option;
  if (typeof result === "string") {
    if (!own.call(markers, result)) {
      throw fault("Missing matter definition for `%s`", result);
    }
    result = {
      type: result,
      marker: markers[result]
    };
  } else if (typeof result !== "object") {
    throw fault("Expected matter to be an object, not `%j`", result);
  }
  if (!own.call(result, "type")) {
    throw fault("Missing `type` in matter `%j`", result);
  }
  if (!own.call(result, "fence") && !own.call(result, "marker")) {
    throw fault("Missing `marker` or `fence` in matter `%j`", result);
  }
  return result;
}
const unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
function markdownLineEnding(code) {
  return code !== null && code < -2;
}
function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32;
}
regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code) {
    return code !== null && regex.test(String.fromCharCode(code));
  }
}
function frontmatter(options) {
  const settings = matters(options);
  const flow2 = {};
  let index2 = -1;
  let matter2;
  let code;
  while (++index2 < settings.length) {
    matter2 = settings[index2];
    code = fence$1(matter2, "open").charCodeAt(0);
    if (code in flow2) {
      flow2[code].push(parse(matter2));
    } else {
      flow2[code] = [parse(matter2)];
    }
  }
  return {
    flow: flow2
  };
}
function parse(matter2) {
  const name2 = matter2.type;
  const anywhere = matter2.anywhere;
  const valueType = name2 + "Value";
  const fenceType = name2 + "Fence";
  const sequenceType = fenceType + "Sequence";
  const fenceConstruct = {
    tokenize: tokenizeFence,
    partial: true
  };
  let buffer2;
  return {
    tokenize: tokenizeFrontmatter,
    concrete: true
  };
  function tokenizeFrontmatter(effects, ok2, nok) {
    const self2 = this;
    return start;
    function start(code) {
      const position2 = self2.now();
      if (position2.column !== 1 || !anywhere && position2.line !== 1) {
        return nok(code);
      }
      effects.enter(name2);
      buffer2 = fence$1(matter2, "open");
      return effects.attempt(fenceConstruct, afterOpeningFence, nok)(code);
    }
    function afterOpeningFence(code) {
      buffer2 = fence$1(matter2, "close");
      return lineEnd(code);
    }
    function lineStart(code) {
      if (code === null || markdownLineEnding(code)) {
        return lineEnd(code);
      }
      effects.enter(valueType);
      return lineData(code);
    }
    function lineData(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit(valueType);
        return lineEnd(code);
      }
      effects.consume(code);
      return lineData;
    }
    function lineEnd(code) {
      if (code === null) {
        return nok(code);
      }
      effects.enter("lineEnding");
      effects.consume(code);
      effects.exit("lineEnding");
      return effects.attempt(fenceConstruct, after, lineStart);
    }
    function after(code) {
      effects.exit(name2);
      return ok2(code);
    }
  }
  function tokenizeFence(effects, ok2, nok) {
    let bufferIndex = 0;
    return start;
    function start(code) {
      if (code === buffer2.charCodeAt(bufferIndex)) {
        effects.enter(fenceType);
        effects.enter(sequenceType);
        return insideSequence(code);
      }
      return nok(code);
    }
    function insideSequence(code) {
      if (bufferIndex === buffer2.length) {
        effects.exit(sequenceType);
        if (markdownSpace(code)) {
          effects.enter("whitespace");
          return insideWhitespace(code);
        }
        return fenceEnd(code);
      }
      if (code === buffer2.charCodeAt(bufferIndex++)) {
        effects.consume(code);
        return insideSequence;
      }
      return nok(code);
    }
    function insideWhitespace(code) {
      if (markdownSpace(code)) {
        effects.consume(code);
        return insideWhitespace;
      }
      effects.exit("whitespace");
      return fenceEnd(code);
    }
    function fenceEnd(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit(fenceType);
        return ok2(code);
      }
      return nok(code);
    }
  }
}
function fence$1(matter2, prop) {
  return matter2.marker ? pick$1(matter2.marker, prop).repeat(3) : pick$1(matter2.fence, prop);
}
function pick$1(schema2, prop) {
  return typeof schema2 === "string" ? schema2 : schema2[prop];
}
function frontmatterFromMarkdown(options) {
  const settings = matters(options);
  const enter = {};
  const exit2 = {};
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    enter[matter2.type] = opener(matter2);
    exit2[matter2.type] = close2;
    exit2[matter2.type + "Value"] = value;
  }
  return { enter, exit: exit2 };
}
function opener(matter2) {
  return open;
  function open(token) {
    this.enter({ type: matter2.type, value: "" }, token);
    this.buffer();
  }
}
function close2(token) {
  const data2 = this.resume();
  this.exit(token).value = data2.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
}
function value(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function frontmatterToMarkdown(options) {
  const unsafe = [];
  const handlers = {};
  const settings = matters(options);
  let index2 = -1;
  while (++index2 < settings.length) {
    const matter2 = settings[index2];
    handlers[matter2.type] = handler(matter2);
    unsafe.push({ atBreak: true, character: fence(matter2, "open").charAt(0) });
  }
  return { unsafe, handlers };
}
function handler(matter2) {
  const open = fence(matter2, "open");
  const close3 = fence(matter2, "close");
  return handle;
  function handle(node) {
    return open + (node.value ? "\n" + node.value : "") + "\n" + close3;
  }
}
function fence(matter2, prop) {
  return matter2.marker ? pick(matter2.marker, prop).repeat(3) : pick(matter2.fence, prop);
}
function pick(schema2, prop) {
  return typeof schema2 === "string" ? schema2 : schema2[prop];
}
function remarkFrontmatter(options = "yaml") {
  const data2 = this.data();
  add("micromarkExtensions", frontmatter(options));
  add("fromMarkdownExtensions", frontmatterFromMarkdown(options));
  add("toMarkdownExtensions", frontmatterToMarkdown(options));
  function add(field, value2) {
    const list2 = data2[field] ? data2[field] : data2[field] = [];
    list2.push(value2);
  }
}
function remarkCodeBlock(options) {
  return (tree, _file) => {
    const modules = [];
    let prevModules = [];
    tree.children.forEach((node) => {
      if (node.type === "thematicBreak") {
        modules.push(...prevModules);
        prevModules = [];
        return;
      }
      if (node.type === "code" && isJsx(node.lang) && isTypes(node.value)) {
        modules.push(...prevModules, {
          ...node,
          type: "property-code"
        });
        prevModules = [];
        return;
      }
      prevModules.push(node);
      if (node.type === "code" && hasReact(node.value) && isJsx(node.lang)) {
        modules.push({
          ...node,
          type: "component-block",
          children: prevModules
        });
        prevModules = [];
        return;
      }
    });
    if (!!prevModules.length) {
      modules.push(...prevModules);
    }
    tree.children = modules;
    return tree;
  };
}
function MarkdownArea({ data: res }) {
  if (!res) {
    return null;
  }
  const { moduleMap, content: content2, error, pathHash } = res;
  const getModule = useMemoizedFn((value2) => moduleMap == null ? void 0 : moduleMap[value2.trim()]);
  const code = useMemoizedFn(({ language, value: value2 = "" }) => {
    return /* @__PURE__ */ React$a.createElement(HighLighter, {
      lang: language,
      children: value2
    });
  });
  const componentBlock = useMemoizedFn((props) => {
    return /* @__PURE__ */ React$a.createElement(ComponentBlock, {
      ...props,
      error,
      pathHash,
      renderer: getModule(props.value)
    });
  });
  const propertyCode = useMemoizedFn((props) => /* @__PURE__ */ React$a.createElement(PropertyArea, {
    ...props,
    renderer: getModule(props.value)
  }));
  const markdownElements = useCreation(() => /* @__PURE__ */ React$a.createElement(reactMarkdown, {
    className: "markdown-body",
    plugins: [remarkFrontmatter, remarkCodeBlock],
    renderers: {
      yaml: () => null,
      code,
      "component-block": componentBlock,
      "property-code": propertyCode
    }
  }, content2), [content2, moduleMap]);
  return /* @__PURE__ */ React$a.createElement("div", {
    className: "markdown-area"
  }, markdownElements);
}
function toName(name2) {
  if (!name2) {
    return null;
  }
  return name2.replace(/-/g, " ").replace(/\//g, " - ").replace(/^[a-z] /, "").replace(/^./, (s) => s.toUpperCase()).replace(/ \w/g, (s) => s.toUpperCase());
}
const { Title: Title2, Text: Text2 } = Typography$1;
function PageTitle(props) {
  const compInfo = useComponentInfo();
  const { flattenRoutes = [] } = useRouteMap() || {};
  const route = props.route;
  const currentRoute = flattenRoutes.find(({ path }) => path === route);
  return /* @__PURE__ */ React$a.createElement("a", {
    href: compInfo == null ? void 0 : compInfo.npmLink,
    className: "link-title"
  }, /* @__PURE__ */ React$a.createElement(Title2, {
    level: 1,
    className: "component-name"
  }, toName(currentRoute == null ? void 0 : currentRoute.name) || (compInfo == null ? void 0 : compInfo.packageName), /* @__PURE__ */ React$a.createElement(LinkCopy, {
    route: props.route
  })), /* @__PURE__ */ React$a.createElement("span", {
    className: "component-sub-title"
  }, /* @__PURE__ */ React$a.createElement(Text2, {
    type: "secondary"
  }, "Package: ", compInfo == null ? void 0 : compInfo.packageName), /* @__PURE__ */ React$a.createElement(Text2, {
    type: "secondary"
  }, "Version: ", compInfo == null ? void 0 : compInfo.packageVersion)));
}
var DoubleLeftOutlined$4 = { exports: {} };
var DoubleLeftOutlined$3 = {};
var DoubleLeftOutlined$2 = {};
var hasRequiredDoubleLeftOutlined;
function requireDoubleLeftOutlined() {
  if (hasRequiredDoubleLeftOutlined)
    return DoubleLeftOutlined$2;
  hasRequiredDoubleLeftOutlined = 1;
  Object.defineProperty(DoubleLeftOutlined$2, "__esModule", { value: true });
  var DoubleLeftOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, "name": "double-left", "theme": "outlined" };
  DoubleLeftOutlined$2.default = DoubleLeftOutlined4;
  return DoubleLeftOutlined$2;
}
var _interopRequireWildcard$2 = interopRequireWildcard.exports;
var _interopRequireDefault$2 = interopRequireDefault.exports;
Object.defineProperty(DoubleLeftOutlined$3, "__esModule", {
  value: true
});
DoubleLeftOutlined$3.default = void 0;
var _objectSpread2$2 = _interopRequireDefault$2(requireObjectSpread2());
var React$2 = _interopRequireWildcard$2(react.exports);
var _DoubleLeftOutlined = _interopRequireDefault$2(requireDoubleLeftOutlined());
var _AntdIcon$2 = _interopRequireDefault$2(requireAntdIcon());
var DoubleLeftOutlined$1 = function DoubleLeftOutlined2(props, ref) {
  return /* @__PURE__ */ React$2.createElement(_AntdIcon$2.default, (0, _objectSpread2$2.default)((0, _objectSpread2$2.default)({}, props), {}, {
    ref,
    icon: _DoubleLeftOutlined.default
  }));
};
DoubleLeftOutlined$1.displayName = "DoubleLeftOutlined";
var _default$2 = /* @__PURE__ */ React$2.forwardRef(DoubleLeftOutlined$1);
DoubleLeftOutlined$3.default = _default$2;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _DoubleLeftOutlined2 = _interopRequireDefault2(DoubleLeftOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _DoubleLeftOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(DoubleLeftOutlined$4, DoubleLeftOutlined$4.exports);
const DoubleLeftOutlined3 = /* @__PURE__ */ getDefaultExportFromCjs(DoubleLeftOutlined$4.exports);
var CloseOutlined$4 = { exports: {} };
var CloseOutlined$3 = {};
var CloseOutlined$2 = {};
var hasRequiredCloseOutlined;
function requireCloseOutlined() {
  if (hasRequiredCloseOutlined)
    return CloseOutlined$2;
  hasRequiredCloseOutlined = 1;
  Object.defineProperty(CloseOutlined$2, "__esModule", { value: true });
  var CloseOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
  CloseOutlined$2.default = CloseOutlined4;
  return CloseOutlined$2;
}
var _interopRequireWildcard$1 = interopRequireWildcard.exports;
var _interopRequireDefault$1 = interopRequireDefault.exports;
Object.defineProperty(CloseOutlined$3, "__esModule", {
  value: true
});
CloseOutlined$3.default = void 0;
var _objectSpread2$1 = _interopRequireDefault$1(requireObjectSpread2());
var React$1 = _interopRequireWildcard$1(react.exports);
var _CloseOutlined = _interopRequireDefault$1(requireCloseOutlined());
var _AntdIcon$1 = _interopRequireDefault$1(requireAntdIcon());
var CloseOutlined$1 = function CloseOutlined2(props, ref) {
  return /* @__PURE__ */ React$1.createElement(_AntdIcon$1.default, (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, props), {}, {
    ref,
    icon: _CloseOutlined.default
  }));
};
CloseOutlined$1.displayName = "CloseOutlined";
var _default$1 = /* @__PURE__ */ React$1.forwardRef(CloseOutlined$1);
CloseOutlined$3.default = _default$1;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _CloseOutlined2 = _interopRequireDefault2(CloseOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _CloseOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(CloseOutlined$4, CloseOutlined$4.exports);
const CloseOutlined3 = /* @__PURE__ */ getDefaultExportFromCjs(CloseOutlined$4.exports);
const PANE_VISIBLE = "pane_visible";
const form = "";
const Setters = {
  NumberSetter: (props) => /* @__PURE__ */ React$a.createElement(InputNumber$1, {
    ...props,
    style: { width: 120 }
  }),
  TextSetter: (props) => /* @__PURE__ */ React$a.createElement(Input$1, {
    ...props,
    style: { width: 120 }
  }),
  ChoiceSetter: (props) => /* @__PURE__ */ React$a.createElement(Radio$1.Group, {
    ...props,
    optionType: "button",
    size: "small"
  }),
  SelectSetter: (props) => /* @__PURE__ */ React$a.createElement(Select$1, {
    ...props,
    style: { width: 120 },
    allowClear: true
  }),
  BoolSetter: (props) => /* @__PURE__ */ React$a.createElement(Switch$1, {
    ...props,
    checked: props.value
  })
};
function SetterFormItem({ name: name2, tip, defaultValue, setter, ...rest }) {
  const Setter = Setters[setter];
  return /* @__PURE__ */ React$a.createElement(List2.Item, {
    className: "setter-form-item"
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "setter-form-item-label"
  }, /* @__PURE__ */ React$a.createElement(Tooltip$1, {
    className: classNames(!!tip && "has-tip"),
    title: tip
  }, name2)), /* @__PURE__ */ React$a.createElement("div", {
    className: "setter-form-item-value"
  }, Setter && /* @__PURE__ */ React$a.createElement(Form$1.Item, {
    name: name2,
    initialValue: defaultValue,
    style: { marginBottom: 0 }
  }, /* @__PURE__ */ React$a.createElement(Setter, {
    ...rest
  }))));
}
function Stage({
  componentName,
  configure: configure2,
  initialValues,
  onValuesChange
}) {
  const [form2] = Form$1.useForm();
  const propertyDefaultValues = useCreation(() => configure2.reduce((prev, { name: name2, defaultValue }) => {
    defaultValue !== void 0 && Object.assign(prev, { [name2]: defaultValue });
    return prev;
  }, {}), [configure2]);
  react.exports.useEffect(() => {
    form2.setFieldsValue({
      ...propertyDefaultValues,
      ...initialValues
    });
  }, [initialValues, propertyDefaultValues]);
  return /* @__PURE__ */ React$a.createElement(Form$1, {
    form: form2,
    onValuesChange
  }, /* @__PURE__ */ React$a.createElement(List2, {
    className: "pane-stage",
    dataSource: configure2,
    renderItem: (item) => {
      return /* @__PURE__ */ React$a.createElement(SetterFormItem, {
        ...item
      });
    }
  }));
}
var isArray$1 = isArray_1, isSymbol$1 = isSymbol_1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$1(value2, object4) {
  if (isArray$1(value2)) {
    return false;
  }
  var type4 = typeof value2;
  if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value2 == null || isSymbol$1(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object4 != null && value2 in Object(object4);
}
var _isKey = isKey$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize$1(func, resolver2) {
  if (typeof func != "function" || resolver2 != null && typeof resolver2 != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver2 ? resolver2.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key2, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache)();
  return memoized;
}
memoize$1.Cache = MapCache;
var memoize_1 = memoize$1;
var memoize = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize(func, function(key2) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key2;
  });
  var cache2 = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string3) {
  var result = [];
  if (string3.charCodeAt(0) === 46) {
    result.push("");
  }
  string3.replace(rePropName, function(match2, number4, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
  });
  return result;
});
var _stringToPath = stringToPath$1;
var isArray2 = isArray_1, isKey = _isKey, stringToPath = _stringToPath, toString = toString_1;
function castPath$2(value2, object4) {
  if (isArray2(value2)) {
    return value2;
  }
  return isKey(value2, object4) ? [value2] : stringToPath(toString(value2));
}
var _castPath = castPath$2;
var isSymbol = isSymbol_1;
var INFINITY = 1 / 0;
function toKey$2(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
var _toKey = toKey$2;
var castPath$1 = _castPath, toKey$1 = _toKey;
function baseGet$1(object4, path) {
  path = castPath$1(path, object4);
  var index2 = 0, length = path.length;
  while (object4 != null && index2 < length) {
    object4 = object4[toKey$1(path[index2++])];
  }
  return index2 && index2 == length ? object4 : void 0;
}
var _baseGet = baseGet$1;
var baseGet = _baseGet;
function get(object4, path, defaultValue) {
  var result = object4 == null ? void 0 : baseGet(object4, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
var getNative = _getNative;
var defineProperty$1 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty = defineProperty$1;
var defineProperty = _defineProperty;
function baseAssignValue$1(object4, key2, value2) {
  if (key2 == "__proto__" && defineProperty) {
    defineProperty(object4, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object4[key2] = value2;
  }
}
var _baseAssignValue = baseAssignValue$1;
var baseAssignValue = _baseAssignValue, eq = eq_1;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function assignValue$1(object4, key2, value2) {
  var objValue = object4[key2];
  if (!(hasOwnProperty.call(object4, key2) && eq(objValue, value2)) || value2 === void 0 && !(key2 in object4)) {
    baseAssignValue(object4, key2, value2);
  }
}
var _assignValue = assignValue$1;
var assignValue = _assignValue, castPath = _castPath, isIndex = _isIndex, isObject = isObject_1, toKey = _toKey;
function baseSet$1(object4, path, value2, customizer) {
  if (!isObject(object4)) {
    return object4;
  }
  path = castPath(path, object4);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object4;
  while (nested != null && ++index2 < length) {
    var key2 = toKey(path[index2]), newValue = value2;
    if (key2 === "__proto__" || key2 === "constructor" || key2 === "prototype") {
      return object4;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key2];
      newValue = customizer ? customizer(objValue, key2, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    assignValue(nested, key2, newValue);
    nested = nested[key2];
  }
  return object4;
}
var _baseSet = baseSet$1;
var baseSet = _baseSet;
function set(object4, path, value2) {
  return object4 == null ? object4 : baseSet(object4, path, value2);
}
var set_1 = set;
const HOC_PROPS = [
  "request",
  "label",
  "visible",
  "hotload",
  "tips",
  "labelPosition",
  "subLabel",
  "required"
];
const BLOCK_PROPS = [
  "name",
  "renderComponent",
  "elements",
  "runAction",
  "actions",
  "itemData",
  "uiType",
  "componentKey",
  "itemData",
  "App",
  ...HOC_PROPS
];
const DEFAULT_VISION_CONFIG = {
  category: "*",
  icon: "//img.alicdn.com/tfs/TB1whTmvAL0gK0jSZFxXXXWHVXa-200-200.svg",
  isContainer: false
};
const STRING = "string";
const NUMBER = "number";
const BOOL = "boolean";
const Normal_Types = [STRING, NUMBER, BOOL];
const Null_TYPES = ["undefined", "null"];
const Composite_Types = [
  "any",
  "any[]",
  "string[]",
  "number[]",
  "object",
  "object[]"
];
const isNotEnumTypes = (types2 = "") => {
  return types2.split("|").some((str) => Normal_Types.concat(Composite_Types).includes(str.trim()));
};
const isNumberTypes = (types2 = "") => {
  return types2.split("|").every((str) => [NUMBER].concat(Null_TYPES).includes(str.trim()));
};
const isTextTypes = (types2 = "") => {
  return types2.split("|").every((str) => [STRING, NUMBER].concat(Null_TYPES).includes(str.trim()));
};
const isBoolTypes = (types2 = "") => {
  return types2.split("|").every((str) => [BOOL].concat(Null_TYPES).includes(str.trim()));
};
const strToObj = (str) => {
  try {
    return JSON.parse(str);
  } catch (error) {
    return str;
  }
};
const filterQuotaMarkAndUndefined = (typeStr) => typeStr.split("|").map((val) => val.replace(/"/g, "").trim()).filter((val) => val !== "undefined");
const REGEXP_ISMultipleTypes = /\S+(\[\])?\s*\|/g;
const REGEXP_ISFunction = /\(.*\)\s*=>\s*.+/;
const REGEXP_ISObject = /^\{.+}$/;
const REGEXP_ISArray = /{.+}\[]$/;
class VisionSchemaTransfer {
  transformProps(propType) {
    const defaultConfig = this.defaultVisionConfig;
    const { configure: defaultConfigure = [] } = defaultConfig;
    const { name: name2, description } = propType;
    const defaultValue = VisionSchemaTransfer.getDefaultPropByTypes(propType);
    const type4 = get_1(propType, "type.name");
    const tags = Object.entries(propType.tags || {}).reduce((previousValue, [key2, value2]) => set_1(previousValue, key2, strToObj(value2)), {});
    if (tags.vision === false) {
      return null;
    }
    const visionJsonConfig = defaultConfigure.find((configure2) => configure2.name === name2);
    const setterInfo = VisionSchemaTransfer.getSetterByTSType(type4);
    if (!setterInfo) {
      return false;
    }
    const visionDocsConfig = get_1(tags, "vision");
    return {
      name: name2,
      tip: description,
      defaultValue,
      ...setterInfo,
      ...visionJsonConfig,
      ...visionDocsConfig
    };
  }
  static getObjectTypes(typeStr) {
    if (!/^{.+}$/.test(typeStr.trim())) {
      return typeStr;
    }
    const reg2 = /(\w+)\??: ([\w\[\]]+|{.+});/g;
    let regResult, result = {};
    while (regResult = reg2.exec(typeStr)) {
      const [, key2, value2] = regResult;
      result[key2] = value2;
    }
    return result;
  }
  static getSetterByTSType(tsType) {
    const typeStr = `${tsType}`.trim();
    let result;
    [
      this.getNumberSetterByTypes.bind(this),
      this.getBoolSetterByTypes.bind(this),
      this.getTextSetterByTypes.bind(this),
      this.getChoiceSetterByTypes.bind(this),
      this.getSelectSetterByTypes.bind(this)
    ].some((fn) => {
      const item = fn(typeStr);
      if (item) {
        result = item;
      }
      return item;
    });
    return result;
  }
  static getBoolSetterByTypes(types2) {
    return isBoolTypes(types2) && { setter: "BoolSetter" };
  }
  static getNumberSetterByTypes(types2) {
    return isNumberTypes(types2) && { setter: "NumberSetter" };
  }
  static getTextSetterByTypes(types2) {
    return isTextTypes(types2) && { setter: "TextSetter" };
  }
  static getListSetterByTypes(typeStr) {
    if (REGEXP_ISArray.test(typeStr)) {
      const typeItemStr = typeStr.replace(/\[]$/, "").trim();
      const resultType = this.getObjectTypes(typeItemStr);
      const configure2 = resultType instanceof Object ? Object.entries(resultType).map(([key2, item]) => ({
        name: key2,
        setter: this.getSetterByTSType(item)
      })) : void 0;
      return {
        setter: "ListSetter",
        checkField: null,
        configure: configure2
      };
    }
    return typeStr;
  }
  static getChoiceSetterByTypes(typeStr) {
    if (!REGEXP_ISFunction.test(typeStr) && !REGEXP_ISObject.test(typeStr) && REGEXP_ISMultipleTypes.test(typeStr) && !isNotEnumTypes(typeStr) && filterQuotaMarkAndUndefined(typeStr).length <= 3) {
      return {
        setter: "ChoiceSetter",
        options: filterQuotaMarkAndUndefined(typeStr)
      };
    }
    return false;
  }
  static getSelectSetterByTypes(typeStr) {
    if (!REGEXP_ISFunction.test(typeStr) && !REGEXP_ISObject.test(typeStr) && REGEXP_ISMultipleTypes.test(typeStr) && !isNotEnumTypes(typeStr)) {
      return {
        setter: "SelectSetter",
        options: typeStr.split("|").map((val) => val.replace(/"/g, "").trim()).filter((val) => val !== "undefined").map((val) => {
          return {
            text: val,
            value: val
          };
        })
      };
    }
    return false;
  }
  static getDefaultPropByTypes(propType) {
    let defaultValue = get_1(propType, "defaultValue.value");
    try {
      if (!defaultValue) {
        return defaultValue;
      }
      defaultValue = new Function("global", `return ("" + ${defaultValue}) in global ? (""+${defaultValue}) : ${defaultValue}`)(globalThis);
    } catch (e2) {
    }
    return defaultValue;
  }
  constructor(types2, options) {
    this.types = types2;
    const { defaultConfig = {}, blockProps = BLOCK_PROPS } = options || {};
    this.blockProps = blockProps;
    this.defaultVisionConfig = Object.assign({}, DEFAULT_VISION_CONFIG, defaultConfig);
  }
  transformTypeSchema() {
    const defaultVisionConfig = this.defaultVisionConfig;
    const { displayName, props = {}, tags = {} } = this.types;
    const isVisionContainer = tags["vision.isContainer"];
    const configure2 = Object.values(props).filter((prop) => !this.blockProps.includes(get_1(prop, "name", ""))).map(this.transformProps.bind(this)).filter(Boolean);
    const restConfigs = configure2.filter((config) => config.setter !== "ActionSetter" && config);
    let isContainer;
    if (isVisionContainer !== void 0) {
      isContainer = JSON.parse(isVisionContainer);
    } else {
      isContainer = Object.keys(props).includes("elements") || false;
    }
    return Object.assign({}, defaultVisionConfig, {
      componentName: displayName,
      isContainer,
      configure: restConfigs
    });
  }
}
function buildVisionFromTypes(typeDesc, options) {
  return new VisionSchemaTransfer(typeDesc, options).transformTypeSchema();
}
const index$1 = "";
function PropertyPane() {
  const [properties] = useAtom(propertiesStore);
  const [propertyDrawerShow, setPropertyDrawerShow] = useLocalStorageState$1(PANE_VISIBLE, {});
  const [storeProps, setStore] = useAtom(propertiesPropsStore);
  const { defaultProps } = storeProps;
  const onPropsChange = useMemoizedFn((props) => {
    setStore({
      ...storeProps,
      props: {
        ...storeProps.props,
        ...props
      }
    });
  });
  const { data: prototypeOptions } = useRequest(async () => {
    return buildVisionFromTypes(properties);
  }, {
    refreshDeps: [properties]
  });
  const renderIndex = react.exports.useRef(0);
  useUpdateEffect(() => {
    renderIndex.current++;
    if (renderIndex.current > 1) {
      setPropertyDrawerShow("1");
    }
  }, [defaultProps]);
  if (!Object.keys(properties).length) {
    return null;
  }
  return /* @__PURE__ */ React$a.createElement("div", {
    className: "vision-property-container"
  }, propertyDrawerShow && prototypeOptions ? /* @__PURE__ */ React$a.createElement(Anchor$1, {
    offsetTop: 20,
    style: { backgroundColor: "unset" }
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "ant-drawer-wrapper-body "
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "component-block"
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "ant-drawer-header"
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "ant-drawer-title"
  }, /* @__PURE__ */ React$a.createElement(BugOutlined2, {
    className: "code-box-code-action",
    style: { marginRight: 8 }
  }), "Debug Panel"), /* @__PURE__ */ React$a.createElement("button", {
    "aria-label": "Close",
    className: "ant-drawer-close",
    onClick: () => setPropertyDrawerShow("")
  }, /* @__PURE__ */ React$a.createElement(CloseOutlined3, null))), /* @__PURE__ */ React$a.createElement("div", {
    className: "ant-drawer-body"
  }, /* @__PURE__ */ React$a.createElement(Stage, {
    ...prototypeOptions,
    initialValues: defaultProps,
    onValuesChange: onPropsChange
  }))))) : /* @__PURE__ */ React$a.createElement("div", {
    className: "icon-vision-property-show",
    onClick: () => setPropertyDrawerShow("1")
  }, /* @__PURE__ */ React$a.createElement(Button$2, null, /* @__PURE__ */ React$a.createElement(DoubleLeftOutlined3, null), "Debug Panel")));
}
function ReadmePane() {
  const { route } = useRoute();
  const Components = useMarkdown();
  const setProperties = useSetAtom(propertiesStore);
  const setDefaultProps = useSetAtom(propertiesPropsStore);
  useUnmount$1(() => {
    setProperties({});
    setDefaultProps({
      current: void 0,
      defaultProps: {},
      props: {}
    });
  });
  return /* @__PURE__ */ React$a.createElement("div", {
    id: "public-component-show-container"
  }, Components ? /* @__PURE__ */ React$a.createElement("div", {
    className: "component-page"
  }, /* @__PURE__ */ React$a.createElement(PageTitle, {
    route
  }), /* @__PURE__ */ React$a.createElement("div", {
    className: "component-main"
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "component-part"
  }, /* @__PURE__ */ React$a.createElement("div", {
    className: "component-description"
  }, /* @__PURE__ */ React$a.createElement(MarkdownArea, {
    data: Components
  }))), /* @__PURE__ */ React$a.createElement(PropertyPane, null))) : "Loading...");
}
const index = "";
var DoubleRightOutlined$4 = { exports: {} };
var DoubleRightOutlined$3 = {};
var DoubleRightOutlined$2 = {};
var hasRequiredDoubleRightOutlined;
function requireDoubleRightOutlined() {
  if (hasRequiredDoubleRightOutlined)
    return DoubleRightOutlined$2;
  hasRequiredDoubleRightOutlined = 1;
  Object.defineProperty(DoubleRightOutlined$2, "__esModule", { value: true });
  var DoubleRightOutlined4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, "name": "double-right", "theme": "outlined" };
  DoubleRightOutlined$2.default = DoubleRightOutlined4;
  return DoubleRightOutlined$2;
}
var _interopRequireWildcard = interopRequireWildcard.exports;
var _interopRequireDefault = interopRequireDefault.exports;
Object.defineProperty(DoubleRightOutlined$3, "__esModule", {
  value: true
});
DoubleRightOutlined$3.default = void 0;
var _objectSpread2 = _interopRequireDefault(requireObjectSpread2());
var React = _interopRequireWildcard(react.exports);
var _DoubleRightOutlined = _interopRequireDefault(requireDoubleRightOutlined());
var _AntdIcon = _interopRequireDefault(requireAntdIcon());
var DoubleRightOutlined$1 = function DoubleRightOutlined2(props, ref) {
  return /* @__PURE__ */ React.createElement(_AntdIcon.default, (0, _objectSpread2.default)((0, _objectSpread2.default)({}, props), {}, {
    ref,
    icon: _DoubleRightOutlined.default
  }));
};
DoubleRightOutlined$1.displayName = "DoubleRightOutlined";
var _default = /* @__PURE__ */ React.forwardRef(DoubleRightOutlined$1);
DoubleRightOutlined$3.default = _default;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = void 0;
  var _DoubleRightOutlined2 = _interopRequireDefault2(DoubleRightOutlined$3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var _default2 = _DoubleRightOutlined2;
  exports.default = _default2;
  module.exports = _default2;
})(DoubleRightOutlined$4, DoubleRightOutlined$4.exports);
const DoubleRightOutlined3 = /* @__PURE__ */ getDefaultExportFromCjs(DoubleRightOutlined$4.exports);
const { SubMenu } = Menu$1;
function MenuLink(item) {
  return /* @__PURE__ */ React$a.createElement("div", {
    className: "nav-menu-link-item"
  }, /* @__PURE__ */ React$a.createElement(Link$2, {
    to: item.path
  }, /* @__PURE__ */ React$a.createElement("span", {
    style: { flex: 1 }
  }, toName(item.name))), /* @__PURE__ */ React$a.createElement(LinkCopy, {
    route: item.path
  }));
}
function RouterSwitch() {
  const { tree: menuData, routes } = useRouteMap() || {};
  const { npmLink, logo } = useComponentInfo() || {};
  const [showMenu, { toggle, setFalse }] = useBoolean(false);
  const { url: route } = useRouteMatch();
  useUpdateEffect(() => {
    setFalse();
  }, [route]);
  if (!routes || (routes == null ? void 0 : routes.length) <= 1) {
    return /* @__PURE__ */ React$a.createElement(React$a.Fragment, null);
  }
  const openKeys = menuData == null ? void 0 : menuData.filter(({ children }) => !!children).map(({ name: name2 }) => name2);
  return /* @__PURE__ */ React$a.createElement(React$a.Fragment, null, /* @__PURE__ */ React$a.createElement("div", {
    className: "route-switch-placeholder"
  }), /* @__PURE__ */ React$a.createElement("div", {
    className: classNames("route-switch-scope", showMenu && "router-switch-open")
  }, /* @__PURE__ */ React$a.createElement("a", {
    className: "logo",
    href: npmLink
  }, /* @__PURE__ */ React$a.createElement("img", {
    alt: "Vite Docs",
    src: logo || "//img.alicdn.com/imgextra/i1/O1CN01yPg2Vc1gAJ2EFm5iG_!!6000000004101-55-tps-1058-237.svg",
    style: { width: 160 }
  })), /* @__PURE__ */ React$a.createElement(Button$2, {
    className: "responsive-btn",
    onClick: () => toggle()
  }, showMenu ? /* @__PURE__ */ React$a.createElement(DoubleLeftOutlined3, null) : /* @__PURE__ */ React$a.createElement(DoubleRightOutlined3, null)), /* @__PURE__ */ React$a.createElement(Menu$1, {
    mode: "inline",
    className: "router-switch",
    defaultSelectedKeys: [route],
    defaultOpenKeys: openKeys
  }, menuData && menuData.map((item) => {
    var _a;
    if (item.path) {
      return /* @__PURE__ */ React$a.createElement(Menu$1.Item, {
        className: "capitalize nav-item-link",
        key: item.path
      }, /* @__PURE__ */ React$a.createElement(MenuLink, {
        ...item
      }));
    }
    return /* @__PURE__ */ React$a.createElement(SubMenu, {
      title: item.name,
      className: "capitalize",
      key: item.name
    }, (_a = item.children) == null ? void 0 : _a.map((item2) => /* @__PURE__ */ React$a.createElement(Menu$1.Item, {
      className: "nav-item-link",
      key: item2.path
    }, /* @__PURE__ */ React$a.createElement(MenuLink, {
      ...item2
    }))));
  }))));
}
const antd_min = "";
function App() {
  const { routes } = useRouteMap() || {};
  if (!routes) {
    return null;
  }
  return /* @__PURE__ */ React$a.createElement(Switch$3, null, routes.map((route) => {
    return /* @__PURE__ */ React$a.createElement(Route, {
      path: route
    }, /* @__PURE__ */ React$a.createElement("div", {
      style: { display: "flex" },
      className: "code-box-demo"
    }, /* @__PURE__ */ React$a.createElement(RouterSwitch, null), /* @__PURE__ */ React$a.createElement(ReadmePane, {
      key: `${route}_readme_pane`
    })));
  }), /* @__PURE__ */ React$a.createElement(Redirect, {
    to: routes[0]
  }));
}
ReactDOM.render(/* @__PURE__ */ React$a.createElement(HashRouter, null, /* @__PURE__ */ React$a.createElement(App, null)), document.querySelector("#component-root"));
export {
  App
};
